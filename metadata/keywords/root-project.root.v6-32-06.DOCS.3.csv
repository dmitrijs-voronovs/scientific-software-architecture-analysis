id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:46157,Integrability,wrap,wrap,46157,"Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfac",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47012,Integrability,interface,interfaces,47012,"ndl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Exam",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47136,Integrability,wrap,wrap,47136,"GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::Wrap",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47156,Integrability,interface,interfaces,47156,"GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::Wrap",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47208,Integrability,interface,interface,47208," in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```.",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47221,Integrability,wrap,wrap,47221," in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```.",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47370,Integrability,wrap,wrapped,47370,"nd `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy sho",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47387,Integrability,interface,interfaces,47387,"nd `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy sho",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47741,Integrability,wrap,wrap,47741,"luation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47778,Integrability,interface,interface,47778,"luation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimension is required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:47919,Integrability,wrap,wrap,47919,"required when constructing the functor. #### Special case: Wrapping TF1 objects in Parametric Function interfaces. In many cases, the user works with the `TF1` class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods.; If the desired interface to wrap is one-dimensional, the class to use is `ROOT::Math::WrappedTF1`.; The default constructor takes a `TF1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48314,Integrability,integrat,integration,48314,"1` reference as an argument, that will be wrapped with the interfaces of a `ROOT::Math::IParametricGradFunctionOneDim`.; Example:; ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; ```. For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48632,Integrability,interface,interfaces,48632,"sional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48654,Integrability,integrat,integrator,48654,"sional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48760,Integrability,integrat,integration,48760,"sional function or in case we need to wrap in a multi-dimensional function interface, the class to use is `ROOT::Math::WrappedMultiTF1`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48869,Integrability,integrat,integration,48869,"`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `RO",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48940,Integrability,integrat,integrator,48940,"into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some spe",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48951,Integrability,interface,interfaces,48951,"into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some spe",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49028,Integrability,integrat,integrating,49028,"TF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integr",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49288,Integrability,integrat,integration,49288,"`. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important;",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49380,Integrability,interface,interface,49380,"onality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-di",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49552,Integrability,integrat,integration,49552,"onality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-di",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49602,Integrability,integrat,integrated,49602,"tiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49638,Integrability,interface,interface,49638,"tiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:50876,Integrability,integrat,integration,50876,"ific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ER",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:51297,Integrability,integrat,integrators,51297,"part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;;",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:52709,Integrability,integrat,integration,52709,"::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kLEGENDRE);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:53442,Integrability,integrat,integration,53442,"ral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT:",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:53571,Integrability,rout,routine,53571,"LT) > ERRORLIMIT;. return status;; }; ```. ### One-dimensional Integration Algorithms. Here we provide a brief description of the different integration algorithms, which are also; implemented as separate classes. The algorithms can be instantiated using the following enumeration values:. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorOneDim::kGAUSS` | `ROOT::Math::GaussianIntegrator` |; | `ROOT::Math::IntegratorOneDim::kLEGENDRE` | `ROOT::Math:::GausLegendreIntegrator` |; | `ROOT::Math::Integration::kNONADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVE` | `ROOT::Math:::GSLIntegrator` |; | `ROOT::Math::Integration::kADAPTIVESINGULAR` | `ROOT::Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLI",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54392,Integrability,integrat,integration,54392,":Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` clas",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54591,Integrability,wrap,wrapper,54591,"s; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54618,Integrability,integrat,integrator,54618,"s; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54681,Integrability,integrat,integration,54681,"#include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative t",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54772,Integrability,integrat,integration,54772,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54835,Integrability,integrat,integration,54835,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54979,Integrability,integrat,integration,54979,"se);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55179,Integrability,interface,interface,55179,"user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users document",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55269,Integrability,integrat,integration,55269," integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It i",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55387,Integrability,integrat,integrator,55387,"placing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56063,Integrability,integrat,integration,56063," code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56438,Integrability,integrat,integration,56438,"grator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56576,Integrability,integrat,integration,56576,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56603,Integrability,integrat,integration,56603,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56767,Integrability,integrat,integration,56767,"sfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that whe",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:57437,Integrability,integrat,integration,57437,"s.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:57599,Integrability,integrat,integration,57599,"nto subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instan",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:57715,Integrability,integrat,integration,57715,"st estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58177,Integrability,integrat,integration,58177,"USS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; st",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58290,Integrability,integrat,integration,58290,"ile lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58345,Integrability,integrat,integration,58345,"ile lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:60543,Integrability,integrat,integration,60543,"ntegral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; ```. #### Multi-dimensions Integration Algorithms. Here is the types, that can be specified as enumeration and the corresponding classes. | **Enumeration name**| **Integrator class** |; |------------------------------------ |-------------------------------|; | `ROOT::Math::IntegratorMultiDim::kADAPTIVE` | `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum a",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61228,Integrability,integrat,integration,61228," `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when usin",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61366,Integrability,integrat,integration,61366,"egratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Deriv",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61689,Integrability,integrat,integration,61689," values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the thir",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61755,Integrability,integrat,integration,61755,"Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61855,Integrability,integrat,integration,61855,"Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61921,Integrability,integrat,integration,61921,"erance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used f",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61962,Integrability,integrat,integration,61962,"erance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used f",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62278,Integrability,interface,interface,62278," quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62521,Integrability,wrap,wrapping,62521," can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62533,Integrability,integrat,integration,62533," can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62647,Integrability,integrat,integration,62647,"# `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. These algorithms are for finding the minimum of a one-dimensional minimization function.; The function to ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62836,Integrability,integrat,integration,62836,"ical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. These algorithms are for finding the minimum of a one-dimensional minimization function.; The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; The algorithms supported are only bracketing algorithm which do not use derivatives information. Two classes exist. One in",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:64978,Integrability,wrap,wraps,64978,"ferent methods, using in some case the derivatives. #### `ROOT::Math::BrentMinimizer1D`. This class implements the Brent method to minimize one-dimensional function.; An interval containing the function minimum must be provided.; Here is an example where we define the function to minimize as a *lambda* function; (requires C++11). The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object. ```{.cpp}; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; ```. Note that when setting the function to minimize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:65702,Integrability,interface,interface,65702,"ize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in d",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:66611,Integrability,interface,interface,66611,"algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT; plug-in manager.; More information on multi-dimensional minimization is provided in the Fitting Histogram chapter. ## ROOT Finder Algorithms. The function must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; Some of the algorithm requires the derivatives of the function.; In that case a `ROOT::Math::IGradientFunctionOneDim` object must be provided. ## Generic Vectors for 2, 3 and 4 Dimensions (GenVector). `GenVector` is a package intended to represent vectors and their; operations and transformations, such as rotations and Lorentz; transformations, in 3 and 4 dimensions. The 3D space is used to describe; the geometry vectors and points, while the 4D space-time is used for; physics vectors representing relativistic particles. These 3",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74071,Integrability,interface,interface,74071,"ilable; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (**`ROOT::Math::RotationZ`**); and described by just one angle. - 3D transformation: we describe the transformations defined as a; composition between a rotation and a translation using the class; **`ROOT::Math::Transform3D`**. It is important to note that; transformations act differently on vectors and points. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesi",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74658,Integrability,interface,interface,74658,"ransformations defined as a; composition between a rotation and a translation using the class; **`ROOT::Math::Transform3D`**. It is important to note that; transformations act differently on vectors and points. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesian vector. We then enforce the use; of transformations as rotations or translations (additions) for; modifying the vector contents. - The majority of the functionality, which is present in the CLHEP; package, involving operations on two vectors, is moved in separated; helper functions (see `ROOT::Math::VectorUtil`). This has the; advantage that the basic interface will remain more stable with time; while additional functions can be added easily. #### Naming Convention. As part of ROOT, the `GenVector` package adheres to the prescribed ROOT; naming ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:75464,Integrability,interface,interface,75464,"s:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesian vector. We then enforce the use; of transformations as rotations or translations (additions) for; modifying the vector contents. - The majority of the functionality, which is present in the CLHEP; package, involving operations on two vectors, is moved in separated; helper functions (see `ROOT::Math::VectorUtil`). This has the; advantage that the basic interface will remain more stable with time; while additional functions can be added easily. #### Naming Convention. As part of ROOT, the `GenVector` package adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (see the next section about CLHEP compatibility). #### Compatibility with CLHEP Vector Classes. - For backward compatibility with CLHEP the vector classes can be; constructed from a CLHEP `HepVector` or **`HepLorentzVector`**, by; using a template constructor, which requires only that the classes; implement the accessors` x()`, `y()`, and `z()` (and `t()` for the; 4D). - We provide vector member function with the same naming convention as; CLHEP for the most used functions like `x()`, `y()` and `z()`. #### Connection to Linear Algebra Package. In some use cases, like in track reconstruction, it is needed to use the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:76613,Integrability,depend,dependency,76613,"age adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (see the next section about CLHEP compatibility). #### Compatibility with CLHEP Vector Classes. - For backward compatibility with CLHEP the vector classes can be; constructed from a CLHEP `HepVector` or **`HepLorentzVector`**, by; using a template constructor, which requires only that the classes; implement the accessors` x()`, `y()`, and `z()` (and `t()` for the; 4D). - We provide vector member function with the same naming convention as; CLHEP for the most used functions like `x()`, `y()` and `z()`. #### Connection to Linear Algebra Package. In some use cases, like in track reconstruction, it is needed to use the; content of the vector and rotation classes in conjunction with linear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float'",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:87908,Integrability,interface,interface,87908," Constructors and Assignment. The following declarations are available:. ``` {.cpp}; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; ```. Note that each type of vector is constructed by passing its coordinate; representation, so a **`XYZTVector`**`(1,2,3,4)` is different from a; `PtEtaPhiEVector(1,2,3,4)`. In addition, the Vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`,; `z()` and `t()`. This can be another `ROOT::Math::`**`LorentzVector`** based on a; different coordinate system or any vector of a different package, like; the CLHEP **`HepLorentzVector`** that implements the required signature. ``` {.cpp}; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; ```. #### Coordinate Accessors. All the same coordinate accessors are available through the interface of; `ROOT::Math::`**`LorentzVector`**. For example:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); ```. In addition, all 4 vector coordinates can be retrieved with the; `GetCoordinates` method:. ``` {.cpp}; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; ```. To get information on all the coordinate accessors see the; `ROOT::Math::`**`LorentzVector`** reference documentation. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; //sets the (x,y,z,t) for a XYZTVector; v1.SetCo",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:96783,Integrability,depend,depending,96783," or return their; inverse:. ``` {.cpp}; Rotation3D r1(...);; r1.Invert(); //invert the rotation modifying its content; Rotation3D r2 =r1.Inverse(); //return the inverse in a new; //rotation class; ```. We have used rotation as examples, but all these operations can be; applied to all the transformation classes. #### Set/GetComponents Methods. Common methods to all transformations are `Get` and `SetComponents`.; They can be used to retrieve all the scalar values on which the; transformation is based. ``` {.cpp}; RotationX rx;; rx.SetComponents(1.); //set agle of the X rotation; double d[9] = {........};; Rotation3D r;; r.SetComponents(d,d+9); //set 9 components of 3D rotation; double d[16];; LorentzRotation lr;; lr.GetComponents(d,d+16); //get 16 components of a LorentzRotation; TMatrixD(3,4) m;; Transform3D t;; t.GetComponens(m); //fill 3x4 matrix with components of t; ```. The` GetComponents` and `SetComponents` methods can be used with a; signature based iterators or by using any foreign matrix which; implements the `operator(i,j)` or a different signatures depending on; the transformation type. For more details on all methods see the; reference documentation of any specific transformation class. ### Example with External Packages. #### Connection to Linear Algebra Classes. It is possible to use the vector and rotation classes together with the; linear algebra classes and to set and get the contents of any 3D or 4D; vector from a linear algebra vector class which implements an iterator; or something which behaves like an iterator. For example a pointer to a; C array (double`*`) behaves like an iterator. It is then assumed that; the coordinates, like (`x,y,z`) will be stored contiguously. ``` {.cpp}; TVectorD r2(N); //ROOT Linear Algebra Vector containing; //many vectors; XYZVector v2;; //construct vector from x=r[INDEX], y=r[INDEX+1], z=r[INDEX+2]; v2.SetCoordinates(&r2[INDEX],&r2[index]+3);; ```. To fill a linear algebra vector from a 3D or 4D vector, with; `GetC",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:103432,Integrability,interface,interface,103432,":. - Default constructor for a zero vector (all elements equal to zero). - Constructor (and assignment) from a vector expression, like; `v=p*q+w`. Due to the expression template technique, no temporary; objects are created in this operation. - Constructor by passing directly the elements. This is possible only; for vectors up to size 10. - Constructor from an iterator copying the data referred by the; iterator. It is possible to specify the *begin* and *end* of the; iterator or the *begin* and the *size*. Note that for the Vector the; iterator is not generic and must be of type `T*`, where `T` is the; type of the contained elements. In the following example we assume that we are using the namespace; **`ROOT::Math`**. ``` {.cpp}; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; ```. #### Accessing and Setting Methods. The single vector elements can be set or retrieved using the; `operator[i]`, `operator(i)` or the iterator interface. Notice that the; index starts from zero and not from one as in FORTRAN. Also no check is; performed on the passed index. The full vector elements can be set also; by using the SetElements function passing a generic iterator. ``` {.cpp}; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; ```. In addition there are methods to place a sub-vector in a vector. If the; size of the sub-vector is larger than the vector size a static assert (a; compilation error) is produced. ``` {.cpp}; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:109009,Integrability,interface,interface,109009,"ath::MatRepSym<double,3>> SMatrixSym3;; typedef ROOT::Math::SVector>double,2> SVector2;; typedef ROOT::Math::SVector>double,3> SVector3;; typedef ROOT::Math::SVector>double,6> SVector6;; SMatrix33 m0; // create a zero 3x3 matrix; // create an 3x3 identity matrix; SMatrix33 i = ROOT::Math::SMatrixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); ```. Example to fill a symmetric matrix from an `std::vector`:. ``` {.cpp}; std::vector<double> v(6);; for (int i = 0; i<6; ++i) v[i] = double(i+1);; SMatrixSym3 s(v.begin(),v.end()) // this will produce the; // symmetric matrix; // ( 1 2 4 ); // ( 2 3 5 ); // ( 4 5 6 ); //create a general matrix from a symmetric matrix (the opposite; // will not compile); SMatrix33 m2 = s;; ```. #### Accessing and Setting Methods. The matrix elements can be set using the `operator()(irow,icol)`, where; `irow` and `icol` are the row and column indexes or by using the; iterator interface. Notice that the indexes start from zero and not from; one as in FORTRAN. Furthermore, all the matrix elements can be set also; by using the SetElements function passing a generic iterator. The; elements can be accessed by the same methods as well as by using the; function `ROOT::Math::SMatrix::apply`. The `apply(i)` has exactly the; same behavior for general and symmetric matrices; in contrast to the; iterator access methods which behave differently (it follows the data; order). ``` {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the differenc",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:112428,Integrability,rout,routine,112428,";; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; ```. #### Linear Algebra Matrix Functions (Inversion, Determinant). Only limited linear algebra functionality is available for `SMatrix`. It; is possible for squared matrices `NxN`, to find the inverse or to; calculate the determinant. Different inversion algorithms are used if; the matrix is smaller than `6x6` or if it is symmetric. In the case of a; small matrix, a faster direct inversion is used. For a large; `(N>6) `symmetric matrix the Bunch-Kaufman diagonal pivoting method is; used while for a large `(N>6)` general matrix an LU factorization is; performed using the same algorithm as in the CERNLIB routine `dinv`. ``` {.cpp}; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calculate determinant by using a temporary matrix; preserves; // matrix content; bool ret = n.Det2(det);; ```. ### Example: Matrix and Vector Functions and Operators. #### Matrix and Vector Operators. The **`ROOT::Math::SVector`** and **`ROOT::Math::SMatrix`** classes; define the following operators described below. The `m1`, `m2`, `m3` are; vectors or matrices of the same type (and size) and `a` is a scalar; value:",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:117797,Integrability,wrap,wrapped,117797,"for Computing Limits and Confidence Levels. **`TFeldmanCousins`** class calculates the `CL` upper/lower limit for a; Poisson process using the Feldman-Cousins method (as described in PRD; V57 \#7, p3873-3889). No treatment is provided in this method for the; uncertainties in the signal or the background. **`TRolke`** computes confidence intervals for the rate of a Poisson; process in the presence of background and efficiency, using the profile; likelihood technique for treating the uncertainties in the efficiency; and background estimate. The signal is always assumed to be Poisson;; background may be Poisson, Gaussian, or user-supplied; efficiency may be; Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum.; Meth. A551:493-503,2005. **`TLimit`** class computes 95% C.L. limits using the Likelihood ratio; semi-Bayesian method ( <CLs> method; see e.g. T. Junk, NIM A434, p.; 435-443, 1999). It takes signal background and data histograms wrapped; in a `TLimitDataSource` as input, and runs a set of Monte Carlo; experiments in order to compute the limits. If needed, inputs are; fluctuated according to systematic. ### Specialized Classes for Fitting. **`TFractionFitter`** fits Monte Carlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:5291,Modifiability,config,configure,5291,"`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is found in the system. The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. - numerical constants (like `pi`, `e`, `h`, etc.);. - trigonometric and elementary mathematical functions;. - functions to work with arrays and collections (e.g. functions to find `min` and `max` of arrays);. - statistic functions to work on array of data (e.g. mean and `RMS` of arrays);. - algorithms for binary search/hashing sorting;. - special mathematical fun",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:5328,Modifiability,config,configure,5328,"rted. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is found in the system. The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. - numerical constants (like `pi`, `e`, `h`, etc.);. - trigonometric and elementary mathematical functions;. - functions to work with arrays and collections (e.g. functions to find `min` and `max` of arrays);. - statistic functions to work on array of data (e.g. mean and `RMS` of arrays);. - algorithms for binary search/hashing sorting;. - special mathematical functions like `Bessel`, `Erf`, `Gamma`, etc.;. - statistical functions, li",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35026,Modifiability,inherit,inherit,35026,"istributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunction",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:36643,Modifiability,inherit,inherit,36643,"ser class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradientFunctionOneDim`: Some of the numerical algorithm will need to calculate the derivatives of the function. In these cases, the user will have to provide the necessary code for; this to happen. The interface defined in `IGradientFunctionOneDim` introduced the method `double Derivative(double x)` that will return the derivative of the function at the point `x`. The class; inherit by the user will have to implement the abstract method `double DoDerivative(double x)`, leaving the rest of the class untouched. Example for implementing a gradient one-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions t",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:38156,Modifiability,variab,variables,38156,"ivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Mat",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:38927,Modifiability,variab,variable,38927,"erent dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; ```. ### Parametric Function Interfaces. These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the header file; `Math/IParamFunction.h`.; See also the documentation of the `ROOT::Fit` classes in the Fitting chapter for more information. * **`ROOT::Math::IParametricFunctionMultiDim`**: Describes a multi dimensional parametric funct",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54763,Modifiability,adapt,adaptive,54763,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55378,Modifiability,adapt,adaptive,55378,"placing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56292,Modifiability,adapt,adaptive,56292,"lass.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rul",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56553,Modifiability,adapt,adaptiva,56553,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61208,Modifiability,adapt,adaptive,61208," `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when usin",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61333,Modifiability,adapt,adaptive,61333,"egratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Deriv",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62089,Modifiability,config,configuration,62089," quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:66817,Modifiability,plug-in,plug-in,66817,"case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT; plug-in manager.; More information on multi-dimensional minimization is provided in the Fitting Histogram chapter. ## ROOT Finder Algorithms. The function must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; Some of the algorithm requires the derivatives of the function.; In that case a `ROOT::Math::IGradientFunctionOneDim` object must be provided. ## Generic Vectors for 2, 3 and 4 Dimensions (GenVector). `GenVector` is a package intended to represent vectors and their; operations and transformations, such as rotations and Lorentz; transformations, in 3 and 4 dimensions. The 3D space is used to describe; the geometry vectors and points, while the 4D space-time is used for; physics vectors representing relativistic particles. These 3D and 4D; vectors are different from vectors of the linear algebra package, which; describe generic N-dimensional vectors. Similar functionality is; currently pr",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:68439,Modifiability,inherit,inherit,68439,"geometry vectors and points, while the 4D space-time is used for; physics vectors representing relativistic particles. These 3D and 4D; vectors are different from vectors of the linear algebra package, which; describe generic N-dimensional vectors. Similar functionality is; currently provided by the CLHEP <Vector> and <Geometry> packages and the; ROOT Physics vector classes (See ""Physics Vectors""). It also re-uses; concepts and ideas from the CMS; [Common Vector package](Common Vector package). In contrast to CLHEP or; the ROOT physics libraries, `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:69374,Modifiability,polymorphi,polymorphically,69374,"specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case, between points and vectors, modeling them with; different classes:. - `ROOT::Math::`**`DisplacementVector2D`** and; `ROOT::Math::`**`DisplacementVector3D`** template classes describing; 2 and 3 component direction and magnitude vectors, not rooted at any; particular point;. - `ROOT::Math::`**`PositionVector2D`** and; `ROOT::Math::`**`PositionVector3D`** template classes modeling the; points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them,; `ROOT::Math::`**`LorentzVector`**, since we have recognized a limited; need for modeling the functionality of a 4D po",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:69414,Modifiability,inherit,inheriting,69414,"specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case, between points and vectors, modeling them with; different classes:. - `ROOT::Math::`**`DisplacementVector2D`** and; `ROOT::Math::`**`DisplacementVector3D`** template classes describing; 2 and 3 component direction and magnitude vectors, not rooted at any; particular point;. - `ROOT::Math::`**`PositionVector2D`** and; `ROOT::Math::`**`PositionVector3D`** template classes modeling the; points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them,; `ROOT::Math::`**`LorentzVector`**, since we have recognized a limited; need for modeling the functionality of a 4D po",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:119340,Modifiability,extend,extended,119340,"arlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum likelihood fit and with a tool to access the quality and; validity of the fit producing distributions for the control variables.; (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369,; 2005). ### Multi-variate Analysis Classes. **`TMultiLayerPerceptron`** is a Neural Network class (see for more; details the chapter ""Neural Networks""). **`TPrincipal`** provides the Principal Component Analysis. **`TRobustEstimator`** is a robust method for minimum covariance; determinant estimator (MCD). **`TMVA`** is a package for multivariate data analysis (see; <https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf> the User's Guide).; ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:119476,Modifiability,variab,variables,119476,"arlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum likelihood fit and with a tool to access the quality and; validity of the fit producing distributions for the control variables.; (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369,; 2005). ### Multi-variate Analysis Classes. **`TMultiLayerPerceptron`** is a Neural Network class (see for more; details the chapter ""Neural Networks""). **`TPrincipal`** provides the Principal Component Analysis. **`TRobustEstimator`** is a robust method for minimum covariance; determinant estimator (MCD). **`TMVA`** is a package for multivariate data analysis (see; <https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf> the User's Guide).; ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:468,Performance,optimiz,optimized,468,"# Math Libraries in ROOT. The aim of Math libraries in ROOT is to provide and to support a; coherent set of mathematical and statistical functions. The latest; developments have been concentrated in providing first versions of the; `MathCore` and `MathMore` libraries, included in ROOT v5.08. Other; recent developments include the new version of `MINUIT`, which has been; re-designed and re-implemented in the C++ language. It is integrated in; ROOT. In addition, an optimized package for describing small matrices; and vector with fixed sizes and their operation has been developed; (`SMatrix`). The structure is shown in the following picture. ![Math libraries and packages](pictures/02000109.jpg). ## MathCore Library. `MathCore` provides a collection of functions and C++ classes for; numerical computing. This library includes only the basic mathematical; functions and algorithms and not all the functionality required by the; physics community. A more advanced mathematical functionality is; provided by the `MathMore` library. The current set of included classes,; which are provided in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49540,Performance,perform,perform,49540,"onality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-di",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54377,Performance,perform,performing,54377,":Math:::GSLIntegrator` |. #### ROOT::Math:::GaussIntegrator. It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian; quadrature approximations. It is derived from the `DGAUSS` routine of the *CERNLIB* by S. Kolbig.; This class; Here is an example of using directly the `GaussIntegrator` class. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` clas",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61668,Performance,perform,performing,61668," values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the thir",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62417,Performance,perform,perform,62417,"region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimizatio",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:65846,Performance,perform,perform,65846,"erance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT; plug-in manager.; More information on multi-dimensional minimization is provided in the Fit",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:68576,Performance,optimiz,optimize,68576,"les. These 3D and 4D; vectors are different from vectors of the linear algebra package, which; describe generic N-dimensional vectors. Similar functionality is; currently provided by the CLHEP <Vector> and <Geometry> packages and the; ROOT Physics vector classes (See ""Physics Vectors""). It also re-uses; concepts and ideas from the CMS; [Common Vector package](Common Vector package). In contrast to CLHEP or; the ROOT physics libraries, `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while po",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:68585,Performance,perform,performances,68585,"les. These 3D and 4D; vectors are different from vectors of the linear algebra package, which; describe generic N-dimensional vectors. Similar functionality is; currently provided by the CLHEP <Vector> and <Geometry> packages and the; ROOT Physics vector classes (See ""Physics Vectors""). It also re-uses; concepts and ideas from the CMS; [Common Vector package](Common Vector package). In contrast to CLHEP or; the ROOT physics libraries, `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while po",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:68968,Performance,perform,performance,68968," package](Common Vector package). In contrast to CLHEP or; the ROOT physics libraries, `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case, between points and vectors, modeling them with; different classes:. - `ROOT::Math::`**`DisplacementVector2D`** and; `ROOT::Math::`**`DisplacementVector3D`** template classes descri",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:73455,Performance,optimiz,optimized,73455,"non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, which are; translation`/`rotation combinations. Each group has several members; which may model physically equivalent transformations but with different; internal representations. Transformation classes can operate on all type; of vectors by using the operator `() `or the operator `*` and the; transformations can be combined via the operator `*`. The available; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (**`ROOT::Math::RotationZ`**); and described by just one angle. - 3D transformation: we describe the transformations defined as a; composition between a rotation and a translation using the class; **`ROOT::Math::Transform3D`**. It is important to note that; transformations act differently on vectors and points. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROO",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:99065,Performance,perform,performance,99065,"ing the data; ```. In the case of transformations, constructor and method to set`/`get; components exist with linear algebra matrices. The requisite is that the; matrix data are stored, for example in the case of a Lorentz rotation,; from (`0,0`) thru (`3,3`). ``` {.cpp}; TMatrixD(4,4) m;; LorentzRotation r(m); //create Lorentz r; ```. #### Connection to Other Vector Classes. The 3D and 4D vectors of the `GenVector` package can be constructed and; assigned from any vector which satisfies the following requisites:. - for 3D vectors implementing the `x()`, `y()` and `z()` methods. - for Lorentz vectors implementing the `x()`, `y()`, `z()` and `t()`; methods. ``` {.cpp}; CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; ```. ## Linear Algebra: SMatrix Package. The ROOT Linear algebra package is documented in a separate chapter (see; ""Linear Algebra in ROOT""). `SMatrix` is a C++ package, for high; performance vector and matrix computations. It has been introduced in; ROOT v5.08. It is optimized for describing small matrices and vectors; and It can be used only in problems when the size of the matrices is; known at compile time, like in the tracking reconstruction of physics; experiments. It is based on a C++ technique, called expression; templates, to achieve an high level optimization. The C++ templates can; be used to implement vector and matrix expressions such that these; expressions can be transformed at compile time to code which is; equivalent to hand optimized code in a low-level language like FORTRAN; or C (see for example T. Veldhuizen, Expression Templates, C++ Report,; 1995). The `SMatrix` has been developed initially by T. Glebe in; Max-Planck-Institut, Heidelberg, as part of the `HeraB` analysis; framework. A subset of the original package has been now incorporated in; the ROOT distribution, with the aim to provide a stand-alone and high; performance matrix package. ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:99154,Performance,optimiz,optimized,99154,"for example in the case of a Lorentz rotation,; from (`0,0`) thru (`3,3`). ``` {.cpp}; TMatrixD(4,4) m;; LorentzRotation r(m); //create Lorentz r; ```. #### Connection to Other Vector Classes. The 3D and 4D vectors of the `GenVector` package can be constructed and; assigned from any vector which satisfies the following requisites:. - for 3D vectors implementing the `x()`, `y()` and `z()` methods. - for Lorentz vectors implementing the `x()`, `y()`, `z()` and `t()`; methods. ``` {.cpp}; CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; ```. ## Linear Algebra: SMatrix Package. The ROOT Linear algebra package is documented in a separate chapter (see; ""Linear Algebra in ROOT""). `SMatrix` is a C++ package, for high; performance vector and matrix computations. It has been introduced in; ROOT v5.08. It is optimized for describing small matrices and vectors; and It can be used only in problems when the size of the matrices is; known at compile time, like in the tracking reconstruction of physics; experiments. It is based on a C++ technique, called expression; templates, to achieve an high level optimization. The C++ templates can; be used to implement vector and matrix expressions such that these; expressions can be transformed at compile time to code which is; equivalent to hand optimized code in a low-level language like FORTRAN; or C (see for example T. Veldhuizen, Expression Templates, C++ Report,; 1995). The `SMatrix` has been developed initially by T. Glebe in; Max-Planck-Institut, Heidelberg, as part of the `HeraB` analysis; framework. A subset of the original package has been now incorporated in; the ROOT distribution, with the aim to provide a stand-alone and high; performance matrix package. The API of the current package differs from; the original one, in order to be compliant to the ROOT coding; conventions. `SMatrix` contains the generic **`ROOT::Math::SMatrix`** and; **`R",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:99448,Performance,optimiz,optimization,99448,"Connection to Other Vector Classes. The 3D and 4D vectors of the `GenVector` package can be constructed and; assigned from any vector which satisfies the following requisites:. - for 3D vectors implementing the `x()`, `y()` and `z()` methods. - for Lorentz vectors implementing the `x()`, `y()`, `z()` and `t()`; methods. ``` {.cpp}; CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; ```. ## Linear Algebra: SMatrix Package. The ROOT Linear algebra package is documented in a separate chapter (see; ""Linear Algebra in ROOT""). `SMatrix` is a C++ package, for high; performance vector and matrix computations. It has been introduced in; ROOT v5.08. It is optimized for describing small matrices and vectors; and It can be used only in problems when the size of the matrices is; known at compile time, like in the tracking reconstruction of physics; experiments. It is based on a C++ technique, called expression; templates, to achieve an high level optimization. The C++ templates can; be used to implement vector and matrix expressions such that these; expressions can be transformed at compile time to code which is; equivalent to hand optimized code in a low-level language like FORTRAN; or C (see for example T. Veldhuizen, Expression Templates, C++ Report,; 1995). The `SMatrix` has been developed initially by T. Glebe in; Max-Planck-Institut, Heidelberg, as part of the `HeraB` analysis; framework. A subset of the original package has been now incorporated in; the ROOT distribution, with the aim to provide a stand-alone and high; performance matrix package. The API of the current package differs from; the original one, in order to be compliant to the ROOT coding; conventions. `SMatrix` contains the generic **`ROOT::Math::SMatrix`** and; **`ROOT::Math::SVector`** classes for describing matrices and vectors of; arbitrary dimensions and of arbitrary type. The classes are templated on; the scalar ty",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:99637,Performance,optimiz,optimized,99637,"- for 3D vectors implementing the `x()`, `y()` and `z()` methods. - for Lorentz vectors implementing the `x()`, `y()`, `z()` and `t()`; methods. ``` {.cpp}; CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; ```. ## Linear Algebra: SMatrix Package. The ROOT Linear algebra package is documented in a separate chapter (see; ""Linear Algebra in ROOT""). `SMatrix` is a C++ package, for high; performance vector and matrix computations. It has been introduced in; ROOT v5.08. It is optimized for describing small matrices and vectors; and It can be used only in problems when the size of the matrices is; known at compile time, like in the tracking reconstruction of physics; experiments. It is based on a C++ technique, called expression; templates, to achieve an high level optimization. The C++ templates can; be used to implement vector and matrix expressions such that these; expressions can be transformed at compile time to code which is; equivalent to hand optimized code in a low-level language like FORTRAN; or C (see for example T. Veldhuizen, Expression Templates, C++ Report,; 1995). The `SMatrix` has been developed initially by T. Glebe in; Max-Planck-Institut, Heidelberg, as part of the `HeraB` analysis; framework. A subset of the original package has been now incorporated in; the ROOT distribution, with the aim to provide a stand-alone and high; performance matrix package. The API of the current package differs from; the original one, in order to be compliant to the ROOT coding; conventions. `SMatrix` contains the generic **`ROOT::Math::SMatrix`** and; **`ROOT::Math::SVector`** classes for describing matrices and vectors of; arbitrary dimensions and of arbitrary type. The classes are templated on; the scalar type and on the size, like number of rows and columns for a; matrix . Therefore, the matrix/vector dimension has to be known at; compile time. An advantage of using the dimension ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:100039,Performance,perform,performance,100039," chapter (see; ""Linear Algebra in ROOT""). `SMatrix` is a C++ package, for high; performance vector and matrix computations. It has been introduced in; ROOT v5.08. It is optimized for describing small matrices and vectors; and It can be used only in problems when the size of the matrices is; known at compile time, like in the tracking reconstruction of physics; experiments. It is based on a C++ technique, called expression; templates, to achieve an high level optimization. The C++ templates can; be used to implement vector and matrix expressions such that these; expressions can be transformed at compile time to code which is; equivalent to hand optimized code in a low-level language like FORTRAN; or C (see for example T. Veldhuizen, Expression Templates, C++ Report,; 1995). The `SMatrix` has been developed initially by T. Glebe in; Max-Planck-Institut, Heidelberg, as part of the `HeraB` analysis; framework. A subset of the original package has been now incorporated in; the ROOT distribution, with the aim to provide a stand-alone and high; performance matrix package. The API of the current package differs from; the original one, in order to be compliant to the ROOT coding; conventions. `SMatrix` contains the generic **`ROOT::Math::SMatrix`** and; **`ROOT::Math::SVector`** classes for describing matrices and vectors of; arbitrary dimensions and of arbitrary type. The classes are templated on; the scalar type and on the size, like number of rows and columns for a; matrix . Therefore, the matrix/vector dimension has to be known at; compile time. An advantage of using the dimension as template parameters; is that the correctness of dimension in the matrix/vector operations can; be checked at compile time. `SMatrix` supports, since ROOT v5.10, symmetric matrices using a storage; class (**`ROOT::Math::MatRepSym`**) which contains only the `N*(N+1)/2`; independent element of a `NxN` symmetric matrix. It is not in the; mandate of this package to provide complete linear algebr",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:101241,Performance,optimiz,optimized,101241,":Math::SVector`** classes for describing matrices and vectors of; arbitrary dimensions and of arbitrary type. The classes are templated on; the scalar type and on the size, like number of rows and columns for a; matrix . Therefore, the matrix/vector dimension has to be known at; compile time. An advantage of using the dimension as template parameters; is that the correctness of dimension in the matrix/vector operations can; be checked at compile time. `SMatrix` supports, since ROOT v5.10, symmetric matrices using a storage; class (**`ROOT::Math::MatRepSym`**) which contains only the `N*(N+1)/2`; independent element of a `NxN` symmetric matrix. It is not in the; mandate of this package to provide complete linear algebra; functionality. It provides basic matrix and vector functions such as; matrix-matrix, matrix-vector, vector-vector operations, plus some extra; functionality for square matrices, like inversion and determinant; calculation. The inversion is based on the optimized Cramer method for; squared matrices of size up to `6x6`. The `SMatrix` package contains only header files. Normally one does not; need to build any library. In the ROOT distribution a library,; `libSmatrix` is produced with the C++ dictionary information for squared; and symmetric matrices and vectors up to dimension 7 and based on; **`Double_t`**, **`Float_t`** and **`Double32_t`**. The following; paragraphs describe the main characteristics of the matrix and vector; classes. More detailed information about the `SMatrix` classes API is; available in the; [online reference documentation](online reference documentation). ### Example: Vector Class (SVector). The template class **`ROOT::Math::SVector`** represents `n`-dimensional; vectors for objects of arbitrary type. This class has 2 template; parameters, which define at compile time, its properties: 1) type of the; contained elements (for example *float* or *double*); 2) size of the; vector. The use of this dictionary is mandatory if one want ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:103533,Performance,perform,performed,103533,"he expression template technique, no temporary; objects are created in this operation. - Constructor by passing directly the elements. This is possible only; for vectors up to size 10. - Constructor from an iterator copying the data referred by the; iterator. It is possible to specify the *begin* and *end* of the; iterator or the *begin* and the *size*. Note that for the Vector the; iterator is not generic and must be of type `T*`, where `T` is the; type of the contained elements. In the following example we assume that we are using the namespace; **`ROOT::Math`**. ``` {.cpp}; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; ```. #### Accessing and Setting Methods. The single vector elements can be set or retrieved using the; `operator[i]`, `operator(i)` or the iterator interface. Notice that the; index starts from zero and not from one as in FORTRAN. Also no check is; performed on the passed index. The full vector elements can be set also; by using the SetElements function passing a generic iterator. ``` {.cpp}; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; ```. In addition there are methods to place a sub-vector in a vector. If the; size of the sub-vector is larger than the vector size a static assert (a; compilation error) is produced. ``` {.cpp}; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; ```. For th",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:112375,Performance,perform,performed,112375,";; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; ```. #### Linear Algebra Matrix Functions (Inversion, Determinant). Only limited linear algebra functionality is available for `SMatrix`. It; is possible for squared matrices `NxN`, to find the inverse or to; calculate the determinant. Different inversion algorithms are used if; the matrix is smaller than `6x6` or if it is symmetric. In the case of a; small matrix, a faster direct inversion is used. For a large; `(N>6) `symmetric matrix the Bunch-Kaufman diagonal pivoting method is; used while for a large `(N>6)` general matrix an LU factorization is; performed using the same algorithm as in the CERNLIB routine `dinv`. ``` {.cpp}; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calculate determinant by using a temporary matrix; preserves; // matrix content; bool ret = n.Det2(det);; ```. ### Example: Matrix and Vector Functions and Operators. #### Matrix and Vector Operators. The **`ROOT::Math::SVector`** and **`ROOT::Math::SMatrix`** classes; define the following operators described below. The `m1`, `m2`, `m3` are; vectors or matrices of the same type (and size) and `a` is a scalar; value:",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:11869,Safety,detect,detected,11869,"g a linear congruential random; generator. The multipliers used are the same of the BSD `rand()` random; generator. Its sequence is:. $x_{n+1} = (ax_n + c) mod m$ with $a =1103515245$,; $c = 12345$ and $m =2^{31}$. This type of generator uses a state of only a 32 bit integer and it has; a very short period, 2^31^,about 10^9^, which can be exhausted in just; few seconds. The quality of this generator is therefore BAD and it is; strongly recommended to NOT use for any statistical study. ### TRandom1. This random number generator is based on the Ranlux engine, developed by; M. Lüsher and implemented in Fortran by F. James. This engine has; mathematically proven random proprieties and a long period of about; 10^171^. Various luxury levels are provided `(1,2,3,4)` and can be; specified by the user in the constructor. Higher the level, better; random properties are obtained at a price of longer CPU time for; generating a random number. The level 3 is the default, where any; theoretical possible correlation has very small chance of being; detected. This generator uses a state of 24 32-bits words. Its main; disadvantage is that is much slower than the others (see timing table).; For more information on the generator see the following article:. - F. James, ""RANLUX: A Fortran implementation of the high quality; pseudo-random number generator of Lüscher"", Computer Physics; Communication, 79 (1994) 111. ### TRandom2. This generator is based on the maximally equi-distributed combined; Tausworthe generator by L'Ecuyer. It uses only 3 32-bits words for the; state and it has a period of about 10^26^. It is fast and given its; small states, it is recommended for applications, which require a very; small random number size. For more information on the generator see the; following article:. - P. L'Ecuyer, ""Maximally Equi-distributed Combined Tausworthe; Generators"", Mathematics of Computation, 65, 213 (1996), 203-213. ### TRandom3. This is based on the Mersenne and Twister pseudo-rand",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42235,Safety,avoid,avoid,42235,"icGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signat",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:69003,Safety,avoid,avoided,69003,", `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case, between points and vectors, modeling them with; different classes:. - `ROOT::Math::`**`DisplacementVector2D`** and; `ROOT::Math::`**`DisplacementVector3D`** template classes describing; 2 and 3 component direction and magnitude vectors, not rooted at any; particul",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:69337,Safety,avoid,avoid,69337,"specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically vectors and points are two distinct concepts. They have; different transformations, as vectors only rotate while points rotate; and translate. You can add two vectors but not two points and the; difference between two points is a vector. We then distinguish for the 3; dimensional case, between points and vectors, modeling them with; different classes:. - `ROOT::Math::`**`DisplacementVector2D`** and; `ROOT::Math::`**`DisplacementVector3D`** template classes describing; 2 and 3 component direction and magnitude vectors, not rooted at any; particular point;. - `ROOT::Math::`**`PositionVector2D`** and; `ROOT::Math::`**`PositionVector3D`** template classes modeling the; points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them,; `ROOT::Math::`**`LorentzVector`**, since we have recognized a limited; need for modeling the functionality of a 4D po",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:71696,Safety,avoid,avoid,71696," classes:. - **`ROOT::Math::Cartesian3D`**, based on (`x,y,z`);. - **`ROOT::Math::Polar3D`**, based on (`r,theta,phi`);. - **`ROOT::Math::Cylindrical3D`**, based on (`rho,z,phi`). - **`ROOT::Math::CylindricalEta3D`**, based on (`rho,eta,phi`), where; `eta` is the pseudo-rapidity;. 4D coordinate system classes:. - **`ROOT::Math::PxPyPzE4D`**, based on based on (`px,py,pz,E`);. - **`ROOT::Math::PxPyPzM4D`**, based on based on (`px,py,pz,M`);. - **`ROOT::Math::PtEtaPhiE4D`**, based on based on (`pt,eta,phi,E`);. - **`ROOT::Math::PtEtaPhiM4D`**, based on based on (`pt,eta,phi,M`);. Users can define the vectors according to the coordinate type, which is; the most efficient for their use. Transformations between the various; coordinate systems are available through copy constructors or the; assignment (=) operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformations are modeled using simple (non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, w",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:72596,Safety,avoid,avoid,72596,") operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformations are modeled using simple (non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, which are; translation`/`rotation combinations. Each group has several members; which may model physically equivalent transformations but with different; internal representations. Transformation classes can operate on all type; of vectors by using the operator `() `or the operator `*` and the; transformations can be combined via the operator `*`. The available; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74842,Safety,avoid,avoiding,74842,"s. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesian vector. We then enforce the use; of transformations as rotations or translations (additions) for; modifying the vector contents. - The majority of the functionality, which is present in the CLHEP; package, involving operations on two vectors, is moved in separated; helper functions (see `ROOT::Math::VectorUtil`). This has the; advantage that the basic interface will remain more stable with time; while additional functions can be added easily. #### Naming Convention. As part of ROOT, the `GenVector` package adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (s",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:76596,Safety,avoid,avoid,76596,"age adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (see the next section about CLHEP compatibility). #### Compatibility with CLHEP Vector Classes. - For backward compatibility with CLHEP the vector classes can be; constructed from a CLHEP `HepVector` or **`HepLorentzVector`**, by; using a template constructor, which requires only that the classes; implement the accessors` x()`, `y()`, and `z()` (and `t()` for the; 4D). - We provide vector member function with the same naming convention as; CLHEP for the most used functions like `x()`, `y()` and `z()`. #### Connection to Linear Algebra Package. In some use cases, like in track reconstruction, it is needed to use the; content of the vector and rotation classes in conjunction with linear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float'",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:77495,Safety,avoid,avoid,77495,"inear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float's. To use them, one; must include the header file `Math/Vector3D.h`. The following typedef's,; defined in the header file `Math/Vector3Dfwd.h`, are available for the; different instantiations of the template class; `ROOT::Math::`**`DisplacementVector3D`**:. - `ROOT::Math::`**`XYZVector`** vector based on `x,y,z` coordinates; (Cartesian) in double precision. - `ROOT::Math::`**`XYZVectorF`** vector based on `x,y,z` coordinates; (Cartesian) in float precision. - `ROOT::Math::`**`Polar3DVector`** vector based on `r,theta,phi`; coordinates (polar) in double precision. - `ROOT::Math::`**`Polar3DVectorF`** vector based on `r,theta,phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiVector`** vector based on `rho,z,phi`; coordinates (cylindrical) in double precision. - `ROOT::Math::`**`RhoZPhiVectorF`** vector based on `rho,z,phi`; coordinates (cylindrical) in float precision. - `ROOT::Math::`**`RhoEtaPhiVector`",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:107438,Safety,avoid,avoid,107438,"assignment) for a matrix with the same; representation, or from a different one when possible, for example; from a symmetric to a general matrix. - Constructor (and assignment) from a matrix expression, like; `D=A*B+C`. Due to the expression template technique, no temporary; objects are created in this operation. In the case of an operation; like `A=A*B+C`, a temporary object is needed and it is created; automatically to store the intermediary result in order to preserve; the validity of this operation. - Constructor from a generic STL-like iterator copying the data; referred by the iterator, following its order. It is both possible; to specify the begin and end of the iterator or the begin and the; size. In case of a symmetric matrix, it is required only the; triangular block and the user can specify whether giving a block; representing the lower (default case) or the upper diagonal part. Here are some examples on how to create a matrix. We use typedef's in; the following examples to avoid the full C++ names for the matrix; classes. Notice that for a general matrix the representation has the; default value, **`ROOT::Math::MatRepStd`**, and it is not needed to be; specified. Furthermore, for a general square matrix, the number of; column may be as well omitted. ``` {.cpp}; // typedef definitions used in the following declarations; typedef ROOT::Math::SMatrix<double,3> SMatrix33;; typedef ROOT::Math::SMatrix<double,2> SMatrix22;; typedef ROOT::Math::SMatrix<double,3,3,; ROOT::Math::MatRepSym<double,3>> SMatrixSym3;; typedef ROOT::Math::SVector>double,2> SVector2;; typedef ROOT::Math::SVector>double,3> SVector3;; typedef ROOT::Math::SVector>double,6> SVector6;; SMatrix33 m0; // create a zero 3x3 matrix; // create an 3x3 identity matrix; SMatrix33 i = ROOT::Math::SMatrixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:118317,Safety,predict,predictions,118317,"kground estimate. The signal is always assumed to be Poisson;; background may be Poisson, Gaussian, or user-supplied; efficiency may be; Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum.; Meth. A551:493-503,2005. **`TLimit`** class computes 95% C.L. limits using the Likelihood ratio; semi-Bayesian method ( <CLs> method; see e.g. T. Junk, NIM A434, p.; 435-443, 1999). It takes signal background and data histograms wrapped; in a `TLimitDataSource` as input, and runs a set of Monte Carlo; experiments in order to compute the limits. If needed, inputs are; fluctuated according to systematic. ### Specialized Classes for Fitting. **`TFractionFitter`** fits Monte Carlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:6226,Security,hash,hashing,6226,". The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. - numerical constants (like `pi`, `e`, `h`, etc.);. - trigonometric and elementary mathematical functions;. - functions to work with arrays and collections (e.g. functions to find `min` and `max` of arrays);. - statistic functions to work on array of data (e.g. mean and `RMS` of arrays);. - algorithms for binary search/hashing sorting;. - special mathematical functions like `Bessel`, `Erf`, `Gamma`, etc.;. - statistical functions, like common probability and cumulative; (quantile) distributions. - geometrical functions. For more details, see the reference documentation of **`TMath`** at; [<http://root.cern.ch/root/htmldoc/TMath.html>](https://root.cern/doc/master/namespaceTMath.html). ### Numerical Constants. `TMath` offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.;",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:7806,Security,secur,security,7806,"nstants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.; * Elementary charge. ### Elementary Functions. A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding. Although there are some functions that are not in the standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to calculate:. * Mean.; * Median.; * Geometrical mean.; * Sample Standard Deviation (*RMS*).; * The kth smallest element. These functions, as the array algorithms, have two different interfaces. An old-style one where the size of the array is passed as a first argument followed by a pointer to the array itself; and a modern C++-like interface that recei",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:76181,Security,access,accessors,76181,"artesian vector. We then enforce the use; of transformations as rotations or translations (additions) for; modifying the vector contents. - The majority of the functionality, which is present in the CLHEP; package, involving operations on two vectors, is moved in separated; helper functions (see `ROOT::Math::VectorUtil`). This has the; advantage that the basic interface will remain more stable with time; while additional functions can be added easily. #### Naming Convention. As part of ROOT, the `GenVector` package adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (see the next section about CLHEP compatibility). #### Compatibility with CLHEP Vector Classes. - For backward compatibility with CLHEP the vector classes can be; constructed from a CLHEP `HepVector` or **`HepLorentzVector`**, by; using a template constructor, which requires only that the classes; implement the accessors` x()`, `y()`, and `z()` (and `t()` for the; 4D). - We provide vector member function with the same naming convention as; CLHEP for the most used functions like `x()`, `y()` and `z()`. #### Connection to Linear Algebra Package. In some use cases, like in track reconstruction, it is needed to use the; content of the vector and rotation classes in conjunction with linear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:79378,Security,access,accessors,79378,"rho,z,phi`; coordinates (cylindrical) in double precision. - `ROOT::Math::`**`RhoZPhiVectorF`** vector based on `rho,z,phi`; coordinates (cylindrical) in float precision. - `ROOT::Math::`**`RhoEtaPhiVector`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in double; precision. - `ROOT::Math::`**`RhoEtaPhiVectorF`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in float; precision. #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; ```. Note that each vector type is constructed by passing its coordinate; representation, so a `XYZVector(1,2,3)` is different from a; `Polar3DVector(1,2,3)`. In addition, the vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`; and `z()`. This can be another 3D vector based on a different coordinate; system type. It can be even any vector of a different package, like the; CLHEP **`HepThreeVector`** that implements the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:79773,Security,access,accessors,79773,". #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; ```. Note that each vector type is constructed by passing its coordinate; representation, so a `XYZVector(1,2,3)` is different from a; `Polar3DVector(1,2,3)`. In addition, the vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`; and `z()`. This can be another 3D vector based on a different coordinate; system type. It can be even any vector of a different package, like the; CLHEP **`HepThreeVector`** that implements the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; ```. See the reference documentation of; `ROOT::Math::`**`DisplacementVector3D`** for more details on all the; coordinate accessors. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinat",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:80643,Security,access,accessors,80643,"ts the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; ```. See the reference documentation of; `ROOT::Math::`**`DisplacementVector3D`** for more details on all the; coordinate accessors. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinates(c1,c2,c3); // r,theta,phi for a Polar3DVector; r2.SetXYZ(x,y,z); // 3 cartesian components for Polar3DVector; ```. Single coordinate setter methods are available for the basic vector; coordinates, like `SetX()` for a **`XYZVector`** or `SetR()` for a polar; vector. Attempting to do a `SetX()` on a polar vector will not compile. ``` {.cpp}; XYZVector v1;; v1.SetX(1); //OK setting x for a Cartesian vector; Polar3DVector v2;; v2.SetX(1); //ERROR: cannot set X for a Polar vector.; //Method will not compile; v2.SetR(1); //OK setting r for a Polar vector; ```. In addition, there are setter methods from C arrays or iterator. ``` {.cpp}; double d[3] = {1.,2.,3.};; XYZVector v;; // set (x,y,z) components of v using values from d; v.SetCoordinates(d);; ```. or, for example, fro",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:84464,Security,access,accessors,84464,"`** point based on `r`, `theta`, `phi`; coordinates (polar) in float precision. - `ROOT::Math::`**`RhoZPhiPoint`** point based on `rho`, `z`, `phi`; coordinates (cylindrical using `z`) in double precision. - `ROOT::Math::`**`RhoZPhiPointF`** point based on `rho`, `z`, `phi`; coordinates (cylindrical using `z`) in float precision. - `ROOT::Math::`**`RhoEtaPhiPoint`** point based on `rho`, `eta`,; `phi` coordinates (cylindrical using eta instead of `z`) in double; precision. - `ROOT::Math::`**`RhoEtaPhiPointF`** point based on `rho`, `eta`,; `phi` coordinates (cylindrical using eta instead of `z`) in float; precision. #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; XYZPoint p1; //an empty vector (x=0, y=0, z=0); XYZPoint p2(1,2,3); //; ```. Note that each point type is constructed by passing its coordinate; representation, so a `XYZPoint(1,2,3)` is different from a; `Polar3DPoint(1,2,3)`. In addition the point classes can be constructed; by any vector, which implements the accessors `x()`, `y()` and `z()`.; This can be another 3D point based on a different coordinate system type; or even any vector of a different package, like the CLHEP; **`HepThreePoint`** that implements the required signatures. ``` {.cpp}; XYZPoint p1(1,2,3);; RhoEtaPHiPoint r2(v1);; CLHEP::HepThreePoint q(1,2,3);; XYZPoint p3(q);; ```. #### Coordinate Accessors and Setter Methods. For the points classes we have the same getter and setter methods as for; the vector classes. See ""Example: 3D Vector Classes"". #### Point-Vector Operations. The following operations are possible between points and vector classes:; (`p1`, `p2` and `p3` are instantiations of the; `ROOT::Math::`**`PositionVector3D`** objects with `p1` and `p3` of the; same type; `v1` and `v2` are `ROOT::Math::`**`DisplacementVector3D`**; objects). ``` {.cpp}; p1 += v1;; p1 -= v1;; p3 = p1 + v1; // p1 and p3 are the same type; p3 = v1 + p1; // p3 is based on the same coordinate system as v1; p3 = p1 ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:87445,Security,access,accessors,87445,"`z`, `t`; coordinates (Cartesian) in float precision. - `ROOT::Math::`**`PtEtaPhiEVector`** vector based on `pt(rho)`,; `eta`, `phi` and `E(t)` coordinates in double precision. - `ROOT::Math::`**`PtEtaPhiMVector`** vector based on `pt(rho)`,; `eta`, `phi` and `M(t)` coordinates in double precision. - `ROOT::Math::`**`PxPyPzMVector`** vector based on `px`, `py`, `pz`; and `M(mass)` coordinates in double precision. The metric used for all the LorentzVector is (`-,-,-,+`) . #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; ```. Note that each type of vector is constructed by passing its coordinate; representation, so a **`XYZTVector`**`(1,2,3,4)` is different from a; `PtEtaPhiEVector(1,2,3,4)`. In addition, the Vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`,; `z()` and `t()`. This can be another `ROOT::Math::`**`LorentzVector`** based on a; different coordinate system or any vector of a different package, like; the CLHEP **`HepLorentzVector`** that implements the required signature. ``` {.cpp}; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; ```. #### Coordinate Accessors. All the same coordinate accessors are available through the interface of; `ROOT::Math::`**`LorentzVector`**. For example:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); ```. In addition, all 4 vector coordinates can be retrieved with the; `GetCoordinates` method:. ``` {.cpp}; double d[4];; //fill d array with (x,y,z,t) co",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:87872,Security,access,accessors,87872," Constructors and Assignment. The following declarations are available:. ``` {.cpp}; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; ```. Note that each type of vector is constructed by passing its coordinate; representation, so a **`XYZTVector`**`(1,2,3,4)` is different from a; `PtEtaPhiEVector(1,2,3,4)`. In addition, the Vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`,; `z()` and `t()`. This can be another `ROOT::Math::`**`LorentzVector`** based on a; different coordinate system or any vector of a different package, like; the CLHEP **`HepLorentzVector`** that implements the required signature. ``` {.cpp}; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; ```. #### Coordinate Accessors. All the same coordinate accessors are available through the interface of; `ROOT::Math::`**`LorentzVector`**. For example:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); ```. In addition, all 4 vector coordinates can be retrieved with the; `GetCoordinates` method:. ``` {.cpp}; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; ```. To get information on all the coordinate accessors see the; `ROOT::Math::`**`LorentzVector`** reference documentation. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; //sets the (x,y,z,t) for a XYZTVector; v1.SetCo",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:88695,Security,access,accessors,88695,"ZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; ```. #### Coordinate Accessors. All the same coordinate accessors are available through the interface of; `ROOT::Math::`**`LorentzVector`**. For example:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); ```. In addition, all 4 vector coordinates can be retrieved with the; `GetCoordinates` method:. ``` {.cpp}; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; ```. To get information on all the coordinate accessors see the; `ROOT::Math::`**`LorentzVector`** reference documentation. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e for a PtEtaPhiEVector; v2.SetCoordinates(c1,c2,c3,c4);; //sets cartesian components for PtEtaPhiEVector; v2.SetXYZ(x,y,z,t);; ```. Single coordinate setter methods are available for the basic vector; coordinates, like `SetX()` for a `XYZTVector` or `SetPt()` for a; **`PtEtaPhiEVector`**. Attempting to do a `SetX()` on a non-Cartesian; vector will not compile. ``` {.cpp}; XYZTVector v1;; v1.SetX(1); //OK setting x for a cartesian vector; PtEtaPhiEVector v2;; v2.SetX(1); //ERROR: cannot set X for a non-cartesian; //vector. Method will not compile.; v2.SetR(1) // OK setting Pt for a PtEtaPhiEVector vector; ```. In addition, there are setter methods from C arrays or iterators. ``` {.cpp}; double d[4] = {1.,2.,3.,4.};; XYZTVector v;; //set (x,y,z,t) components ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:109230,Security,access,accessed,109230,",2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); ```. Example to fill a symmetric matrix from an `std::vector`:. ``` {.cpp}; std::vector<double> v(6);; for (int i = 0; i<6; ++i) v[i] = double(i+1);; SMatrixSym3 s(v.begin(),v.end()) // this will produce the; // symmetric matrix; // ( 1 2 4 ); // ( 2 3 5 ); // ( 4 5 6 ); //create a general matrix from a symmetric matrix (the opposite; // will not compile); SMatrix33 m2 = s;; ```. #### Accessing and Setting Methods. The matrix elements can be set using the `operator()(irow,icol)`, where; `irow` and `icol` are the row and column indexes or by using the; iterator interface. Notice that the indexes start from zero and not from; one as in FORTRAN. Furthermore, all the matrix elements can be set also; by using the SetElements function passing a generic iterator. The; elements can be accessed by the same methods as well as by using the; function `ROOT::Math::SMatrix::apply`. The `apply(i)` has exactly the; same behavior for general and symmetric matrices; in contrast to the; iterator access methods which behave differently (it follows the data; order). ``` {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; ```. There are methods to place and/or retrieve **`ROOT::Math::SVector`**; objects as rows or columns in (from) a matrix. In addition one can put; (get) a sub-ma",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:109434,Security,access,access,109434,"; // ( 4 5 6 ); // ( 7 8 9 ); ```. Example to fill a symmetric matrix from an `std::vector`:. ``` {.cpp}; std::vector<double> v(6);; for (int i = 0; i<6; ++i) v[i] = double(i+1);; SMatrixSym3 s(v.begin(),v.end()) // this will produce the; // symmetric matrix; // ( 1 2 4 ); // ( 2 3 5 ); // ( 4 5 6 ); //create a general matrix from a symmetric matrix (the opposite; // will not compile); SMatrix33 m2 = s;; ```. #### Accessing and Setting Methods. The matrix elements can be set using the `operator()(irow,icol)`, where; `irow` and `icol` are the row and column indexes or by using the; iterator interface. Notice that the indexes start from zero and not from; one as in FORTRAN. Furthermore, all the matrix elements can be set also; by using the SetElements function passing a generic iterator. The; elements can be accessed by the same methods as well as by using the; function `ROOT::Math::SMatrix::apply`. The `apply(i)` has exactly the; same behavior for general and symmetric matrices; in contrast to the; iterator access methods which behave differently (it follows the data; order). ``` {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; ```. There are methods to place and/or retrieve **`ROOT::Math::SVector`**; objects as rows or columns in (from) a matrix. In addition one can put; (get) a sub-matrix as another **`ROOT::Math::SMatrix`** object in a; matrix. If the size of the sub-vector or sub-matrix is larger than the; matrix size a static ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:119392,Security,access,access,119392,"arlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum likelihood fit and with a tool to access the quality and; validity of the fit producing distributions for the control variables.; (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369,; 2005). ### Multi-variate Analysis Classes. **`TMultiLayerPerceptron`** is a Neural Network class (see for more; details the chapter ""Neural Networks""). **`TPrincipal`** provides the Principal Component Analysis. **`TRobustEstimator`** is a robust method for minimum covariance; determinant estimator (MCD). **`TMVA`** is a package for multivariate data analysis (see; <https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf> the User's Guide).; ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:6871,Testability,log,logarithm,6871,"ided for the following functionality:. - numerical constants (like `pi`, `e`, `h`, etc.);. - trigonometric and elementary mathematical functions;. - functions to work with arrays and collections (e.g. functions to find `min` and `max` of arrays);. - statistic functions to work on array of data (e.g. mean and `RMS` of arrays);. - algorithms for binary search/hashing sorting;. - special mathematical functions like `Bessel`, `Erf`, `Gamma`, etc.;. - statistical functions, like common probability and cumulative; (quantile) distributions. - geometrical functions. For more details, see the reference documentation of **`TMath`** at; [<http://root.cern.ch/root/htmldoc/TMath.html>](https://root.cern/doc/master/namespaceTMath.html). ### Numerical Constants. `TMath` offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.; * Elementary charge. ### Elementary Functions. A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding. Although there are some functions that are not in the standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometri",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:7515,Testability,log,logarithm,7515,"`TMath`** at; [<http://root.cern.ch/root/htmldoc/TMath.html>](https://root.cern/doc/master/namespaceTMath.html). ### Numerical Constants. `TMath` offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.; * Elementary charge. ### Elementary Functions. A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding. Although there are some functions that are not in the standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to ca",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:45661,Testability,test,test,45661,"ative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function obje",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:45724,Testability,test,test,45724,"(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluati",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:45804,Testability,test,test,45804,":Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const d",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:45866,Testability,test,test,45866,"i-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluation and another function object implementing `double operator() (const double *, int icoord)`; for the partial derivatives. The function dimensio",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58833,Testability,test,testIntegrationMultiDim,58833,"tion type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);; ig2.SetFunction(wf);; val = ig2.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val <<",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:104156,Testability,assert,assert,104156,"ector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; ```. #### Accessing and Setting Methods. The single vector elements can be set or retrieved using the; `operator[i]`, `operator(i)` or the iterator interface. Notice that the; index starts from zero and not from one as in FORTRAN. Also no check is; performed on the passed index. The full vector elements can be set also; by using the SetElements function passing a generic iterator. ``` {.cpp}; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; ```. In addition there are methods to place a sub-vector in a vector. If the; size of the sub-vector is larger than the vector size a static assert (a; compilation error) is produced. ``` {.cpp}; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; ```. For the vector functions see later in the Matrix and Vector Operators; and Functions paragraph. ### Example: Matrix Class (SMatrix). The template class **`ROOT::Math::SMatrix`** represents a matrix of; arbitrary type with `nrows` `x` `ncol` dimension. The class has 4; template parameters, which define at compile time, its properties:. - type of the contained elements, T, for example float or double;. - number of rows;. - number of columns;. - representation type. This is a class describing the underlined; storage model of the Matrix. Presently exists only two types of this; class:. - **`ROOT::Math::Ma",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:110413,Testability,assert,assert,110413,"tric matrices; in contrast to the; iterator access methods which behave differently (it follows the data; order). ``` {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; ```. There are methods to place and/or retrieve **`ROOT::Math::SVector`**; objects as rows or columns in (from) a matrix. In addition one can put; (get) a sub-matrix as another **`ROOT::Math::SMatrix`** object in a; matrix. If the size of the sub-vector or sub-matrix is larger than the; matrix size a static assert (a compilation error) is produced. The; non-const methods are:. ``` {.cpp}; SMatrix33 m;; SVector2 v2(1,2);; // place a vector in the first row from; // element (0,1) : m(0,1)=v2[0]; m.Place_in_row(v2,0,1);; // place the vector in the second column from; // (0,1) : m(0,1) = v2[0]; m.Place in_col(v2,0,1);; SMatrix22 m2;; // place m2 in m starting from the; // element (1,1) : m(1,1) = m2(0,0); m.Place_at(m2,1,1);; SVector3 v3(1,2,3);; // set v3 as the diagonal elements; // of m : m(i,i) = v3[i] for i=0,1,2; m.SetDiagonal(v3); ```. The const methods retrieving contents (getting slices of a matrix) are:. ``` {.cpp}; a = {1,2,3,4,5,6,7,8,9};; SMatrix33 m(a,a+9);; SVector3 irow = m.Row(0); // return as vector the first row; SVector3 jcol = m.Col(1); // return as vector the second column. // return a slice of the first row from; // (0,1): r2[0]= m(0,1); r2[1]=m(0,2); SVector2 r2 = m.SubRow<SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:15109,Usability,simpl,simplest,15109,"apsed time is less than a second. ### Examples of Using the Generators. The method `Rndm()` is used for generating a pseudo-random number; distributed between 0 and 1 as shown in the following example:. ``` {.cpp}; // use default seed; // (same random numbers will be generated each time); TRandom3 r; // generate a number in interval ]0,1] (0 is excluded); r.Rndm();; double x[100];; r.RndmArray(100,x); // generate an array of random numbers in ]0,1]; TRandom3 rdm(111); // construct with a user-defined seed; // use 0: a unique seed will be automatically generated using TUUID; TRandom1 r1(0);; TRandom2 r2(0);; TRandom3 r3(0);; // seed generated using machine clock (different every second); TRandom r0(0);; ```. ### Random Number Distributions. The **`TRandom`** base class provides functions, which can be used by; all the other derived classes for generating random variates according; to predefined distributions. In the simplest cases, like in the case of; the exponential distribution, the non-uniform random number is obtained; by applying appropriate transformations. In the more complicated cases,; random variates are obtained using acceptance-rejection methods, which; require several random numbers. ``` {.cpp}; TRandom3 r;; // generate a gaussian distributed number with:; // mu=0, sigma=1 (default values); double x1 = r.Gaus();; double x2 = r.Gaus(10,3); // use mu = 10, sigma = 3;; ```. The following table shows the various distributions that can be; generated using methods of the **`TRandom`** classes. More information; is available in the reference documentation for **`TRandom`**. In; addition, random numbers distributed according to a user defined; function, in a limited interval, or to a user defined histogram, can be; generated in a very efficient way using **`TF1::`**GetRandom() or; **`TH1::`**GetRandom(). +-------------------------------------------+--------------------------------+; | Distributions | Description |; +-------------------------------------------+-",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35631,Usability,simpl,simple,35631,"eds to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradientFunctionOneDim`: Some of the numerical algorithm will need to calculate the derivatives of the function. In these cases, the user will have to provide the necessary code for; this to happen. The interface defined in `IGradientFunctionOneDim` introduced the method `double Derivative(double x)` that will return the derivative of the function at the point `x`. The ",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:44873,Usability,simpl,simple,44873,"er function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test fro",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54916,Usability,guid,guide,54916,"se);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62072,Usability,guid,guide,62072,"100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimizat",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62139,Usability,guid,guide,62139," quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:65111,Usability,simpl,simplest,65111,"ze one-dimensional function.; An interval containing the function minimum must be provided.; Here is an example where we define the function to minimize as a *lambda* function; (requires C++11). The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object. ```{.cpp}; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; ```. Note that when setting the function to minimize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1:",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:72529,Usability,simpl,simple,72529,") operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformations are modeled using simple (non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, which are; translation`/`rotation combinations. Each group has several members; which may model physically equivalent transformations but with different; internal representations. Transformation classes can operate on all type; of vectors by using the operator `() `or the operator `*` and the; transformations can be combined via the operator `*`. The available; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (",MatchSource.DOCS,documentation/users-guide/MathLibraries.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1254,Integrability,message,message,1254,"er the network. If the request is accepted, it; returns a full-duplex socket. Once the connection is accepted, we can; communicate to the client that we are ready to go by sending the string; ""go"", and we can close the server socket. ``` {.cpp}; { // server; TServerSocket *ss = new TServerSocket(9090,kTRUE);; TSocket *socket = ss->Accept();; socket->Send(""go"");; ss->Close();; }; ```. *On the clientside*, we create a socket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a po",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1606,Integrability,message,message,1606,"Send(""go"");; ss->Close();; }; ```. *On the clientside*, we create a socket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closi",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1663,Integrability,message,message,1663,"ket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the conn",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1878,Integrability,message,message,1878," established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png).",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1934,Integrability,message,message,1934,"ve a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server h",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1950,Integrability,message,message,1950,"ve a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server h",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1989,Integrability,message,message,1989,"d an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we nee",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2011,Integrability,message,message,2011,"d an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we nee",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2129,Integrability,message,message,2129,"use it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method retu",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2171,Integrability,message,message,2171," `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example ",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2356,Integrability,message,message,2356,"r`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2457,Integrability,message,message,2457,"e the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2480,Integrability,message,message,2480,"e the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2506,Integrability,message,message,2506,"e the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2526,Integrability,message,message,2526,"e the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2556,Integrability,message,message,2556,"e the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:40,Usability,learn,learn,40,"# Networking. In this chapter, you will learn how to send data over the network using; the ROOT socket classes. ## Setting-up a Connection. *On the serverside*, we create a **`TServerSocket`** to wait for a; connection request over the network. If the request is accepted, it; returns a full-duplex socket. Once the connection is accepted, we can; communicate to the client that we are ready to go by sending the string; ""go"", and we can close the server socket. ``` {.cpp}; { // server; TServerSocket *ss = new TServerSocket(9090,kTRUE);; TSocket *socket = ss->Accept();; socket->Send(""go"");; ss->Close();; }; ```. *On the clientside*, we create a socket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; soc",MatchSource.DOCS,documentation/users-guide/Networking.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:4251,Security,access,accessed,4251,"ns List of TF1, TF2, TF3; TSeqCollection* fTasks List of TTask; TSeqCollection* fColors List of TColor; TSeqCollection* fGeometries List of geometries; TSeqCollection* fBrowsers List of TBrowser; TSeqCollection* fSpecials List of special objects; TSeqCollection* fCleanups List of recursiveRemove collections; ```. These collections are also displayed in the root folder of the; `Object Browser`. Most of these collections are self explanatory. The; special cases are the collections of specials and cleanups. ### The Collection of Specials. This collection contains objects of the following classes:; **`TCutG`**, **`TMultiDimFit`**, **`TPrincipal`**, **`TChains`**. In; addition it contains the ***`gHtml`*** object, ***`gMinuit`***; objects, and the array of contours graphs (**`TGraph`**) created when; calling the `Draw` method of a histogram with the `""CONT`, `LIST""`; option. ### Access to the Collection Contents. The current content for a collection listed above can be accessed with; the corresponding `gROOT->GetListOf` method (for example; `gROOT->GetListOfCanvases`). In addition, `gROOT->GetListOfBrowsables`; returns a collection of all objects visible on the left side panel in; the browser. See the image of the Object Browser in the next figure. ![The ROOT Object Browser](pictures/03000094.png). ## Ownership by Other Objects. When an object creates another, the creating object is the owner of the; created one. For example:. ``` {.cpp}; myHisto->Fit(""gaus""); ```. The call to Fit copies the global **`TF1`** Gaussian function and; attaches the copy to the histogram. When the histogram is deleted, the; copy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two",MatchSource.DOCS,documentation/users-guide/ObjectOwnership.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:5550,Testability,test,tested,5550,"/03000094.png). ## Ownership by Other Objects. When an object creates another, the creating object is the owner of the; created one. For example:. ``` {.cpp}; myHisto->Fit(""gaus""); ```. The call to Fit copies the global **`TF1`** Gaussian function and; attaches the copy to the histogram. When the histogram is deleted, the; copy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two bits, `kCanDelete` and `kMustCleanup`, that; influence how an object is managed (in `TObject::fBits)`. These are in; an enumeration in `TObject.h.` To set these bits do:. ``` {.cpp}; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); ```. The bits can be reset and tested with the `TObject::ResetBit` and; **`TObject::TestBit` methods.**. ### The kCanDelete Bit. The ***`gROOT`*** collections (see above) own their members and will; delete them regardless of the `kCanDelete` bit. In all other; collections, when the collection `Clear` method is called (i.e.; **`TList::Clear())`**, members with the `kCanDelete` bit set, are; deleted and removed from the collection. If the `kCanDelete` bit is; not set, the object is only removed from the collection but not; deleted. If a collection `Delete` (`TList::Delete()`) method is called, all; objects in the collection are deleted without considering the; `kCanDelete` bit. It is important to realize that deleting the; collection (i.e. delete `MyCollection`), DOES NOT delete the members; of the collection. If the user specified `MyCollection->SetOwner()` the collection owns; the objects and delete `MyCollection` will delete all its members.; Otherwise, you need to:. ``` {.cpp}; // delete all member objects in the collection; MyCollecti",MatchSource.DOCS,documentation/users-guide/ObjectOwnership.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:4943,Usability,clear,cleared,4943,"Html`*** object, ***`gMinuit`***; objects, and the array of contours graphs (**`TGraph`**) created when; calling the `Draw` method of a histogram with the `""CONT`, `LIST""`; option. ### Access to the Collection Contents. The current content for a collection listed above can be accessed with; the corresponding `gROOT->GetListOf` method (for example; `gROOT->GetListOfCanvases`). In addition, `gROOT->GetListOfBrowsables`; returns a collection of all objects visible on the left side panel in; the browser. See the image of the Object Browser in the next figure. ![The ROOT Object Browser](pictures/03000094.png). ## Ownership by Other Objects. When an object creates another, the creating object is the owner of the; created one. For example:. ``` {.cpp}; myHisto->Fit(""gaus""); ```. The call to Fit copies the global **`TF1`** Gaussian function and; attaches the copy to the histogram. When the histogram is deleted, the; copy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two bits, `kCanDelete` and `kMustCleanup`, that; influence how an object is managed (in `TObject::fBits)`. These are in; an enumeration in `TObject.h.` To set these bits do:. ``` {.cpp}; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); ```. The bits can be reset and tested with the `TObject::ResetBit` and; **`TObject::TestBit` methods.**. ### The kCanDelete Bit. The ***`gROOT`*** collections (see above) own their members and will; delete them regardless of the `kCanDelete` bit. In all other; collections, when the collection `Clear` method is called (i.e.; **`TList::Clear())`**, members with the `kCanDelete` bit set, are; deleted and removed from the collection. If the `kCanDelete` bi",MatchSource.DOCS,documentation/users-guide/ObjectOwnership.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:1088,Energy Efficiency,energy,energy,1088,"hysics vector classes describe vectors in three and four dimensions; and their rotation algorithms. The classes were ported to root from; CLHEP see:. <http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html>. ## The Physics Vector Classes. In order to use the physics vector classes you will have to load the; Physics library:. ``` {.cpp}; gSystem.Load(""libPhysics.so"");; ```. There are four classes in this package. They are:. **`TVector3`** is a general three-vector. A **`TVector3`** may be; expressed in Cartesian, polar, or cylindrical coordinates. Methods; include dot and cross products, unit vectors and magnitudes, angles; between vectors, and rotations and boosts. There are also functions of; particular use to HEP, like pseudo-rapidity, projections, and transverse; part of a **`TVector3`**, and kinetic methods on 4-vectors such as; Invariant Mass of pairs or containers of particles`.`. **`TLorentzVector`** is a general four-vector class, which can be used; either for the description of position and time (`x`, `y`, `z`, `t`) or; momentum and energy (`px`, `py`, `pz`, `E`). **`TRotation`** is a class; describing a rotation of a **`TVector3`** object. **`TLorentzRotation`**; is a class to describe the Lorentz transformations including Lorentz; boosts and rotations. In addition, a **`TVector2`** is a basic; implementation of a vector in two dimensions and is not part of the; CLHEP translation. ## TVector3. ![](pictures/030001A9.png). **`TVector3`** is a general three-vector; class, which can be used for description of different vectors in 3D.; Components of three vectors:. - $x$, $y$, $z$ = basic components. - $\theta$ = azimuth angle. - $\phi$ = polar angle. - magnitude = $mag$ = $\sqrt{x^2 + y^2 + z^2}$. - transverse component = $perp$ = $\sqrt{x^2 + y^2}$. Using the **`TVector3`** class, you should remember that it contains; only common features of three vectors and lacks methods specific for; some particular vector values. For example, it has no translated; f",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:9540,Energy Efficiency,energy,energy,9540,"`operator *` has been implemented in a way that follows the; mathematical notation of a product of the two matrices which describe; the two consecutive rotations. Therefore, the second rotation should be; placed first:. ``` {.cpp}; r = r2 * r1;; ```. ### Rotation of TVector3. The **`TRotation`** class provides an `operator *` which allows; expressing a rotation of a **`TVector3`** analog to the mathematical; notation:. $$; \left|; \begin{array}{c}; x' \\; y' \\; z'; \end{array}; \right|; =; \left|; \begin{array}{ccc}; xx & xy & xz \\; yx & yy & yz \\; zx & zy & zz; \end{array}; \right|; \times; \left|; \begin{array}{c}; x \\; y \\; z; \end{array}; \right|; $$. ``` {.cpp}; TRotation r;; TVector3 v(1,1,1);; v = r * v;; ```. You can also use the `Transform()` method or the `operator *=` of the; **`TVector3`** class:. ``` {.cpp}; TVector3 v;; TRotation r;; v.Transform(r);; ```. ## TLorentzVector. **`TLorentzVector`** is a general four-vector class, which can be used; either for the description of position and time (`x`, `y`, `z`, `t`) or; momentum and energy (`px`, `py`, `pz`, `E`). ### Declaration. **`TLorentzVector`** has been implemented as a set a **`TVector3`** and; a `Double_t` variable. By default, all components are initialized by; zero. ``` {.cpp}; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; ```. For backward compatibility there are two constructors from a `Double_t`; and `Float_t` array. ### Access to Components. There are two sets of access functions to the components of a; **`TLorentzVector`**: `X()`, `Y()`, `Z()`, `T()` and `Px()`, `Py()`,; `Pz()` and `E()`. Both sets return the same values but the first set is; more relevant for use where **`TLorentzVector`** describes a combination; of position and time and the second set is more relevant where; **`TLorentzVector`** describes momentum and energy:. ``` {.cpp}; Double_t xx =v.X();; ...; Double_t tt = ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:10415,Energy Efficiency,energy,energy,10415,". ``` {.cpp}; TVector3 v;; TRotation r;; v.Transform(r);; ```. ## TLorentzVector. **`TLorentzVector`** is a general four-vector class, which can be used; either for the description of position and time (`x`, `y`, `z`, `t`) or; momentum and energy (`px`, `py`, `pz`, `E`). ### Declaration. **`TLorentzVector`** has been implemented as a set a **`TVector3`** and; a `Double_t` variable. By default, all components are initialized by; zero. ``` {.cpp}; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; ```. For backward compatibility there are two constructors from a `Double_t`; and `Float_t` array. ### Access to Components. There are two sets of access functions to the components of a; **`TLorentzVector`**: `X()`, `Y()`, `Z()`, `T()` and `Px()`, `Py()`,; `Pz()` and `E()`. Both sets return the same values but the first set is; more relevant for use where **`TLorentzVector`** describes a combination; of position and time and the second set is more relevant where; **`TLorentzVector`** describes momentum and energy:. ``` {.cpp}; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; ```. The components of **`TLorentzVector`** can also accessed by index:. ``` {.cpp}; xx = v(0);orxx = v[0];; yy = v(1);yy = v[1];; zz = v(2);zz = v[2];; tt = v(3);tt = v[3];; ```. You can use the `Vect()` method to get the vector component of; **`TLorentzVector`**:. ``` {.cpp}; TVector3 p = v.Vect();; ```. For setting components there are two methods: `SetX(),.., SetPx(),..:`. ``` {.cpp}; v.SetX(1.); orv.SetPx(1.);; ......; v.SetT(1.);v.SetE(1.);; ```. To set more the one component by one call you can use the `SetVect()`; function for the **`TVector3`** part or `SetXYZT()`, `SetPxPyPzE()`. For; convenience there is also a `SetXYZM()`:. ``` {.cpp}; v.SetVect(TVector3(1,2,3));; v.SetXYZT(x,y,z,t);; v.SetPxPyPzE(px,py,pz,e);; v.SetXYZM(x,y,z,m); // v = (x,y,z",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:12942,Energy Efficiency,energy,energy,12942," another vector; pp2v2 = v.Perp(v1);; ```. there are two more set functions `SetPtEtaPhiE(pt,eta,phi,e)` and; `SetPtEtaPhiM(pt,eta,phi,m)` for convenience. ### Arithmetic and Comparison Operators. The **`TLorentzVector`** class provides operators to add subtract or; compare four-vectors:. ``` {.cpp}; v3 = -v1;; v1 = v2+v3;; v1+= v3;; v1 = v2 + v3;; v1-= v3;; if (v1 == v2) {...}; if (v1 != v3) {...}; ```. ### Magnitude/Invariant mass, beta, gamma, scalar product. The scalar product of two four-vectors is calculated with the; `(-,-,-,+) `metric:. **`s = v1*v2 `** `= t1*t2-x1*x2-y1*y2-z1*z2 `. The magnitude squared `mag2` of a four-vector is therefore:. **`mag2 = v*v`** ` = t*t-x*x-y*y-z*z `. If `mag2` is negative: **`mag = -Sqrt(-mag*mag)`**. The methods are:. ``` {.cpp}; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; ```. Since in case of momentum and energy the magnitude has the meaning of; invariant mass **`TLorentzVector`** provides the more meaningful aliases; `M2()` and `M()`. The methods `Beta()` and `Gamma()` returns `beta` and; `gamma = 1/Sqrt(1-beta*beta)`. ### Lorentz Boost. A boost in a general direction can be parameterized with three; parameters which can be taken as the components of a three vector; `b=(bx,by,bz)`. With `x=(x,y,z)` and `gamma=1/Sqrt(1-beta*beta)` (beta; being the module of vector b)`,` an arbitrary active Lorentz boost; transformation (from the rod frame to the original frame) can be written; as:. `x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b `. `t = gamma(t'+ b*x') `. The `Boost()` method performs a boost transformation from the rod frame; to the original frame. `BoostVector()` returns a **`TVector3`** of the; spatial components divided by the time component:. ``` {.cpp}; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); ```. ### Rotations. There are four sets of functions to rotate the **`TVector3`** compon",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:2193,Modifiability,variab,variables,2193,"or3`** object. **`TLorentzRotation`**; is a class to describe the Lorentz transformations including Lorentz; boosts and rotations. In addition, a **`TVector2`** is a basic; implementation of a vector in two dimensions and is not part of the; CLHEP translation. ## TVector3. ![](pictures/030001A9.png). **`TVector3`** is a general three-vector; class, which can be used for description of different vectors in 3D.; Components of three vectors:. - $x$, $y$, $z$ = basic components. - $\theta$ = azimuth angle. - $\phi$ = polar angle. - magnitude = $mag$ = $\sqrt{x^2 + y^2 + z^2}$. - transverse component = $perp$ = $\sqrt{x^2 + y^2}$. Using the **`TVector3`** class, you should remember that it contains; only common features of three vectors and lacks methods specific for; some particular vector values. For example, it has no translated; function because translation has no meaning for vectors. ### Declaration / Access to the Components. **`TVector3`** has been implemented as a vector of three `Double_t`; variables, representing the Cartesian coordinates. By default the values; are initialized to zero, however you can change them in the constructor:. ``` {.cpp}; TVector3 v1; // v1 = (0,0,0); TVector3 v2(1); // v2 = (1,0,0); TVector3 v3(1,2,3); // v3 = (1,2,3); TVector3 v4(v2); // v4 = v2; ```. It is also possible (but not recommended) to initialize a **`TVector3`**; with a `Double_t` or `Float_t C` array. You can get the components by; name or by index:. ``` {.cpp}; xx = v1.X(); or xx = v1(0);; yy = v1.Y(); yy = v1(1);; zz = v1.Z(); zz = v1(2);; ```. The methods `SetX()`, `SetY()`, `SetZ()` and `SetXYZ()` allow you to set; the components:. ``` {.cpp}; v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);; v1.SetXYZ(1.,2.,3.);; ```. ### Other Coordinates. To get information on the **`TVector3`** in spherical (`rho`, `phi`,; `theta`) or cylindrical (`z`, `r`, `theta`) coordinates, the following; methods can be used. ``` {.cpp}; Double_t m = v.Mag();; // get magnitude (=rho=Sqrt(x*x+y*y+z*z)));",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:9675,Modifiability,variab,variable,9675,"s. Therefore, the second rotation should be; placed first:. ``` {.cpp}; r = r2 * r1;; ```. ### Rotation of TVector3. The **`TRotation`** class provides an `operator *` which allows; expressing a rotation of a **`TVector3`** analog to the mathematical; notation:. $$; \left|; \begin{array}{c}; x' \\; y' \\; z'; \end{array}; \right|; =; \left|; \begin{array}{ccc}; xx & xy & xz \\; yx & yy & yz \\; zx & zy & zz; \end{array}; \right|; \times; \left|; \begin{array}{c}; x \\; y \\; z; \end{array}; \right|; $$. ``` {.cpp}; TRotation r;; TVector3 v(1,1,1);; v = r * v;; ```. You can also use the `Transform()` method or the `operator *=` of the; **`TVector3`** class:. ``` {.cpp}; TVector3 v;; TRotation r;; v.Transform(r);; ```. ## TLorentzVector. **`TLorentzVector`** is a general four-vector class, which can be used; either for the description of position and time (`x`, `y`, `z`, `t`) or; momentum and energy (`px`, `py`, `pz`, `E`). ### Declaration. **`TLorentzVector`** has been implemented as a set a **`TVector3`** and; a `Double_t` variable. By default, all components are initialized by; zero. ``` {.cpp}; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; ```. For backward compatibility there are two constructors from a `Double_t`; and `Float_t` array. ### Access to Components. There are two sets of access functions to the components of a; **`TLorentzVector`**: `X()`, `Y()`, `Z()`, `T()` and `Px()`, `Py()`,; `Pz()` and `E()`. Both sets return the same values but the first set is; more relevant for use where **`TLorentzVector`** describes a combination; of position and time and the second set is more relevant where; **`TLorentzVector`** describes momentum and energy:. ``` {.cpp}; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; ```. The components of **`TLorentzVector`** can also accessed by index:. ``` {.cpp}; xx = v(0);orxx = ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:13218,Modifiability,parameteriz,parameterized,13218,"ct or; compare four-vectors:. ``` {.cpp}; v3 = -v1;; v1 = v2+v3;; v1+= v3;; v1 = v2 + v3;; v1-= v3;; if (v1 == v2) {...}; if (v1 != v3) {...}; ```. ### Magnitude/Invariant mass, beta, gamma, scalar product. The scalar product of two four-vectors is calculated with the; `(-,-,-,+) `metric:. **`s = v1*v2 `** `= t1*t2-x1*x2-y1*y2-z1*z2 `. The magnitude squared `mag2` of a four-vector is therefore:. **`mag2 = v*v`** ` = t*t-x*x-y*y-z*z `. If `mag2` is negative: **`mag = -Sqrt(-mag*mag)`**. The methods are:. ``` {.cpp}; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; ```. Since in case of momentum and energy the magnitude has the meaning of; invariant mass **`TLorentzVector`** provides the more meaningful aliases; `M2()` and `M()`. The methods `Beta()` and `Gamma()` returns `beta` and; `gamma = 1/Sqrt(1-beta*beta)`. ### Lorentz Boost. A boost in a general direction can be parameterized with three; parameters which can be taken as the components of a three vector; `b=(bx,by,bz)`. With `x=(x,y,z)` and `gamma=1/Sqrt(1-beta*beta)` (beta; being the module of vector b)`,` an arbitrary active Lorentz boost; transformation (from the rod frame to the original frame) can be written; as:. `x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b `. `t = gamma(t'+ b*x') `. The `Boost()` method performs a boost transformation from the rod frame; to the original frame. `BoostVector()` returns a **`TVector3`** of the; spatial components divided by the time component:. ``` {.cpp}; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); ```. ### Rotations. There are four sets of functions to rotate the **`TVector3`** component; of a **`TLorentzVector`**:. Around Axes:. ``` {.cpp}; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; ```. Around an arbitrary axis:. ``` {.cpp}; v.Rotate(TMath::Pi()/4., v1); // rotation around v1; ```. Transformation from rotated frame:. ``",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:329,Performance,load,load,329,"# Physics Vectors. The physics vector classes describe vectors in three and four dimensions; and their rotation algorithms. The classes were ported to root from; CLHEP see:. <http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html>. ## The Physics Vector Classes. In order to use the physics vector classes you will have to load the; Physics library:. ``` {.cpp}; gSystem.Load(""libPhysics.so"");; ```. There are four classes in this package. They are:. **`TVector3`** is a general three-vector. A **`TVector3`** may be; expressed in Cartesian, polar, or cylindrical coordinates. Methods; include dot and cross products, unit vectors and magnitudes, angles; between vectors, and rotations and boosts. There are also functions of; particular use to HEP, like pseudo-rapidity, projections, and transverse; part of a **`TVector3`**, and kinetic methods on 4-vectors such as; Invariant Mass of pairs or containers of particles`.`. **`TLorentzVector`** is a general four-vector class, which can be used; either for the description of position and time (`x`, `y`, `z`, `t`) or; momentum and energy (`px`, `py`, `pz`, `E`). **`TRotation`** is a class; describing a rotation of a **`TVector3`** object. **`TLorentzRotation`**; is a class to describe the Lorentz transformations including Lorentz; boosts and rotations. In addition, a **`TVector2`** is a basic; implementation of a vector in two dimensions and is not part of the; CLHEP translation. ## TVector3. ![](pictures/030001A9.png). **`TVector3`** is a general three-vector; class, which can be used for description of different vectors in 3D.; Components of three vectors:. - $x$, $y$, $z$ = basic components. - $\theta$ = azimuth angle. - $\phi$ = polar angle. - magnitude = $mag$ = $\sqrt{x^2 + y^2 + z^2}$. - transverse component = $perp$ = $\sqrt{x^2 + y^2}$. Using the **`TVector3`** class, you should remember that it contains; only common features of three vectors and lacks methods specific for; some particular vector values. For example, ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:13632,Performance,perform,performs,13632," = v*v`** ` = t*t-x*x-y*y-z*z `. If `mag2` is negative: **`mag = -Sqrt(-mag*mag)`**. The methods are:. ``` {.cpp}; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; ```. Since in case of momentum and energy the magnitude has the meaning of; invariant mass **`TLorentzVector`** provides the more meaningful aliases; `M2()` and `M()`. The methods `Beta()` and `Gamma()` returns `beta` and; `gamma = 1/Sqrt(1-beta*beta)`. ### Lorentz Boost. A boost in a general direction can be parameterized with three; parameters which can be taken as the components of a three vector; `b=(bx,by,bz)`. With `x=(x,y,z)` and `gamma=1/Sqrt(1-beta*beta)` (beta; being the module of vector b)`,` an arbitrary active Lorentz boost; transformation (from the rod frame to the original frame) can be written; as:. `x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b `. `t = gamma(t'+ b*x') `. The `Boost()` method performs a boost transformation from the rod frame; to the original frame. `BoostVector()` returns a **`TVector3`** of the; spatial components divided by the time component:. ``` {.cpp}; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); ```. ### Rotations. There are four sets of functions to rotate the **`TVector3`** component; of a **`TLorentzVector`**:. Around Axes:. ``` {.cpp}; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; ```. Around an arbitrary axis:. ``` {.cpp}; v.Rotate(TMath::Pi()/4., v1); // rotation around v1; ```. Transformation from rotated frame:. ``` {.cpp}; v.RotateUz(direction); // direction must be a unit TVector3; ```. Rotation by **`TRotation`**:. ``` {.cpp}; TRotation r;; v.Transform(r);//or v *= r; (v = r*v); ```. ### Miscellaneous. Angle between two vectors:. ``` {.cpp}; Double_t a = v1.Angle(v2);// get angle between v1 and v2; ```. Methods `Plus()` and `Minus()` return the positive and negative; light-cone components:. ``` {.cpp}; Double",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:18221,Performance,load,loaded,18221,"{.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as follows:. $$; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; $$. ### Transformation of a TLorentzVector. To apply **`TLorentzRotation`** to **`TLorentzVector`** you can use; either the `VectorMultiplication()` method or the `* operator`. You can; also use the `Transform()` function and the `*= `operator of the class; **`TLorentzVector`**. ``` {.cpp}; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; ```. ### Physics Vector Example. The test file `$ROOTSYS/test/TestVectors.cxx is` an example of using; physics vectors. The vector classes are not loaded by default, and to; run it, you will need to load `libPhysics.so` first:. ``` {.cpp}; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; ```. To load the physics vector library in a ROOT application use:. ``` {.cpp}; gSystem->Load(""libPhysics"");; ```. The example `$ROOTSYS/test/TestVectors.cxx` does not return much,; especially if all went well, but when you look at the code you will find; examples for many calls.; ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:18273,Performance,load,load,18273,"{.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as follows:. $$; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; $$. ### Transformation of a TLorentzVector. To apply **`TLorentzRotation`** to **`TLorentzVector`** you can use; either the `VectorMultiplication()` method or the `* operator`. You can; also use the `Transform()` function and the `*= `operator of the class; **`TLorentzVector`**. ``` {.cpp}; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; ```. ### Physics Vector Example. The test file `$ROOTSYS/test/TestVectors.cxx is` an example of using; physics vectors. The vector classes are not loaded by default, and to; run it, you will need to load `libPhysics.so` first:. ``` {.cpp}; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; ```. To load the physics vector library in a ROOT application use:. ``` {.cpp}; gSystem->Load(""libPhysics"");; ```. The example `$ROOTSYS/test/TestVectors.cxx` does not return much,; especially if all went well, but when you look at the code you will find; examples for many calls.; ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:18387,Performance,load,load,18387,"{.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as follows:. $$; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; $$. ### Transformation of a TLorentzVector. To apply **`TLorentzRotation`** to **`TLorentzVector`** you can use; either the `VectorMultiplication()` method or the `* operator`. You can; also use the `Transform()` function and the `*= `operator of the class; **`TLorentzVector`**. ``` {.cpp}; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; ```. ### Physics Vector Example. The test file `$ROOTSYS/test/TestVectors.cxx is` an example of using; physics vectors. The vector classes are not loaded by default, and to; run it, you will need to load `libPhysics.so` first:. ``` {.cpp}; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; ```. To load the physics vector library in a ROOT application use:. ``` {.cpp}; gSystem->Load(""libPhysics"");; ```. The example `$ROOTSYS/test/TestVectors.cxx` does not return much,; especially if all went well, but when you look at the code you will find; examples for many calls.; ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:10049,Security,access,access,10049,"}; x \\; y \\; z; \end{array}; \right|; $$. ``` {.cpp}; TRotation r;; TVector3 v(1,1,1);; v = r * v;; ```. You can also use the `Transform()` method or the `operator *=` of the; **`TVector3`** class:. ``` {.cpp}; TVector3 v;; TRotation r;; v.Transform(r);; ```. ## TLorentzVector. **`TLorentzVector`** is a general four-vector class, which can be used; either for the description of position and time (`x`, `y`, `z`, `t`) or; momentum and energy (`px`, `py`, `pz`, `E`). ### Declaration. **`TLorentzVector`** has been implemented as a set a **`TVector3`** and; a `Double_t` variable. By default, all components are initialized by; zero. ``` {.cpp}; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; ```. For backward compatibility there are two constructors from a `Double_t`; and `Float_t` array. ### Access to Components. There are two sets of access functions to the components of a; **`TLorentzVector`**: `X()`, `Y()`, `Z()`, `T()` and `Px()`, `Py()`,; `Pz()` and `E()`. Both sets return the same values but the first set is; more relevant for use where **`TLorentzVector`** describes a combination; of position and time and the second set is more relevant where; **`TLorentzVector`** describes momentum and energy:. ``` {.cpp}; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; ```. The components of **`TLorentzVector`** can also accessed by index:. ``` {.cpp}; xx = v(0);orxx = v[0];; yy = v(1);yy = v[1];; zz = v(2);zz = v[2];; tt = v(3);tt = v[3];; ```. You can use the `Vect()` method to get the vector component of; **`TLorentzVector`**:. ``` {.cpp}; TVector3 p = v.Vect();; ```. For setting components there are two methods: `SetX(),.., SetPx(),..:`. ``` {.cpp}; v.SetX(1.); orv.SetPx(1.);; ......; v.SetT(1.);v.SetE(1.);; ```. To set more the one component by one call you can use the `SetVect()`; function for the **`TVector3`** part or ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:10587,Security,access,accessed,10587,"### Declaration. **`TLorentzVector`** has been implemented as a set a **`TVector3`** and; a `Double_t` variable. By default, all components are initialized by; zero. ``` {.cpp}; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; ```. For backward compatibility there are two constructors from a `Double_t`; and `Float_t` array. ### Access to Components. There are two sets of access functions to the components of a; **`TLorentzVector`**: `X()`, `Y()`, `Z()`, `T()` and `Px()`, `Py()`,; `Pz()` and `E()`. Both sets return the same values but the first set is; more relevant for use where **`TLorentzVector`** describes a combination; of position and time and the second set is more relevant where; **`TLorentzVector`** describes momentum and energy:. ``` {.cpp}; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; ```. The components of **`TLorentzVector`** can also accessed by index:. ``` {.cpp}; xx = v(0);orxx = v[0];; yy = v(1);yy = v[1];; zz = v(2);zz = v[2];; tt = v(3);tt = v[3];; ```. You can use the `Vect()` method to get the vector component of; **`TLorentzVector`**:. ``` {.cpp}; TVector3 p = v.Vect();; ```. For setting components there are two methods: `SetX(),.., SetPx(),..:`. ``` {.cpp}; v.SetX(1.); orv.SetPx(1.);; ......; v.SetT(1.);v.SetE(1.);; ```. To set more the one component by one call you can use the `SetVect()`; function for the **`TVector3`** part or `SetXYZT()`, `SetPxPyPzE()`. For; convenience there is also a `SetXYZM()`:. ``` {.cpp}; v.SetVect(TVector3(1,2,3));; v.SetXYZT(x,y,z,t);; v.SetPxPyPzE(px,py,pz,e);; v.SetXYZM(x,y,z,m); // v = (x,y,z,e = Sqrt(x*x+y*y+z*z+m*m)); ```. ### Vector Components in Non-Cartesian Coordinates. There are a couple of methods to get and set the **`TVector3`** part of; the parameters in `spherical` coordinate systems:. ``` {.cpp}; Double_t m, theta, cost, phi, pp, pp2, ppv2, pp2v2",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16131,Security,access,access,16131,"y & xz & xt \\; yx & yy & yz & yt \\; zx & zy & zz & zt \\; tx & ty & tz & tt; \end{array}; \right|; $$. ### Declaration. By default it is initialized to the identity matrix, but it may also be; initialized by other **`TLorentzRotation`**, by a pure **`TRotation`**; or by a boost:. ``` {.cpp}; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to ret",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:6702,Testability,test,test,6702,"yx & yy & yz \\; zx & zy & zz; \end{array}; \right|$$. It describes a so-called active rotation, i.e. a rotation of objects; inside a static system of coordinates. In case you want to rotate the; frame and want to know the coordinates of objects in the rotated system,; you should apply the inverse rotation to the objects. If you want to; transform coordinates from the rotated frame to the original frame you; have to apply the direct transformation. A rotation around a specified; axis means counterclockwise rotation around the positive direction of; the axis. ### Declaration, Access, Comparisons. ``` {.cpp}; TRotation r; // r initialized as identity; TRotation m(r); // m = r; ```. There is no direct way to set the matrix elements - to ensure that a; **`TRotation`** always describes a real rotation. But you can get the; values by with the methods `XX()..ZZ()` or the `(,)` operator:. ``` {.cpp}; Double_t xx = r.XX(); // the same as xx=r(0,0); xx = r(0,0);; if (r==m) {...} // test for equality; if (r!=m) {..} // test for inequality; if (r.IsIdentity()) {...} // test for identity; ```. ### Rotation around Axes. The following matrices describe counter-clockwise rotations around the; coordinate axes and are implemented in: `RotateX()`,` RotateY()` and; `RotateZ()`:. $$; Rx(a) = \left|; \begin{array}{ccc}; 1 & 0 & 0 \\; 0 & cos(a) & -sin(a) \\; 0 & sin(a) & cos(a); \end{array}; \right|; Ry(a) = \left|; \begin{array}{ccc}; cos(a) & 0 & sin(a) \\; 0 & 1 & 0 \\; -sin(a) & 0 & cos(a); \end{array}; \right|; Rz(a) = \left|; \begin{array}{ccc}; cos(a) & -sin(a) & 0 \\; sin(a) & cos(a) & 0 \\; 0 & 0 & 1; \end{array}; \right|; $$. ``` {.cpp}; r.RotateX(TMath::Pi()); // rotation around the x-axis; ```. ### Rotation around Arbitrary Axis. The `Rotate()` method allows you to rotate around an arbitrary vector; (not necessary a unit one) and returns the result. ``` {.cpp}; r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; ```. It is possible to find a unit vector and an angle, which describe the",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:6739,Testability,test,test,6739,"{array}; \right|$$. It describes a so-called active rotation, i.e. a rotation of objects; inside a static system of coordinates. In case you want to rotate the; frame and want to know the coordinates of objects in the rotated system,; you should apply the inverse rotation to the objects. If you want to; transform coordinates from the rotated frame to the original frame you; have to apply the direct transformation. A rotation around a specified; axis means counterclockwise rotation around the positive direction of; the axis. ### Declaration, Access, Comparisons. ``` {.cpp}; TRotation r; // r initialized as identity; TRotation m(r); // m = r; ```. There is no direct way to set the matrix elements - to ensure that a; **`TRotation`** always describes a real rotation. But you can get the; values by with the methods `XX()..ZZ()` or the `(,)` operator:. ``` {.cpp}; Double_t xx = r.XX(); // the same as xx=r(0,0); xx = r(0,0);; if (r==m) {...} // test for equality; if (r!=m) {..} // test for inequality; if (r.IsIdentity()) {...} // test for identity; ```. ### Rotation around Axes. The following matrices describe counter-clockwise rotations around the; coordinate axes and are implemented in: `RotateX()`,` RotateY()` and; `RotateZ()`:. $$; Rx(a) = \left|; \begin{array}{ccc}; 1 & 0 & 0 \\; 0 & cos(a) & -sin(a) \\; 0 & sin(a) & cos(a); \end{array}; \right|; Ry(a) = \left|; \begin{array}{ccc}; cos(a) & 0 & sin(a) \\; 0 & 1 & 0 \\; -sin(a) & 0 & cos(a); \end{array}; \right|; Rz(a) = \left|; \begin{array}{ccc}; cos(a) & -sin(a) & 0 \\; sin(a) & cos(a) & 0 \\; 0 & 0 & 1; \end{array}; \right|; $$. ``` {.cpp}; r.RotateX(TMath::Pi()); // rotation around the x-axis; ```. ### Rotation around Arbitrary Axis. The `Rotate()` method allows you to rotate around an arbitrary vector; (not necessary a unit one) and returns the result. ``` {.cpp}; r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; ```. It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:6789,Testability,test,test,6789,"ive rotation, i.e. a rotation of objects; inside a static system of coordinates. In case you want to rotate the; frame and want to know the coordinates of objects in the rotated system,; you should apply the inverse rotation to the objects. If you want to; transform coordinates from the rotated frame to the original frame you; have to apply the direct transformation. A rotation around a specified; axis means counterclockwise rotation around the positive direction of; the axis. ### Declaration, Access, Comparisons. ``` {.cpp}; TRotation r; // r initialized as identity; TRotation m(r); // m = r; ```. There is no direct way to set the matrix elements - to ensure that a; **`TRotation`** always describes a real rotation. But you can get the; values by with the methods `XX()..ZZ()` or the `(,)` operator:. ``` {.cpp}; Double_t xx = r.XX(); // the same as xx=r(0,0); xx = r(0,0);; if (r==m) {...} // test for equality; if (r!=m) {..} // test for inequality; if (r.IsIdentity()) {...} // test for identity; ```. ### Rotation around Axes. The following matrices describe counter-clockwise rotations around the; coordinate axes and are implemented in: `RotateX()`,` RotateY()` and; `RotateZ()`:. $$; Rx(a) = \left|; \begin{array}{ccc}; 1 & 0 & 0 \\; 0 & cos(a) & -sin(a) \\; 0 & sin(a) & cos(a); \end{array}; \right|; Ry(a) = \left|; \begin{array}{ccc}; cos(a) & 0 & sin(a) \\; 0 & 1 & 0 \\; -sin(a) & 0 & cos(a); \end{array}; \right|; Rz(a) = \left|; \begin{array}{ccc}; cos(a) & -sin(a) & 0 \\; sin(a) & cos(a) & 0 \\; 0 & 0 & 1; \end{array}; \right|; $$. ``` {.cpp}; r.RotateX(TMath::Pi()); // rotation around the x-axis; ```. ### Rotation around Arbitrary Axis. The `Rotate()` method allows you to rotate around an arbitrary vector; (not necessary a unit one) and returns the result. ``` {.cpp}; r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; ```. It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:. ``` {.cpp}; Double_t angle;; TVector3 axis;; r",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16402,Testability,test,test,16402," **`TRotation`**; or by a boost:. ``` {.cpp}; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16442,Testability,test,test,16442," {.cpp}; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse tra",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16492,Testability,test,test,16492," as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as f",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:18111,Testability,test,test,18111,"{.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as follows:. $$; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; $$. ### Transformation of a TLorentzVector. To apply **`TLorentzRotation`** to **`TLorentzVector`** you can use; either the `VectorMultiplication()` method or the `* operator`. You can; also use the `Transform()` function and the `*= `operator of the class; **`TLorentzVector`**. ``` {.cpp}; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; ```. ### Physics Vector Example. The test file `$ROOTSYS/test/TestVectors.cxx is` an example of using; physics vectors. The vector classes are not loaded by default, and to; run it, you will need to load `libPhysics.so` first:. ``` {.cpp}; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; ```. To load the physics vector library in a ROOT application use:. ``` {.cpp}; gSystem->Load(""libPhysics"");; ```. The example `$ROOTSYS/test/TestVectors.cxx` does not return much,; especially if all went well, but when you look at the code you will find; examples for many calls.; ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:18131,Testability,test,test,18131,"{.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as follows:. $$; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; $$. ### Transformation of a TLorentzVector. To apply **`TLorentzRotation`** to **`TLorentzVector`** you can use; either the `VectorMultiplication()` method or the `* operator`. You can; also use the `Transform()` function and the `*= `operator of the class; **`TLorentzVector`**. ``` {.cpp}; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; ```. ### Physics Vector Example. The test file `$ROOTSYS/test/TestVectors.cxx is` an example of using; physics vectors. The vector classes are not loaded by default, and to; run it, you will need to load `libPhysics.so` first:. ``` {.cpp}; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; ```. To load the physics vector library in a ROOT application use:. ``` {.cpp}; gSystem->Load(""libPhysics"");; ```. The example `$ROOTSYS/test/TestVectors.cxx` does not return much,; especially if all went well, but when you look at the code you will find; examples for many calls.; ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:18516,Testability,test,test,18516,"{.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as follows:. $$; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; $$. ### Transformation of a TLorentzVector. To apply **`TLorentzRotation`** to **`TLorentzVector`** you can use; either the `VectorMultiplication()` method or the `* operator`. You can; also use the `Transform()` function and the `*= `operator of the class; **`TLorentzVector`**. ``` {.cpp}; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; ```. ### Physics Vector Example. The test file `$ROOTSYS/test/TestVectors.cxx is` an example of using; physics vectors. The vector classes are not loaded by default, and to; run it, you will need to load `libPhysics.so` first:. ``` {.cpp}; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; ```. To load the physics vector library in a ROOT application use:. ``` {.cpp}; gSystem->Load(""libPhysics"");; ```. The example `$ROOTSYS/test/TestVectors.cxx` does not return much,; especially if all went well, but when you look at the code you will find; examples for many calls.; ",MatchSource.DOCS,documentation/users-guide/PhysicsVectors.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:2297,Availability,mainten,maintenance,2297,"s, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feeling he has been sitting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte-Carlo. They have been; working with the ROOT team since 2000. **Olivier Couet**, who after a successful development and maintenance; of PAW, has joined the ROOT team in 2000 and has been working on the; graphics sub-system. **Ilka Antcheva** has been working on the Graphical User Interface; classes. She is also responsible for this latest edition of the Users; Guide with a better style, improved index and several new chapters; (since 2002). **Bertrand Bellenot** has been developing and maintaining the Win32GDK; version of ROOT. Bertrand has also many other contributions like the; nice RootShower example (since 2001). **Valeriy Onoutchin** has been working on several ROOT packages, in; particular the graphics sub-system for Windows and the GUI Builder; (since 2000). **Gerri Ganis** has been working on the authentication procedures to; be used by the root daemons and the PROOF system (since 2002). **Maarten Ballintijn** (MIT) is one of the main developers of the; PROOF sub-system (since 1995). **Valeri Fine** (now at BNL) ported ROOT to Windows and contributed; largely to the 3-D graphics. He is currently working on the Qt lay",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:1027,Deployability,release,release,1027,"learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feeling he has been sitting in the room next door; since 1",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:1589,Deployability,release,release,1589,"hout templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feeling he has been sitting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte-Carlo. They have been; working with the ROOT team since 2000. **Olivier Couet**, who after a successful development and maintenance; of PAW, has joined the ROOT team in 2000 and has been working on the; graphics sub-system. **Ilka Antcheva** has been working on the Graphical User Interface; classes. She is also responsible for this latest edition of the Users; Guide with a better style, improved index and several new chap",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:1604,Deployability,release,release,1604,"hout templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feeling he has been sitting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte-Carlo. They have been; working with the ROOT team since 2000. **Olivier Couet**, who after a successful development and maintenance; of PAW, has joined the ROOT team in 2000 and has been working on the; graphics sub-system. **Ilka Antcheva** has been working on the Graphical User Interface; classes. She is also responsible for this latest edition of the Users; Guide with a better style, improved index and several new chap",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:3562,Deployability,integrat,integrated,3562," a better style, improved index and several new chapters; (since 2002). **Bertrand Bellenot** has been developing and maintaining the Win32GDK; version of ROOT. Bertrand has also many other contributions like the; nice RootShower example (since 2001). **Valeriy Onoutchin** has been working on several ROOT packages, in; particular the graphics sub-system for Windows and the GUI Builder; (since 2000). **Gerri Ganis** has been working on the authentication procedures to; be used by the root daemons and the PROOF system (since 2002). **Maarten Ballintijn** (MIT) is one of the main developers of the; PROOF sub-system (since 1995). **Valeri Fine** (now at BNL) ported ROOT to Windows and contributed; largely to the 3-D graphics. He is currently working on the Qt layer; of ROOT (since 1995). **Victor Perevoztchikov** (BNL) worked on key elements of the I/O; system, in particular the improved support for STL collections; (1997-2001). **Nenad Buncic** developed the HTML documentation generation system; and integrated the X3D viewer inside ROOT (1995-1997). **Suzanne Panacek** was the author of the first version of this User's; Guide and very active in preparing tutorials and giving lectures about; ROOT (1999-2002). **Axel Naumann** has been developing further the HTML Reference Guide; and helps in porting ROOT under Windows (cygwin/gcc implementation); (since 2000). **Anna Kreshuk** has developed the Linear Fitter and Robust Fitter; classes as well as many functions in TMath, TF1, TGraph (since 2005). **Richard Maunder** has contributed to the GL viewer classes (since; 2004). **Timur Pocheptsov** has contributed to the GL viewer classes and GL; in pad classes (since 2004). **Sergei Linev** has developed the XML driver and the TSQLFile classes; (since 2003). **Stefan Roiser** has been contributing to the reflex and cintex; packages (since 2005). **Lorenzo Moneta** has been contributing the MathCore, MathMore,; Smatrix & Minuit2 packages (since 2005). **Wim Lavrijsen** is the a",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:814,Energy Efficiency,efficient,efficient,814,"# Preface {.unnumbered}. In late 1994, we decided to learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feelin",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:1211,Energy Efficiency,monitor,monitor,1211,"ues for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feeling he has been sitting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:3562,Integrability,integrat,integrated,3562," a better style, improved index and several new chapters; (since 2002). **Bertrand Bellenot** has been developing and maintaining the Win32GDK; version of ROOT. Bertrand has also many other contributions like the; nice RootShower example (since 2001). **Valeriy Onoutchin** has been working on several ROOT packages, in; particular the graphics sub-system for Windows and the GUI Builder; (since 2000). **Gerri Ganis** has been working on the authentication procedures to; be used by the root daemons and the PROOF system (since 2002). **Maarten Ballintijn** (MIT) is one of the main developers of the; PROOF sub-system (since 1995). **Valeri Fine** (now at BNL) ported ROOT to Windows and contributed; largely to the 3-D graphics. He is currently working on the Qt layer; of ROOT (since 1995). **Victor Perevoztchikov** (BNL) worked on key elements of the I/O; system, in particular the improved support for STL collections; (1997-2001). **Nenad Buncic** developed the HTML documentation generation system; and integrated the X3D viewer inside ROOT (1995-1997). **Suzanne Panacek** was the author of the first version of this User's; Guide and very active in preparing tutorials and giving lectures about; ROOT (1999-2002). **Axel Naumann** has been developing further the HTML Reference Guide; and helps in porting ROOT under Windows (cygwin/gcc implementation); (since 2000). **Anna Kreshuk** has developed the Linear Fitter and Robust Fitter; classes as well as many functions in TMath, TF1, TGraph (since 2005). **Richard Maunder** has contributed to the GL viewer classes (since; 2004). **Timur Pocheptsov** has contributed to the GL viewer classes and GL; in pad classes (since 2004). **Sergei Linev** has developed the XML driver and the TSQLFile classes; (since 2003). **Stefan Roiser** has been contributing to the reflex and cintex; packages (since 2005). **Lorenzo Moneta** has been contributing the MathCore, MathMore,; Smatrix & Minuit2 packages (since 2005). **Wim Lavrijsen** is the a",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:445,Modifiability,rewrite,rewrite,445,"# Preface {.unnumbered}. In late 1994, we decided to learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feelin",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:575,Modifiability,rewrite,rewrite,575,"# Preface {.unnumbered}. In late 1994, we decided to learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feelin",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:2993,Security,authenticat,authentication,2993,"ting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte-Carlo. They have been; working with the ROOT team since 2000. **Olivier Couet**, who after a successful development and maintenance; of PAW, has joined the ROOT team in 2000 and has been working on the; graphics sub-system. **Ilka Antcheva** has been working on the Graphical User Interface; classes. She is also responsible for this latest edition of the Users; Guide with a better style, improved index and several new chapters; (since 2002). **Bertrand Bellenot** has been developing and maintaining the Win32GDK; version of ROOT. Bertrand has also many other contributions like the; nice RootShower example (since 2001). **Valeriy Onoutchin** has been working on several ROOT packages, in; particular the graphics sub-system for Windows and the GUI Builder; (since 2000). **Gerri Ganis** has been working on the authentication procedures to; be used by the root daemons and the PROOF system (since 2002). **Maarten Ballintijn** (MIT) is one of the main developers of the; PROOF sub-system (since 1995). **Valeri Fine** (now at BNL) ported ROOT to Windows and contributed; largely to the 3-D graphics. He is currently working on the Qt layer; of ROOT (since 1995). **Victor Perevoztchikov** (BNL) worked on key elements of the I/O; system, in particular the improved support for STL collections; (1997-2001). **Nenad Buncic** developed the HTML documentation generation system; and integrated the X3D viewer inside ROOT (1995-1997). **Suzanne Panacek** was the author of the first version of this User's; Guide and very active in preparing tutorials and giving lectures about; ROOT (1999-2002). **Axel Naumann** has been developing further the HTML Reference Guide; and helps in porting ROOT under Windows (cygwin/gcc implementation); (since 2000). **Anna Kreshuk** has developed the Linear Fitter and Robust Fitter; classes as well as man",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:53,Usability,learn,learn,53,"# Preface {.unnumbered}. In late 1994, we decided to learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feelin",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:248,Usability,learn,learn,248,"# Preface {.unnumbered}. In late 1994, we decided to learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feelin",MatchSource.DOCS,documentation/users-guide/Preface.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:692,Energy Efficiency,adapt,adapt,692,"# PROOF: Parallel Processing; \index{PROOF}; \index{parallel processing}. The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing; transparent analysis of large sets of ROOT files in parallel on remote; computer clusters or multi-core computers. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier struct",MatchSource.DOCS,documentation/users-guide/PROOF.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:1257,Energy Efficiency,adapt,adapted,1257,"ters. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier structure of a PROOF cluster](pictures/03000200.png). Details about the PROOF system and the way to use it can be found at; <PROOFWiki> [^1]. The PROOF development is a joint effort between CERN and MIT. [^1]: http://root.cern.ch/twiki/bin/view/ROOT/PROOF; ",MatchSource.DOCS,documentation/users-guide/PROOF.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:1785,Energy Efficiency,monitor,monitor,1785,"ters. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier structure of a PROOF cluster](pictures/03000200.png). Details about the PROOF system and the way to use it can be found at; <PROOFWiki> [^1]. The PROOF development is a joint effort between CERN and MIT. [^1]: http://root.cern.ch/twiki/bin/view/ROOT/PROOF; ",MatchSource.DOCS,documentation/users-guide/PROOF.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:692,Modifiability,adapt,adapt,692,"# PROOF: Parallel Processing; \index{PROOF}; \index{parallel processing}. The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing; transparent analysis of large sets of ROOT files in parallel on remote; computer clusters or multi-core computers. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier struct",MatchSource.DOCS,documentation/users-guide/PROOF.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:1257,Modifiability,adapt,adapted,1257,"ters. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier structure of a PROOF cluster](pictures/03000200.png). Details about the PROOF system and the way to use it can be found at; <PROOFWiki> [^1]. The PROOF development is a joint effort between CERN and MIT. [^1]: http://root.cern.ch/twiki/bin/view/ROOT/PROOF; ",MatchSource.DOCS,documentation/users-guide/PROOF.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:756,Performance,load,load,756,"# PROOF: Parallel Processing; \index{PROOF}; \index{parallel processing}. The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing; transparent analysis of large sets of ROOT files in parallel on remote; computer clusters or multi-core computers. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier struct",MatchSource.DOCS,documentation/users-guide/PROOF.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:1443,Performance,perform,performing,1443,"ters. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier structure of a PROOF cluster](pictures/03000200.png). Details about the PROOF system and the way to use it can be found at; <PROOFWiki> [^1]. The PROOF development is a joint effort between CERN and MIT. [^1]: http://root.cern.ch/twiki/bin/view/ROOT/PROOF; ",MatchSource.DOCS,documentation/users-guide/PROOF.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:728,Availability,avail,available,728,"# Python Interface; \index{Python}. Python is a popular, open-source, dynamic programming language with an; interactive interpreter. Its interoperability with other programming; languages, both for extending Python as well as embedding it, is; excellent and many existing third-party applications and libraries have; therefore so-called ""Python bindings."" PyROOT provides Python bindings; for ROOT: it enables cross-calls from ROOT/Cling into Python and vice; versa, the intermingling of the two interpreters, and the transport of; user-level objects from one interpreter to the other. PyROOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5585,Availability,avail,available,5585,"he `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5753,Availability,down,download,5753,"tches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that th",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5795,Availability,down,download,5795,"tches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that th",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5987,Availability,avail,available,5987,"PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. T",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9743,Availability,avail,available,9743,"es are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9818,Availability,avail,available,9818," should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:11025,Availability,avail,available,11025,"ROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from there, in the ROOT module directly, but doing so makes the; code less clear, of course). Be careful in their use, because Python; already has types called ""`string`"" and ""`list`."". In order to understand how to get access to a templated class, think of; the general template as a meta class. By instantiating the meta class; with the proper parameters, you get an actual class, which can then be; used t",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:11118,Availability,avail,available,11118,"or(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from there, in the ROOT module directly, but doing so makes the; code less clear, of course). Be careful in their use, because Python; already has types called ""`string`"" and ""`list`."". In order to understand how to get access to a templated class, think of; the general template as a meta class. By instantiating the meta class; with the proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.v",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13246,Availability,avail,available,13246," 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13332,Availability,avail,available,13332,"here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly through their containing module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDe",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13564,Availability,avail,available,13564,"nt\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly through their containing module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13886,Availability,avail,available,13886,"that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly through their containing module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; ```. The above is another good reason to prefer 'import ROOT' over 'from ROOT; import \*'. ####",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:15849,Availability,avail,available,15849,".ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; ```. The above is another good reason to prefer 'import ROOT' over 'from ROOT; import \*'. #### Access to Python. The access to Python from Cling goes through the **`TPython`** class, or; directly if a Python object or class has crossed the border. The; **`TPython`** class, which looks approximately like this:. ``` {.cpp}; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; ```. `LoadMacro(const char* name)` - the argument is a name of a Python file; that is to be executed (`'execfile'`), after which any new classes are; automatically made available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed ('execfile'); in a private namespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is need",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:16351,Availability,error,error,16351,"t char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; ```. `LoadMacro(const char* name)` - the argument is a name of a Python file; that is to be executed (`'execfile'`), after which any new classes are; automatically made available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed ('execfile'); in a private namespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:16419,Availability,error,errors,16419,"t char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; ```. `LoadMacro(const char* name)` - the argument is a name of a Python file; that is to be executed (`'execfile'`), after which any new classes are; automatically made available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed ('execfile'); in a private namespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:18240,Availability,avail,available,18240,"/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ``` {.cpp}; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; ```. Here, the callback is a string that will be interpreted by Cling to call; `TPython::Exec()`, which will, in turn, interpret and execute the string; given to it. Note the use of raw strings (the '`r`' in front of the; second argument string), in order to remove the need of escaping the; backslashes. #### Cling Commands. In interactive mode, the Python exception hook is used to mim",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:19261,Availability,avail,available,19261,"class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ``` {.cpp}; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; ```. Here, the callback is a string that will be interpreted by Cling to call; `TPython::Exec()`, which will, in turn, interpret and execute the string; given to it. Note the use of raw strings (the '`r`' in front of the; second argument string), in order to remove the need of escaping the; backslashes. #### Cling Commands. In interactive mode, the Python exception hook is used to mimic some of; the Cling commands available. These are: `.q`, **`.!`**, **`.x`**,; **`.L`**, **`.cd`**, **`.ls`**, **`.pwd`**, **`.?`** and **`.help`**.; Note that **`.x`** translates to Python '`execfile()`' and thus accepts; only Python files, not Cling macros. ### Memory Handling. The Python interpreter handles memory for the user by employing; reference counting and a garbage collector (for new-style objects, which; includes `PyROOT` objects). In C++, however, memory handling is done; either by hand, or by an application specific, customized mechanism (as; is done in ROOT). Although `PyROOT` is made aware of ROOT memory; management, there are still a few boundary conditions that need to be; dealt with by hand. Also, the heuristics that `PyROOT` employs to deal; with memory management are not infallible. An understanding in some; detail of the choices that are made is thus important. #### Automatic Memory Management. There are two global policies that can be set: heuristics a",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:21605,Availability,alive,alive,21605," passed by non-const address as; a parameter to a C++ function (with the exception of the use as; ""self"" to a member function), ownership is relinquished. - A ROOT object coming from a ROOT call is not owned, but before it; passes to the Python interpreter, its ""must cleanup"" bit is set if; its type is a class derived from **`TObject`**. When the object goes; out of scope on the C++ side, the Python object will change type; into an object that largely behaves like None. The strict policy differs in that it will never relinquish ownership; when passing an object as a parameter to a function. It is then up to; the developer to prevent double deletes. Choosing one or the other; policy is done by:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryStrict ); ```. for the strict policy, or for the heuristic policy:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); ```. Care must be taken in the case of graphic objects: when drawn on the; current pad, a reference to the graphics is kept that `PyROOT` isn't; currently aware of, and it is up to the developer to keep at lease one; Python reference alive. See `$ROOTSYS/tutorials/pyroot/zdemo.py`; (available in the latest release) for an example. Alternatively, one can; tell python to give up ownership for individual instances:. ``` {.cpp}; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective lang",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:21655,Availability,avail,available,21655,"a ROOT call is not owned, but before it; passes to the Python interpreter, its ""must cleanup"" bit is set if; its type is a class derived from **`TObject`**. When the object goes; out of scope on the C++ side, the Python object will change type; into an object that largely behaves like None. The strict policy differs in that it will never relinquish ownership; when passing an object as a parameter to a function. It is then up to; the developer to prevent double deletes. Choosing one or the other; policy is done by:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryStrict ); ```. for the strict policy, or for the heuristic policy:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); ```. Care must be taken in the case of graphic objects: when drawn on the; current pad, a reference to the graphics is kept that `PyROOT` isn't; currently aware of, and it is up to the developer to keep at lease one; Python reference alive. See `$ROOTSYS/tutorials/pyroot/zdemo.py`; (available in the latest release) for an example. Alternatively, one can; tell python to give up ownership for individual instances:. ``` {.cpp}; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typi",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:31065,Availability,avail,available,31065,"ing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the pointer to the address of the; object that is used for filling must be given to the **`TTree::Branch()`**; call, even though the formal argument is declared a '`void*'`. In the; case of ROOT objects, similar pointer manipulation is unnecessary,; because the full type information is available, and `TTree::Branch()`; has been Pythonized to take care of the call details. However, data; members of such objects that are of built-in types, still require; something extra since they are normally translated to Python primitive; types on access and hence their address cannot be taken. For that; purpose, there is the `AddressOf()` function. As an example:. ``` {.cpp}; from ROOT import TFile, TTree; from ROOT import gROOT, AddressOf. gROOT.ProcessLine(; ""struct MyStruct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:32934,Availability,echo,echo,32934,"ranch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a macro directly, but if you do not use ACLiC, you; will be restricted to use the default constructor of your class, which; is otherwise fully functional. For example:. ``` {.cpp}; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); ```; ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5572,Deployability,install,installation,5572,"he `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5808,Deployability,install,install,5808,"tches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that th",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5934,Deployability,install,installations,5934,"PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. T",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:6713,Deployability,install,installation,6713,"e care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x v",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:6850,Deployability,configurat,configuration,6850,"e care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x v",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7566,Deployability,configurat,configuration,7566,">`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the s",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8131,Deployability,install,installed,8131,"=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow wor",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8310,Deployability,install,install,8310,"contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what y",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8873,Deployability,configurat,configuration,8873,"ons older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at st",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8924,Deployability,configurat,configuration,8924,"ons older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at st",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:12994,Deployability,release,release,12994,"he proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:18548,Deployability,install,installation,18548,"ython access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ``` {.cpp}; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; ```. Here, the callback is a string that will be interpreted by Cling to call; `TPython::Exec()`, which will, in turn, interpret and execute the string; given to it. Note the use of raw strings (the '`r`' in front of the; second argument string), in order to remove the need of escaping the; backslashes. #### Cling Commands. In interactive mode, the Python exception hook is used to mimic some of; the Cling commands available. These are: `.q`, **`.!`**, **`.x`**,; **`.L`**, **`.cd`**, **`.ls`**, **`.pwd`**, **`.?`** and **`.help`**.; Note that **`.x`** translates to Python '`execfile()`' and thus accepts; only Python files, not Cling macros. ### Memory Handling. The Python interpreter handle",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:21679,Deployability,release,release,21679,"a ROOT call is not owned, but before it; passes to the Python interpreter, its ""must cleanup"" bit is set if; its type is a class derived from **`TObject`**. When the object goes; out of scope on the C++ side, the Python object will change type; into an object that largely behaves like None. The strict policy differs in that it will never relinquish ownership; when passing an object as a parameter to a function. It is then up to; the developer to prevent double deletes. Choosing one or the other; policy is done by:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryStrict ); ```. for the strict policy, or for the heuristic policy:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); ```. Care must be taken in the case of graphic objects: when drawn on the; current pad, a reference to the graphics is kept that `PyROOT` isn't; currently aware of, and it is up to the developer to keep at lease one; Python reference alive. See `$ROOTSYS/tutorials/pyroot/zdemo.py`; (available in the latest release) for an example. Alternatively, one can; tell python to give up ownership for individual instances:. ``` {.cpp}; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typi",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:21874,Deployability,release,release,21874,"ut of scope on the C++ side, the Python object will change type; into an object that largely behaves like None. The strict policy differs in that it will never relinquish ownership; when passing an object as a parameter to a function. It is then up to; the developer to prevent double deletes. Choosing one or the other; policy is done by:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryStrict ); ```. for the strict policy, or for the heuristic policy:. ``` {.cpp}; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); ```. Care must be taken in the case of graphic objects: when drawn on the; current pad, a reference to the graphics is kept that `PyROOT` isn't; currently aware of, and it is up to the developer to keep at lease one; Python reference alive. See `$ROOTSYS/tutorials/pyroot/zdemo.py`; (available in the latest release) for an example. Alternatively, one can; tell python to give up ownership for individual instances:. ``` {.cpp}; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough;",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:28586,Deployability,release,release,28586,"ble and supply; that **`TF1`** as a parameter to the `Fit()` member function of the; histogram. After the fit, you can retrieve the fit parameters from the; **`TF1`** instance. For example:. ``` {.cpp}; from ROOT import TF1, TH1F, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function for fitting; f = TF1('pyf3',Linear(),-1.,1.,2). # create and fill a histogram; h = TH1F('h','test',100,-1.,1.); f2 = TF1('cf2','6.+x*4.5',-1.,1.); h.FillRandom('cf2',10000). # fit the histo with the python 'linear' function; h.Fit(f). # print results; par = f.GetParameters(); print('fit results: const =', par[0], ',pitch =', par[1]); ```. ### Working with Trees. Next to making histograms, working with trees is probably the most; common part of any analysis. The **`TTree`** implementation uses; pointers and dedicated buffers to reduce the memory usage and to speed; up access. Consequently, mapping **`TTree`** functionality to Python is; not straightforward, and most of the following features are implemented; in ROOT release 4.01/04 and later only, whereas you will need 5.02 if; you require all of them. #### Accessing an Existing Tree. Let us assume that you have a file containing **`TTrees`**,; **`TChains`**, or **`TNtuples`** and want to read the contents for use; in your analysis code. This is commonly the case when you work with the; result of the reconstruction software of your experiment (e.g. the; combined ntuple in ATLAS). The following example code outlines the main; steps (you can run it on the result of the `tree1.C` macro):. ``` {.cpp}; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; co",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:32277,Deployability,release,releases,32277,"eir address cannot be taken. For that; purpose, there is the `AddressOf()` function. As an example:. ``` {.cpp}; from ROOT import TFile, TTree; from ROOT import gROOT, AddressOf. gROOT.ProcessLine(; ""struct MyStruct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:28394,Energy Efficiency,reduce,reduce,28394,"Histograms. Fitting a histogram with a Python function is no more difficult than; plotting: instantiate a **`TF1`** with the Python callable and supply; that **`TF1`** as a parameter to the `Fit()` member function of the; histogram. After the fit, you can retrieve the fit parameters from the; **`TF1`** instance. For example:. ``` {.cpp}; from ROOT import TF1, TH1F, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function for fitting; f = TF1('pyf3',Linear(),-1.,1.,2). # create and fill a histogram; h = TH1F('h','test',100,-1.,1.); f2 = TF1('cf2','6.+x*4.5',-1.,1.); h.FillRandom('cf2',10000). # fit the histo with the python 'linear' function; h.Fit(f). # print results; par = f.GetParameters(); print('fit results: const =', par[0], ',pitch =', par[1]); ```. ### Working with Trees. Next to making histograms, working with trees is probably the most; common part of any analysis. The **`TTree`** implementation uses; pointers and dedicated buffers to reduce the memory usage and to speed; up access. Consequently, mapping **`TTree`** functionality to Python is; not straightforward, and most of the following features are implemented; in ROOT release 4.01/04 and later only, whereas you will need 5.02 if; you require all of them. #### Accessing an Existing Tree. Let us assume that you have a file containing **`TTrees`**,; **`TChains`**, or **`TNtuples`** and want to read the contents for use; in your analysis code. This is commonly the case when you work with the; result of the reconstruction software of your experiment (e.g. the; combined ntuple in ATLAS). The following example code outlines the main; steps (you can run it on the result of the `tree1.C` macro):. ``` {.cpp}; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:137,Integrability,interoperab,interoperability,137,"# Python Interface; \index{Python}. Python is a popular, open-source, dynamic programming language with an; interactive interpreter. Its interoperability with other programming; languages, both for extending Python as well as embedding it, is; excellent and many existing third-party applications and libraries have; therefore so-called ""Python bindings."" PyROOT provides Python bindings; for ROOT: it enables cross-calls from ROOT/Cling into Python and vice; versa, the intermingling of the two interpreters, and the transport of; user-level objects from one interpreter to the other. PyROOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5497,Integrability,depend,depends,5497,"r, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:16358,Integrability,message,message,16358,"t char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; ```. `LoadMacro(const char* name)` - the argument is a name of a Python file; that is to be executed (`'execfile'`), after which any new classes are; automatically made available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed ('execfile'); in a private namespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:25847,Integrability,depend,depends,25847,"n you're; done with it. ### Use of Python Functions. It is possible to mix Python functions with ROOT and perform such; operations as plotting and fitting of histograms with them. In all; cases, the procedure consists of instantiating a ROOT **`TF1`**,; **`TF2`**, or **`TF3`** with the Python function and working with that; ROOT object. There are some memory issues, so it is for example not yet; possible to delete a **`TF1`** instance and then create another one with; the same name. In addition, the Python function, once used for; instantiating the **`TF1`**, is never deleted. Instead of a Python function, you can also use callable instances (e.g.,; an instance of a class that has implemented the `__call__` member; function). The signature of the Python callable should provide for one; or two arrays. The first array, which must always be present, shall; contain the `x`, `y`, `z`, and t values for the call. The second array,; which is optional and its size depends on the number given to the; **`TF1`** constructor, contains the values that parameterize the; function. For more details, see the **`TF1`** documentation and the; examples below. #### Plotting Python Function. This is an example of a parameter less Python function that is plotted; on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); ```. Because no number of parameters is given to the **`TF1`** constructor,; '`0`' (the default) is assumed. This way, the '`identity'` function need; not handle a second argument, which would normally be used to pass the; function parameters. Note that the argument '`x`' is an array of size 4.; The following is an example of a parameterized Python callable instance; that is plotted on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # c",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:198,Modifiability,extend,extending,198,"# Python Interface; \index{Python}. Python is a popular, open-source, dynamic programming language with an; interactive interpreter. Its interoperability with other programming; languages, both for extending Python as well as embedding it, is; excellent and many existing third-party applications and libraries have; therefore so-called ""Python bindings."" PyROOT provides Python bindings; for ROOT: it enables cross-calls from ROOT/Cling into Python and vice; versa, the intermingling of the two interpreters, and the transport of; user-level objects from one interpreter to the other. PyROOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5304,Modifiability,variab,variables,5304,"l other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHO",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:6850,Modifiability,config,configuration,6850,"e care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x v",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7015,Modifiability,config,configure,7015,"/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7115,Modifiability,config,configure,7115,"ATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your sys",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7566,Modifiability,config,configuration,7566,">`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the s",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7626,Modifiability,variab,variable,7626,">`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the s",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8232,Modifiability,config,configured,8232,"clude; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. Th",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8873,Modifiability,config,configuration,8873,"ons older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at st",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8924,Modifiability,config,configuration,8924,"ons older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at st",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:12958,Modifiability,variab,variable,12958,"he proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:16948,Modifiability,variab,variable,16948," available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed ('execfile'); in a private namespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling sess",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17128,Modifiability,variab,variable,17128,"mespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyP",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:25931,Modifiability,parameteriz,parameterize,25931,"n you're; done with it. ### Use of Python Functions. It is possible to mix Python functions with ROOT and perform such; operations as plotting and fitting of histograms with them. In all; cases, the procedure consists of instantiating a ROOT **`TF1`**,; **`TF2`**, or **`TF3`** with the Python function and working with that; ROOT object. There are some memory issues, so it is for example not yet; possible to delete a **`TF1`** instance and then create another one with; the same name. In addition, the Python function, once used for; instantiating the **`TF1`**, is never deleted. Instead of a Python function, you can also use callable instances (e.g.,; an instance of a class that has implemented the `__call__` member; function). The signature of the Python callable should provide for one; or two arrays. The first array, which must always be present, shall; contain the `x`, `y`, `z`, and t values for the call. The second array,; which is optional and its size depends on the number given to the; **`TF1`** constructor, contains the values that parameterize the; function. For more details, see the **`TF1`** documentation and the; examples below. #### Plotting Python Function. This is an example of a parameter less Python function that is plotted; on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); ```. Because no number of parameters is given to the **`TF1`** constructor,; '`0`' (the default) is assumed. This way, the '`identity'` function need; not handle a second argument, which would normally be used to pass the; function parameters. Note that the argument '`x`' is an array of size 4.; The following is an example of a parameterized Python callable instance; that is plotted on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # c",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:26678,Modifiability,parameteriz,parameterized,26678,"array, which must always be present, shall; contain the `x`, `y`, `z`, and t values for the call. The second array,; which is optional and its size depends on the number given to the; **`TF1`** constructor, contains the values that parameterize the; function. For more details, see the **`TF1`** documentation and the; examples below. #### Plotting Python Function. This is an example of a parameter less Python function that is plotted; on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); ```. Because no number of parameters is given to the **`TF1`** constructor,; '`0`' (the default) is assumed. This way, the '`identity'` function need; not handle a second argument, which would normally be used to pass the; function parameters. Note that the argument '`x`' is an array of size 4.; The following is an example of a parameterized Python callable instance; that is plotted on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function with offset 5, and pitch 2; f = TF1('pyf2',Linear(),-1.,1.,2); f.SetParameters(5.,2.). # plot the function; c = TCanvas(); f.Draw(); ```. Note that this time the constructor is told that there are two; parameters, and note in particular how these parameters are set. It is,; of course, also possible (and preferable if you only use the function; for plotting) to keep the parameters as data members of the callable; instance and use and set them directly from Python. #### Fitting Histograms. Fitting a histogram with a Python function is no more difficult than; plotting: instantiate a **`TF1`** with the Python callable and supply; that **`TF1`** as a parameter to the `Fit()` member function of the; histogram. After the fit, you can retrieve the fit parameters from the; **`TF1`** instance. For",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:877,Performance,perform,performance,877,"# Python Interface; \index{Python}. Python is a popular, open-source, dynamic programming language with an; interactive interpreter. Its interoperability with other programming; languages, both for extending Python as well as embedding it, is; excellent and many existing third-party applications and libraries have; therefore so-called ""Python bindings."" PyROOT provides Python bindings; for ROOT: it enables cross-calls from ROOT/Cling into Python and vice; versa, the intermingling of the two interpreters, and the transport of; user-level objects from one interpreter to the other. PyROOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:1553,Performance,load,loaded,1553,"OOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, becomes children play. The following; example shows how a Python class can be used to have ROOT code respond; to a click on a Qt widget. ``` {.cpp}; # Glue-ing Qt and ROOT through Python; import sys, ROOT; from qt import *. theApp = QApplication( sys.argv); box = QVBox(); box.resize(QSize(40,10).expandedTo(box.minimumSizeHint())). class myButton(QPushButton):; def __init__( self,label,master):; QPushButton.__init__(self,label,master); self.setFont( QFont('Times',18,QFont.Bold)). def browse(self):; self.b = ROOT.TBrowser(). bb = myButton('browser',box); QObject.connect( bb,SIGNAL('c",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:4517,Performance,load,loaded,4517,"ng a Gaussian distribution. More examples like the one above are; distributed with ROOT under the `$ROOTSYS/tutorials` directory. ``` {.cpp}; # Example: displaying a ROOT histogram from Python; from ROOT import gRandom,TCanvas,TH1F. c1 = TCanvas('c1','Example',200,10,700,500); hpx = TH1F('hpx','px',100,-4,4). for i in xrange(25000):; px = gRandom.Gaus(); hpx.Fill(px). hpx.Draw(); c1.Update(); ```. ### Access to Python from ROOT. Access to Python objects from Cling is not completely fleshed out.; Currently, ROOT objects and built-in types can cross the boundary; between the two interpreters, but other objects are much more; restricted. For example, for a Python object to cross, it has to be a; class instance, and its class has to be known to Cling first (i.e. the; class has to cross first, before the instance can). All other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific si",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:4599,Performance,load,loaded,4599," with ROOT under the `$ROOTSYS/tutorials` directory. ``` {.cpp}; # Example: displaying a ROOT histogram from Python; from ROOT import gRandom,TCanvas,TH1F. c1 = TCanvas('c1','Example',200,10,700,500); hpx = TH1F('hpx','px',100,-4,4). for i in xrange(25000):; px = gRandom.Gaus(); hpx.Fill(px). hpx.Draw(); c1.Update(); ```. ### Access to Python from ROOT. Access to Python objects from Cling is not completely fleshed out.; Currently, ROOT objects and built-in types can cross the boundary; between the two interpreters, but other objects are much more; restricted. For example, for a Python object to cross, it has to be a; class instance, and its class has to be known to Cling first (i.e. the; class has to cross first, before the instance can). All other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:4976,Performance,load,load,4976,"completely fleshed out.; Currently, ROOT objects and built-in types can cross the boundary; between the two interpreters, but other objects are much more; restricted. For example, for a Python object to cross, it has to be a; class instance, and its class has to be known to Cling first (i.e. the; class has to cross first, before the instance can). All other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from;",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5015,Performance,load,loading,5015,"completely fleshed out.; Currently, ROOT objects and built-in types can cross the boundary; between the two interpreters, but other objects are much more; restricted. For example, for a Python object to cross, it has to be a; class instance, and its class has to be known to Cling first (i.e. the; class has to cross first, before the instance can). All other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from;",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9464,Performance,load,loaded,9464,"`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9608,Performance,load,loading,9608,"vironment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes w",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9903,Performance,load,load,9903,"ft out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amou",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:10626,Performance,load,loaded,10626,"g mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from the",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13088,Performance,load,loaded,13088,"sage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13124,Performance,load,loading,13124,"; >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13320,Performance,load,loaded,13320,"here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly through their containing module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDe",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13498,Performance,load,loading,13498,"here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly through their containing module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDe",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:15212,Performance,load,load,15212,"aining module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; ```. The above is another good reason to prefer 'import ROOT' over 'from ROOT; import \*'. #### Access to Python. The access to Python from Cling goes through the **`TPython`** class, or; directly if a Python object or class has crossed the border. The; **`TPython`** class, which looks approximately like this:. ``` {.cpp}; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; ```. `LoadMacro(const char* name)` - the argument is a name of a Python file; that is to be executed (`'execfile'`), after which any new classes are; automatically made available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed ('execfile'); in a private namespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17277,Performance,load,loaded,17277,"hat; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly.",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17359,Performance,load,loaded,17359,"printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest w",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17825,Performance,load,loaded,17825,"ll be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ``` {.cpp}; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; ```. Here, the callback is a string that wil",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:22331,Performance,perform,performance,22331,"`. Care must be taken in the case of graphic objects: when drawn on the; current pad, a reference to the graphics is kept that `PyROOT` isn't; currently aware of, and it is up to the developer to keep at lease one; Python reference alive. See `$ROOTSYS/tutorials/pyroot/zdemo.py`; (available in the latest release) for an example. Alternatively, one can; tell python to give up ownership for individual instances:. ``` {.cpp}; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invarian",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:22568,Performance,optimiz,optimize,22568," `PyROOT` isn't; currently aware of, and it is up to the developer to keep at lease one; Python reference alive. See `$ROOTSYS/tutorials/pyroot/zdemo.py`; (available in the latest release) for an example. Alternatively, one can; tell python to give up ownership for individual instances:. ``` {.cpp}; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:22754,Performance,perform,performance,22754,"ject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optim",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:22861,Performance,perform,performance,22861,"ject(); ROOT.SetOwnership( o, False ) # True to own, False to release; ```. #### Memory Management by Hand. If needed, you can explicitly destroy a ROOT object that you own through; its associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optim",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:22976,Performance,optimiz,optimization,22976,"associated **`TClass`**:. ``` {.cpp}; myobject.IsA().Destructor(myobject); ```. which will send out the deletion notification to the system (thus you do; not need to care anymore at this point about Python reference counting,; the object will go, even if it's reference count it non-zero), and free; the memory. ### Performance. The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:23456,Performance,optimiz,optimizing,23456,"e languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:23530,Performance,bottleneck,bottlenecks,23530,"e languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:23553,Performance,perform,performance,23553," ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method:",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:23808,Performance,optimiz,optimizes,23808,"nce critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; ```. Note that if you do not discard the bound method, a reference to the; histogram will remain outstanding, and it will not be deleted when it; should be. It is therefore important to delete the met",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:23877,Performance,perform,performance,23877,"nce critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; ```. Note that if you do not discard the bound method, a reference to the; histogram will remain outstanding, and it will not be deleted when it; should be. It is therefore important to delete the met",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:24515,Performance,cache,cache,24515,"s; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; ```. Note that if you do not discard the bound method, a reference to the; histogram will remain outstanding, and it will not be deleted when it; should be. It is therefore important to delete the method when you're; done with it. ### Use of Python Functions. It is possible to mix Python functions with ROOT and perform such; operations as plotting and fitting of histograms with them. In all; cases, the procedure consists of instantiating a ROOT **`TF1`**,; **`TF2`**, or **`TF3`** with the Python function and working with that; ROOT object. There are some memory issues, so it is for example not yet; possible to delete a **`TF1`** instance and then create another one with; the same name. In addition, the Python function, once used for; instantiating the **`TF1`**, is never deleted. Instead of a Python function, you can also use callable instances (e.g.,; an ins",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:24655,Performance,cache,cached,24655,"d by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; ```. Note that if you do not discard the bound method, a reference to the; histogram will remain outstanding, and it will not be deleted when it; should be. It is therefore important to delete the method when you're; done with it. ### Use of Python Functions. It is possible to mix Python functions with ROOT and perform such; operations as plotting and fitting of histograms with them. In all; cases, the procedure consists of instantiating a ROOT **`TF1`**,; **`TF2`**, or **`TF3`** with the Python function and working with that; ROOT object. There are some memory issues, so it is for example not yet; possible to delete a **`TF1`** instance and then create another one with; the same name. In addition, the Python function, once used for; instantiating the **`TF1`**, is never deleted. Instead of a Python function, you can also use callable instances (e.g.,; an instance of a class that has implemented the `__call__` member; function). The signatu",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:24983,Performance,perform,perform,24983," other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cut this process by looking up and binding; the method before the loop, and discarding it afterwards. Here is an; example:. ``` {.cpp}; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; ```. Note that if you do not discard the bound method, a reference to the; histogram will remain outstanding, and it will not be deleted when it; should be. It is therefore important to delete the method when you're; done with it. ### Use of Python Functions. It is possible to mix Python functions with ROOT and perform such; operations as plotting and fitting of histograms with them. In all; cases, the procedure consists of instantiating a ROOT **`TF1`**,; **`TF2`**, or **`TF3`** with the Python function and working with that; ROOT object. There are some memory issues, so it is for example not yet; possible to delete a **`TF1`** instance and then create another one with; the same name. In addition, the Python function, once used for; instantiating the **`TF1`**, is never deleted. Instead of a Python function, you can also use callable instances (e.g.,; an instance of a class that has implemented the `__call__` member; function). The signature of the Python callable should provide for one; or two arrays. The first array, which must always be present, shall; contain the `x`, `y`, `z`, and t values for the call. The second array,; which is optional and its size depends on the number given to the; **`TF1`** constructor, contains the values that parameterize the; function. For more details, see the **`TF1`*",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:32569,Performance,load,loading,32569," fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a macro directly, but if you do not use ACLiC, you; will be restricted to use the default constructor of your class, which; is otherwise fully functional. For example:. ``` {.cpp}; from ROOT import gROOT. # load MyClass definition macro (append '+' to us",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:33142,Performance,load,load,33142,"ranch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a macro directly, but if you do not use ACLiC, you; will be restricted to use the default constructor of your class, which; is otherwise fully functional. For example:. ``` {.cpp}; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); ```; ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:33329,Performance,load,load,33329,"ranch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a macro directly, but if you do not use ACLiC, you; will be restricted to use the default constructor of your class, which; is otherwise fully functional. For example:. ``` {.cpp}; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); ```; ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:33541,Performance,load,load,33541,"ranch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a macro directly, but if you do not use ACLiC, you; will be restricted to use the default constructor of your class, which; is otherwise fully functional. For example:. ``` {.cpp}; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); ```; ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:602,Security,access,access,602,"# Python Interface; \index{Python}. Python is a popular, open-source, dynamic programming language with an; interactive interpreter. Its interoperability with other programming; languages, both for extending Python as well as embedding it, is; excellent and many existing third-party applications and libraries have; therefore so-called ""Python bindings."" PyROOT provides Python bindings; for ROOT: it enables cross-calls from ROOT/Cling into Python and vice; versa, the intermingling of the two interpreters, and the transport of; user-level objects from one interpreter to the other. PyROOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:1627,Security,access,access,1627,"OOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, becomes children play. The following; example shows how a Python class can be used to have ROOT code respond; to a click on a Qt widget. ``` {.cpp}; # Glue-ing Qt and ROOT through Python; import sys, ROOT; from qt import *. theApp = QApplication( sys.argv); box = QVBox(); box.resize(QSize(40,10).expandedTo(box.minimumSizeHint())). class myButton(QPushButton):; def __init__( self,label,master):; QPushButton.__init__(self,label,master); self.setFont( QFont('Times',18,QFont.Bold)). def browse(self):; self.b = ROOT.TBrowser(). bb = myButton('browser',box); QObject.connect( bb,SIGNAL('c",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:4922,Security,access,accessing,4922,"completely fleshed out.; Currently, ROOT objects and built-in types can cross the boundary; between the two interpreters, but other objects are much more; restricted. For example, for a Python object to cross, it has to be a; class instance, and its class has to be known to Cling first (i.e. the; class has to cross first, before the instance can). All other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from;",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:11827,Security,access,access,11827,"nspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from there, in the ROOT module directly, but doing so makes the; code less clear, of course). Be careful in their use, because Python; already has types called ""`string`"" and ""`list`."". In order to understand how to get access to a templated class, think of; the general template as a meta class. By instantiating the meta class; with the proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:14976,Security,access,access,14976," ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since they are references, they can; be changed only if done so directly through their containing module. The; following session shows that in detail:. ``` {.cpp}; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; ```. The above is another good reason to prefer 'import ROOT' over 'from ROOT; import \*'. #### Access to Python. The access to Python from Cling goes through the **`TPython`** class, or; directly if a Python object or class has crossed the border. The; **`TPython`** class, which looks approximately like this:. ``` {.cpp}; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; ```. `LoadMacro(const char* name)` - the argument is a name of a Python file; that is to be executed (`'execfile'`), after which any new classes are; automatically made available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17546,Security,access,access,17546,"turned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ```",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:28435,Security,access,access,28435,"Histograms. Fitting a histogram with a Python function is no more difficult than; plotting: instantiate a **`TF1`** with the Python callable and supply; that **`TF1`** as a parameter to the `Fit()` member function of the; histogram. After the fit, you can retrieve the fit parameters from the; **`TF1`** instance. For example:. ``` {.cpp}; from ROOT import TF1, TH1F, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function for fitting; f = TF1('pyf3',Linear(),-1.,1.,2). # create and fill a histogram; h = TH1F('h','test',100,-1.,1.); f2 = TF1('cf2','6.+x*4.5',-1.,1.); h.FillRandom('cf2',10000). # fit the histo with the python 'linear' function; h.Fit(f). # print results; par = f.GetParameters(); print('fit results: const =', par[0], ',pitch =', par[1]); ```. ### Working with Trees. Next to making histograms, working with trees is probably the most; common part of any analysis. The **`TTree`** implementation uses; pointers and dedicated buffers to reduce the memory usage and to speed; up access. Consequently, mapping **`TTree`** functionality to Python is; not straightforward, and most of the following features are implemented; in ROOT release 4.01/04 and later only, whereas you will need 5.02 if; you require all of them. #### Accessing an Existing Tree. Let us assume that you have a file containing **`TTrees`**,; **`TChains`**, or **`TNtuples`** and want to read the contents for use; in your analysis code. This is commonly the case when you work with the; result of the reconstruction software of your experiment (e.g. the; combined ntuple in ATLAS). The following example code outlines the main; steps (you can run it on the result of the `tree1.C` macro):. ``` {.cpp}; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:29737,Security,access,access,29737,"r **`TNtuples`** and want to read the contents for use; in your analysis code. This is commonly the case when you work with the; result of the reconstruction software of your experiment (e.g. the; combined ntuple in ATLAS). The following example code outlines the main; steps (you can run it on the result of the `tree1.C` macro):. ``` {.cpp}; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); ```. Access to arrays works the same way as access to single value tree; elements, where the size of the array is determined by the number of; values actually read from the file. For example:. ``` {.cpp}; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; ```. #### Writing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the po",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:29978,Security,access,access,29978,"in ATLAS). The following example code outlines the main; steps (you can run it on the result of the `tree1.C` macro):. ``` {.cpp}; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); ```. Access to arrays works the same way as access to single value tree; elements, where the size of the array is determined by the number of; values actually read from the file. For example:. ``` {.cpp}; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; ```. #### Writing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the pointer to the address of the; object that is used for filling must be given to the **`TTree::Branch()`**; call, even though the formal argument is declared a '`void*'`. In the; case of ROOT objects, similar pointer",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:31316,Security,access,access,31316,"-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the pointer to the address of the; object that is used for filling must be given to the **`TTree::Branch()`**; call, even though the formal argument is declared a '`void*'`. In the; case of ROOT objects, similar pointer manipulation is unnecessary,; because the full type information is available, and `TTree::Branch()`; has been Pythonized to take care of the call details. However, data; members of such objects that are of built-in types, still require; something extra since they are normally translated to Python primitive; types on access and hence their address cannot be taken. For that; purpose, there is the `AddressOf()` function. As an example:. ``` {.cpp}; from ROOT import TFile, TTree; from ROOT import gROOT, AddressOf. gROOT.ProcessLine(; ""struct MyStruct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and late",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:32554,Security,access,accessed,32554," fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); ```. The C++ class is defined through the `gROOT.ProcessLine()` call, and; note how the `AddressOf()` function is used for data members of built-in; type. Most of the above is for ROOT version 5.02 and later only. For; older releases, and without further support, here is an example as to; how you can get hold of a pointer-to-pointer to a ROOT object:. ``` {.cpp}; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); ```. ### Using Your Own Classes. A user's own classes can be accessed after loading, either directly or; indirectly, the library that contains the dictionary. One easy way of; obtaining such a library, is by using ACLiC:. ``` {.cpp}; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; ```. Then you can use it, for example, like so:. ``` {.cpp}; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); ```. You can also load a macro directly, but if you do not use ACLiC, you; will be restricted to use the default constructor of your class, which; is otherwise fully functional. For example:. ``` {.cpp}; from ROOT import gROOT. # load MyClass definition macro (append '+' to us",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:27954,Testability,test,test,27954,"'pyf2',Linear(),-1.,1.,2); f.SetParameters(5.,2.). # plot the function; c = TCanvas(); f.Draw(); ```. Note that this time the constructor is told that there are two; parameters, and note in particular how these parameters are set. It is,; of course, also possible (and preferable if you only use the function; for plotting) to keep the parameters as data members of the callable; instance and use and set them directly from Python. #### Fitting Histograms. Fitting a histogram with a Python function is no more difficult than; plotting: instantiate a **`TF1`** with the Python callable and supply; that **`TF1`** as a parameter to the `Fit()` member function of the; histogram. After the fit, you can retrieve the fit parameters from the; **`TF1`** instance. For example:. ``` {.cpp}; from ROOT import TF1, TH1F, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function for fitting; f = TF1('pyf3',Linear(),-1.,1.,2). # create and fill a histogram; h = TH1F('h','test',100,-1.,1.); f2 = TF1('cf2','6.+x*4.5',-1.,1.); h.FillRandom('cf2',10000). # fit the histo with the python 'linear' function; h.Fit(f). # print results; par = f.GetParameters(); print('fit results: const =', par[0], ',pitch =', par[1]); ```. ### Working with Trees. Next to making histograms, working with trees is probably the most; common part of any analysis. The **`TTree`** implementation uses; pointers and dedicated buffers to reduce the memory usage and to speed; up access. Consequently, mapping **`TTree`** functionality to Python is; not straightforward, and most of the following features are implemented; in ROOT release 4.01/04 and later only, whereas you will need 5.02 if; you require all of them. #### Accessing an Existing Tree. Let us assume that you have a file containing **`TTrees`**,; **`TChains`**, or **`TNtuples`** and want to read the contents for use; in your analysis code. This is commonly the case when you work with the; result of the reconstruct",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:30406,Testability,test,test,30406,"ry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); ```. Access to arrays works the same way as access to single value tree; elements, where the size of the array is determined by the number of; values actually read from the file. For example:. ``` {.cpp}; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; ```. #### Writing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the pointer to the address of the; object that is used for filling must be given to the **`TTree::Branch()`**; call, even though the formal argument is declared a '`void*'`. In the; case of ROOT objects, similar pointer manipulation is unnecessary,; because the full type information is available, and `TTree::Branch()`; has been Pythonized to take care of the call details. However, data; members of such objects that are of built-in types, still require; something extra since they are normally translated to Python primitive; types on access and hence their address cannot be taken. For that; purpose, there is the `AddressO",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:30438,Testability,test,test,30438,"# copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); ```. Access to arrays works the same way as access to single value tree; elements, where the size of the array is determined by the number of; values actually read from the file. For example:. ``` {.cpp}; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; ```. #### Writing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the pointer to the address of the; object that is used for filling must be given to the **`TTree::Branch()`**; call, even though the formal argument is declared a '`void*'`. In the; case of ROOT objects, similar pointer manipulation is unnecessary,; because the full type information is available, and `TTree::Branch()`; has been Pythonized to take care of the call details. However, data; members of such objects that are of built-in types, still require; something extra since they are normally translated to Python primitive; types on access and hence their address cannot be taken. For that; purpose, there is the `AddressOf()` function. As an example:",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:6082,Usability,simpl,simply,6082," // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you m",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9984,Usability,simpl,simple,9984,"ROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to f",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:10288,Usability,clear,clearer,10288," succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class stati",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:10426,Usability,simpl,simple,10426,"to the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; """,MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:11682,Usability,clear,clear,11682,"ed) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from there, in the ROOT module directly, but doing so makes the; code less clear, of course). Be careful in their use, because Python; already has types called ""`string`"" and ""`list`."". In order to understand how to get access to a templated class, think of; the general template as a meta class. By instantiating the meta class; with the proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extensio",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13181,Usability,clear,clear,13181,"ack(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since the",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:18364,Usability,simpl,simplest,18364,"()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ``` {.cpp}; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; ```. Here, the callback is a string that will be interpreted by Cling to call; `TPython::Exec()`, which will, in turn, interpret and execute the string; given to it. Note the use of raw strings (the '`r`' in front of the; second argument string), in order to remove the need of escaping the; backslashes. #### Cling Commands. In interactive mode, the Python exception hook is used to mimic some of; the Cling commands available. These are: `.q`, **`.!`**, **`.x`**,; **`.L`**, **`.cd`**, **`.ls`**, **`.pwd`**, **`.?`** and **`.help`**.; Note that ",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:23331,Usability,simpl,simple,23331," The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cu",MatchSource.DOCS,documentation/users-guide/PythonRuby.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:8226,Deployability,update,update,8226,"ace the standard `ClassImp` macro by `ClassImpQ`. Signals are currently implemented for all ROOT GUI classes and the [TTimer](https://root.cern/doc/master/classTTimer.html) and [TCanvas](https://root.cern/doc/master/classTCanvas.html) classes (to find quickly all defined signals do for example: `grep '*SIGNAL*' $ROOTSYS/include/*.h`). ## Examples. ### A First Time Example ([rqfirst.C](http://root.cern.ch/root/rqex/rqfirst.C)). This example shows:. * How to create interpreted class with signals with different types/number of arguments.; * How to connect signals to slots.; * How to activate signals. ### Histogram Filling with Dynamic State Reported via Signals ([rqsimple.C](http://root.cern.ch/root/rqex/rqsimple.C)). Based on hsimple this example demonstrates:. * All features of the hsimple example.; * How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; * How to use the [TTimer](https://root.cern/doc/master/classTTimer.html) class for emulation of ""multithreading"".; * How to use signals for the concurrent update of pad, file, benchmark facility, etc. ### An Example on How to Use Canvas Event Signals ([rqfiller.C](http://root.cern.ch/root/rqex/rqfiller.C)). This example shows:. * How the object communication mechanism can be used for handling the [TCanvas](https://root.cern/doc/master/classTCanvas.html)'s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. * Click the left button or move mouse with button pressed to fill histograms.; * Use the right button of the mouse to reset the histograms. ### Complex GUI Using Signals and Slots ([guitest.C](https://root.cern.ch/doc/master/guitest_8C.html)). Based on `$ROOTSYS/test/guitest.cxx` this example demonstrates:. * All features of the original compiled guitest.cxx program.; * Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program.; ",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:6913,Integrability,interface,interface,6913,"ton, ""Pressed()"", ""TH1"", hist, ""SetMaximum(=123)"");; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw(=\""LEGO\"")"");; ```. ## Signals. A signal is a normal class method. **The first requirement** is that it should call an `Emit()` method. The format of this method is the following:. ``` {.cpp}; Emit(""full_method_name""[,arguments]);; ```. where `""full_method_name""` is the method name and prototype string of the signal method.; For example, for `SetValue(Int_t value)` the full method name will be `""SetValue(Int_t)""`, where `SetValue` is the method name and `Int_t` the prototype string. Note that typedefs will be resolved to facilitate matching of slots to signals. So the slot `""print(int)""` can be connected to the above signal which has an `Int_t` as argument. **The second requirement** is that the method declaration should have the string `*SIGNAL*` in its comment field. Like:. ``` {.cpp}; void SetValue(Int_t x); //*SIGNAL*; ```. This provides an explicit interface specification for the user (this requirement is currently not enforced at run-time). **The third requirement**, only necessary if you want to have class signals (i.e. for all objects of a class), is that you have to replace the standard `ClassImp` macro by `ClassImpQ`. Signals are currently implemented for all ROOT GUI classes and the [TTimer](https://root.cern/doc/master/classTTimer.html) and [TCanvas](https://root.cern/doc/master/classTCanvas.html) classes (to find quickly all defined signals do for example: `grep '*SIGNAL*' $ROOTSYS/include/*.h`). ## Examples. ### A First Time Example ([rqfirst.C](http://root.cern.ch/root/rqex/rqfirst.C)). This example shows:. * How to create interpreted class with signals with different types/number of arguments.; * How to connect signals to slots.; * How to activate signals. ### Histogram Filling with Dynamic State Reported via Signals ([rqsimple.C](http://root.cern.ch/root/rqex/rqsimple.C)). Based on hsimple this example demonstrates:. * All features of the hsimple exam",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:9059,Integrability,interface,interface,9059,"ace the standard `ClassImp` macro by `ClassImpQ`. Signals are currently implemented for all ROOT GUI classes and the [TTimer](https://root.cern/doc/master/classTTimer.html) and [TCanvas](https://root.cern/doc/master/classTCanvas.html) classes (to find quickly all defined signals do for example: `grep '*SIGNAL*' $ROOTSYS/include/*.h`). ## Examples. ### A First Time Example ([rqfirst.C](http://root.cern.ch/root/rqex/rqfirst.C)). This example shows:. * How to create interpreted class with signals with different types/number of arguments.; * How to connect signals to slots.; * How to activate signals. ### Histogram Filling with Dynamic State Reported via Signals ([rqsimple.C](http://root.cern.ch/root/rqex/rqsimple.C)). Based on hsimple this example demonstrates:. * All features of the hsimple example.; * How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; * How to use the [TTimer](https://root.cern/doc/master/classTTimer.html) class for emulation of ""multithreading"".; * How to use signals for the concurrent update of pad, file, benchmark facility, etc. ### An Example on How to Use Canvas Event Signals ([rqfiller.C](http://root.cern.ch/root/rqex/rqfiller.C)). This example shows:. * How the object communication mechanism can be used for handling the [TCanvas](https://root.cern/doc/master/classTCanvas.html)'s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. * Click the left button or move mouse with button pressed to fill histograms.; * Use the right button of the mouse to reset the histograms. ### Complex GUI Using Signals and Slots ([guitest.C](https://root.cern.ch/doc/master/guitest_8C.html)). Based on `$ROOTSYS/test/guitest.cxx` this example demonstrates:. * All features of the original compiled guitest.cxx program.; * Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program.; ",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:4051,Modifiability,inherit,inheritance,4051,"gnal, which `b` will receive, i.e. `b->SetValue(79)` is invoked. It is executed immediately, just like a normal function call. `b` will in turn emit the same signal, which nobody receives, since no slot has been connected to it, so it disappears into hyperspace. This example illustrates that objects can work together without knowing about each other, as long as there is someone around to set up a connection between them. ## Features of the ROOT implementation. * The ROOT implementation **does not require the** *moc* preprocessor and the `signal:` and `slot:` keywords in the class declaration. Signals and slots are normal class methods. * The class which corresponds to **Qt's** **QObject** is [TQObject](https://root.cern/doc/master/classTQObject.html). It reproduces the general features of the QObject class and has the `Connect()`, `Disconnect()` and `Emit()` methods. The [TQObject](https://root.cern/doc/master/classTQObject.html) class does not derive from any class which makes it possible to have multiple inheritance from [TObject](https://root.cern/doc/master/classTQObject.html) derived classes and [TQObject](https://root.cern/doc/master/classTQObject.html). * By placing the [`RQ_OBJECT()`](https://root.cern/doc/master/RQ__OBJECT_8h.html) macro inside a class body you can use signals and slots with classes not inheriting from [TQObject](https://root.cern/doc/master/classTQObject.html), like interpreted classes which can not derive from compiled classes. This makes it possible to apply the **Object Communication Mechanism** between compiled and interpreted classes in an interactive ROOT session. * The ROOT implementation allows to make connections to any object known to the ROOT C++ interpreter. The following line makes a connection between signal `Pressed()` from `button` and method/slot `Draw()` from object `hist` of class (compiled or interpreted) `TH1`. ``` {.cpp}; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw()"");; ```. To connect to a stand-alone function (",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:4363,Modifiability,inherit,inheriting,4363,"ther without knowing about each other, as long as there is someone around to set up a connection between them. ## Features of the ROOT implementation. * The ROOT implementation **does not require the** *moc* preprocessor and the `signal:` and `slot:` keywords in the class declaration. Signals and slots are normal class methods. * The class which corresponds to **Qt's** **QObject** is [TQObject](https://root.cern/doc/master/classTQObject.html). It reproduces the general features of the QObject class and has the `Connect()`, `Disconnect()` and `Emit()` methods. The [TQObject](https://root.cern/doc/master/classTQObject.html) class does not derive from any class which makes it possible to have multiple inheritance from [TObject](https://root.cern/doc/master/classTQObject.html) derived classes and [TQObject](https://root.cern/doc/master/classTQObject.html). * By placing the [`RQ_OBJECT()`](https://root.cern/doc/master/RQ__OBJECT_8h.html) macro inside a class body you can use signals and slots with classes not inheriting from [TQObject](https://root.cern/doc/master/classTQObject.html), like interpreted classes which can not derive from compiled classes. This makes it possible to apply the **Object Communication Mechanism** between compiled and interpreted classes in an interactive ROOT session. * The ROOT implementation allows to make connections to any object known to the ROOT C++ interpreter. The following line makes a connection between signal `Pressed()` from `button` and method/slot `Draw()` from object `hist` of class (compiled or interpreted) `TH1`. ``` {.cpp}; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw()"");; ```. To connect to a stand-alone function (compiled or interpreted) the arguments corresponding to the name of the class and receiving object should be zero. For example. ``` {.cpp}; Connect(button, ""Pressed()"", 0, 0, ""printInfo()"");; ```. * It is also possible to make a single connection from all objects of the same class. For example:. ``` {.cpp}; TQObje",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:8215,Performance,concurren,concurrent,8215,"ace the standard `ClassImp` macro by `ClassImpQ`. Signals are currently implemented for all ROOT GUI classes and the [TTimer](https://root.cern/doc/master/classTTimer.html) and [TCanvas](https://root.cern/doc/master/classTCanvas.html) classes (to find quickly all defined signals do for example: `grep '*SIGNAL*' $ROOTSYS/include/*.h`). ## Examples. ### A First Time Example ([rqfirst.C](http://root.cern.ch/root/rqex/rqfirst.C)). This example shows:. * How to create interpreted class with signals with different types/number of arguments.; * How to connect signals to slots.; * How to activate signals. ### Histogram Filling with Dynamic State Reported via Signals ([rqsimple.C](http://root.cern.ch/root/rqex/rqsimple.C)). Based on hsimple this example demonstrates:. * All features of the hsimple example.; * How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; * How to use the [TTimer](https://root.cern/doc/master/classTTimer.html) class for emulation of ""multithreading"".; * How to use signals for the concurrent update of pad, file, benchmark facility, etc. ### An Example on How to Use Canvas Event Signals ([rqfiller.C](http://root.cern.ch/root/rqex/rqfiller.C)). This example shows:. * How the object communication mechanism can be used for handling the [TCanvas](https://root.cern/doc/master/classTCanvas.html)'s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. * Click the left button or move mouse with button pressed to fill histograms.; * Use the right button of the mouse to reset the histograms. ### Complex GUI Using Signals and Slots ([guitest.C](https://root.cern.ch/doc/master/guitest_8C.html)). Based on `$ROOTSYS/test/guitest.cxx` this example demonstrates:. * All features of the original compiled guitest.cxx program.; * Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program.; ",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:1981,Security,access,access,1981,"e used for receiving signals. A slot does not know if it has any signal(s) connected to it. This is true information encapsulation, and ensures that the object can be used as a true software component. Signals and slots can take any number of arguments of any type. It is possible to connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you desire. It is possible to make a single connection from all objects of the same class. ## A Small Example. A minimal C++ class declaration might read:. ``` {.cpp}; class A {; private:; Int_t fValue;; public:; A() { fValue = 0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; ```. A small ROOT **interpreted** class might read:. ``` {.cpp}; class A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() { fValue = 0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); //*SIGNAL*; };; ```. This class has the same internal state, and public methods to access the state, but in addition it has support for component programming using signals. This class can tell the outside world that its state has changed by emitting a signal, `SetValue(Int_t)`. Here is a possible implementation of `A::SetValue()`:. ``` {.cpp}; void A::SetValue(Int_t v); {; if (v != fValue) {; fValue = v;; Emit(""SetValue(Int_t)"", v);; }; }; ```. The line `Emit(""SetValue(Int_t)"", v)` emits the signal `SetValue(Int_t)` with argument `v` from the object. As you can see, you emit a signal by using `Emit(""full_method_name"",arguments)`. Here is one of the ways to connect two of these objects together:. ``` {.cpp}; A *a = new A();; A *b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; b->SetValue(11);; a->SetValue(79);; b->GetValue(); // this would now be 79, why?; ```. The statement `a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"")` denotes that object `a` connects its `""SetValue(Int_t)""` signal to `""A::SetValue(Int_t)""` method of object `b`. Calling `a->Se",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:8247,Testability,benchmark,benchmark,8247,"ace the standard `ClassImp` macro by `ClassImpQ`. Signals are currently implemented for all ROOT GUI classes and the [TTimer](https://root.cern/doc/master/classTTimer.html) and [TCanvas](https://root.cern/doc/master/classTCanvas.html) classes (to find quickly all defined signals do for example: `grep '*SIGNAL*' $ROOTSYS/include/*.h`). ## Examples. ### A First Time Example ([rqfirst.C](http://root.cern.ch/root/rqex/rqfirst.C)). This example shows:. * How to create interpreted class with signals with different types/number of arguments.; * How to connect signals to slots.; * How to activate signals. ### Histogram Filling with Dynamic State Reported via Signals ([rqsimple.C](http://root.cern.ch/root/rqex/rqsimple.C)). Based on hsimple this example demonstrates:. * All features of the hsimple example.; * How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; * How to use the [TTimer](https://root.cern/doc/master/classTTimer.html) class for emulation of ""multithreading"".; * How to use signals for the concurrent update of pad, file, benchmark facility, etc. ### An Example on How to Use Canvas Event Signals ([rqfiller.C](http://root.cern.ch/root/rqex/rqfiller.C)). This example shows:. * How the object communication mechanism can be used for handling the [TCanvas](https://root.cern/doc/master/classTCanvas.html)'s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. * Click the left button or move mouse with button pressed to fill histograms.; * Use the right button of the mouse to reset the histograms. ### Complex GUI Using Signals and Slots ([guitest.C](https://root.cern.ch/doc/master/guitest_8C.html)). Based on `$ROOTSYS/test/guitest.cxx` this example demonstrates:. * All features of the original compiled guitest.cxx program.; * Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program.; ",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:8885,Testability,test,test,8885,"ace the standard `ClassImp` macro by `ClassImpQ`. Signals are currently implemented for all ROOT GUI classes and the [TTimer](https://root.cern/doc/master/classTTimer.html) and [TCanvas](https://root.cern/doc/master/classTCanvas.html) classes (to find quickly all defined signals do for example: `grep '*SIGNAL*' $ROOTSYS/include/*.h`). ## Examples. ### A First Time Example ([rqfirst.C](http://root.cern.ch/root/rqex/rqfirst.C)). This example shows:. * How to create interpreted class with signals with different types/number of arguments.; * How to connect signals to slots.; * How to activate signals. ### Histogram Filling with Dynamic State Reported via Signals ([rqsimple.C](http://root.cern.ch/root/rqex/rqsimple.C)). Based on hsimple this example demonstrates:. * All features of the hsimple example.; * How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; * How to use the [TTimer](https://root.cern/doc/master/classTTimer.html) class for emulation of ""multithreading"".; * How to use signals for the concurrent update of pad, file, benchmark facility, etc. ### An Example on How to Use Canvas Event Signals ([rqfiller.C](http://root.cern.ch/root/rqex/rqfiller.C)). This example shows:. * How the object communication mechanism can be used for handling the [TCanvas](https://root.cern/doc/master/classTCanvas.html)'s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. * Click the left button or move mouse with button pressed to fill histograms.; * Use the right button of the mouse to reset the histograms. ### Complex GUI Using Signals and Slots ([guitest.C](https://root.cern.ch/doc/master/guitest_8C.html)). Based on `$ROOTSYS/test/guitest.cxx` this example demonstrates:. * All features of the original compiled guitest.cxx program.; * Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program.; ",MatchSource.DOCS,documentation/users-guide/SignalSlot.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:1478,Availability,error,error,1478," a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:4952,Availability,down,downloading,4952,"ndition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can follow the example below:. <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>. 3. Loading. Start an interactive ROOT session. Load the shared library:. ``` {.cpp}; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");; ```. 4. Creating. Create a thread instance (see also example `RunMhs3.C `or` RunPi.C`); with:. ``` {.cpp}; root[] TThread *th = new TThread(UserFun,UserArgs);; ```. When called from the interpreter, this gives the name ""`UserFun`"" to the; thread. This name can be used to retrieve the thread later. However,; when called from compiled code, this method does not give any name to; the thread. So give a name to the thread in compiled use:. ``` {.cpp}; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; ```. You can pass arguments to the thread function using the; `UserArgs`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17219,Availability,avail,available,17219,"ethod to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jum",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6187,Deployability,update,updated,6187,"(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");; ```. 4. Creating. Create a thread instance (see also example `RunMhs3.C `or` RunPi.C`); with:. ``` {.cpp}; root[] TThread *th = new TThread(UserFun,UserArgs);; ```. When called from the interpreter, this gives the name ""`UserFun`"" to the; thread. This name can be used to retrieve the thread later. However,; when called from compiled code, this method does not give any name to; the thread. So give a name to the thread in compiled use:. ``` {.cpp}; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; ```. You can pass arguments to the thread function using the; `UserArgs`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The m",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10179,Deployability,install,installed,10179,"il; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calli",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:19145,Deployability,toggle,toggle,19145,"ion`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynchronous timers. The; ***`kSigWindowChanged`*** signal handles the resizing of the terminal; window. The other signals have no other behavior then that to call any; registered **`TSignalHandler`*****`::Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private addres",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22612,Deployability,release,releases,22612,"ource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The dev",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:350,Energy Efficiency,adapt,adapted,350,"# Threads. A thread is an independent flow of control that operates within the same; address space as other independent flows of controls within a process.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread re",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:1147,Energy Efficiency,schedul,schedulable,1147,"rocess.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two poi",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:2046,Energy Efficiency,schedul,scheduled,2046,". - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:2070,Energy Efficiency,schedul,scheduler,2070,". - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6692,Energy Efficiency,allocate,allocates,6692,"iled use:. ``` {.cpp}; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; ```. You can pass arguments to the thread function using the; `UserArgs`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be acce",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:19570,Energy Efficiency,adapt,adapted,19570,":Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`*",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:1053,Integrability,message,message,1053,"t operates within the same; address space as other independent flows of controls within a process.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled b",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:2592,Integrability,rout,routine,2592,"routine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The pla",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:2817,Integrability,interface,interface,2817,",; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3192,Integrability,depend,depend,3192,"r to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3596,Integrability,depend,dependent,3596,"At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3808,Integrability,depend,dependent,3808,"T. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thre",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:4034,Integrability,depend,dependent,4034," ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can follow the example below:. <http://www-linux.gsi.de/~go4/HOWTOthreads/howto",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:4202,Integrability,synchroniz,synchronize,4202,"make; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can follow the example below:. <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>. 3. Loading. Start an interactive ROOT session. Load the shared library:. ``` {.cpp}; root[] gSystem->Load(""mhs",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:4236,Integrability,depend,dependent,4236,"so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can follow the example below:. <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>. 3. Loading. Start an interactive ROOT session. Load the shared library:. ``` {.cpp}; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");; ```. 4. Crea",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6850,Integrability,synchroniz,synchronize,6850,"s`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:7521,Integrability,synchroniz,synchronize,7521,"the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create a; **`TCondition`** object, a **`TMutex`** instance is required for the; Wait and `TimedWait` locking methods. One can pass the address of an; external mutex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TCondition`** creates and uses its own internal; mutex:. ``` {.cpp}; TCondition MyCondition(0);; ```. You can now use the following methods of synchronization:. - `TCondition::Wait()` waits until any thread sends a signal of the; same condition instance: `MyCondition.Wait()` reacts on; `MyCondition.Signal()` or `MyCondition.Broadcast()`.; `MyOtherCondition.Signal()` has no effect. - If several threads wait for the signal from the same; **`TCo",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:8278,Integrability,synchroniz,synchronization,8278," a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create a; **`TCondition`** object, a **`TMutex`** instance is required for the; Wait and `TimedWait` locking methods. One can pass the address of an; external mutex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TCondition`** creates and uses its own internal; mutex:. ``` {.cpp}; TCondition MyCondition(0);; ```. You can now use the following methods of synchronization:. - `TCondition::Wait()` waits until any thread sends a signal of the; same condition instance: `MyCondition.Wait()` reacts on; `MyCondition.Signal()` or `MyCondition.Broadcast()`.; `MyOtherCondition.Signal()` has no effect. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Signal()` only one; thread will react; to activate a further thread another; `MyCondition.Signal()` is required, etc. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reache",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:9027,Integrability,depend,depending,9027,"tex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TCondition`** creates and uses its own internal; mutex:. ``` {.cpp}; TCondition MyCondition(0);; ```. You can now use the following methods of synchronization:. - `TCondition::Wait()` waits until any thread sends a signal of the; same condition instance: `MyCondition.Wait()` reacts on; `MyCondition.Signal()` or `MyCondition.Broadcast()`.; `MyOtherCondition.Signal()` has no effect. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Signal()` only one; thread will react; to activate a further thread another; `MyCondition.Signal()` is required, etc. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not threa",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:9794,Integrability,synchroniz,synchronized,9794,"me; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the mai",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10074,Integrability,message,messages,10074," had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous actio",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10126,Integrability,depend,depends,10126,"il; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calli",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:18219,Integrability,message,message,18219,"ill able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynchronous timers. The; ***`kSigWindowChanged`*** signal handles the resizing of the terminal; window. The other signals have no other behavior then that to call any; registered **`TSignalHandler`*****`::Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:18743,Integrability,message,message,18743,"ode when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynchronous timers. The; ***`kSigWindowChanged`*** signal handles the resizing of the terminal; window. The other signals have no other behavior then that to call any; registered **`TSignalHandler`*****`::Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes be",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:21818,Integrability,synchroniz,synchronization,21818,"case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer loc",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22324,Integrability,synchroniz,synchronization,22324," there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Mul",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:350,Modifiability,adapt,adapted,350,"# Threads. A thread is an independent flow of control that operates within the same; address space as other independent flows of controls within a process.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread re",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:1562,Modifiability,variab,variable,1562,"processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; threa",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3128,Modifiability,config,configure,3128,"having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implem",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3217,Modifiability,config,configures,3217,"es one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform depen",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3966,Modifiability,variab,variable,3966,"to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). A",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3993,Modifiability,variab,variable,3993,"as operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:16611,Modifiability,inherit,inherits,16611,"ns and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object insta",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:19570,Modifiability,adapt,adapted,19570,":Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`*",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:19957,Modifiability,variab,variables,19957,"signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Norm",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:20986,Modifiability,variab,variables,20986,"ed process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:21509,Modifiability,variab,variables,21509,"rs.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the;",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23230,Modifiability,variab,variable,23230,"g the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify st",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:509,Performance,multi-thread,multi-threaded,509,"# Threads. A thread is an independent flow of control that operates within the same; address space as other independent flows of controls within a process.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread re",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:633,Performance,multi-thread,multi-threaded,633,"# Threads. A thread is an independent flow of control that operates within the same; address space as other independent flows of controls within a process.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread re",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:1061,Performance,queue,queues,1061,"t operates within the same; address space as other independent flows of controls within a process.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled b",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:1508,Performance,multi-thread,multi-threaded,1508,"processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; threa",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:2603,Performance,multi-thread,multi-threaded,2603,"routine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The pla",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:4635,Performance,load,loads,4635,"**`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can follow the example below:. <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>. 3. Loading. Start an interactive ROOT session. Load the shared library:. ``` {.cpp}; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");; ```. 4. Creating. Create a thread instance (see also example `RunMhs3.C `or` RunPi.C`); with:. ``` {.cpp}; root[] TThread *th = new TThread(UserFun,UserArgs);; ```. When called from the interpreter, this gives the name ""`UserFun`"" to the; thread. This name can be used to retrieve the thread later. However,; when called from compiled code, this method does not give any name to; the thread. So give a name to the thread in compile",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:7070,Performance,perform,performed,7070,"IX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create a; **`TCondition`** object, a **`TMutex`** instance is required for the; Wait and `TimedWait` locking methods. One can pass the address of an; external mutex to the **`TCondition`** constructor:. ``` {.cpp}; TM",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:7117,Performance,perform,perform,7117," two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create a; **`TCondition`** object, a **`TMutex`** instance is required for the; Wait and `TimedWait` locking methods. One can pass the address of an; external mutex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TConditi",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:16829,Performance,load,loaded,16829," Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default s",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:19678,Performance,load,loaded,19678,"s the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:20304,Performance,concurren,concurrency,20304,"t`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronizatio",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:20524,Performance,concurren,concurrency,20524,". ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:20833,Performance,concurren,concurrency,20833,"a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24556,Performance,perform,perform,24556,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6415,Safety,safe,safe,6415,"rpreter, this gives the name ""`UserFun`"" to the; thread. This name can be used to retrieve the thread later. However,; when called from compiled code, this method does not give any name to; the thread. So give a name to the thread in compiled use:. ``` {.cpp}; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; ```. You can pass arguments to the thread function using the; `UserArgs`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:6814,Safety,avoid,avoid,6814,"s`-pointer. When you want to start a method of a class as a; thread, you have to give the pointer to the class instance as; `UserArgs`. 5. Running. ``` {.cpp}; root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; ```. With the `mhs3` example, you should be able to see a canvas with two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:9285,Safety,timeout,timeouts,9285," the following methods of synchronization:. - `TCondition::Wait()` waits until any thread sends a signal of the; same condition instance: `MyCondition.Wait()` reacts on; `MyCondition.Signal()` or `MyCondition.Broadcast()`.; `MyOtherCondition.Signal()` has no effect. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Signal()` only one; thread will react; to activate a further thread another; `MyCondition.Signal()` is required, etc. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is ca",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:9710,Safety,timeout,timeout,9710,"ther; `MyCondition.Signal()` is required, etc. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are c",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10005,Safety,safe,safe,10005,"ctivated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Cance",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10395,Safety,avoid,avoid,10395,"Time; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:11332,Safety,safe,safe,11332," threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by invoking; **`TThread`**`::CancelPoint()`. Then, if a thread is canceled, the; cancellation is deferred up to the call of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a th",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:11397,Safety,risk,risk,11397," threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by invoking; **`TThread`**`::CancelPoint()`. Then, if a thread is canceled, the; cancellation is deferred up to the call of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a th",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:11648,Safety,safe,safely,11648,"object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by invoking; **`TThread`**`::CancelPoint()`. Then, if a thread is canceled, the; cancellation is deferred up to the call of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:11938,Safety,safe,safe,11938," and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calling `TThread::SetCancelOn()`. There are two cancellation modes:; deferred and asynchronous. #### Deferred. Set by `TThread::SetCancelDeferred()` (default): When the user knows; safe places in their code where a thread can be canceled without risk for; the rest of the system, they can define these points by invoking; **`TThread`**`::CancelPoint()`. Then, if a thread is canceled, the; cancellation is deferred up to the call of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only if thread is not; running. Often during the canceling, some clean up actions must be; taken. To define clean up functions use:. ``` {.cpp}; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThr",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:12571,Safety,safe,safe,12571,"of; **`TThread`**`::CancelPoint()` and then the thread is canceled safely.; There are some default cancel points for `pthreads` implementation, e.g.; any call of the `TCondition::Wait()`, **`TCondition`**`::TimedWait()`,; `TThread::Join()`. #### Asynchronous. Set by `TThread::SetCancelAsynchronous()`: If the user is sure that; their application is cancel safe, they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only if thread is not; running. Often during the canceling, some clean up actions must be; taken. To define clean up functions use:. ``` {.cpp}; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; ```. Note: `CleanUpPush` and `CleanUpPop` should be used as corresponding; pairs like brackets; unlike `pthreads` cleanup stack (which is *not*; implemented here), **`TThread`** does not force this usage. #### Finishing thread. When a thread returns from a user function the thread is finished. It; also can be finished by `TThread::Exit()`. Then, in case of; `thread`-detached mode, the thread vanishes completely. By default, on; finishing **`TThread`** executes the most recent cleanup ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17027,Safety,safe,safe,17027,"blems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingE",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17520,Safety,safe,safe,17520," simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynchronous timers. The; ***`kSigWindowChanged`*** signal handles the resizing of the terminal; window. The other sig",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23430,Safety,safe,safety,23430,"alue. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24626,Safety,safe,safe,24626,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:1846,Security,access,accessed,1846,"cess group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread receives an own process id, so that it; can be scheduled by the kernel scheduler). All threads share the same; address space. This means that two pointers having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a plat",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:7136,Security,access,access,7136," two; pads on it. Both pads keep histograms updated and filled by three; different threads. With the `CalcPi` example, you should be able to see; two threads calculating Pi with the given number of intervals as; precision. ### TThread in More Details. Cling is not thread safe yet, and it will block the execution of the; threads until it has finished executing. #### Asynchronous Actions. Different threads can work simultaneously with the same object. Some; actions can be dangerous. For example, when two threads create a; histogram object, ROOT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create a; **`TCondition`** object, a **`TMutex`** instance is required for the; Wait and `TimedWait` locking methods. One can pass the address of an; external mutex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TConditi",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:7684,Security,access,accessible,7684,"OT allocates memory and puts them to the same; collection. If it happens at the same time, the results are; undetermined. To avoid this problem, the user has to synchronize these; actions with:. ``` {.cpp}; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; ```. The code between `Lock()` and `UnLock()` will be performed; uninterrupted. No other threads can perform actions or access; objects/collections while it is being executed. The methods; `TThread::Lock() `and **`TThread::UnLock()`** internally use a global; `TMutex` instance for locking. The user may also define their own **`TMutex`** `MyMutex` instance and may; locally protect their asynchronous actions by calling `MyMutex.Lock()` and; `MyMutex.UnLock().`. #### Synchronous Actions: TCondition. To synchronize the actions of different threads you can use the; **`TCondition`** class, which provides a signaling mechanism. The; **`TCondition`** instance must be accessible by all threads that need to; use it, i.e. it should be a global object (or a member of the class; which owns the threaded methods, see below). To create a; **`TCondition`** object, a **`TMutex`** instance is required for the; Wait and `TimedWait` locking methods. One can pass the address of an; external mutex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TCondition`** creates and uses its own internal; mutex:. ``` {.cpp}; TCondition MyCondition(0);; ```. You can now use the following methods of synchronization:. - `TCondition::Wait()` waits until any thread sends a signal of the; same condition instance: `MyCondition.Wait()` reacts on; `MyCondition.Signal()` or `MyCondition.Broadcast()`.; `MyOtherCondition.Signal()` has no effect. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Signal()` only one; thread will react; to activate a further threa",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:14991,Security,access,access,14991,"Thread(""memberfunction"",; (void(*)(void *))&Thread0,(void*) this);; mTh->Run();; return 0;; }; return 1;; }; ```. Here `mTh` is a `TThread*` pointer which is member of `Myclass `and; should be initialized to 0 in the constructor. The **`TThread`**; constructor is called as when we used a plain C function above, except; for the following two differences. First, the member function Thread0 requires an explicit cast to; `(void(*) (void *)`). This may cause an annoying but harmless compiler; warning:. ``` {.cpp}; Myclass.cxx:98: warning:; converting from ""void (Myclass::*)(void *)""to ""void *"" ); ```. Strictly speaking, `Thread0` must be a static member function to be; called from a thread. Some compilers, for example `gcc` version 2.95.2,; may not allow the `(void(*) (void*))s` cast and just stop if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** construc",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:15550,Security,access,access,15550,"yclass.cxx:98: warning:; converting from ""void (Myclass::*)(void *)""to ""void *"" ); ```. Strictly speaking, `Thread0` must be a static member function to be; called from a thread. Some compilers, for example `gcc` version 2.95.2,; may not allow the `(void(*) (void*))s` cast and just stop if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:15773,Security,access,access,15773,"p if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libT",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:21604,Security,access,accesses,21604,"ll behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continue",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22718,Security,access,access,22718,"l section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other t",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22865,Security,access,access,22865,"tes locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this;",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22913,Security,access,access,22913,"tes locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this;",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23662,Security,access,access,23662,"ted. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23979,Security,access,access,23979," holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24860,Security,access,access,24860,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24956,Security,access,access,24956,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:8928,Testability,test,tests,8928,"tex to the **`TCondition`** constructor:. ``` {.cpp}; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; ```. If zero is passed, **`TCondition`** creates and uses its own internal; mutex:. ``` {.cpp}; TCondition MyCondition(0);; ```. You can now use the following methods of synchronization:. - `TCondition::Wait()` waits until any thread sends a signal of the; same condition instance: `MyCondition.Wait()` reacts on; `MyCondition.Signal()` or `MyCondition.Broadcast()`.; `MyOtherCondition.Signal()` has no effect. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Signal()` only one; thread will react; to activate a further thread another; `MyCondition.Signal()` is required, etc. - If several threads wait for the signal from the same; **`TCondition`** `MyCondition`, at `MyCondition.Broadcast()` all; threads waiting for `MyCondition` are activated at once. In some tests of `MyCondition` using an internal mutex, `Broadcast()`; activated only one thread (probably depending whether `MyCondition` had; been signaled before). - `MyCondition.TimedWait(secs,nanosecs)` waits for `MyCondition` until; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not threa",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:12982,Usability,resume,resumes,12982," they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only if thread is not; running. Often during the canceling, some clean up actions must be; taken. To define clean up functions use:. ``` {.cpp}; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; ```. Note: `CleanUpPush` and `CleanUpPop` should be used as corresponding; pairs like brackets; unlike `pthreads` cleanup stack (which is *not*; implemented here), **`TThread`** does not force this usage. #### Finishing thread. When a thread returns from a user function the thread is finished. It; also can be finished by `TThread::Exit()`. Then, in case of; `thread`-detached mode, the thread vanishes completely. By default, on; finishing **`TThread`** executes the most recent cleanup function; (`CleanUpPop(1)` is called automatically once). ## Advanced TThread: Launching a Method in a Thread. Consider a class `Myclass` with a member function that shall be launched; as a thread. ``` {.cpp}; void* Myclass::Thread0((void* arg); ```. To start Thread0 as a **`TThread`**, class `Myclass` may provide a; method:. ``` {.cpp}; Int_t Myclass::Thread",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:15622,Usability,simpl,simple,15622,"ed from a thread. Some compilers, for example `gcc` version 2.95.2,; may not allow the `(void(*) (void*))s` cast and just stop if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing th",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:16498,Usability,simpl,simple,16498,"st; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17134,Usability,simpl,simple,17134," be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstru",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17422,Usability,usab,usable,17422," 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynch",MatchSource.DOCS,documentation/users-guide/Threads.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:10404,Availability,echo,echoed,10404,"duce a record: the; histogram must be produced when clicking the DRAW button on the; bottom-left. The records will appear on the list of records in the; bottom right of the tree viewer. Selecting a record will draw the; corresponding histogram. Records can be played using the arrow buttons; near to the record button. When saving the session, the list of records; is being saved as well. Records have a default name corresponding to the Z: Y: X selection, but; this can be changed using `SetRecordName()` method from the right panel; context menu. You can create a new expression by right clicking on any; of the` E()` boxes. The expression can be dragged and dropped into any; of the boxes (`X,` `Y,` `Z,` `Cut`, or `Scan`). To scan one or more; variables, drop them into the Scan box, then double click on the box.; You can also redirect the result of the scan to a file by checking the; Scan box on top. ![](pictures/030000F5.png). When the ""`Rec`"" box is checked, the `Draw` and `Scan` commands are; recorded in the history file and echoed on the command line. The; ""Histogram"" text box contains the name of the resulting histogram. By; default it is `htemp`. You can type any name, if the histogram does not; exist it will create one. The Option text box contains the list of Draw; options. See ""Draw Options"". You can select the options with the Options; menu. The Command box lets you enter any command that you could also; enter on the command line. The vertical slider on the far left side can; be used to select the minimum and maximum of an event range. The actual; start and end index are shown in on the bottom in the status window. There is an extensive help utility accessible with the Help menu. The; `IList` and `OList` are to `specify` an input list of entry indices and; a name for the output list respectively. Both need to be of type; **`TList`** and contain integers of entry indices. These lists are; described below in the paragraph ""**Error! Reference source not; found.**"".",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:13551,Availability,recover,recover,13551,"placing the data into the folder structure and; calling `TTree::Fill`. ### Tree and TRef Objects. ``` {.cpp}; MyTree->BranchRef();; ```. This call requests the construction of an optional branch supporting; table of references (**`TRefTable`**). This branch (**`TBranchRef`**); will keep all the information needed to find the branches containing; referenced objects at each `Tree::Fill`, the branch numbers containing; the referenced objects are saved in the table of references. When the; Tree header is saved (via `TTree::Write` for example), the branch is; saved, keeping the information with the pointers to the branches having; referenced objects. Enabling this optional table, allow; `TTree::Draw` to automatically load the branches needed to; dereference a **`TRef`** (or **`TRefArray`**) object. ### Autosave. `Autosave` gives the option to save all branch buffers every `n` byte.; We recommend using `Autosave` for large acquisitions. If the acquisition; fails to complete, you can recover the file and all the contents since; the last `Autosave`. To set the number of bytes between `Autosave` you; can use the `TTree::SetAutosave()` method. You can also call; **`TTree::Autosave` in the acquisition loop every `n `entry.**. ### Trees with Circular Buffers. When a **`TTree`** is memory resident, you set it up so that it retains; retain only the last few entries. For example, this can be very useful; for monitoring purpose. ``` {.cpp}; void TTree::SetCircular(Long64_t maxEntries);; ```. where `maxEntries` is the maximum number of entries to be kept in the; buffers. When the number of entries exceeds this value, the first; entries in the **`Tree`** are deleted and the buffers used again. An; example of a script using a circular buffer is shown below:. ``` {.cpp}; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:17985,Availability,failure,failure,17985,"n be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` may be expressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:41364,Availability,avail,available,41364,"`; example). If ""`->`"" is not specified, the pointer member is read via; `buf >> pointer`. In this case the pointer may be null. Note that the; option with ""`->`"" is faster to read or write and it also consumes less; space in the file. Option 2 - the option `AutoDelete` is set:. ``` {.cpp}; TBranch *branch = T.GetBranch(""event"");; branch->SetAddress(&event);; branch->SetAutoDelete(kTRUE);; for (Int_t i=0; i<nentries; i++) {; T.GetEntry(i); // the object event has been filled at this point; }; ```. At any iteration, the `GetEntry` deletes the object `event` and a new; instance of `Event` is created and filled. Option 3 - same as option 1, but you delete the event yourself:. ``` {.cpp}; for (Int_t i=0; i<nentries; i++) {; delete event;; event = 0; //EXTREMELY IMPORTANT; T.GetEntry(i);; // the objrect event has been filled at this point; }; ```. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like `TTree::Draw` (internally; calling `TTree::GetEntry`) will be functional even when the classes in; the file are not available. Reading selected branches is quicker than; reading an entire entry. If you are interested in only one branch, you; can use the `TBranch::GetEntry` method and only that branch is read.; Here is the script `tree1r`:. ``` {.cpp}; void tree1r(){; // read the Tree generated by tree1w and fill two histograms; // note that we use ""new"" to create the TFile and TTree objects,; // to keep them alive after leaving this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&ev);; // create two histograms; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-3,3);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",30,-3,3,30,-3,3);; //read all entries and fill the histograms; Int",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:41762,Availability,alive,alive,41762,"entries; i++) {; T.GetEntry(i); // the object event has been filled at this point; }; ```. At any iteration, the `GetEntry` deletes the object `event` and a new; instance of `Event` is created and filled. Option 3 - same as option 1, but you delete the event yourself:. ``` {.cpp}; for (Int_t i=0; i<nentries; i++) {; delete event;; event = 0; //EXTREMELY IMPORTANT; T.GetEntry(i);; // the objrect event has been filled at this point; }; ```. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like `TTree::Draw` (internally; calling `TTree::GetEntry`) will be functional even when the classes in; the file are not available. Reading selected branches is quicker than; reading an entire entry. If you are interested in only one branch, you; can use the `TBranch::GetEntry` method and only that branch is read.; Here is the script `tree1r`:. ``` {.cpp}; void tree1r(){; // read the Tree generated by tree1w and fill two histograms; // note that we use ""new"" to create the TFile and TTree objects,; // to keep them alive after leaving this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&ev);; // create two histograms; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-3,3);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",30,-3,3,30,-3,3);; //read all entries and fill the histograms; Int_t nentries = (Int_t)t1->GetEntries();; for (Int_t i=0; i<nentries; i++) {; t1->GetEntry(i);; hpx->Fill(px);; hpxpy->Fill(px,py);; }; // We do not close the file. We want to keep the generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram i",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:49814,Availability,alive,alive,49814,"`` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in the; vector. Here we use the **`TTree::Draw`** method. It automatically creates; a histogram and plots the 3 expressions (see Trees in Analysis). ![](pictures/030000FF.png). ``` {.cpp}; void tree2r() {. // read the Tree generated by tree2w and fill one histogram; // we are only interested by the destep branch. // note that we use ""new"" to create the TFile and TTree objects because we; // want to keep these objects alive when we leave this function; TFile *f = new TFile(""tree2.root"");; TTree *t2 = (TTree*)f->Get(""t2"");; static Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);. //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; //read only the destep branch for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d v",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:64560,Availability,alive,alive,64560,"; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; ```. ### Reading the Tree. First, we check if the shared library with the class definitions is; loaded. If not we load it. Then we read two branches, one for the number; of tracks and one for the entire event. We check the number of tracks; first, and if it meets our condition, we read the entire event. We show; the fist entry that meets the condition. ``` {.cpp}; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Clear();; }. if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ```. Now, let's see how the tree looks like in the tree viewer. ![The tree view",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67625,Availability,avail,available,67625,"name,; const char *branchDescriptor); ```. Creates or simply read branches from the file named whose name is passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will us",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:73887,Availability,avail,available,73887,"enation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in Batch Mode. The `TTree::Draw` method creates a histogram called `htemp` and puts it; on the active pad. In a batch program, the histogram `htemp` created by; default, is reachable from the current pad. ``` {.cpp}; // draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; ```. If you pipe the result of the `TTree::Draw` into a histogram, the; histogram is also available in the current directory. You can do:. ``` {.cpp}; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; ```. ### Using Draw Options in TTree::Draw. The next parameter is the draw option for the histogram:. ``` {.cpp}; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");; ```. ![Using draw options in trees](pictures/03000104.png). The draw options are the same as for `TH1::Draw`. See ""Draw Options""; where they are listed. In addition to the draw options defined in; **`TH1`**, there are three more. The `'prof'` and `'profs'` draw a; profile histogram (**`TProfile`**) rather than a regular 2D histogram; (**`TH2D`**) from an expression with two variables. If the expression; has three variables, a **`TProfile2D`** is generated. The '`profs`' generates a **`TPr",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:74876,Availability,error,error,74876,", the; histogram is also available in the current directory. You can do:. ``` {.cpp}; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; ```. ### Using Draw Options in TTree::Draw. The next parameter is the draw option for the histogram:. ``` {.cpp}; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");; ```. ![Using draw options in trees](pictures/03000104.png). The draw options are the same as for `TH1::Draw`. See ""Draw Options""; where they are listed. In addition to the draw options defined in; **`TH1`**, there are three more. The `'prof'` and `'profs'` draw a; profile histogram (**`TProfile`**) rather than a regular 2D histogram; (**`TH2D`**) from an expression with two variables. If the expression; has three variables, a **`TProfile2D`** is generated. The '`profs`' generates a **`TProfile`** with error on the spread. The; '`prof`' option generates a **`TProfile`** with error on the mean. The; ""`goff`"" option suppresses generating the graphics. You can combine the; draw options in a list separated by commas. After typing the lines; above, you should now have a canvas that looks this. ### Superimposing Two Histograms. When superimposing two 2-D histograms inside a script with `TTree::Draw`; and using the ""`same`"" option, you will need to update the pad between; `Draw` commands. ``` {.cpp}; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTree *myTree = (TTree*)f.Get(""T"");; // the update is needed for the next ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:74950,Availability,error,error,74950,"o:. ``` {.cpp}; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; ```. ### Using Draw Options in TTree::Draw. The next parameter is the draw option for the histogram:. ``` {.cpp}; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");; ```. ![Using draw options in trees](pictures/03000104.png). The draw options are the same as for `TH1::Draw`. See ""Draw Options""; where they are listed. In addition to the draw options defined in; **`TH1`**, there are three more. The `'prof'` and `'profs'` draw a; profile histogram (**`TProfile`**) rather than a regular 2D histogram; (**`TH2D`**) from an expression with two variables. If the expression; has three variables, a **`TProfile2D`** is generated. The '`profs`' generates a **`TProfile`** with error on the spread. The; '`prof`' option generates a **`TProfile`** with error on the mean. The; ""`goff`"" option suppresses generating the graphics. You can combine the; draw options in a list separated by commas. After typing the lines; above, you should now have a canvas that looks this. ### Superimposing Two Histograms. When superimposing two 2-D histograms inside a script with `TTree::Draw`; and using the ""`same`"" option, you will need to update the pad between; `Draw` commands. ``` {.cpp}; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTree *myTree = (TTree*)f.Get(""T"");; // the update is needed for the next draw command to work properly; gPad->Update();; myTree->Draw(""Cost:Ag",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:85800,Availability,avail,available,85800," the same as case 15. The first dimension minimum is 4 (from; `fMatrix`), and the second dimension minimum is 3 (from `fVertex`).; Twelve values are selected from each entry. 22. **`tree->Draw(""fClosestDistance"")`**. This event data member `fClosestDistance` is a variable length array:. `Float_t *fClosestDistance; //[fNvertex]`. This command selects all elements, but the number per entry depends on; the number of vertices of that entry. 23. **`tree->Draw(""fClosestDistance[fNvertex/2]"")`**. With this command the element at `fNvertex/2` of the; `fClosestDistance `array is selected. Only one per entry is selected. 24. **`tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)"")`**. This command shows the use of a mathematical expression. It draws the; square root of the sum of the product. 25. **`tree->Draw(""TMath::BreitWigner(fPx,3,2)"")`**. The formula can contains call to a function that takes numerical; arguments and returns a numerical value. The function needs to be; declared to the dictionary and need to be available from the global; namespace. In particular, global functions and public static member; functions can be called. 26. **`tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "")`**. You can compare strings, using the symbols == and !=, in the first two; parameters of the `Draw` command (`TTreeFormula`). In this case,; the event number for ‘type1' events is plotted. 27. **`tree->Draw(""fEvtHdr.fEvtNum"",""strstr(fType,""1"") "")`**. To compare strings, you can also use `strstr`. In this case, events; having a '1' in `fType` are selected. 28. **`tree->Draw(""fTracks.fPoints"")`**. If `fPoints` is a data member of the `Track` class declared as:. `Int_t fNpoint;`. `Int_t *fPoints; [fNpoint]`. The size of the array `fPoints` varies with each track of each event.; This command draws all the value in the `fPoints` arrays. 29. **`tree->Draw(""fTracks.fPoints - fTracks.fPoints[][fAvgPoints]"");`**. `When fAvgPoints` is a data member of the `Event` class, this example; selects:. `fTracks[0].",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:91407,Availability,avail,available,91407," **`tree->Draw(""fPx[600]"")`**. 37. **`tree->Draw(""fPx[600]"",""fNtrack > 600"")`**. When using a specific element for a variable length array the entries; with fewer elements are ignored. Thus these two commands are equivalent. 38. **`tree->Draw(""Nation"")`**. `Nation` is a `char*` branch. When drawing a `char*` it will plot an; alphanumeric histogram, of the different value of the string `Nation`.; The axis will have the `Nation` values. See ""Histograms"". 39. **`tree->Draw(""MyChar +0"")`**. If you want to plot a char\* variable as a byte rather than a string,; you can use the syntax above. 40. **`tree->Draw(""fTracks.fTriggerBits"")`**. `fTriggerBits` is a data member of **`TTrack`** of type **`TBits`**.; Objects of class **`TBits`** can be drawn directly. This command will; create a 1D histogram from 0 to `nbits` which is filled for each; non-null bit-number. 41. **`tree->Draw(""fMatrix-Alt$(fClosestDistance,0)"")`**. `Alt$(primary,alternate)` returns the value of ""`primary`"" if it is; available for the current iteration; otherwise return the value of; ""`alternate`"". Assuming that `fClosestDistance` is a smaller array than; `fMatrix`. This example will draw `fMatrix[i]+fClosestDistance[i]` for; `i` less than the size of `fClosestDistance`, and will draw; `fMatrix[i]+0` for the other value of `i`. 42. **`tree->Draw(""fClosestDistance:Iteration$"")`**. This example draws a 2D plot with, for all entries,; `fClosestDistance[i]:i` for each value of `i` between 0 and the size of; `fClosestDistance`. `Iterations$` is one of four special variables; giving some indications of the state of the loops implied by the; formula:. `Entry$ :` return the current entry number (`TTree::GetReadEntry()`). `Entries$ :` return the total number of entries (`TTree::GetEntries()`). `Length$ :` return the total number of element of this formula for; this entry. `Iteration$:` return the current iteration over this formula for this; entry (i.e. varies from 0 to `Length$`). 43. **`tree->Draw(""fLastTrack.G",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94052,Availability,avail,available,94052,"fer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsString` (`AsDouble` has priority). For such a class (for example; **`TTimeStamp`**), the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider pl",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:98468,Availability,avail,available,98468,"nd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:122578,Availability,avail,available,122578," generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`"", and just to verify that we are working; with the correct one, we print the tree, which",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:127578,Availability,error,error,127578,"s one branch and one leaf per data member. The methods; of `MyClass` are:. - `MyClass(TTree *tree=0) -` this constructor has an optional tree; for a parameter. If you pass a tree, `MyClass` will use it rather; than the tree from which it was created. - `void Init(TTree *tree) -` it is called by the constructor to; initialize the tree for reading. It associates each branch with the; corresponding leaf data member. - `~MyClass() - `the destructor, nothing special. - `Int_t GetEntry(Int_t entry) -` it loads the class with the entry; specified. Once you have executed `GetEntry`, the leaf data members; in `MyClass` are set to the values of the entry. For example,; `GetEntry(12)` loads the 13th event into the event data member of; `MyClass` (note that the first entry is 0). `GetEntry` returns the; number of bytes read from the file. In case the same entry is read; twice, ROOT does not have to do any I/O. In this case `GetEntry`; returns 1. It does not return 0, because many people assume a return; of 0 means an error has occurred while reading. - `Int_t LoadTree(Int_t entry)` and `void Notify()` - these two; methods are related to chains. `LoadTree` will load the tree; containing the specified entry from a chain of trees. Notify is; called by `LoadTree` to adjust the branch addresses. - `void Loop()` - it is the skeleton method that loops through each; entry of the tree. This is interesting to us, because we will need; to customize it for our analysis. ### MyClass.C. `MyClass::Loop` consists of a for-loop calling `GetEntry` for each; entry. In the template, the numbers of bytes are added up, but it does; nothing else. If we were to execute it now, there would be no output. ``` {.cpp}; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fCh",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:136323,Availability,down,down,136323," trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; data member of the Event class. The list of tracks (a; **`TClonesArray`**) has the data members of the Track class also; split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. +------------+--------+---------------+---------------+----------------+----------------+; | Event | File | Total Time to | Effective | Total Time to | Total Time to ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:7669,Deployability,toggle,toggle,7669,"File f(""cernstaff.root""); root[] T->StartViewer(); ```. If you want to start a tree viewer without a tree, you need to load the; tree player library first:. ``` {.cpp}; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); ```. The figure above shows how the tree viewer looks like for the example file; `cernstaff.root`. The left panel contains the list of trees and their; branches; in this case there is only one tree. You can add more trees; with the File-Open command to open the file containing the new tree,; then use the context menu on the right panel, select `SetTreeName` and; enter the name of the tree to add. On the right are the leaves or; variables in the tree. You can double click on any leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refresh the tree. The three check buttons toggle the following:. `Hist`- the histogram drawing mode;. `Scan`- enables redirecting of `TTree::Scan `command in an ASCII file;. `Rec` - enables recording of the last issued command. - ![](pictures/020000F1.jpg) To draw more than one dimension you can drag; and drop any leaf to the `X,Y,Z` boxes"". Then push the Draw button,; witch is marked with the purple icon on the bottom left. - ![](pictures/030000F2.png) All commands can be interrupted at any time; by pressing this button. - ![](pictures/030000F3.png) The method **`TTree::Refresh`** is called by; pressing the refresh button in `TTreeViewer`. It redraws the current; exposed expression. Calling `TTree::Refresh` is useful when a tree is; produced by a writer process and concurrently analyzed by one or more; readers. - ![](pictures/030000F4.png) To add a cut/weight to the histogram, enter an; expression in the ""cut box"". The cut box is the one with the scissor; icon. Below them there are two text widgets for specifying the input a",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:17641,Deployability,update,update,17641,":Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` may be expressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to sepa",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26389,Deployability,configurat,configuration,26389,"e split-level is 1, an object data member is assigned a branch.; If the split-level is 2, the data member objects will be split also, and; a split level of 3 its data members objects, will be split. As the; split-level increases so does the splitting depth. The ROOT default for; the split-level is 99. This means the object will be split to the; maximum. #### Memory Considerations when Splitting a Branch. Splitting a branch can quickly generate many branches. Each branch has; its own buffer in memory. In case of many branches (say more than 100),; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:51556,Deployability,update,update,51556," (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::A",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60300,Deployability,release,releases,60300,"m. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass squar",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:68301,Deployability,configurat,configuration,68301," syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and re",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:75324,Deployability,update,update,75324,"e histogram:. ``` {.cpp}; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");; ```. ![Using draw options in trees](pictures/03000104.png). The draw options are the same as for `TH1::Draw`. See ""Draw Options""; where they are listed. In addition to the draw options defined in; **`TH1`**, there are three more. The `'prof'` and `'profs'` draw a; profile histogram (**`TProfile`**) rather than a regular 2D histogram; (**`TH2D`**) from an expression with two variables. If the expression; has three variables, a **`TProfile2D`** is generated. The '`profs`' generates a **`TProfile`** with error on the spread. The; '`prof`' option generates a **`TProfile`** with error on the mean. The; ""`goff`"" option suppresses generating the graphics. You can combine the; draw options in a list separated by commas. After typing the lines; above, you should now have a canvas that looks this. ### Superimposing Two Histograms. When superimposing two 2-D histograms inside a script with `TTree::Draw`; and using the ""`same`"" option, you will need to update the pad between; `Draw` commands. ``` {.cpp}; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTree *myTree = (TTree*)f.Get(""T"");; // the update is needed for the next draw command to work properly; gPad->Update();; myTree->Draw(""Cost:Age"", """",""same"");; }; ```. In this example, `h2->Draw` is only adding the object h2 to the pad's; list of primitives. It does not paint the object on the screen. However,; `TTree::Draw` when called with option ""`same`"" gets the current pad; coordinates to build an intermediate histogram with the right limits.; Since nothing has been painted in the pad",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:75833,Deployability,update,update,75833,"the spread. The; '`prof`' option generates a **`TProfile`** with error on the mean. The; ""`goff`"" option suppresses generating the graphics. You can combine the; draw options in a list separated by commas. After typing the lines; above, you should now have a canvas that looks this. ### Superimposing Two Histograms. When superimposing two 2-D histograms inside a script with `TTree::Draw`; and using the ""`same`"" option, you will need to update the pad between; `Draw` commands. ``` {.cpp}; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTree *myTree = (TTree*)f.Get(""T"");; // the update is needed for the next draw command to work properly; gPad->Update();; myTree->Draw(""Cost:Age"", """",""same"");; }; ```. In this example, `h2->Draw` is only adding the object h2 to the pad's; list of primitives. It does not paint the object on the screen. However,; `TTree::Draw` when called with option ""`same`"" gets the current pad; coordinates to build an intermediate histogram with the right limits.; Since nothing has been painted in the pad yet, the pad limits have not; been computed. Calling `pad->Update()` forces the painting of the pad; and allows `TTree::Draw` to compute the right limits for the; intermediate histogram. ### Setting the Range in TTree::Draw. There are two more optional parameters to the `TTree::Draw` method: one; is the number of entries and the second one is the entry to start with.; For example, this command draws 1000 entries starting with entry 100:. ``` {.cpp}; myTree->Draw(""Cost:Age"", """","""",1000,100);; ```. ### TTree::Draw Examples. The examples below use the `Event.root` file generated by the; `$ROOTSYS/t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:131223,Deployability,configurat,configuration,131223,"get entry 0, and print the number of tracks (594).; Then we get entry 1 and print the number of tracks (597). ``` {.cpp}; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; ```. Now we can call the `Loop` method, which will build and display the two; histograms. ``` {.cpp}; root[] m.Loop(); ```. You should now see a canvas that looks like this. ![](pictures/03000106.png). To conclude the discussion on `MakeClass` let us lists the steps that; got us here. - Call `TTree::MakeClass`, which automatically creates a class to loop; over the tree. - Modify the `MyClass::Loop()` method in `MyClass.C` to fit your task. - Load and instantiate `MyClass`, and run `MyClass::Loop()`. ## Using TTree::MakeSelector; \index{tree!MakeSelector}. With a **`TTree`** we can make a selector and use it to process a; limited set of entries. This is especially important in a parallel; processing configuration where the analysis is distributed over several; processors and we can specify which entries to send to each processor.; The `TTree::Process` method is used to specify the selector and the; entries. Before we can use **`TTree::Process`** we need to make a; selector. We can call the `TTree::MakeSelector` method. It creates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this functi",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:132893,Deployability,upgrade,upgrades,132893,"reate your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this function returns `kFALSE`. It; combines the methods **`TSelector::ProcessCut()` and; `TSelector`**`::ProcessFill()` in one, avoiding the necessity to; maintain the state in the class to communicate between these two; functions. It reduces the information that needs to be shared; between them and promotes a more granular data access by reading; branches as they are needed. - `TSelector::Terminate() -` it is called at the end of a loop on a; **`TTree`**. This is a convenient place to draw and fit your; histograms. - `TSelector::Version()` `-` this function provides backward; compatibility for old versions and support for the future upgrades. - The **`TSelector`**, unlike the resulting class from `MakeClass`,; separates the processing into a `ProcessCut()` and `ProcessFill()`,; so we can limit reading of branches to the ones we need. - When a selector is used with a **`TChain`** in methods `Process()`,; `ProcessFill()`, `ProcessCut()`, you must use the pointer to the; current **`TTree`** to call the method `GetEntry(entry)`. The; parameter `entry` is always the local entry number in the current; tree. Assuming that `fChain` is the pointer to the **`TChain`**; being processed, use. ``` {.cpp}; fChain->GetTree()->GetEntry(entry);; ```. To create a selector call:. ``` {.cpp}; root[] T->MakeSelector(""MySelector"");; ```. Where `T` is the **`TTree`** and `MySelector` is the name of created; class and the name of the `.h` and `.C` files. The resulting; **`TSelector`** is the argument to **`TTree::Process`**. The argument can; be the file name or a pointer to the sel",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:136424,Deployability,configurat,configurations,136424,"ray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; data member of the Event class. The list of tracks (a; **`TClonesArray`**) has the data members of the Track class also; split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. +------------+--------+---------------+---------------+----------------+----------------+; | Event | File | Total Time to | Effective | Total Time to | Total Time to |; | Parameters | Size | Write | Time to Write | Read All | Read Sample |; | | | (MB/sec) | (MB/sec) | (",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:316,Energy Efficiency,reduce,reduce,316,"# Trees. ## Why Should You Use a Tree?. In the ""Input/Output"" chapter, we saw how objects can be saved in ROOT; files. In case you want to store large quantities of same-class objects,; ROOT has designed the **`TTree`** and **`TNtuple`** classes specifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:1220,Energy Efficiency,reduce,reduces,1220,"ecifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! Th",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:1534,Energy Efficiency,reduce,reduced,1534,"ddition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! This is very time consuming,; and we really do not need to read the entire event, every time. All we; need are two little data members (`Px` and `Py`). On the other hand, if; we use a tree with one branch containing `Px` and another branch; containing `Py`, we can read all values of `Px` and",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:13976,Energy Efficiency,monitor,monitoring,13976,"rs containing; the referenced objects are saved in the table of references. When the; Tree header is saved (via `TTree::Write` for example), the branch is; saved, keeping the information with the pointers to the branches having; referenced objects. Enabling this optional table, allow; `TTree::Draw` to automatically load the branches needed to; dereference a **`TRef`** (or **`TRefArray`**) object. ### Autosave. `Autosave` gives the option to save all branch buffers every `n` byte.; We recommend using `Autosave` for large acquisitions. If the acquisition; fails to complete, you can recover the file and all the contents since; the last `Autosave`. To set the number of bytes between `Autosave` you; can use the `TTree::SetAutosave()` method. You can also call; **`TTree::Autosave` in the acquisition loop every `n `entry.**. ### Trees with Circular Buffers. When a **`TTree`** is memory resident, you set it up so that it retains; retain only the last few entries. For example, this can be very useful; for monitoring purpose. ``` {.cpp}; void TTree::SetCircular(Long64_t maxEntries);; ```. where `maxEntries` is the maximum number of entries to be kept in the; buffers. When the number of entries exceeds this value, the first; entries in the **`Tree`** are deleted and the buffers used again. An; example of a script using a circular buffer is shown below:. ``` {.cpp}; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");; T->Branch(""py"",&py,""py/F"");; T->Branch(""pz"",&pz,""pz/F"");; T->Branch(""random"",&random,""random/D"");; T->Branch(""i"",&i,""i/s"");; T->SetCircular(20000);; for (i = 0; i < 65000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; random = r.Rndm();; T->Fill();; }; T->Print();; }; ```. ### Size of TTree in the File. When writing a **`TTree`** to a file, if the file size reaches the value; stored in the `TTree::",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18385,Energy Efficiency,efficient,efficient,18385,"be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21747,Energy Efficiency,allocate,allocate,21747,"d and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f =",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38885,Energy Efficiency,allocate,allocated,38885,"ram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When reading the Tree, one can choose one of these 3 options:. Option 1:. ``` {.cpp}; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; ```. This is the default and recommended way to create an object of the class; `Event. `It will be pointed by `event`. At the following entries, `event` will be overwritten by the new data.; All internal members that are **`TObject`**\* are automatically deleted.; It is important that these members be in a valid state when `GetEntry`; is called. Pointers must be correct",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:46138,Energy Efficiency,charge,charge,46138,"vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ```. ### Writing the Tree. ``` {.cpp}; void tree2w() {; // write tree2 example; //create a Tree file tree2.root; TFile f(""tree2.root"",""recreate"");. //create the file, the Tree; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; // declare a variable of the C structure type; Gctrak_t gstep;. // add the branches for a subset of gstep; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.0",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:46546,Energy Efficiency,charge,charge,46546,"ile f(""tree2.root"",""recreate"");. //create the file, the Tree; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; // declare a variable of the C structure type; Gctrak_t gstep;. // add the branches for a subset of gstep; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:46586,Energy Efficiency,charge,charge,46586," the Tree; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; // declare a variable of the C structure type; Gctrak_t gstep;. // add the branches for a subset of gstep; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:46764,Energy Efficiency,charge,charge,46764,"; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### A",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:47064,Energy Efficiency,energy,energy,47064,".pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You d",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:47215,Energy Efficiency,charge,charge,47215,"p.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:61465,Energy Efficiency,charge,charge,61465,"ding class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67701,Energy Efficiency,power,powerful,67701,"s passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:96695,Energy Efficiency,reduce,reduce,96695,"n three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and equally spaced. A point in n-dimensional; space is represented as a polyline with vertices on the parallel axes.; The position of the vertex on the i-th axis corresponds to the i-th; coordinate of the point. The three following figures show some very; simple examples:. ![The Parallel Coordinates representation of the six dimensional point `(-5,3,4,2,0,1)`.](pictures/para1.png). ![The line `y = -3x+20` and a circle in Parallel Coordinates.](pictures/para2.png). The Parallel Coordinates technique is good at: spotting irregular; events, seeing the data trend, finding correlations and clusters. Its; main weakness is the cluttering of the output. Because each “point” in; the multidimensional space is represented as a line, the output is very; quickly opaque and therefore it is difficult to see the data clusters.; Most of the work done about Parallel Coordinates is to find techniques; to reduce the output’s cluttering. The Parallel Coordinates plots in; ROOT have been implemented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99332,Energy Efficiency,reduce,reduced,99332,"prove the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to defi",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99554,Energy Efficiency,reduce,reduce,99554," show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with log",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101341,Energy Efficiency,power,powerful,101341," combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined allows to select exactly the two; correlated “random spheres”. ![Output of `nt->Draw(“x:y:z”)` and `nt->Draw(“u:v:w”)` after applying the selection.](pictures/para10.png). Another technique has been implemented in order to show clusters when; the picture is cluttered. A weight is assigned to each event",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:132486,Energy Efficiency,reduce,reduces,132486,"ates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this function returns `kFALSE`. It; combines the methods **`TSelector::ProcessCut()` and; `TSelector`**`::ProcessFill()` in one, avoiding the necessity to; maintain the state in the class to communicate between these two; functions. It reduces the information that needs to be shared; between them and promotes a more granular data access by reading; branches as they are needed. - `TSelector::Terminate() -` it is called at the end of a loop on a; **`TTree`**. This is a convenient place to draw and fit your; histograms. - `TSelector::Version()` `-` this function provides backward; compatibility for old versions and support for the future upgrades. - The **`TSelector`**, unlike the resulting class from `MakeClass`,; separates the processing into a `ProcessCut()` and `ProcessFill()`,; so we can limit reading of branches to the ones we need. - When a selector is used with a **`TChain`** in methods `Process()`,; `ProcessFill()`, `ProcessCut()`, you must use the pointer to the; current **`TTree`** to call the method `GetEntry(entry)`. The; parameter `entry` is always the local entry number in the current; tree. Assuming that `fChain` is the pointer to the **`TChain`**; being processed, use. ``` {.cpp}; fChain->GetTree()->GetEntry(entry);; ```. To create a selector call:. ``` {.cpp}; root[] T->",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:16252,Integrability,depend,depending,16252,"he case where; the tree is in the top level directory. The file should not contain; sub-directories. Before switching to a new file, the tree header is; written to the current file, then the current file is closed. To process; the multiple files created by `ChangeFile()`, one must use a; **`TChain`**. The new file name has a suffix ""`_N`"" where `N` is equal to; `fFileNumber+1`. By default a Root session starts with `fFileNumber=0`.; One can set `fFileNumber` to a different value via; `TTree::SetFileNumber()`. In case a file named ""`_N`"" already exists,; the function will try a file named ""`__N`"", then ""`___N`"", etc. The; maximum tree size can be set via the static function; `TTree::SetMaxTreeSize()`. The default value of `fgMaxTreeSize` is 100; GB. If the current file contains other objects (like **`TH1`** and; **`TTree`**), these objects are automatically moved to the new file. ### User Info Attached to a TTree Object. The function `TTree::GetUserInfo()` allows adding any object defined by; a user to the tree that is not depending on the entry number. For; example:. ``` {.cpp}; tree->GetUserInfo()->Add(myruninfo);; ```. ### Indexing a Tree. Use `TTree::BuildIndex()`, to build an index table using expressions; depending on the value in the leaves. ``` {.cpp}; tree->BuildIndex(majorname, minorname);; ```. The index is built in the following way:. - a pass on all entries is made like in `TTree::Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` m",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:16444,Integrability,depend,depending,16444,". To process; the multiple files created by `ChangeFile()`, one must use a; **`TChain`**. The new file name has a suffix ""`_N`"" where `N` is equal to; `fFileNumber+1`. By default a Root session starts with `fFileNumber=0`.; One can set `fFileNumber` to a different value via; `TTree::SetFileNumber()`. In case a file named ""`_N`"" already exists,; the function will try a file named ""`__N`"", then ""`___N`"", etc. The; maximum tree size can be set via the static function; `TTree::SetMaxTreeSize()`. The default value of `fgMaxTreeSize` is 100; GB. If the current file contains other objects (like **`TH1`** and; **`TTree`**), these objects are automatically moved to the new file. ### User Info Attached to a TTree Object. The function `TTree::GetUserInfo()` allows adding any object defined by; a user to the tree that is not depending on the entry number. For; example:. ``` {.cpp}; tree->GetUserInfo()->Add(myruninfo);; ```. ### Indexing a Tree. Use `TTree::BuildIndex()`, to build an index table using expressions; depending on the value in the leaves. ``` {.cpp}; tree->BuildIndex(majorname, minorname);; ```. The index is built in the following way:. - a pass on all entries is made like in `TTree::Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` may be expressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21912,Integrability,depend,depending,21912,"pe is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ``",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33639,Integrability,wrap,wrapper,33639," `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:44245,Integrability,rout,routines,44245,"d a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The calls; to the `Branch` methods are the same as if Geant3 were used. ``` {.cpp}; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];. vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[k",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:44366,Integrability,rout,routine,44366,"ver, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The calls; to the `Branch` methods are the same as if Geant3 were used. ``` {.cpp}; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];. vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48398,Integrability,depend,dependent,48398,"ut[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:85175,Integrability,depend,depends,85175,"[2] - fVertex[3][1]`. 20. **`tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]"")`**. This is similar to case 19. Twelve values are selected (4x3) from each; entry:. `fMatrix[0][2] - fVertex[0][0]`. `fMatrix[0][2] - fVertex[0][1]`. `fMatrix[0][2] - fVertex[0][2]`. `fMatrix[1][2] - fVertex[1][0]`. `fMatrix[1][2] - fVertex[1][1]`. `fMatrix[1][2] - fVertex[1][2]`. `fMatrix[2][2] - fVertex[2][0]`. `fMatrix[2][2] - fVertex[2][1]`. `fMatrix[2][2] - fVertex[2][2]`. `fMatrix[3][2] - fVertex[3][0]`. `fMatrix[3][2] - fVertex[3][1]`. `fMatrix[3][2] - fVertex[3][2]`. 21. **`tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]"")`**. This is the same as case 15. The first dimension minimum is 4 (from; `fMatrix`), and the second dimension minimum is 3 (from `fVertex`).; Twelve values are selected from each entry. 22. **`tree->Draw(""fClosestDistance"")`**. This event data member `fClosestDistance` is a variable length array:. `Float_t *fClosestDistance; //[fNvertex]`. This command selects all elements, but the number per entry depends on; the number of vertices of that entry. 23. **`tree->Draw(""fClosestDistance[fNvertex/2]"")`**. With this command the element at `fNvertex/2` of the; `fClosestDistance `array is selected. Only one per entry is selected. 24. **`tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)"")`**. This command shows the use of a mathematical expression. It draws the; square root of the sum of the product. 25. **`tree->Draw(""TMath::BreitWigner(fPx,3,2)"")`**. The formula can contains call to a function that takes numerical; arguments and returns a numerical value. The function needs to be; declared to the dictionary and need to be available from the global; namespace. In particular, global functions and public static member; functions can be called. 26. **`tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "")`**. You can compare strings, using the symbols == and !=, in the first two; parameters of the `Draw` command (`TTreeFormula`). In this case,; the event number for ‘type1' events is plotted. 27.",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:106134,Integrability,synchroniz,synchronized,106134,"r2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; ```. However, if there is a selection criterium which is an array, then all; the formulas will be synchronized with the selection criterium (see; **`TTree::Draw` for more information).**. The third parameter of `TTree::Scan` can be use to specific the layout; of the table:. - `lenmax=dd` - where 'dd' is the maximum number of elements per array; that should be printed. If 'dd' is 0, all e",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:106806,Integrability,synchroniz,synchronized,106806,"ping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; ```. However, if there is a selection criterium which is an array, then all; the formulas will be synchronized with the selection criterium (see; **`TTree::Draw` for more information).**. The third parameter of `TTree::Scan` can be use to specific the layout; of the table:. - `lenmax=dd` - where 'dd' is the maximum number of elements per array; that should be printed. If 'dd' is 0, all elements are printed (this; is the default). - `colsize=ss` - where 'ss' will be used as the default size for all; the column. If this options is not specified, the default column; size is 9. - `precision=pp` - where 'pp' will be used as the default 'precision'; for the printing format. - `col=xxx` - where '`xxx`' is colon (:) delimited list of printing; format for each column if no format is specified for a column, the; default is used. For example:. ``` {.cpp}; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10"");; ```. will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printf format for the; columns (assuming they are",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:140054,Integrability,depend,depends,140054,"non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTree`**. For example, to; generate a histogram corresponding to the attribute ""`x`"" in tree ""`T`""; by processing sequentially the three files of this chain, we can use the;",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:339,Modifiability,enhance,enhance,339,"# Trees. ## Why Should You Use a Tree?. In the ""Input/Output"" chapter, we saw how objects can be saved in ROOT; files. In case you want to store large quantities of same-class objects,; ROOT has designed the **`TTree`** and **`TNtuple`** classes specifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:4435,Modifiability,variab,variables,4435,",""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",&Hrweek,""Hrweek/I"");; tree->Branch(""Cost"",&Cost,""Cost/I"");; tree->Branch(""Division"",Division,""Division/C"");; tree->Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d %d %d %s %s"",; &Category,&Flag,&Age,&Service,&Children,&Grade,&Step,&Hrweek,&Cost,Division,Nation);; tree->Fill();; }; tree->Print();; tree->Write();. fclose(fp);; delete hfile;; }; ```. The script opens the; ASCII file, creates a ROOT file and a **`TTree`**. Then it creates; branches with the `TTree::Branch` method. The first parameter of the; `Branch` method is the branch name. The second parameter is the address; from which the first leaf is to be read. Once the branches are defined, the script; reads the data from the ASCII file into C variables and; fills the `tree`. The ASCII file is closed, and the ROOT file is written; to disk saving the `tree`. Remember, trees (and histograms) are created in; the current directory, which is the file in our example. Hence a; `f->Write() `saves the tree. ## Show an Entry with TTree::Show. An easy way to access one entry of a tree is the use the `TTree::Show`; method. For example to look at the 10th entry in the `cernstaff.root` tree:. ``` {.cpp}; root[] TFile f(""cernstaff.root""); root[] T->Show(10); ======> EVENT:10; Category = 361; Flag = 15; Age = 51; Service = 29; Children = 0; Grade = 7; Step = 13; Hrweek = 40; Cost = 7599; Division = PS; Nation = FR; ```. ## Print the Tree Structure with TTree::Print. A helpful command to see the tree structure meaning the number of; entries, the branches and the leaves, is `TTree::Print`. ``` {.cpp}; root[] T->Print(); **********************************************************************; *Tree :T : staff data fro",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:7336,Modifiability,variab,variables,7336,"[Activating the tree viewer](pictures/030000EF.png). The tree viewer is a quick and easy way to examine a tree. To start the; tree viewer, open a file and object browser. Right click on a; **`TTree`** and select `StartViewer`. You can also start the tree viewer; from the command line. First load the viewer library. ``` {.cpp}; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); ```. If you want to start a tree viewer without a tree, you need to load the; tree player library first:. ``` {.cpp}; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); ```. The figure above shows how the tree viewer looks like for the example file; `cernstaff.root`. The left panel contains the list of trees and their; branches; in this case there is only one tree. You can add more trees; with the File-Open command to open the file containing the new tree,; then use the context menu on the right panel, select `SetTreeName` and; enter the name of the tree to add. On the right are the leaves or; variables in the tree. You can double click on any leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refresh the tree. The three check buttons toggle the following:. `Hist`- the histogram drawing mode;. `Scan`- enables redirecting of `TTree::Scan `command in an ASCII file;. `Rec` - enables recording of the last issued command. - ![](pictures/020000F1.jpg) To draw more than one dimension you can drag; and drop any leaf to the `X,Y,Z` boxes"". Then push the Draw button,; witch is marked with the purple icon on the bottom left. - ![](pictures/030000F2.png) All commands can be interrupted at any time; by pressing this button. - ![](pictures/030000F3.png) The method **`TTree::Refresh`** is called by; pressing the refresh button in `TTreeViewer`. It redraws the current; exposed expression. Calling `TT",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:10114,Modifiability,variab,variables,10114,"record can be produced in the following way: dragging; leaves/expression on X/Y/Z; changing drawing options; clicking the RED; button on the bottom when happy with the histogram. NOTE that just double clicking a leaf will not produce a record: the; histogram must be produced when clicking the DRAW button on the; bottom-left. The records will appear on the list of records in the; bottom right of the tree viewer. Selecting a record will draw the; corresponding histogram. Records can be played using the arrow buttons; near to the record button. When saving the session, the list of records; is being saved as well. Records have a default name corresponding to the Z: Y: X selection, but; this can be changed using `SetRecordName()` method from the right panel; context menu. You can create a new expression by right clicking on any; of the` E()` boxes. The expression can be dragged and dropped into any; of the boxes (`X,` `Y,` `Z,` `Cut`, or `Scan`). To scan one or more; variables, drop them into the Scan box, then double click on the box.; You can also redirect the result of the scan to a file by checking the; Scan box on top. ![](pictures/030000F5.png). When the ""`Rec`"" box is checked, the `Draw` and `Scan` commands are; recorded in the history file and echoed on the command line. The; ""Histogram"" text box contains the name of the resulting histogram. By; default it is `htemp`. You can type any name, if the histogram does not; exist it will create one. The Option text box contains the list of Draw; options. See ""Draw Options"". You can select the options with the Options; menu. The Command box lets you enter any command that you could also; enter on the command line. The vertical slider on the far left side can; be used to select the minimum and maximum of an event range. The actual; start and end index are shown in on the bottom in the status window. There is an extensive help utility accessible with the Help menu. The; `IList` and `OList` are to `specify` an input list of ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:17254,Modifiability,variab,variables,17254," a user to the tree that is not depending on the entry number. For; example:. ``` {.cpp}; tree->GetUserInfo()->Add(myruninfo);; ```. ### Indexing a Tree. Use `TTree::BuildIndex()`, to build an index table using expressions; depending on the value in the leaves. ``` {.cpp}; tree->BuildIndex(majorname, minorname);; ```. The index is built in the following way:. - a pass on all entries is made like in `TTree::Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` may be expressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variabl",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18160,Modifiability,variab,variables,18160,"pressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to bui",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18214,Modifiability,variab,variables,18214,"pressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to bui",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18314,Modifiability,variab,variables,18314,"be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18448,Modifiability,variab,variable,18448,"=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the foll",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18933,Modifiability,variab,variables,18933,"entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems,",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19411,Modifiability,variab,variables,19411," one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19701,Modifiability,variab,variable,19701,"e call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntr",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:20143,Modifiability,variab,variable,20143," copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a charact",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:20247,Modifiability,variab,variables,20247,"a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`:",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:20778,Modifiability,variab,variable,20778,"vent"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to a",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21762,Modifiability,variab,variable,21762,"has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:22035,Modifiability,variab,variable,22035,"x`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; thi",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:22246,Modifiability,variab,variable,22246,"; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:22489,Modifiability,variab,variables,22489,"ned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:22677,Modifiability,variab,variable,22677,"ean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. First, we need to open a file and create a tree. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); ```. We need to create a pointer to an `Event` obje",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26389,Modifiability,config,configuration,26389,"e split-level is 1, an object data member is assigned a branch.; If the split-level is 2, the data member objects will be split also, and; a split level of 3 its data members objects, will be split. As the; split-level increases so does the splitting depth. The ROOT default for; the split-level is 99. This means the object will be split to the; maximum. #### Memory Considerations when Splitting a Branch. Splitting a branch can quickly generate many branches. Each branch has; its own buffer in memory. In case of many branches (say more than 100),; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26557,Modifiability,variab,variables,26557," depth. The ROOT default for; the split-level is 99. This means the object will be split to the; maximum. #### Memory Considerations when Splitting a Branch. Splitting a branch can quickly generate many branches. Each branch has; its own buffer in memory. In case of many branches (say more than 100),; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class definition. See ""Input/Output"". - Pointer data member are not split, except for pointers to a; **`TClonesArray`**. The **`TClonesArray`** (pointed to) is split if; the split level is greater than two. When the split level is one,; the **`TClonesArr",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26877,Modifiability,variab,variables,26877,",; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class definition. See ""Input/Output"". - Pointer data member are not split, except for pointers to a; **`TClonesArray`**. The **`TClonesArray`** (pointed to) is split if; the split level is greater than two. When the split level is one,; the **`TClonesArray`** is not split. - If a data member is a pointer to an object, a special branch is; created. The branch will be filled by calling the class `Streamer`; function to serialize the object into the branch buffer. - If a data member is an object, the data members of this object are; split into branche",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33266,Modifiability,variab,variables,33266," 2`, one top level branch is created for each array; element. If one of the array elements is a **`TCollection`**, one; top level branch will be created for each element of this; collection. In case a collection element is a **`TClonesArray`**, the special Tree; constructor for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the fu",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33537,Modifiability,variab,variables,33537,"r for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33770,Modifiability,extend,extend,33770,"by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33875,Modifiability,variab,variable,33875," is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This exam",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33916,Modifiability,variab,variable,33916,"h names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (in",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33971,Modifiability,variab,variables,33971,"h names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (in",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34967,Modifiability,variab,variables,34967,"riable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A sing",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35067,Modifiability,variab,variables,35067,"e we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; c",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35162,Modifiability,variab,variables,35162,", with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35233,Modifiability,variab,variable,35233,", with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35432,Modifiability,variab,variables,35432,"n either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:36008,Modifiability,variab,variables,36008,"s. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating point type leaf also called `px`. ``` {.cpp}; t1.Branch(""px"",&px,""px/F"");; ```. #### Filling the Tree. First we find some random values for the variables. We assign `px` and; `py` a Gaussian with mean = 0 and sigma = 1 by calling; `gRandom->Rannor(px,py)`, and calculate` pz`. Then we call the; `TTree::Fill()` method. The call `t1.Fill()` fills all branches in the; tree because we have already organized the tree into branches and told; each branch where to get the value from. After this script is executed; we have a ROOT file called `",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:36580,Modifiability,variab,variables,36580,"""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating point type leaf also called `px`. ``` {.cpp}; t1.Branch(""px"",&px,""px/F"");; ```. #### Filling the Tree. First we find some random values for the variables. We assign `px` and; `py` a Gaussian with mean = 0 and sigma = 1 by calling; `gRandom->Rannor(px,py)`, and calculate` pz`. Then we call the; `TTree::Fill()` method. The call `t1.Fill()` fills all branches in the; tree because we have already organized the tree into branches and told; each branch where to get the value from. After this script is executed; we have a ROOT file called `tree1.root` with a tree called `t1`. There; is a possibility to fill branches one by one using the method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; bec",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38065,Modifiability,variab,variables,38065,"he method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consi",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38178,Modifiability,variab,variables,38178,"s can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. `",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38345,Modifiability,variab,variable,38345,"The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38542,Modifiability,variab,variable,38542,"e that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When reading the Tree, one can choose one of these 3 options:. Option 1:. ``` {.cpp}; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; ```. This ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38708,Modifiability,variab,variables,38708," is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When reading the Tree, one can choose one of these 3 options:. Option 1:. ``` {.cpp}; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; ```. This is the default and recommended way to create an object of the class; `Event. `It will be pointed by `event`. At the following entries, `event` will be overwritte",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:43070,Modifiability,variab,variable,43070,"s(""ev"",&ev);; // create two histograms; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-3,3);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",30,-3,3,30,-3,3);; //read all entries and fill the histograms; Int_t nentries = (Int_t)t1->GetEntries();; for (Int_t i=0; i<nentries; i++) {; t1->GetEntry(i);; hpx->Fill(px);; hpxpy->Fill(px,py);; }; // We do not close the file. We want to keep the generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; ```. ## Example 2: A Tree with a C Structure. The executable script for this example is; `$ROOTSYS/tutorials/tree/tree2.C. `In this example we show:. - how to build branches from a C structure; - how to make a branch with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:43471,Modifiability,variab,variables,43471,"he generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; ```. ## Example 2: A Tree with a C Structure. The executable script for this example is; `$ROOTSYS/tutorials/tree/tree2.C. `In this example we show:. - how to build branches from a C structure; - how to make a branch with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The ca",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:45673,Modifiability,variab,variable,45673,"t_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];. vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ```. ### Writing the Tree. ``` {.cpp}; void tree2w() {; // write tree2 example; //create a Tree file tree2.root; TFile f(""tree2.root"",""recreate"");. //create the file, the Tree; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; // declare a variable of the C structure type; Gctrak_t gstep;. // add the branches for a subset of gstep; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:47871,Modifiability,variab,variables,47871,"ticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filli",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48123,Modifiability,variab,variable,48123,"001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First,",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48458,Modifiability,variab,variable,48458," (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in the; vector. Here we use the **`TTree::Draw`** method. It automatically creates",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48505,Modifiability,variab,variable,48505," (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in the; vector. Here we use the **`TTree::Draw`** method. It automatically creates",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48727,Modifiability,variab,variable,48727,"``. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in the; vector. Here we use the **`TTree::Draw`** method. It automatically creates; a histogram and plots the 3 expressions (see Trees in Analysis). ![](pictures/030000FF.png). ``` {.cpp}; void tree2r() {. // read the Tree generated by tree2w and fill one histogram; // we are only interested by the destep branch. // note that we use ""new"" to create the TFile an",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:50910,Modifiability,extend,extend,50910," Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);. //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; //read only the destep branch for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:51095,Modifiability,variab,variable,51095,"for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk lo",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52280,Modifiability,extend,extend,52280,"nd save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the fir",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:53154,Modifiability,variab,variables,53154,"rmission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For exampl",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:53842,Modifiability,variab,variables,53842,"),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries o",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54008,Modifiability,variab,variablename,54008,"thod. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is w",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54057,Modifiability,variab,variable,54057,"thod. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is w",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54174,Modifiability,variab,variable,54174,"000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also r",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54225,Modifiability,variab,variable,54225,"000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also r",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54261,Modifiability,variab,variable,54261,"000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also r",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:55700,Modifiability,variab,variable,55700,"he list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. ``` {.cpp}; tree.Draw(""var:ft1.var:ft2.var"");; ```. The example code is in `$ROOTSYS/tutorials/tree/tree3.C`. Here is the; script:. ``` {.cpp}; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the second roo",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:55952,Modifiability,variab,variables,55952,"he histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. ``` {.cpp}; tree.Draw(""var:ft1.var:ft2.var"");; ```. The example code is in `$ROOTSYS/tutorials/tree/tree3.C`. Here is the; script:. ``` {.cpp}; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the second root file with a different tree; TFile fr(""tree3f.root"",""recreate"");; TTree *t3f = new TTree(""t3f"",""a friend Tree"");; t3f->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3f->Branch(""sumstat"",&sumstat,""sumstat/D"");; t3f->Branch(""pt"",pt,""pt[ntrack]/F"");. /",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58630,Modifiability,inherit,inherits,58630,"first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; ch",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58763,Modifiability,inherit,inherits,58763,"se pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; Event",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58861,Modifiability,inherit,inheriting,58861,". // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60144,Modifiability,inherit,inherit,60144,"n `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60259,Modifiability,inherit,inherit,60259,"; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component o",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60345,Modifiability,inherit,inheriting,60345,"m. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass squar",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60440,Modifiability,inherit,inheriting,60440,"cks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge depositio",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60968,Modifiability,inherit,inheritance,60968," ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassD",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62816,Modifiability,variab,variable,62816,"his track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree conten",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67440,Modifiability,variab,variable,67440,"adFile` can be used to automatic define the; structure of the **`TTree`** and read the data from a formatted ascii; file. ``` {.cpp}; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); ```. Creates or simply read branches from the file named whose name is passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each process",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67788,Modifiability,variab,variable,67788,"c2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); roo",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:68301,Modifiability,config,configuration,68301," syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and re",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:69406,Modifiability,variab,variable,69406,"uted over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; m",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:69866,Modifiability,variab,variable,69866,"ee T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In gen",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:70136,Modifiability,inherit,inherited,70136,"ointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In general, this parameter is; a string that contains up to three expressions, one for each dimension,; separated by a colon (""`e1:e2:e3`""). A list of examples follows this; introduction. ### Using Selection with TTree:Draw. Change the active pad to 3, and add a selection to the list of; parameters of the ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:70593,Modifiability,variab,variables,70593,"ptions, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In general, this parameter is; a string that contains up to three expressions, one for each dimension,; separated by a colon (""`e1:e2:e3`""). A list of examples follows this; introduction. ### Using Selection with TTree:Draw. Change the active pad to 3, and add a selection to the list of; parameters of the draw command. ``` {.cpp}; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); ```. This will draw the `Cost `vs. `Age` for the entries where the nation is; equal to ""`FR`"". You can use any C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:70850,Modifiability,variab,variable,70850,"ot[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In general, this parameter is; a string that contains up to three expressions, one for each dimension,; separated by a colon (""`e1:e2:e3`""). A list of examples follows this; introduction. ### Using Selection with TTree:Draw. Change the active pad to 3, and add a selection to the list of; parameters of the draw command. ``` {.cpp}; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); ```. This will draw the `Cost `vs. `Age` for the entries where the nation is; equal to ""`FR`"". You can use any C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72328,Modifiability,variab,variables,72328,"Cost `vs. `Age` for the entries where the nation is; equal to ""`FR`"". You can use any C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates to true, the histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2);",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72359,Modifiability,variab,variable,72359,"C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates to true, the histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in B",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72455,Modifiability,variab,variable,72455,"parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates to true, the histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in Batch Mode. The `TTree::Draw` method creates a histogram called `htemp` and pu",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72773,Modifiability,inherit,inherits,72773,"*(boolean expression)""; ```. If the Boolean expression evaluates to true, the histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in Batch Mode. The `TTree::Draw` method creates a histogram called `htemp` and puts it; on the active pad. In a batch program, the histogram `htemp` created by; default, is reachable from the current pad. ``` {.cpp}; // draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:74746,Modifiability,variab,variables,74746,"pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; ```. If you pipe the result of the `TTree::Draw` into a histogram, the; histogram is also available in the current directory. You can do:. ``` {.cpp}; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; ```. ### Using Draw Options in TTree::Draw. The next parameter is the draw option for the histogram:. ``` {.cpp}; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");; ```. ![Using draw options in trees](pictures/03000104.png). The draw options are the same as for `TH1::Draw`. See ""Draw Options""; where they are listed. In addition to the draw options defined in; **`TH1`**, there are three more. The `'prof'` and `'profs'` draw a; profile histogram (**`TProfile`**) rather than a regular 2D histogram; (**`TH2D`**) from an expression with two variables. If the expression; has three variables, a **`TProfile2D`** is generated. The '`profs`' generates a **`TProfile`** with error on the spread. The; '`prof`' option generates a **`TProfile`** with error on the mean. The; ""`goff`"" option suppresses generating the graphics. You can combine the; draw options in a list separated by commas. After typing the lines; above, you should now have a canvas that looks this. ### Superimposing Two Histograms. When superimposing two 2-D histograms inside a script with `TTree::Draw`; and using the ""`same`"" option, you will need to update the pad between; `Draw` commands. ``` {.cpp}; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:74786,Modifiability,variab,variables,74786,"();; ```. If you pipe the result of the `TTree::Draw` into a histogram, the; histogram is also available in the current directory. You can do:. ``` {.cpp}; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; ```. ### Using Draw Options in TTree::Draw. The next parameter is the draw option for the histogram:. ``` {.cpp}; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");; ```. ![Using draw options in trees](pictures/03000104.png). The draw options are the same as for `TH1::Draw`. See ""Draw Options""; where they are listed. In addition to the draw options defined in; **`TH1`**, there are three more. The `'prof'` and `'profs'` draw a; profile histogram (**`TProfile`**) rather than a regular 2D histogram; (**`TH2D`**) from an expression with two variables. If the expression; has three variables, a **`TProfile2D`** is generated. The '`profs`' generates a **`TProfile`** with error on the spread. The; '`prof`' option generates a **`TProfile`** with error on the mean. The; ""`goff`"" option suppresses generating the graphics. You can combine the; draw options in a list separated by commas. After typing the lines; above, you should now have a canvas that looks this. ### Superimposing Two Histograms. When superimposing two 2-D histograms inside a script with `TTree::Draw`; and using the ""`same`"" option, you will need to update the pad between; `Draw` commands. ``` {.cpp}; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTre",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:78241,Modifiability,variab,variable,78241," 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""fMatrix - fVertex"");; 16 tree->Draw(""fMatrix[2][1] - fVertex[5][1]"");; 17 tree->Draw(""fMatrix[ ][1] - fVertex[5][1]"");; 18 tree->Draw(""fMatrix[2][ ] - fVertex[5][ ]"");; 19 tree->Draw(""fMatrix[ ][2] - fVertex[ ][1]"");; 20 tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]"");; 21 tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]"");; // variable length arrays; 22 tree->Draw(""fClosestDistance"");; 23 tree->Draw(""fClosestDistance[fNvertex/2]"");; // mathematical expressions; 24 tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz))"");; // external function call; 25 tree->Draw(""TMath::BreitWigner(fPx,3,2)"");; // strings; 26 tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "");; 27 tree->Draw(""fEvtHdr.fEvtNum"",""strstr(fType,""1"" "");; // Where fPoints is defined in the track class:; // Int_t fNpoint;; // Int_t *fPoints; [fNpoint]; 28 tree->Draw(""fTracks.fPoints"");; 29 tree->Draw(""fTracks.fPoints - fTracks.fPoints[][fAvgPoints]"");; 30 tree->Draw(""fTracks.fPoints[2][]- fTracks.fPoints[][55]"");; 31 tree->Draw(""fTracks.fPoints[][] - fTracks.fVertex[][]"");; // selections; 32 tree->Draw(""fValid&0x1"",""(fNvertex>10) && (fNseg<=6000)"");; 33 tree->Draw(""fPx"",""(fBx>.4) || (fBy<=-.4)"");; 34 tree->Draw(""fPx"",""fBx*fBx*(fBx>.4) + fBy*fBy*(fBy<=-.4)"");; 35 tree->Draw(""fVertex"",""fVertex>10"");; 36 tree->Draw(""fPx[600]"");;",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:85048,Modifiability,variab,variable,85048,"ected from each entry:. `fMatrix[0][2] - fVertex[0][1]`. `fMatrix[1][2] - fVertex[1][1]`. `fMatrix[2][2] - fVertex[2][1]`. `fMatrix[3][2] - fVertex[3][1]`. 20. **`tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]"")`**. This is similar to case 19. Twelve values are selected (4x3) from each; entry:. `fMatrix[0][2] - fVertex[0][0]`. `fMatrix[0][2] - fVertex[0][1]`. `fMatrix[0][2] - fVertex[0][2]`. `fMatrix[1][2] - fVertex[1][0]`. `fMatrix[1][2] - fVertex[1][1]`. `fMatrix[1][2] - fVertex[1][2]`. `fMatrix[2][2] - fVertex[2][0]`. `fMatrix[2][2] - fVertex[2][1]`. `fMatrix[2][2] - fVertex[2][2]`. `fMatrix[3][2] - fVertex[3][0]`. `fMatrix[3][2] - fVertex[3][1]`. `fMatrix[3][2] - fVertex[3][2]`. 21. **`tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]"")`**. This is the same as case 15. The first dimension minimum is 4 (from; `fMatrix`), and the second dimension minimum is 3 (from `fVertex`).; Twelve values are selected from each entry. 22. **`tree->Draw(""fClosestDistance"")`**. This event data member `fClosestDistance` is a variable length array:. `Float_t *fClosestDistance; //[fNvertex]`. This command selects all elements, but the number per entry depends on; the number of vertices of that entry. 23. **`tree->Draw(""fClosestDistance[fNvertex/2]"")`**. With this command the element at `fNvertex/2` of the; `fClosestDistance `array is selected. Only one per entry is selected. 24. **`tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)"")`**. This command shows the use of a mathematical expression. It draws the; square root of the sum of the product. 25. **`tree->Draw(""TMath::BreitWigner(fPx,3,2)"")`**. The formula can contains call to a function that takes numerical; arguments and returns a numerical value. The function needs to be; declared to the dictionary and need to be available from the global; namespace. In particular, global functions and public static member; functions can be called. 26. **`tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "")`**. You can compare strings, using the symbols == and !=, in",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:90530,Modifiability,variab,variable,90530,"raw(""fValid&0x1"",""(fNvertex>10) && (fNseg<=6000)"")`**. You can use bit patterns (`&,|,<<`) or Boolean operation. 33. **`tree->Draw(""fPx"",""(fBx>.4) || (fBy<=-.4)"");`**. 34. **`tree->Draw(""fPx"",""fBx*fBx*(fBx>.4) + fBy*fBy*(fBy<=-.4)"");`**. The selection argument is used as a weight. The expression returns a; multiplier and in case of a Boolean the multiplier is either 0 (for; false) or 1 (for true). The first command draws `fPx` for the range; between with conditions on `fBx` and `fBy`, the second command draws `fPx`; for the same conditions, but adds a weight using the result of the second; expression. 35. **`tree->Draw(""fVertex"",""fVertex>10"")`**. When using arrays in the selection and the expression, the selection is; applied to each element of the array. `if (fVertex[0]>10) fVertex[0]`. `if (fVertex[1]>10) fVertex[1]`. `if (fVertex[2]>10) fVertex[2]`. 36. **`tree->Draw(""fPx[600]"")`**. 37. **`tree->Draw(""fPx[600]"",""fNtrack > 600"")`**. When using a specific element for a variable length array the entries; with fewer elements are ignored. Thus these two commands are equivalent. 38. **`tree->Draw(""Nation"")`**. `Nation` is a `char*` branch. When drawing a `char*` it will plot an; alphanumeric histogram, of the different value of the string `Nation`.; The axis will have the `Nation` values. See ""Histograms"". 39. **`tree->Draw(""MyChar +0"")`**. If you want to plot a char\* variable as a byte rather than a string,; you can use the syntax above. 40. **`tree->Draw(""fTracks.fTriggerBits"")`**. `fTriggerBits` is a data member of **`TTrack`** of type **`TBits`**.; Objects of class **`TBits`** can be drawn directly. This command will; create a 1D histogram from 0 to `nbits` which is filled for each; non-null bit-number. 41. **`tree->Draw(""fMatrix-Alt$(fClosestDistance,0)"")`**. `Alt$(primary,alternate)` returns the value of ""`primary`"" if it is; available for the current iteration; otherwise return the value of; ""`alternate`"". Assuming that `fClosestDistance` is a smaller array tha",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:90934,Modifiability,variab,variable,90934,"t command draws `fPx` for the range; between with conditions on `fBx` and `fBy`, the second command draws `fPx`; for the same conditions, but adds a weight using the result of the second; expression. 35. **`tree->Draw(""fVertex"",""fVertex>10"")`**. When using arrays in the selection and the expression, the selection is; applied to each element of the array. `if (fVertex[0]>10) fVertex[0]`. `if (fVertex[1]>10) fVertex[1]`. `if (fVertex[2]>10) fVertex[2]`. 36. **`tree->Draw(""fPx[600]"")`**. 37. **`tree->Draw(""fPx[600]"",""fNtrack > 600"")`**. When using a specific element for a variable length array the entries; with fewer elements are ignored. Thus these two commands are equivalent. 38. **`tree->Draw(""Nation"")`**. `Nation` is a `char*` branch. When drawing a `char*` it will plot an; alphanumeric histogram, of the different value of the string `Nation`.; The axis will have the `Nation` values. See ""Histograms"". 39. **`tree->Draw(""MyChar +0"")`**. If you want to plot a char\* variable as a byte rather than a string,; you can use the syntax above. 40. **`tree->Draw(""fTracks.fTriggerBits"")`**. `fTriggerBits` is a data member of **`TTrack`** of type **`TBits`**.; Objects of class **`TBits`** can be drawn directly. This command will; create a 1D histogram from 0 to `nbits` which is filled for each; non-null bit-number. 41. **`tree->Draw(""fMatrix-Alt$(fClosestDistance,0)"")`**. `Alt$(primary,alternate)` returns the value of ""`primary`"" if it is; available for the current iteration; otherwise return the value of; ""`alternate`"". Assuming that `fClosestDistance` is a smaller array than; `fMatrix`. This example will draw `fMatrix[i]+fClosestDistance[i]` for; `i` less than the size of `fClosestDistance`, and will draw; `fMatrix[i]+0` for the other value of `i`. 42. **`tree->Draw(""fClosestDistance:Iteration$"")`**. This example draws a 2D plot with, for all entries,; `fClosestDistance[i]:i` for each value of `i` between 0 and the size of; `fClosestDistance`. `Iterations$` is one of four spe",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:91960,Modifiability,variab,variables,91960,"use the syntax above. 40. **`tree->Draw(""fTracks.fTriggerBits"")`**. `fTriggerBits` is a data member of **`TTrack`** of type **`TBits`**.; Objects of class **`TBits`** can be drawn directly. This command will; create a 1D histogram from 0 to `nbits` which is filled for each; non-null bit-number. 41. **`tree->Draw(""fMatrix-Alt$(fClosestDistance,0)"")`**. `Alt$(primary,alternate)` returns the value of ""`primary`"" if it is; available for the current iteration; otherwise return the value of; ""`alternate`"". Assuming that `fClosestDistance` is a smaller array than; `fMatrix`. This example will draw `fMatrix[i]+fClosestDistance[i]` for; `i` less than the size of `fClosestDistance`, and will draw; `fMatrix[i]+0` for the other value of `i`. 42. **`tree->Draw(""fClosestDistance:Iteration$"")`**. This example draws a 2D plot with, for all entries,; `fClosestDistance[i]:i` for each value of `i` between 0 and the size of; `fClosestDistance`. `Iterations$` is one of four special variables; giving some indications of the state of the loops implied by the; formula:. `Entry$ :` return the current entry number (`TTree::GetReadEntry()`). `Entries$ :` return the total number of entries (`TTree::GetEntries()`). `Length$ :` return the total number of element of this formula for; this entry. `Iteration$:` return the current iteration over this formula for this; entry (i.e. varies from 0 to `Length$`). 43. **`tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");`**. **`TRef`** and **`TRefArray`** are automatically deferenced and this; shows the value of the `fPx` of the track referenced by `fLastTrack`. To; access the **`TRef`** object itself use the '`@`' notation (see next; example). This auto dereferencing can be extended (via an implementation; of **`TVirtualRefProxy`**) to any reference type. 44. **`tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");`**. Will cast the return value of `GetObject()` (which happens to be; **`TObject*`** in this case) before requesting the `GetPx()` m",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:92697,Modifiability,extend,extended,92697,". 42. **`tree->Draw(""fClosestDistance:Iteration$"")`**. This example draws a 2D plot with, for all entries,; `fClosestDistance[i]:i` for each value of `i` between 0 and the size of; `fClosestDistance`. `Iterations$` is one of four special variables; giving some indications of the state of the loops implied by the; formula:. `Entry$ :` return the current entry number (`TTree::GetReadEntry()`). `Entries$ :` return the total number of entries (`TTree::GetEntries()`). `Length$ :` return the total number of element of this formula for; this entry. `Iteration$:` return the current iteration over this formula for this; entry (i.e. varies from 0 to `Length$`). 43. **`tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");`**. **`TRef`** and **`TRefArray`** are automatically deferenced and this; shows the value of the `fPx` of the track referenced by `fLastTrack`. To; access the **`TRef`** object itself use the '`@`' notation (see next; example). This auto dereferencing can be extended (via an implementation; of **`TVirtualRefProxy`**) to any reference type. 44. **`tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");`**. Will cast the return value of `GetObject()` (which happens to be; **`TObject*`** in this case) before requesting the `GetPx()` member; functions. 45. **`tree->Draw(""This->GetReadEntry()"");`**. You can refer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsStrin",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:93977,Modifiability,variab,variables,93977," member; functions. 45. **`tree->Draw(""This->GetReadEntry()"");`**. You can refer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsString` (`AsDouble` has priority). For such a class (for example; **`TTimeStamp`**), the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical Us",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94093,Modifiability,variab,variables,94093,"fer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsString` (`AsDouble` has priority). For such a class (for example; **`TTimeStamp`**), the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider pl",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94440,Modifiability,variab,variable,94440,"re the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsString` (`AsDouble` has priority). For such a class (for example; **`TTimeStamp`**), the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dime",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94842,Modifiability,variab,variables,94842," returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and equally spaced. A point in n-dimensional; space is represented as a polyline with vertices on ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:95380,Modifiability,variab,variables,95380,"pider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and equally spaced. A point in n-dimensional; space is represented as a polyline with vertices on the parallel axes.; The position of the vertex on the i-th axis corresponds to the i-th; coordinate of the point. The three following figures show some very; simple examples:. ![The Parallel Coordinates representation of the six dimensional point `(-5,3,4,2,0,1)`.](pictures/para1.png). ![The line `y = -3x+20` and a circle in Parallel Coordinates.](pictures/para2.png). The Parallel Coordinates technique is good at: spotting irregular; events, seeing ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:97648,Modifiability,variab,variables,97648,"ates is to find techniques; to reduce the output’s cluttering. The Parallel Coordinates plots in; ROOT have been implemented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:97811,Modifiability,variab,variables,97811,"ented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represent",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:97861,Modifiability,variab,variables,97861,"in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a pal",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100077,Modifiability,variab,variables,100077,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100105,Modifiability,variab,variables,100105,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100166,Modifiability,variab,variables,100166,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101404,Modifiability,variab,variables,101404," combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined allows to select exactly the two; correlated “random spheres”. ![Output of `nt->Draw(“x:y:z”)` and `nt->Draw(“u:v:w”)` after applying the selection.](pictures/para10.png). Another technique has been implemented in order to show clusters when; the picture is cluttered. A weight is assigned to each event",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101461,Modifiability,variab,variables,101461," combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined allows to select exactly the two; correlated “random spheres”. ![Output of `nt->Draw(“x:y:z”)` and `nt->Draw(“u:v:w”)` after applying the selection.](pictures/para10.png). Another technique has been implemented in order to show clusters when; the picture is cluttered. A weight is assigned to each event",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:104853,Modifiability,variab,variables,104853," (also known as a “box-and whisker” plot or “candle stick” plot); is a convenient way to describe graphically a data distribution (D) with only; the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:104939,Modifiability,variab,variable,104939,"o describe graphically a data distribution (D) with only; the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:104970,Modifiability,variab,variables,104970,"mbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an e",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:111848,Modifiability,variab,variable,111848,"Principal` and; `CopyTree` methods to the entries in the list. In general, it affects; the `GetEntryNumber` method and all functions using it for looping over; the tree entries. The `GetEntry` and `GetEntries` methods are not; affected. Note, that in the `SetEventList` method, the **`TEventList`**; argument is internally transformed into a **`TEntryList`**, and this; operation, in case of a **`TChain`**, requires loading of all the tree; headers. In this example, we create a list with all entries with more; than 600 tracks and then set it so that the tree will use this list. To; reset the **`TTree`** to use all events use `SetEventList(0)` or; `SetEntryList(0)`. 1. Let's look at an example. First, open the file and draw the; `fNtrack`. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root"");; root[] TTree *T = (TTree*)f->Get(""T"");; root[] T->Draw(""fNtrack"");; ```. 2. Now, put the entries with over 600 tracks into a **`TEntryList`**; called `myList`. We get the list from the current directory and assign; it to a variable list. ``` {.cpp}; root[] T->Draw("">>myList"",""fNtrack > 600"",""entrylist"");; root[] TEntryList *list=(TEntryList*)gDirectory->Get(""myList"");; ```. 3. Instruct the tree **`T`** to use the new list and draw it again. Note; that this is exactly the same `Draw` command. The list limits the; entries. ``` {.cpp}; root[] T->SetEntryList(list);; root[] T->Draw(""fNtrack"");; ```. You should now see a canvas similar to this one. ![](pictures/03000105.png). #### Operations on TEntryLists. If you have entry lists that were created using different cuts, you can; combine the lists to get a new list, with entries passing at least one; of the cuts. Example:. ``` {.cpp}; root[] T->Draw("">>list1"",""fNtrack>600"",""entrylist"");; root[] TEntryList *list1 = (TEntryList*)gDirectory->Get(""list1"");; root[] T->Draw("">>list2"",""fNtrack<590"",""entrylist"");; root[] TEntryList *list2 = (TEntryList*)gDirectory->Get(""list2"");; root[] list1->Add(list2);; ```. `list1` now contains entries wit",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:115679,Modifiability,variab,variable,115679,"r the currently; processed tree loaded. For more details on entry lists, see **`TEntryList`**,; **`TEntryListBlock`** and **`TEntryListFromFile`** class descriptions,; functions **`TChain`**`::SetEntryList()`, `TChain::SetEntryListFile()`,; and the macro `$ROOTSYS/test/stressEntryList.C`. ### Filling a Histogram. The `TTree::Draw` method can also be used to fill a specific histogram.; The syntax is:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; ```. As we can see, this created a **`TH1`**, called `myHisto`. If you want; to append more entries to the histogram, you can use this syntax:. ``` {.cpp}; root[] T->Draw(""fNtrack >>+ myHisto""); ```. If you do not create a histogram ahead of time, ROOT will create one at; the time of the Draw command (as is the case above). If you would like; to draw the variable into a specific histogram where you, for example,; set the range and bin number, you can define the histogram ahead of time; and use it in the Draw command. The histogram has to be in the same; directory as the tree. ``` {.cpp}; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; ```. When you project a **`TTree`** into a histogram, the histogram inherits; the **`TTree`** attributes and not the current style attributes. This; allows you to project two Trees with different attributes into the same; picture. You can call the method `TTree::UseCurrentStyle` to change the; histogram to use the current style ***`gStyle`***. See ""Graphics and the; Graphical User Interface. The binning of the newly created histogram can be specified in two ways.; You can set a default in the `.rootrc` and/or you can add the binning; information in the `TTree::Draw` command. To set number of bins default for the 1-D, 2-D, 3-D histograms can be; specified in the `.rootrc` file via the environment variables, e.g.:. ```; # default binnings ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:116067,Modifiability,inherit,inherits,116067,"Draw` method can also be used to fill a specific histogram.; The syntax is:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; ```. As we can see, this created a **`TH1`**, called `myHisto`. If you want; to append more entries to the histogram, you can use this syntax:. ``` {.cpp}; root[] T->Draw(""fNtrack >>+ myHisto""); ```. If you do not create a histogram ahead of time, ROOT will create one at; the time of the Draw command (as is the case above). If you would like; to draw the variable into a specific histogram where you, for example,; set the range and bin number, you can define the histogram ahead of time; and use it in the Draw command. The histogram has to be in the same; directory as the tree. ``` {.cpp}; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; ```. When you project a **`TTree`** into a histogram, the histogram inherits; the **`TTree`** attributes and not the current style attributes. This; allows you to project two Trees with different attributes into the same; picture. You can call the method `TTree::UseCurrentStyle` to change the; histogram to use the current style ***`gStyle`***. See ""Graphics and the; Graphical User Interface. The binning of the newly created histogram can be specified in two ways.; You can set a default in the `.rootrc` and/or you can add the binning; information in the `TTree::Draw` command. To set number of bins default for the 1-D, 2-D, 3-D histograms can be; specified in the `.rootrc` file via the environment variables, e.g.:. ```; # default binnings Hist.Binning.1D.x: 100. Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100. Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```. To set the number of bins for a specific histogram when using; `TTree::Draw,` add up to nine number",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:116704,Modifiability,variab,variables,116704," specific histogram where you, for example,; set the range and bin number, you can define the histogram ahead of time; and use it in the Draw command. The histogram has to be in the same; directory as the tree. ``` {.cpp}; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; ```. When you project a **`TTree`** into a histogram, the histogram inherits; the **`TTree`** attributes and not the current style attributes. This; allows you to project two Trees with different attributes into the same; picture. You can call the method `TTree::UseCurrentStyle` to change the; histogram to use the current style ***`gStyle`***. See ""Graphics and the; Graphical User Interface. The binning of the newly created histogram can be specified in two ways.; You can set a default in the `.rootrc` and/or you can add the binning; information in the `TTree::Draw` command. To set number of bins default for the 1-D, 2-D, 3-D histograms can be; specified in the `.rootrc` file via the environment variables, e.g.:. ```; # default binnings Hist.Binning.1D.x: 100. Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100. Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```. To set the number of bins for a specific histogram when using; `TTree::Draw,` add up to nine numbers following the histogram name. The; numbers meaning is:. 1 bins in x-direction. 2 lower limit in x-direction. 3 upper limit in x-direction. 4-6 same for y-direction. 7-9 same for z-direction. When a bin number is specified, the value becomes the default. Any of; the numbers can be skipped. For example:. ``` {.cpp}; tree.Draw(""sqrt(x)>>hsqrt(500,10,20)"";; // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,,50,.1,.5)"";; // plot sqrt(x) against sin(y) 100 bins in x-direction;; // lower limit on x-axis is 10; no upper limit; // 50 bins in y-direction; lower limit on y-axis is .1;",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:118965,Modifiability,variab,variable,118965," 2-D and 3-D histograms. #### Projecting a Histogram. If you would like to fill a histogram, but not draw it you can use the; `TTree::Project()` method. ``` {.cpp}; root[] T->Project(""quietHisto"",""fNtrack""); ```. #### Making a Profile Histogram; \index{histogram!profile}. In case of a two dimensional expression, you can generate a; **`TProfile`** histogram instead of a two dimensional histogram by; specifying the `'prof'` or '`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:119033,Modifiability,variab,variable,119033,"e to fill a histogram, but not draw it you can use the; `TTree::Project()` method. ``` {.cpp}; root[] T->Project(""quietHisto"",""fNtrack""); ```. #### Making a Profile Histogram; \index{histogram!profile}. In case of a two dimensional expression, you can generate a; **`TProfile`** histogram instead of a two dimensional histogram by; specifying the `'prof'` or '`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; ```. By def",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:119100,Modifiability,variab,variable,119100,"ject()` method. ``` {.cpp}; root[] T->Project(""quietHisto"",""fNtrack""); ```. #### Making a Profile Histogram; \index{histogram!profile}. In case of a two dimensional expression, you can generate a; **`TProfile`** histogram instead of a two dimensional histogram by; specifying the `'prof'` or '`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; ```. By default, `TTree::Draw` creates these arrays with `fEstimate` words; whe",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:119385,Modifiability,variab,variable,119385,"'`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; ```. By default, `TTree::Draw` creates these arrays with `fEstimate` words; where `fEstimate` can be set via `TTree::SetEstimate`. If you have more; entries than `fEstimate` only the first `fEstimate` selected entries; will be stored in the arrays. The arrays are used as buffers. When; `fEstimate` entries have been processed, ROOT scans the buffers to; compute the min",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:121135,Modifiability,variab,variable,121135,"e `fEstimate` can be set via `TTree::SetEstimate`. If you have more; entries than `fEstimate` only the first `fEstimate` selected entries; will be stored in the arrays. The arrays are used as buffers. When; `fEstimate` entries have been processed, ROOT scans the buffers to; compute the minimum and maximum of each coordinate and creates the; corresponding histograms. You can use these lines to read all entries; into these arrays:. ``` {.cpp}; root[] Int_t nestimate = (Int_t)T->GetEntries();; root[] T->SetEstimate(nestimate);; ```. Obviously, this will not work if the number of entries is very large.; This technique is useful in several cases, for example if you want to; draw a graph connecting all the `x`, `y(or z)` points. Note that you may; have a tree (or chain) with 1 billion entries, but only a few may; survive the cuts and will fit without problems in these arrays. ## Using TTree::MakeClass; \index{tree!MakeClass}. The `TTree::Draw` method is convenient and easy to use; however it falls; short if you need to do some programming with the variable. For example, for plotting the masses of all oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree w",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:131223,Modifiability,config,configuration,131223,"get entry 0, and print the number of tracks (594).; Then we get entry 1 and print the number of tracks (597). ``` {.cpp}; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; ```. Now we can call the `Loop` method, which will build and display the two; histograms. ``` {.cpp}; root[] m.Loop(); ```. You should now see a canvas that looks like this. ![](pictures/03000106.png). To conclude the discussion on `MakeClass` let us lists the steps that; got us here. - Call `TTree::MakeClass`, which automatically creates a class to loop; over the tree. - Modify the `MyClass::Loop()` method in `MyClass.C` to fit your task. - Load and instantiate `MyClass`, and run `MyClass::Loop()`. ## Using TTree::MakeSelector; \index{tree!MakeSelector}. With a **`TTree`** we can make a selector and use it to process a; limited set of entries. This is especially important in a parallel; processing configuration where the analysis is distributed over several; processors and we can specify which entries to send to each processor.; The `TTree::Process` method is used to specify the selector and the; entries. Before we can use **`TTree::Process`** we need to make a; selector. We can call the `TTree::MakeSelector` method. It creates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this functi",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:136424,Modifiability,config,configurations,136424,"ray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; data member of the Event class. The list of tracks (a; **`TClonesArray`**) has the data members of the Track class also; split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. +------------+--------+---------------+---------------+----------------+----------------+; | Event | File | Total Time to | Effective | Total Time to | Total Time to |; | Parameters | Size | Write | Time to Write | Read All | Read Sample |; | | | (MB/sec) | (MB/sec) | (",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143289,Modifiability,variab,variables,143289,"= chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For addition",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143530,Modifiability,variab,variable,143530,"eg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For additional information see `TTree::AddFriends()`. A full; example of a tree and friends is in Example \#3; `($ROOTSYS/tutorials/tree/tree3.C`) in the Trees section above.; ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143579,Modifiability,variab,variable,143579,"eg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For additional information see `TTree::AddFriends()`. A full; example of a tree and friends is in Example \#3; `($ROOTSYS/tutorials/tree/tree3.C`) in the Trees section above.; ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143689,Modifiability,variab,variable,143689,"eg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For additional information see `TTree::AddFriends()`. A full; example of a tree and friends is in Example \#3; `($ROOTSYS/tutorials/tree/tree3.C`) in the Trees section above.; ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143733,Modifiability,variab,variable,143733,"eg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For additional information see `TTree::AddFriends()`. A full; example of a tree and friends is in Example \#3; `($ROOTSYS/tutorials/tree/tree3.C`) in the Trees section above.; ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143771,Modifiability,variab,variable,143771,"eg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For additional information see `TTree::AddFriends()`. A full; example of a tree and friends is in Example \#3; `($ROOTSYS/tutorials/tree/tree3.C`) in the Trees section above.; ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:303,Performance,optimiz,optimized,303,"# Trees. ## Why Should You Use a Tree?. In the ""Input/Output"" chapter, we saw how objects can be saved in ROOT; files. In case you want to store large quantities of same-class objects,; ROOT has designed the **`TTree`** and **`TNtuple`** classes specifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:1705,Performance,optimiz,optimize,1705,"s, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! This is very time consuming,; and we really do not need to read the entire event, every time. All we; need are two little data members (`Px` and `Py`). On the other hand, if; we use a tree with one branch containing `Px` and another branch; containing `Py`, we can read all values of `Px` and `Py` by only reading; the `Px` and `Py` branches. This makes the use of the **`TTree`** very; attractive. ## A Simple TTree. This script builds a **`TTree`** from",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:6622,Performance,load,load,6622,"e:Children:Grade:... *; * | Cost *; *Entries :3354 : Total Size = 154237 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 bytes Compression= 2.97 *; ```. ## Scan a Variable the Tree with TTree::Scan. The `TTree::Scan` method shows all values of the list of leaves; separated by a colon. ``` {.cpp}; root[] T->Scan(""Cost:Age:Children""); ************************************************; * Row * Cost * Age * Children *; ************************************************; * 0 * 11975 * 58 * 0 *; * 1 * 10228 * 63 * 0 *; * 2 * 10730 * 56 * 2 *; * 3 * 9311 * 61 * 0 *; * 4 * 9966 * 52 * 2 *; * 5 * 7599 * 60 * 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; ```. ## The Tree Viewer. ![Activating the tree viewer](pictures/030000EF.png). The tree viewer is a quick and easy way to examine a tree. To start the; tree viewer, open a file and object browser. Right click on a; **`TTree`** and select `StartViewer`. You can also start the tree viewer; from the command line. First load the viewer library. ``` {.cpp}; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); ```. If you want to start a tree viewer without a tree, you need to load the; tree player library first:. ``` {.cpp}; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); ```. The figure above shows how the tree viewer looks like for the example file; `cernstaff.root`. The left panel contains the list of trees and their; branches; in this case there is only one tree. You can add more trees; with the File-Open command to open the file containing the new tree,; then use the context menu on the right panel, select `SetTreeName` and; enter the name of the tree to add. On the right are the leaves or; variables in the tree. You can double click on any leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refr",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:6786,Performance,load,load,6786,"ompression= 2.97 *; ```. ## Scan a Variable the Tree with TTree::Scan. The `TTree::Scan` method shows all values of the list of leaves; separated by a colon. ``` {.cpp}; root[] T->Scan(""Cost:Age:Children""); ************************************************; * Row * Cost * Age * Children *; ************************************************; * 0 * 11975 * 58 * 0 *; * 1 * 10228 * 63 * 0 *; * 2 * 10730 * 56 * 2 *; * 3 * 9311 * 61 * 0 *; * 4 * 9966 * 52 * 2 *; * 5 * 7599 * 60 * 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; ```. ## The Tree Viewer. ![Activating the tree viewer](pictures/030000EF.png). The tree viewer is a quick and easy way to examine a tree. To start the; tree viewer, open a file and object browser. Right click on a; **`TTree`** and select `StartViewer`. You can also start the tree viewer; from the command line. First load the viewer library. ``` {.cpp}; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); ```. If you want to start a tree viewer without a tree, you need to load the; tree player library first:. ``` {.cpp}; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); ```. The figure above shows how the tree viewer looks like for the example file; `cernstaff.root`. The left panel contains the list of trees and their; branches; in this case there is only one tree. You can add more trees; with the File-Open command to open the file containing the new tree,; then use the context menu on the right panel, select `SetTreeName` and; enter the name of the tree to add. On the right are the leaves or; variables in the tree. You can double click on any leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refresh the tree. The three check buttons toggle the following:. `Hist`- the histogram drawing mode;. `Scan`- enables redirecting of `TTree::Scan ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:8404,Performance,concurren,concurrently,8404,"ny leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refresh the tree. The three check buttons toggle the following:. `Hist`- the histogram drawing mode;. `Scan`- enables redirecting of `TTree::Scan `command in an ASCII file;. `Rec` - enables recording of the last issued command. - ![](pictures/020000F1.jpg) To draw more than one dimension you can drag; and drop any leaf to the `X,Y,Z` boxes"". Then push the Draw button,; witch is marked with the purple icon on the bottom left. - ![](pictures/030000F2.png) All commands can be interrupted at any time; by pressing this button. - ![](pictures/030000F3.png) The method **`TTree::Refresh`** is called by; pressing the refresh button in `TTreeViewer`. It redraws the current; exposed expression. Calling `TTree::Refresh` is useful when a tree is; produced by a writer process and concurrently analyzed by one or more; readers. - ![](pictures/030000F4.png) To add a cut/weight to the histogram, enter an; expression in the ""cut box"". The cut box is the one with the scissor; icon. Below them there are two text widgets for specifying the input and; output event lists. A Tree Viewer session is made by the list of; user-defined expressions and cuts, applying to a specified tree. A; session can be saved using File / `SaveSource` menu or the `SaveSource`; method from the context menu of the right panel. This will create a; macro having as default name `treeviewer.C` that can be ran at any time; to reproduce the session. Besides the list of user-defined expressions, a session may contain a; list of RECORDS. A record can be produced in the following way: dragging; leaves/expression on X/Y/Z; changing drawing options; clicking the RED; button on the bottom when happy with the histogram. NOTE that just double clicking a leaf will not produce a record: the;",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:13281,Performance,load,load,13281,"h branches for each of the sub-folders:. ``` {.cpp}; TTree folder_tree(""MyFolderTree"",""/MyFolder"");; ```. The second argument `""/MyFolder"" `is the top folder, and the ""/"" signals; the **`TTree`** constructor that this is a folder not just the title.; You fill the tree by placing the data into the folder structure and; calling `TTree::Fill`. ### Tree and TRef Objects. ``` {.cpp}; MyTree->BranchRef();; ```. This call requests the construction of an optional branch supporting; table of references (**`TRefTable`**). This branch (**`TBranchRef`**); will keep all the information needed to find the branches containing; referenced objects at each `Tree::Fill`, the branch numbers containing; the referenced objects are saved in the table of references. When the; Tree header is saved (via `TTree::Write` for example), the branch is; saved, keeping the information with the pointers to the branches having; referenced objects. Enabling this optional table, allow; `TTree::Draw` to automatically load the branches needed to; dereference a **`TRef`** (or **`TRefArray`**) object. ### Autosave. `Autosave` gives the option to save all branch buffers every `n` byte.; We recommend using `Autosave` for large acquisitions. If the acquisition; fails to complete, you can recover the file and all the contents since; the last `Autosave`. To set the number of bytes between `Autosave` you; can use the `TTree::SetAutosave()` method. You can also call; **`TTree::Autosave` in the acquisition loop every `n `entry.**. ### Trees with Circular Buffers. When a **`TTree`** is memory resident, you set it up so that it retains; retain only the last few entries. For example, this can be very useful; for monitoring purpose. ``` {.cpp}; void TTree::SetCircular(Long64_t maxEntries);; ```. where `maxEntries` is the maximum number of entries to be kept in the; buffers. When the number of entries exceeds this value, the first; entries in the **`Tree`** are deleted and the buffers used again. An; example of a script ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18060,Performance,optimiz,optimize,18060,"x(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` may be expressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; a",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:23177,Performance,load,load,23177,"ecifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. First, we need to open a file and create a tree. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); ```. We need to create a pointer to an `Event` object that will be used as a; reference in the `TTree::Branch` method. Then we create a branch; with the `TTree::Branch` method. ``` {.cpp}; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); ```. To add a branch to hold an object we use the signature above. The first; parameter is the name of the branch. The second parameter is the name of; the class of the object to be stored. The third parameter is the address; of a pointer to the object to be stored. Note that it is an",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:23406,Performance,load,loaded,23406,"2-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. First, we need to open a file and create a tree. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); ```. We need to create a pointer to an `Event` object that will be used as a; reference in the `TTree::Branch` method. Then we create a branch; with the `TTree::Branch` method. ``` {.cpp}; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); ```. To add a branch to hold an object we use the signature above. The first; parameter is the name of the branch. The second parameter is the name of; the class of the object to be stored. The third parameter is the address; of a pointer to the object to be stored. Note that it is an address of a pointer to the object, not just a; pointer to the object. The fourth parameter is the buffer size and is by default 32000 bytes.; It is the number of bytes of d",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26777,Performance,perform,performance,26777,"te many branches. Each branch has; its own buffer in memory. In case of many branches (say more than 100),; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class definition. See ""Input/Output"". - Pointer data member are not split, except for pointers to a; **`TClonesArray`**. The **`TClonesArray`** (pointed to) is split if; the split level is greater than two. When the split level is one,; the **`TClonesArray`** is not split. - If a data member is a pointer to an object, a special branch is; created. The branch will be filled by calling the class `Streamer`; function to serialize the object into the",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34472,Performance,load,load,34472," are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, p",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52558,Performance,perform,performance,52558,"saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the sa",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62339,Performance,load,load,62339,"t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperatu",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:63936,Performance,load,loaded,63936,"00; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; ```. ### Reading the Tree. First, we check if the shared library with the class definitions is; loaded. If not we load it. Then we read two branches, one for the number; of tracks and one for the entire event. We check the number of tracks; first, and if it meets our condition, we read the entire event. We show; the fist entry that meets the condition. ``` {.cpp}; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_spli",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:63954,Performance,load,load,63954,"annor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; ```. ### Reading the Tree. First, we check if the shared library with the class definitions is; loaded. If not we load it. Then we read two branches, one for the number; of tracks and one for the entire event. We check the number of tracks; first, and if it meets our condition, we read the entire event. We show; the fist entry that meets the condition. ``` {.cpp}; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:64290,Performance,load,load,64290,"Flag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; ```. ### Reading the Tree. First, we check if the shared library with the class definitions is; loaded. If not we load it. Then we read two branches, one for the number; of tracks and one for the entire event. We check the number of tracks; first, and if it meets our condition, we read the entire event. We show; the fist entry that meets the condition. ``` {.cpp}; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:109632,Performance,optimiz,optimized,109632,"of all entries with more than 600; tracks. To see the entry numbers use the `Print(""all"")` command. ``` {.cpp}; root[] myList->Print(""all"");; ```. When using the ""`>>`"" whatever was in the list is overwritten. The list; can be grown by using the ""`>>+`"" syntax. For example to add the; entries, with exactly 600 tracks:. ``` {.cpp}; root[] T->Draw("">>+ myList"",""fNtrack == 600"", ""entrylist"");; ```. If the `Draw` command generates duplicate entries, they are not added to; the list. ``` {.cpp}; root[] T->Draw("">>+ myList"","" fNtrack > 610"", ""entrylist"");; ```. This command does not add any new entries to the list because all; entries with more than 610 tracks have already been found by the; previous command for entries with more than 600 tracks. #### Main Differences between TEventList and TEntryList. The functionality is essentially the same: both are used to store entry; numbers. **`TEntryList`**, however, uses considerably less memory for; storage, and is optimized for both very high and very low selectivity of; cuts (see **`TEntryListBlock`** class description for the details of; internal storage). Unlike the **`TEventList`**, **`TEntryList`** makes a; distinction between indices from a **`TChain`** and from a **`TTree`**.; While a **`TEntryList`** for a **`TTree`** can be seen as just a list of; numbers, a **`TEntryList`** for a **`TChain`** is a collection of; **`TEntryList`**(s) for the **`TTree`**(s) that constitute this; **`TChain`**. Such ""sub-lists"" can be extracted by calling the function. ``` {.cpp}; TEntryList::GetEntryList(const char *treename, const char *filename); ```. and then be used to construct a new **`TEntryList`** for a new; **`TChain`**, or processed independently as normal **`TEntryList`**(s); for **`TTree`**(s). This modularity makes **`TEntryList`** much better; suited for PROOF processing than the **`TEventList`**. #### Using an Event List. A **`TEventList`** or a **`TEntryList`** can be used to limit the; **`TTree`** to the events in the list",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:111240,Performance,load,loading,111240,"lling the function. ``` {.cpp}; TEntryList::GetEntryList(const char *treename, const char *filename); ```. and then be used to construct a new **`TEntryList`** for a new; **`TChain`**, or processed independently as normal **`TEntryList`**(s); for **`TTree`**(s). This modularity makes **`TEntryList`** much better; suited for PROOF processing than the **`TEventList`**. #### Using an Event List. A **`TEventList`** or a **`TEntryList`** can be used to limit the; **`TTree`** to the events in the list. The methods `SetEventList` and; `SetEntryList` tell the tree to use the list and hence limit all; subsequent calls to `Draw`, `Scan`, `Process`, `Query`, `Principal` and; `CopyTree` methods to the entries in the list. In general, it affects; the `GetEntryNumber` method and all functions using it for looping over; the tree entries. The `GetEntry` and `GetEntries` methods are not; affected. Note, that in the `SetEventList` method, the **`TEventList`**; argument is internally transformed into a **`TEntryList`**, and this; operation, in case of a **`TChain`**, requires loading of all the tree; headers. In this example, we create a list with all entries with more; than 600 tracks and then set it so that the tree will use this list. To; reset the **`TTree`** to use all events use `SetEventList(0)` or; `SetEntryList(0)`. 1. Let's look at an example. First, open the file and draw the; `fNtrack`. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root"");; root[] TTree *T = (TTree*)f->Get(""T"");; root[] T->Draw(""fNtrack"");; ```. 2. Now, put the entries with over 600 tracks into a **`TEntryList`**; called `myList`. We get the list from the current directory and assign; it to a variable list. ``` {.cpp}; root[] T->Draw("">>myList"",""fNtrack > 600"",""entrylist"");; root[] TEntryList *list=(TEntryList*)gDirectory->Get(""myList"");; ```. 3. Instruct the tree **`T`** to use the new list and draw it again. Note; that this is exactly the same `Draw` command. The list limits the; entries. ``` {.cpp}; ro",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:114677,Performance,load,load,114677,"t2"");; root[] list2->SetTree(""tree2"", ""file2"");; root[] list2->Enter(0);; root[] list2->Enter(3);; root[] list1->Add(list2);; root[] list1->Print(""all""); tree1 file1; 0; 2; tree2 file2; 0; 3; ```. The result is a **`TEntryList`** for a **`TChain`** of `tree1` and; `tree2`. If the second list was for the same **`TTree`** in the same; file as the first list, the result would be as follows:. ``` {.cpp}; root[] TEntryList *list2_2 = new TEntryList(""list2_2"", ""list2_2"");; root[] list2_2->SetTree(""tree2"", ""file2"");; root[] list2_2->Enter(1);; root[] list2_2->Enter(2);; root[] list2->Add(list2_2);; root[] list2->Print(""all""); tree2 file2; 0; 1; 2; 3; ```. #### TEntryListFromFile. This is a special kind of **`TEntryList`**, used only when processing; **`TChain`** objects (see the method `TChain::SetEntryListFile()`). It; is used in the case, when the entry lists, corresponding to the trees of; this chain, are stored in separate files. It allows to load the entry; lists in memory one by one, keeping only the list for the currently; processed tree loaded. For more details on entry lists, see **`TEntryList`**,; **`TEntryListBlock`** and **`TEntryListFromFile`** class descriptions,; functions **`TChain`**`::SetEntryList()`, `TChain::SetEntryListFile()`,; and the macro `$ROOTSYS/test/stressEntryList.C`. ### Filling a Histogram. The `TTree::Draw` method can also be used to fill a specific histogram.; The syntax is:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; ```. As we can see, this created a **`TH1`**, called `myHisto`. If you want; to append more entries to the histogram, you can use this syntax:. ``` {.cpp}; root[] T->Draw(""fNtrack >>+ myHisto""); ```. If you do not create a histogram ahead of time, ROOT will create one at; the time of the Draw command (as is the case above). If you would like; to draw the variable into a specific histogram where you,",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:114777,Performance,load,loaded,114777,"t2"");; root[] list2->SetTree(""tree2"", ""file2"");; root[] list2->Enter(0);; root[] list2->Enter(3);; root[] list1->Add(list2);; root[] list1->Print(""all""); tree1 file1; 0; 2; tree2 file2; 0; 3; ```. The result is a **`TEntryList`** for a **`TChain`** of `tree1` and; `tree2`. If the second list was for the same **`TTree`** in the same; file as the first list, the result would be as follows:. ``` {.cpp}; root[] TEntryList *list2_2 = new TEntryList(""list2_2"", ""list2_2"");; root[] list2_2->SetTree(""tree2"", ""file2"");; root[] list2_2->Enter(1);; root[] list2_2->Enter(2);; root[] list2->Add(list2_2);; root[] list2->Print(""all""); tree2 file2; 0; 1; 2; 3; ```. #### TEntryListFromFile. This is a special kind of **`TEntryList`**, used only when processing; **`TChain`** objects (see the method `TChain::SetEntryListFile()`). It; is used in the case, when the entry lists, corresponding to the trees of; this chain, are stored in separate files. It allows to load the entry; lists in memory one by one, keeping only the list for the currently; processed tree loaded. For more details on entry lists, see **`TEntryList`**,; **`TEntryListBlock`** and **`TEntryListFromFile`** class descriptions,; functions **`TChain`**`::SetEntryList()`, `TChain::SetEntryListFile()`,; and the macro `$ROOTSYS/test/stressEntryList.C`. ### Filling a Histogram. The `TTree::Draw` method can also be used to fill a specific histogram.; The syntax is:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; ```. As we can see, this created a **`TH1`**, called `myHisto`. If you want; to append more entries to the histogram, you can use this syntax:. ``` {.cpp}; root[] T->Draw(""fNtrack >>+ myHisto""); ```. If you do not create a histogram ahead of time, ROOT will create one at; the time of the Draw command (as is the case above). If you would like; to draw the variable into a specific histogram where you,",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:123125,Performance,load,load,123125," build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`"", and just to verify that we are working; with the correct one, we print the tree, which will show us the header; and branches. ``` {.cpp}; root[] T->Print();; ```. From the output of print we can see that the tree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the name of the class to be made. In the command; below, the name of our class will be ""`MyClass`"". ``` {.cpp}; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; ```. Cling informs us that it has created two files. ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:127061,Performance,load,loads,127061,"his class is instantiated, `fChain` will point to the; original tree or chain this class was made from. In our case, this is; ""T"" in ""`Event.root`"". If the class is instantiated with a tree as a; parameter to the constructor, `fChain` will point to the tree named in; the parameter. Next is `fCurrent`, which is also a pointer to the; current tree/chain. Its role is only relevant when we have multiple; trees chained together in a **`TChain`**. The class definition shows us; that this tree has one branch and one leaf per data member. The methods; of `MyClass` are:. - `MyClass(TTree *tree=0) -` this constructor has an optional tree; for a parameter. If you pass a tree, `MyClass` will use it rather; than the tree from which it was created. - `void Init(TTree *tree) -` it is called by the constructor to; initialize the tree for reading. It associates each branch with the; corresponding leaf data member. - `~MyClass() - `the destructor, nothing special. - `Int_t GetEntry(Int_t entry) -` it loads the class with the entry; specified. Once you have executed `GetEntry`, the leaf data members; in `MyClass` are set to the values of the entry. For example,; `GetEntry(12)` loads the 13th event into the event data member of; `MyClass` (note that the first entry is 0). `GetEntry` returns the; number of bytes read from the file. In case the same entry is read; twice, ROOT does not have to do any I/O. In this case `GetEntry`; returns 1. It does not return 0, because many people assume a return; of 0 means an error has occurred while reading. - `Int_t LoadTree(Int_t entry)` and `void Notify()` - these two; methods are related to chains. `LoadTree` will load the tree; containing the specified entry from a chain of trees. Notify is; called by `LoadTree` to adjust the branch addresses. - `void Loop()` - it is the skeleton method that loops through each; entry of the tree. This is interesting to us, because we will need; to customize it for our analysis. ### MyClass.C. `MyClass::Loop` cons",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:127240,Performance,load,loads,127240,"the constructor, `fChain` will point to the tree named in; the parameter. Next is `fCurrent`, which is also a pointer to the; current tree/chain. Its role is only relevant when we have multiple; trees chained together in a **`TChain`**. The class definition shows us; that this tree has one branch and one leaf per data member. The methods; of `MyClass` are:. - `MyClass(TTree *tree=0) -` this constructor has an optional tree; for a parameter. If you pass a tree, `MyClass` will use it rather; than the tree from which it was created. - `void Init(TTree *tree) -` it is called by the constructor to; initialize the tree for reading. It associates each branch with the; corresponding leaf data member. - `~MyClass() - `the destructor, nothing special. - `Int_t GetEntry(Int_t entry) -` it loads the class with the entry; specified. Once you have executed `GetEntry`, the leaf data members; in `MyClass` are set to the values of the entry. For example,; `GetEntry(12)` loads the 13th event into the event data member of; `MyClass` (note that the first entry is 0). `GetEntry` returns the; number of bytes read from the file. In case the same entry is read; twice, ROOT does not have to do any I/O. In this case `GetEntry`; returns 1. It does not return 0, because many people assume a return; of 0 means an error has occurred while reading. - `Int_t LoadTree(Int_t entry)` and `void Notify()` - these two; methods are related to chains. `LoadTree` will load the tree; containing the specified entry from a chain of trees. Notify is; called by `LoadTree` to adjust the branch addresses. - `void Loop()` - it is the skeleton method that loops through each; entry of the tree. This is interesting to us, because we will need; to customize it for our analysis. ### MyClass.C. `MyClass::Loop` consists of a for-loop calling `GetEntry` for each; entry. In the template, the numbers of bytes are added up, but it does; nothing else. If we were to execute it now, there would be no output. ``` {.cpp}; void MyC",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:127724,Performance,load,load,127724,"ll use it rather; than the tree from which it was created. - `void Init(TTree *tree) -` it is called by the constructor to; initialize the tree for reading. It associates each branch with the; corresponding leaf data member. - `~MyClass() - `the destructor, nothing special. - `Int_t GetEntry(Int_t entry) -` it loads the class with the entry; specified. Once you have executed `GetEntry`, the leaf data members; in `MyClass` are set to the values of the entry. For example,; `GetEntry(12)` loads the 13th event into the event data member of; `MyClass` (note that the first entry is 0). `GetEntry` returns the; number of bytes read from the file. In case the same entry is read; twice, ROOT does not have to do any I/O. In this case `GetEntry`; returns 1. It does not return 0, because many people assume a return; of 0 means an error has occurred while reading. - `Int_t LoadTree(Int_t entry)` and `void Notify()` - these two; methods are related to chains. `LoadTree` will load the tree; containing the specified entry from a chain of trees. Notify is; called by `LoadTree` to adjust the branch addresses. - `void Loop()` - it is the skeleton method that loops through each; entry of the tree. This is interesting to us, because we will need; to customize it for our analysis. ### MyClass.C. `MyClass::Loop` consists of a for-loop calling `GetEntry` for each; entry. In the template, the numbers of bytes are added up, but it does; nothing else. If we were to execute it now, there would be no output. ``` {.cpp}; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes += nb;; // if (Cut(ientry) < 0) continue;; }; }; ```. At the beginning of the file are instructions about reading selected; branches. They are not reprinted here,",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:129918,Performance,load,load,129918,"change the Loop method. ``` {.cpp}; ...; if (fChain == 0) return;; Int_t nentries = Int_t(fChain->GetEntries());; TH1F *myHisto = new TH1F(""myHisto"",""fPx"", 100, -5,5);; TH1F *smallHisto = new TH1F(""small"",""fPx"", 100, -5,5);; ...; ```. In the for-loop, we need to add another for-loop to go over all the; tracks. In the outer for-loop, we get the entry and the number of; tracks. In the inner for-loop, we fill the large histogram (`myHisto`); with all tracks and the small histogram (`smallHisto`) with the track if; it is in the first 100. ``` {.cpp}; ...; for (Int_t jentry=0; jentry<nentries;jentry++) {; GetEntry(jentry);; for (Int_t j = 0; j < 100; j++) {; myHisto->Fill(fTracks_fPx[j]);; if (j < 100) {; smallHisto->Fill(fTracks_fPx[j]);; }; }; }; ...; ```. Outside of the for-loop, we draw both histograms on the same canvas. ``` {.cpp}; ...; myHisto->Draw();; smallHisto->Draw(""Same"");; ...; ```. Save these changes to `MyClass.C` and start a fresh root session. We; will now load `MyClass` and experiment with its methods. ### Loading MyClass. The first step is to load the library and the class file. Then we can; instantiate a `MyClass` object. ``` {.cpp}; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; ```. Now we can get a specific entry and populate the event leaf. In the code; snipped below, we get entry 0, and print the number of tracks (594).; Then we get entry 1 and print the number of tracks (597). ``` {.cpp}; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; ```. Now we can call the `Loop` method, which will build and display the two; histograms. ``` {.cpp}; root[] m.Loop(); ```. You should now see a canvas that looks like this. ![](pictures/03000106.png). To conclude the discussion on `MakeClass` let us lists the steps that; got us here. - Call `TTree::MakeClass`, which automatically creates a class to loop; over the tree. - Modify the `MyClass::Loop()` method in `MyCla",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:130008,Performance,load,load,130008," = Int_t(fChain->GetEntries());; TH1F *myHisto = new TH1F(""myHisto"",""fPx"", 100, -5,5);; TH1F *smallHisto = new TH1F(""small"",""fPx"", 100, -5,5);; ...; ```. In the for-loop, we need to add another for-loop to go over all the; tracks. In the outer for-loop, we get the entry and the number of; tracks. In the inner for-loop, we fill the large histogram (`myHisto`); with all tracks and the small histogram (`smallHisto`) with the track if; it is in the first 100. ``` {.cpp}; ...; for (Int_t jentry=0; jentry<nentries;jentry++) {; GetEntry(jentry);; for (Int_t j = 0; j < 100; j++) {; myHisto->Fill(fTracks_fPx[j]);; if (j < 100) {; smallHisto->Fill(fTracks_fPx[j]);; }; }; }; ...; ```. Outside of the for-loop, we draw both histograms on the same canvas. ``` {.cpp}; ...; myHisto->Draw();; smallHisto->Draw(""Same"");; ...; ```. Save these changes to `MyClass.C` and start a fresh root session. We; will now load `MyClass` and experiment with its methods. ### Loading MyClass. The first step is to load the library and the class file. Then we can; instantiate a `MyClass` object. ``` {.cpp}; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; ```. Now we can get a specific entry and populate the event leaf. In the code; snipped below, we get entry 0, and print the number of tracks (594).; Then we get entry 1 and print the number of tracks (597). ``` {.cpp}; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; ```. Now we can call the `Loop` method, which will build and display the two; histograms. ``` {.cpp}; root[] m.Loop(); ```. You should now see a canvas that looks like this. ![](pictures/03000106.png). To conclude the discussion on `MakeClass` let us lists the steps that; got us here. - Call `TTree::MakeClass`, which automatically creates a class to loop; over the tree. - Modify the `MyClass::Loop()` method in `MyClass.C` to fit your task. - Load and instantiate `MyClass`, and run `MyClass::Loop",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:134231,Performance,load,loaded,134231,", you must use the pointer to the; current **`TTree`** to call the method `GetEntry(entry)`. The; parameter `entry` is always the local entry number in the current; tree. Assuming that `fChain` is the pointer to the **`TChain`**; being processed, use. ``` {.cpp}; fChain->GetTree()->GetEntry(entry);; ```. To create a selector call:. ``` {.cpp}; root[] T->MakeSelector(""MySelector"");; ```. Where `T` is the **`TTree`** and `MySelector` is the name of created; class and the name of the `.h` and `.C` files. The resulting; **`TSelector`** is the argument to **`TTree::Process`**. The argument can; be the file name or a pointer to the selector object. ``` {.cpp}; root[] T->Process(""MySelector.C"","""",1000,100);; ```. This call will interpret the class defined in `MySelector.C` and process; 1000 entries beginning with entry 100. The file name can be appended; with a ""+"" or a ""++"" to use `ACLiC`. ``` {.cpp}; root[] T->Process(""MySelector.C++"","""",1000,100);; ```. When appending a ""++"", the class will be compiled and dynamically; loaded. ``` {.cpp}; root[] T->Process(""MySelector.C+"","""",1000,100);; ```. When appending a ""+"", the class will also be compiled and dynamically; loaded. When it is called again, it recompiles only if the macro; (`MySelector.C`) has changed since it was compiled last. If not, it; loads the existing library. The next example shows how to create a; selector with a pointer:. ``` {.cpp}; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; ```. `Using this form, you can do things like:`. ``` {.cpp}; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:134376,Performance,load,loaded,134376,"umber in the current; tree. Assuming that `fChain` is the pointer to the **`TChain`**; being processed, use. ``` {.cpp}; fChain->GetTree()->GetEntry(entry);; ```. To create a selector call:. ``` {.cpp}; root[] T->MakeSelector(""MySelector"");; ```. Where `T` is the **`TTree`** and `MySelector` is the name of created; class and the name of the `.h` and `.C` files. The resulting; **`TSelector`** is the argument to **`TTree::Process`**. The argument can; be the file name or a pointer to the selector object. ``` {.cpp}; root[] T->Process(""MySelector.C"","""",1000,100);; ```. This call will interpret the class defined in `MySelector.C` and process; 1000 entries beginning with entry 100. The file name can be appended; with a ""+"" or a ""++"" to use `ACLiC`. ``` {.cpp}; root[] T->Process(""MySelector.C++"","""",1000,100);; ```. When appending a ""++"", the class will be compiled and dynamically; loaded. ``` {.cpp}; root[] T->Process(""MySelector.C+"","""",1000,100);; ```. When appending a ""+"", the class will also be compiled and dynamically; loaded. When it is called again, it recompiles only if the macro; (`MySelector.C`) has changed since it was compiled last. If not, it; loads the existing library. The next example shows how to create a; selector with a pointer:. ``` {.cpp}; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; ```. `Using this form, you can do things like:`. ``` {.cpp}; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O performance of; STL vectors to the ROOT native **`TClonesArray`**`s` collection class.; It creates trees with and without compression for the ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:134511,Performance,load,loads,134511,"selector call:. ``` {.cpp}; root[] T->MakeSelector(""MySelector"");; ```. Where `T` is the **`TTree`** and `MySelector` is the name of created; class and the name of the `.h` and `.C` files. The resulting; **`TSelector`** is the argument to **`TTree::Process`**. The argument can; be the file name or a pointer to the selector object. ``` {.cpp}; root[] T->Process(""MySelector.C"","""",1000,100);; ```. This call will interpret the class defined in `MySelector.C` and process; 1000 entries beginning with entry 100. The file name can be appended; with a ""+"" or a ""++"" to use `ACLiC`. ``` {.cpp}; root[] T->Process(""MySelector.C++"","""",1000,100);; ```. When appending a ""++"", the class will be compiled and dynamically; loaded. ``` {.cpp}; root[] T->Process(""MySelector.C+"","""",1000,100);; ```. When appending a ""+"", the class will also be compiled and dynamically; loaded. When it is called again, it recompiles only if the macro; (`MySelector.C`) has changed since it was compiled last. If not, it; loads the existing library. The next example shows how to create a; selector with a pointer:. ``` {.cpp}; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; ```. `Using this form, you can do things like:`. ``` {.cpp}; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O performance of; STL vectors to the ROOT native **`TClonesArray`**`s` collection class.; It creates trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:135202,Performance,perform,performance,135202,"ded. ``` {.cpp}; root[] T->Process(""MySelector.C+"","""",1000,100);; ```. When appending a ""+"", the class will also be compiled and dynamically; loaded. When it is called again, it recompiles only if the macro; (`MySelector.C`) has changed since it was compiled last. If not, it; loads the existing library. The next example shows how to create a; selector with a pointer:. ``` {.cpp}; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; ```. `Using this form, you can do things like:`. ``` {.cpp}; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O performance of; STL vectors to the ROOT native **`TClonesArray`**`s` collection class.; It creates trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:136342,Performance,perform,performance,136342," trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; data member of the Event class. The list of tracks (a; **`TClonesArray`**) has the data members of the Track class also; split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. +------------+--------+---------------+---------------+----------------+----------------+; | Event | File | Total Time to | Effective | Total Time to | Total Time to ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139804,Performance,optimiz,optimized,139804,"ime to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139938,Performance,perform,performance,139938,"ranch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTre",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139977,Performance,perform,performance,139977,"racks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTree`**. For example, to; generate a histogram corresponding to the attrib",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:140042,Performance,perform,performance,140042,"non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTree`**. For example, to; generate a histogram corresponding to the attribute ""`x`"" in tree ""`T`""; by processing sequentially the three files of this chain, we can use the;",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:141548,Performance,load,loaded,141548,"root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTree`**. For example, to; generate a histogram corresponding to the attribute ""`x`"" in tree ""`T`""; by processing sequentially the three files of this chain, we can use the; `TChain::Draw` method. ``` {.cpp}; chain.Draw(""x"");; ```. When using a **`TChain`**, the branch address(es) must be set with:. ``` {.cpp}; chain.SetBranchAdress(branchname,...) // use this for TChain; ```. rather than:. ``` {.cpp}; branch->SetAddress(...); // this will not work; ```. The second form returns the pointer to the branch of the current; **`TTree`** in the chain, typically the first one. The information is; lost when the next **`TTree`** is loaded. The following statements; illustrate how to set the address of the object to be read and how to; loop on all events of all files of the chain. ``` {.cpp}; {; TChain chain(""T""); // create the chain with tree ""T""; chain.Add(""file1.root""); // add the files; chain.Add(""file2.root"");; chain.Add(""file3.root"");; TH1F *hnseg = new TH1F(""hnseg"",; ""Number of segments for selected tracks"",; 5000,0,5000);; // create an object before setting the branch address; Event *event = new Event();; // Specify the address where to read the event object; chain.SetBranchAddress(""event"", &event);. // Start main loop on all events In case you want to read only a few; // branches, use TChain::SetBranchStatus to activate a branch.; Int_t nevent = chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```.",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:13551,Safety,recover,recover,13551,"placing the data into the folder structure and; calling `TTree::Fill`. ### Tree and TRef Objects. ``` {.cpp}; MyTree->BranchRef();; ```. This call requests the construction of an optional branch supporting; table of references (**`TRefTable`**). This branch (**`TBranchRef`**); will keep all the information needed to find the branches containing; referenced objects at each `Tree::Fill`, the branch numbers containing; the referenced objects are saved in the table of references. When the; Tree header is saved (via `TTree::Write` for example), the branch is; saved, keeping the information with the pointers to the branches having; referenced objects. Enabling this optional table, allow; `TTree::Draw` to automatically load the branches needed to; dereference a **`TRef`** (or **`TRefArray`**) object. ### Autosave. `Autosave` gives the option to save all branch buffers every `n` byte.; We recommend using `Autosave` for large acquisitions. If the acquisition; fails to complete, you can recover the file and all the contents since; the last `Autosave`. To set the number of bytes between `Autosave` you; can use the `TTree::SetAutosave()` method. You can also call; **`TTree::Autosave` in the acquisition loop every `n `entry.**. ### Trees with Circular Buffers. When a **`TTree`** is memory resident, you set it up so that it retains; retain only the last few entries. For example, this can be very useful; for monitoring purpose. ``` {.cpp}; void TTree::SetCircular(Long64_t maxEntries);; ```. where `maxEntries` is the maximum number of entries to be kept in the; buffers. When the number of entries exceeds this value, the first; entries in the **`Tree`** are deleted and the buffers used again. An; example of a script using a circular buffer is shown below:. ``` {.cpp}; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19922,Safety,avoid,avoid,19922,"older, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given fo",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:32917,Safety,avoid,avoid,32917," collection, the entry in the collection; becomes in turn top level branches, etc. The split level is decreased by; 1 every time a new collection is found. For example if `list` is a; **`TObjArray`**\*. - If `splitlevel = 1`, one top level branch is created for each; element of the **`TObjArray`**. - If `splitlevel = 2`, one top level branch is created for each array; element. If one of the array elements is a **`TCollection`**, one; top level branch will be created for each element of this; collection. In case a collection element is a **`TClonesArray`**, the special Tree; constructor for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a varia",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:44049,Safety,safe,safety,44049,"with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The calls; to the `Branch` methods are the same as if Geant3 were used. ``` {.cpp}; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = st",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52139,Safety,risk,risk,52139,"y want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variable",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52967,Safety,risk,risk,52967,"```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:132379,Safety,avoid,avoiding,132379,"hod is used to specify the selector and the; entries. Before we can use **`TTree::Process`** we need to make a; selector. We can call the `TTree::MakeSelector` method. It creates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this function returns `kFALSE`. It; combines the methods **`TSelector::ProcessCut()` and; `TSelector`**`::ProcessFill()` in one, avoiding the necessity to; maintain the state in the class to communicate between these two; functions. It reduces the information that needs to be shared; between them and promotes a more granular data access by reading; branches as they are needed. - `TSelector::Terminate() -` it is called at the end of a loop on a; **`TTree`**. This is a convenient place to draw and fit your; histograms. - `TSelector::Version()` `-` this function provides backward; compatibility for old versions and support for the future upgrades. - The **`TSelector`**, unlike the resulting class from `MakeClass`,; separates the processing into a `ProcessCut()` and `ProcessFill()`,; so we can limit reading of branches to the ones we need. - When a selector is used with a **`TChain`** in methods `Process()`,; `ProcessFill()`, `ProcessCut()`, you must use the pointer to the; current **`TTree`** to call the method `GetEntry(entry)`. The; parameter `entry` is always the local entry number in the current; tree. Assuming th",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:347,Security,access,access,347,"# Trees. ## Why Should You Use a Tree?. In the ""Input/Output"" chapter, we saw how objects can be saved in ROOT; files. In case you want to store large quantities of same-class objects,; ROOT has designed the **`TTree`** and **`TNtuple`** classes specifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:1723,Security,access,access,1723,"s, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! This is very time consuming,; and we really do not need to read the entire event, every time. All we; need are two little data members (`Px` and `Py`). On the other hand, if; we use a tree with one branch containing `Px` and another branch; containing `Py`, we can read all values of `Px` and `Py` by only reading; the `Px` and `Py` branches. This makes the use of the **`TTree`** very; attractive. ## A Simple TTree. This script builds a **`TTree`** from",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:4745,Security,access,access,4745,"Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d %d %d %s %s"",; &Category,&Flag,&Age,&Service,&Children,&Grade,&Step,&Hrweek,&Cost,Division,Nation);; tree->Fill();; }; tree->Print();; tree->Write();. fclose(fp);; delete hfile;; }; ```. The script opens the; ASCII file, creates a ROOT file and a **`TTree`**. Then it creates; branches with the `TTree::Branch` method. The first parameter of the; `Branch` method is the branch name. The second parameter is the address; from which the first leaf is to be read. Once the branches are defined, the script; reads the data from the ASCII file into C variables and; fills the `tree`. The ASCII file is closed, and the ROOT file is written; to disk saving the `tree`. Remember, trees (and histograms) are created in; the current directory, which is the file in our example. Hence a; `f->Write() `saves the tree. ## Show an Entry with TTree::Show. An easy way to access one entry of a tree is the use the `TTree::Show`; method. For example to look at the 10th entry in the `cernstaff.root` tree:. ``` {.cpp}; root[] TFile f(""cernstaff.root""); root[] T->Show(10); ======> EVENT:10; Category = 361; Flag = 15; Age = 51; Service = 29; Children = 0; Grade = 7; Step = 13; Hrweek = 40; Cost = 7599; Division = PS; Nation = FR; ```. ## Print the Tree Structure with TTree::Print. A helpful command to see the tree structure meaning the number of; entries, the branches and the leaves, is `TTree::Print`. ``` {.cpp}; root[] T->Print(); **********************************************************************; *Tree :T : staff data from ascii file *; *Entries :3354 : Total = 245417 bytes File Size = 59945*; * Tree compression factor = 2.90 *; **********************************************************************; *Br 0 :staff :Category/I:Flag:Age:Service:Children:Grade:... *; * | Cost *; *Entries :3354 : Total Size = 154237 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 byte",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:8300,Security,expose,exposed,8300,"o add. On the right are the leaves or; variables in the tree. You can double click on any leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refresh the tree. The three check buttons toggle the following:. `Hist`- the histogram drawing mode;. `Scan`- enables redirecting of `TTree::Scan `command in an ASCII file;. `Rec` - enables recording of the last issued command. - ![](pictures/020000F1.jpg) To draw more than one dimension you can drag; and drop any leaf to the `X,Y,Z` boxes"". Then push the Draw button,; witch is marked with the purple icon on the bottom left. - ![](pictures/030000F2.png) All commands can be interrupted at any time; by pressing this button. - ![](pictures/030000F3.png) The method **`TTree::Refresh`** is called by; pressing the refresh button in `TTreeViewer`. It redraws the current; exposed expression. Calling `TTree::Refresh` is useful when a tree is; produced by a writer process and concurrently analyzed by one or more; readers. - ![](pictures/030000F4.png) To add a cut/weight to the histogram, enter an; expression in the ""cut box"". The cut box is the one with the scissor; icon. Below them there are two text widgets for specifying the input and; output event lists. A Tree Viewer session is made by the list of; user-defined expressions and cuts, applying to a specified tree. A; session can be saved using File / `SaveSource` menu or the `SaveSource`; method from the context menu of the right panel. This will create a; macro having as default name `treeviewer.C` that can be ran at any time; to reproduce the session. Besides the list of user-defined expressions, a session may contain a; list of RECORDS. A record can be produced in the following way: dragging; leaves/expression on X/Y/Z; changing drawing options; clicking the RED; button on the bottom when happy w",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:11048,Security,access,accessible,11048,"of the boxes (`X,` `Y,` `Z,` `Cut`, or `Scan`). To scan one or more; variables, drop them into the Scan box, then double click on the box.; You can also redirect the result of the scan to a file by checking the; Scan box on top. ![](pictures/030000F5.png). When the ""`Rec`"" box is checked, the `Draw` and `Scan` commands are; recorded in the history file and echoed on the command line. The; ""Histogram"" text box contains the name of the resulting histogram. By; default it is `htemp`. You can type any name, if the histogram does not; exist it will create one. The Option text box contains the list of Draw; options. See ""Draw Options"". You can select the options with the Options; menu. The Command box lets you enter any command that you could also; enter on the command line. The vertical slider on the far left side can; be used to select the minimum and maximum of an event range. The actual; start and end index are shown in on the bottom in the status window. There is an extensive help utility accessible with the Help menu. The; `IList` and `OList` are to `specify` an input list of entry indices and; a name for the output list respectively. Both need to be of type; **`TList`** and contain integers of entry indices. These lists are; described below in the paragraph ""**Error! Reference source not; found.**"". ![A couple of graphs](pictures/030000F6.png). The first one is a plot of the age distribution, the second a scatter; plot of the cost vs. age. The second one was generated by dragging the; age leaf into the Y-box and the cost leaf into the X-box, and pressing; the Draw button. By default, this will generate a scatter plot. Select a; different option, for example `""lego""` to create a 2D histogram. ## Creating and Saving Trees. This picture shows the **`TTree`** class:. ![The TTree class](pictures/030000F8.png). To create a **`TTree`** we use its constructor. Then we design our data; layout and add the branches. A tree can be created by giving a name and; title:. ``` {.cp",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:28455,Security,access,accessible,28455,"onesArray`**. The **`TClonesArray`** (pointed to) is split if; the split level is greater than two. When the split level is one,; the **`TClonesArray`** is not split. - If a data member is a pointer to an object, a special branch is; created. The branch will be filled by calling the class `Streamer`; function to serialize the object into the branch buffer. - If a data member is an object, the data members of this object are; split into branches according to the split-level (i.e. split-level; \> 2). - Base classes are split when the object is split. - Abstract base classes are never split. - All STL containers are supported. ``` {.cpp}; // STL vector of vectors of TAxis*; vector<vector<TAxis *> > fVectAxis;; // STL map of string/vector; map<string,vector<int> > fMapString;; // STL deque of pair; deque<pair<float,float> > fDequePair;; ```. - C-structure data members are not supported in split mode. - An object that is not split may be slow to browse. - A STL container that is not split will not be accessible in the; browser. ### Exempt a Data Member from Splitting. If you are creating a branch with an object and in general you want the; data members to be split, but you want to exempt a data member from the; split. You can specify this in the comment field of the data member:. ``` {.cpp}; class Event : public TObject {; private:; EventHeader fEvtHdr; //|| Don't split the header; ```. ### Adding a Branch to Hold a TClonesArray. ROOT has two classes to manage arrays of objects. The **`TObjArray`**; can manage objects of different classes, and the **`TClonesArray`** that; specializes in managing objects of the same class (hence the name Clones; Array). **`TClonesArray`** takes advantage of the constant size of each; element when adding the elements to the array. Instead of allocating; memory for each new object as it is added, it reuses the memory. Here is; an example of the time a **`TClonesArray`** can save over a; **`TObjArray`**. We have 100,000 events, and each has ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38011,Security,access,access,38011,"alled `t1`. There; is a possibility to fill branches one by one using the method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52857,Security,access,access,52857,"nch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the fri",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:53140,Security,access,access,53140,"rmission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For exampl",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54487,Security,access,access,54487," the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. `",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:92586,Security,access,access,92586," less than the size of `fClosestDistance`, and will draw; `fMatrix[i]+0` for the other value of `i`. 42. **`tree->Draw(""fClosestDistance:Iteration$"")`**. This example draws a 2D plot with, for all entries,; `fClosestDistance[i]:i` for each value of `i` between 0 and the size of; `fClosestDistance`. `Iterations$` is one of four special variables; giving some indications of the state of the loops implied by the; formula:. `Entry$ :` return the current entry number (`TTree::GetReadEntry()`). `Entries$ :` return the total number of entries (`TTree::GetEntries()`). `Length$ :` return the total number of element of this formula for; this entry. `Iteration$:` return the current iteration over this formula for this; entry (i.e. varies from 0 to `Length$`). 43. **`tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");`**. **`TRef`** and **`TRefArray`** are automatically deferenced and this; shows the value of the `fPx` of the track referenced by `fLastTrack`. To; access the **`TRef`** object itself use the '`@`' notation (see next; example). This auto dereferencing can be extended (via an implementation; of **`TVirtualRefProxy`**) to any reference type. 44. **`tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");`**. Will cast the return value of `GetObject()` (which happens to be; **`TObject*`** in this case) before requesting the `GetPx()` member; functions. 45. **`tree->Draw(""This->GetReadEntry()"");`**. You can refer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94803,Security,access,accessed,94803," the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and e",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:132582,Security,access,access,132582,"ates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this function returns `kFALSE`. It; combines the methods **`TSelector::ProcessCut()` and; `TSelector`**`::ProcessFill()` in one, avoiding the necessity to; maintain the state in the class to communicate between these two; functions. It reduces the information that needs to be shared; between them and promotes a more granular data access by reading; branches as they are needed. - `TSelector::Terminate() -` it is called at the end of a loop on a; **`TTree`**. This is a convenient place to draw and fit your; histograms. - `TSelector::Version()` `-` this function provides backward; compatibility for old versions and support for the future upgrades. - The **`TSelector`**, unlike the resulting class from `MakeClass`,; separates the processing into a `ProcessCut()` and `ProcessFill()`,; so we can limit reading of branches to the ones we need. - When a selector is used with a **`TChain`** in methods `Process()`,; `ProcessFill()`, `ProcessCut()`, you must use the pointer to the; current **`TTree`** to call the method `GetEntry(entry)`. The; parameter `entry` is always the local entry number in the current; tree. Assuming that `fChain` is the pointer to the **`TChain`**; being processed, use. ``` {.cpp}; fChain->GetTree()->GetEntry(entry);; ```. To create a selector call:. ``` {.cpp}; root[] T->",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139392,Security,access,access,139392," The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the fol",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139435,Security,access,access,139435," The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the fol",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:140853,Security,hash,hash,140853,"use the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTree`**. For example, to; generate a histogram corresponding to the attribute ""`x`"" in tree ""`T`""; by processing sequentially the three files of this chain, we can use the; `TChain::Draw` method. ``` {.cpp}; chain.Draw(""x"");; ```. When using a **`TChain`**, the branch address(es) must be set with:. ``` {.cpp}; chain.SetBranchAdress(branchname,...) // use this for TChain; ```. rather than:. ``` {.cpp}; branch->SetAddress(...); // this will not work; ```. The second form returns the pointer to the branch of the current; **`TTree`** in the chain, typically the first one. The information is; lost when the next **`TTree`** is loaded. The following statements; illustrate how to set the address of the object to be read and how to; loop on all events of all files of the chain. ``` {.cpp}; {; TChain chain(""T""); // create the chain with tree ""T""; chain.Add(",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143275,Security,access,access,143275,"= chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For addition",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:14445,Testability,test,test,14445,"te, you can recover the file and all the contents since; the last `Autosave`. To set the number of bytes between `Autosave` you; can use the `TTree::SetAutosave()` method. You can also call; **`TTree::Autosave` in the acquisition loop every `n `entry.**. ### Trees with Circular Buffers. When a **`TTree`** is memory resident, you set it up so that it retains; retain only the last few entries. For example, this can be very useful; for monitoring purpose. ``` {.cpp}; void TTree::SetCircular(Long64_t maxEntries);; ```. where `maxEntries` is the maximum number of entries to be kept in the; buffers. When the number of entries exceeds this value, the first; entries in the **`Tree`** are deleted and the buffers used again. An; example of a script using a circular buffer is shown below:. ``` {.cpp}; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");; T->Branch(""py"",&py,""py/F"");; T->Branch(""pz"",&pz,""pz/F"");; T->Branch(""random"",&random,""random/D"");; T->Branch(""i"",&i,""i/s"");; T->SetCircular(20000);; for (i = 0; i < 65000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; random = r.Rndm();; T->Fill();; }; T->Print();; }; ```. ### Size of TTree in the File. When writing a **`TTree`** to a file, if the file size reaches the value; stored in the `TTree::GetMaxTreeSize()`, the current file is closed and; a new file is created. If the original file is named ""`myfile.root`"",; subsequent files are named ""`myfile_1.root`"", ""`myfile_2.root`"", etc. Currently, the automatic change of file is restricted to the case where; the tree is in the top level directory. The file should not contain; sub-directories. Before switching to a new file, the tree header is; written to the current file, then the current file is closed. To process; the multiple files created by `ChangeFile()`, one must use a; **`TChain`**. The new file name has a",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19144,Testability,test,test,19144,"s called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT use",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19257,Testability,test,test,19257," will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This me",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:23242,Testability,test,test,23242,"ecifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. First, we need to open a file and create a tree. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); ```. We need to create a pointer to an `Event` object that will be used as a; reference in the `TTree::Branch` method. Then we create a branch; with the `TTree::Branch` method. ``` {.cpp}; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); ```. To add a branch to hold an object we use the signature above. The first; parameter is the name of the branch. The second parameter is the name of; the class of the object to be stored. The third parameter is the address; of a pointer to the object to be stored. Note that it is an",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:23305,Testability,test,test,23305,"e below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. First, we need to open a file and create a tree. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); ```. We need to create a pointer to an `Event` object that will be used as a; reference in the `TTree::Branch` method. Then we create a branch; with the `TTree::Branch` method. ``` {.cpp}; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); ```. To add a branch to hold an object we use the signature above. The first; parameter is the name of the branch. The second parameter is the name of; the class of the object to be stored. The third parameter is the address; of a pointer to the object to be stored. Note that it is an address of a pointer to the object, not just a; pointer to the object. The fourth parameter is",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34067,Testability,test,test,34067," e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:39101,Testability,test,test,39101,"ad values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When reading the Tree, one can choose one of these 3 options:. Option 1:. ``` {.cpp}; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; ```. This is the default and recommended way to create an object of the class; `Event. `It will be pointed by `event`. At the following entries, `event` will be overwritten by the new data.; All internal members that are **`TObject`**\* are automatically deleted.; It is important that these members be in a valid state when `GetEntry`; is called. Pointers must be correctly initialized. However these; internal members will not be deleted if the characters ""`->`"" are; specified as the first characters in the comment field of the data; member declaration. The pointer me",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:40274,Testability,test,test,40274,"r point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When reading the Tree, one can choose one of these 3 options:. Option 1:. ``` {.cpp}; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; ```. This is the default and recommended way to create an object of the class; `Event. `It will be pointed by `event`. At the following entries, `event` will be overwritten by the new data.; All internal members that are **`TObject`**\* are automatically deleted.; It is important that these members be in a valid state when `GetEntry`; is called. Pointers must be correctly initialized. However these; internal members will not be deleted if the characters ""`->`"" are; specified as the first characters in the comment field of the data; member declaration. The pointer member is read via the `pointer->Streamer(buf)` if ""`->`"" is; specified. In this case, it is assumed that the pointer is never null; (see pointer `TClonesArray *fTracks` in the `$ROOTSYS/test/Event`; example). If ""`->`"" is not specified, the pointer member is read via; `buf >> pointer`. In this case the pointer may be null. Note that the; option with ""`->`"" is faster to read or write and it also consumes less; space in the file. Option 2 - the option `AutoDelete` is set:. ``` {.cpp}; TBranch *branch = T.GetBranch(""event"");; branch->SetAddress(&event);; branch->SetAutoDelete(kTRUE);; for (Int_t i=0; i<nentries; i++) {; T.GetEntry(i); // the object event has been filled at this point; }; ```. At any iteration, the `GetEntry` deletes the object `event` and a new; instance of `Event` is created and filled. Option 3 - same as option 1, but you delete the event yourself:. ``` {.cpp}; for (Int_t i=0; i<nentries; i++) {; delete event;; event = 0; //EXTREMELY IMPORTANT; T.GetEntry(i);; // the objrect event has been filled at this point; }; ```. It is strongly recommended to use the default option 1. It has the; additional advantage ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58046,Testability,test,test,58046,"xTrack-1);; ntrack = nt;; sumstat = 0;; // set the values in each track; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Belo",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58160,Testability,test,test,58160,";; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point numb",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58237,Testability,test,test,58237,",2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described i",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58296,Testability,test,test,58296,"= chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58371,Testability,test,test,58371,"= chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62438,Testability,test,test,62438," intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:64389,Testability,test,test,64389,"nt->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; ```. ### Reading the Tree. First, we check if the shared library with the class definitions is; loaded. If not we load it. Then we read two branches, one for the number; of tracks and one for the entire event. We check the number of tracks; first, and if it meets our condition, we read the entire event. We show; the fist entry that meets the condition. ``` {.cpp}; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Cle",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:68128,Testability,log,logic,68128,"ult), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72840,Testability,log,logical,72840," histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in Batch Mode. The `TTree::Draw` method creates a histogram called `htemp` and puts it; on the active pad. In a batch program, the histogram `htemp` created by; default, is reachable from the current pad. ``` {.cpp}; // draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; ```. If you pipe the result of the `TT",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:76885,Testability,test,test,76885,"w(""Cost:Age"", """",""same"");; }; ```. In this example, `h2->Draw` is only adding the object h2 to the pad's; list of primitives. It does not paint the object on the screen. However,; `TTree::Draw` when called with option ""`same`"" gets the current pad; coordinates to build an intermediate histogram with the right limits.; Since nothing has been painted in the pad yet, the pad limits have not; been computed. Calling `pad->Update()` forces the painting of the pad; and allows `TTree::Draw` to compute the right limits for the; intermediate histogram. ### Setting the Range in TTree::Draw. There are two more optional parameters to the `TTree::Draw` method: one; is the number of entries and the second one is the entry to start with.; For example, this command draws 1000 entries starting with entry 100:. ``` {.cpp}; myTree->Draw(""Cost:Age"", """","""",1000,100);; ```. ### TTree::Draw Examples. The examples below use the `Event.root` file generated by the; `$ROOTSYS/test/Event` executable and the `Event`, `Track`, and; `EventHeader` class definitions are in `$ROOTSYS/test/Event.h`. The; commands have been tested on the split-levels 0, 1, and 9. Each command; is numbered and referenced by the explanations immediately following the; examples. ``` {.cpp}; // Data members and methods; 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""f",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:76988,Testability,test,test,76988,"w(""Cost:Age"", """",""same"");; }; ```. In this example, `h2->Draw` is only adding the object h2 to the pad's; list of primitives. It does not paint the object on the screen. However,; `TTree::Draw` when called with option ""`same`"" gets the current pad; coordinates to build an intermediate histogram with the right limits.; Since nothing has been painted in the pad yet, the pad limits have not; been computed. Calling `pad->Update()` forces the painting of the pad; and allows `TTree::Draw` to compute the right limits for the; intermediate histogram. ### Setting the Range in TTree::Draw. There are two more optional parameters to the `TTree::Draw` method: one; is the number of entries and the second one is the entry to start with.; For example, this command draws 1000 entries starting with entry 100:. ``` {.cpp}; myTree->Draw(""Cost:Age"", """","""",1000,100);; ```. ### TTree::Draw Examples. The examples below use the `Event.root` file generated by the; `$ROOTSYS/test/Event` executable and the `Event`, `Track`, and; `EventHeader` class definitions are in `$ROOTSYS/test/Event.h`. The; commands have been tested on the split-levels 0, 1, and 9. Each command; is numbered and referenced by the explanations immediately following the; examples. ``` {.cpp}; // Data members and methods; 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""f",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:77027,Testability,test,tested,77027,"f primitives. It does not paint the object on the screen. However,; `TTree::Draw` when called with option ""`same`"" gets the current pad; coordinates to build an intermediate histogram with the right limits.; Since nothing has been painted in the pad yet, the pad limits have not; been computed. Calling `pad->Update()` forces the painting of the pad; and allows `TTree::Draw` to compute the right limits for the; intermediate histogram. ### Setting the Range in TTree::Draw. There are two more optional parameters to the `TTree::Draw` method: one; is the number of entries and the second one is the entry to start with.; For example, this command draws 1000 entries starting with entry 100:. ``` {.cpp}; myTree->Draw(""Cost:Age"", """","""",1000,100);; ```. ### TTree::Draw Examples. The examples below use the `Event.root` file generated by the; `$ROOTSYS/test/Event` executable and the `Event`, `Track`, and; `EventHeader` class definitions are in `$ROOTSYS/test/Event.h`. The; commands have been tested on the split-levels 0, 1, and 9. Each command; is numbered and referenced by the explanations immediately following the; examples. ``` {.cpp}; // Data members and methods; 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""fMatrix - fVertex"");; 16 tree->Draw(""fMatrix[2][1] - fVertex[5][1]"");; 17 tree->Draw(""fMatrix[ ][1] - fVertex[5]",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100492,Testability,log,logical,100492," the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100538,Testability,log,logical,100538," the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:105949,Testability,log,log,105949,"e tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; ```. However, if there is a selection criterium which is an array, then all; the formulas will be synchronized with the selection criterium (see; **`TTree::Draw` for more information).**. The third parameter of `TTree::Scan` can be use to specifi",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:105984,Testability,log,log,105984," tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; ```. However, if there is a selection criterium which is an array, then all; the formulas will be synchronized with the selection criterium (see; **`TTree::Draw` for more information).**. The third parameter of `TTree::Scan` can be use to specific the layout; of the table:. - `l",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:115010,Testability,test,test,115010,"; 0; 3; ```. The result is a **`TEntryList`** for a **`TChain`** of `tree1` and; `tree2`. If the second list was for the same **`TTree`** in the same; file as the first list, the result would be as follows:. ``` {.cpp}; root[] TEntryList *list2_2 = new TEntryList(""list2_2"", ""list2_2"");; root[] list2_2->SetTree(""tree2"", ""file2"");; root[] list2_2->Enter(1);; root[] list2_2->Enter(2);; root[] list2->Add(list2_2);; root[] list2->Print(""all""); tree2 file2; 0; 1; 2; 3; ```. #### TEntryListFromFile. This is a special kind of **`TEntryList`**, used only when processing; **`TChain`** objects (see the method `TChain::SetEntryListFile()`). It; is used in the case, when the entry lists, corresponding to the trees of; this chain, are stored in separate files. It allows to load the entry; lists in memory one by one, keeping only the list for the currently; processed tree loaded. For more details on entry lists, see **`TEntryList`**,; **`TEntryListBlock`** and **`TEntryListFromFile`** class descriptions,; functions **`TChain`**`::SetEntryList()`, `TChain::SetEntryListFile()`,; and the macro `$ROOTSYS/test/stressEntryList.C`. ### Filling a Histogram. The `TTree::Draw` method can also be used to fill a specific histogram.; The syntax is:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; ```. As we can see, this created a **`TH1`**, called `myHisto`. If you want; to append more entries to the histogram, you can use this syntax:. ``` {.cpp}; root[] T->Draw(""fNtrack >>+ myHisto""); ```. If you do not create a histogram ahead of time, ROOT will create one at; the time of the Draw command (as is the case above). If you would like; to draw the variable into a specific histogram where you, for example,; set the range and bin number, you can define the histogram ahead of time; and use it in the Draw command. The histogram has to be in the same; directory as the tree. ```",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:122232,Testability,test,test,122232,"l oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; roo",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:122363,Testability,test,test,122363,"own how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:122487,Testability,test,test,122487,"t program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:122878,Testability,test,test,122878," selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`"", and just to verify that we are working; with the correct one, we print the tree, which will show us the header; and branches. ``` {.cpp}; root[] T->Print();; ```. From the output of print we can see that the tree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the n",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:123004,Testability,test,test,123004,"e a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`"", and just to verify that we are working; with the correct one, we print the tree, which will show us the header; and branches. ``` {.cpp}; root[] T->Print();; ```. From the output of print we can see that the tree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the name of the class to be made. In the command; below, the name of our class will b",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:123293,Testability,benchmark,benchmark,123293,"mmand (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`"", and just to verify that we are working; with the correct one, we print the tree, which will show us the header; and branches. ``` {.cpp}; root[] T->Print();; ```. From the output of print we can see that the tree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the name of the class to be made. In the command; below, the name of our class will be ""`MyClass`"". ``` {.cpp}; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; ```. Cling informs us that it has created two files. `MyClass.`h contains the; class definition and `MyClass.C` contains the `MyClass::Loop()` method.; `MyClass` has more methods than just `Loop()`. The other methods a",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:123338,Testability,benchmark,benchmark,123338,"his creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`"", and just to verify that we are working; with the correct one, we print the tree, which will show us the header; and branches. ``` {.cpp}; root[] T->Print();; ```. From the output of print we can see that the tree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the name of the class to be made. In the command; below, the name of our class will be ""`MyClass`"". ``` {.cpp}; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; ```. Cling informs us that it has created two files. `MyClass.`h contains the; class definition and `MyClass.C` contains the `MyClass::Loop()` method.; `MyClass` has more methods than just `Loop()`. The other methods are a; constructor, a destructor, `GetEntry()`, `LoadTree()`, `Notify()`,; `Cut()` and ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:135134,Testability,benchmark,benchmarks,135134,"cess(""MySelector.C++"","""",1000,100);; ```. When appending a ""++"", the class will be compiled and dynamically; loaded. ``` {.cpp}; root[] T->Process(""MySelector.C+"","""",1000,100);; ```. When appending a ""+"", the class will also be compiled and dynamically; loaded. When it is called again, it recompiles only if the macro; (`MySelector.C`) has changed since it was compiled last. If not, it; loads the existing library. The next example shows how to create a; selector with a pointer:. ``` {.cpp}; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; ```. `Using this form, you can do things like:`. ``` {.cpp}; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O performance of; STL vectors to the ROOT native **`TClonesArray`**`s` collection class.; It creates trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increase",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:135169,Testability,test,test,135169," When appending a ""++"", the class will be compiled and dynamically; loaded. ``` {.cpp}; root[] T->Process(""MySelector.C+"","""",1000,100);; ```. When appending a ""+"", the class will also be compiled and dynamically; loaded. When it is called again, it recompiles only if the macro; (`MySelector.C`) has changed since it was compiled last. If not, it; loads the existing library. The next example shows how to create a; selector with a pointer:. ``` {.cpp}; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; ```. `Using this form, you can do things like:`. ``` {.cpp}; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O performance of; STL vectors to the ROOT native **`TClonesArray`**`s` collection class.; It creates trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small pe",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:135900,Testability,benchmark,benchmark,135900,"lic_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O performance of; STL vectors to the ROOT native **`TClonesArray`**`s` collection class.; It creates trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; d",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:136368,Testability,test,test,136368,"ray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; data member of the Event class. The list of tracks (a; **`TClonesArray`**) has the data members of the Track class also; split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. +------------+--------+---------------+---------------+----------------+----------------+; | Event | File | Total Time to | Effective | Total Time to | Total Time to |; | Parameters | Size | Write | Time to Write | Read All | Read Sample |; | | | (MB/sec) | (MB/sec) | (",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:136392,Testability,test,test,136392,"ray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; data member of the Event class. The list of tracks (a; **`TClonesArray`**) has the data members of the Track class also; split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. +------------+--------+---------------+---------------+----------------+----------------+; | Event | File | Total Time to | Effective | Total Time to | Total Time to |; | Parameters | Size | Write | Time to Write | Read All | Read Sample |; | | | (MB/sec) | (MB/sec) | (",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:137087,Testability,test,tests,137087,"ion is increased by a factor of 5 it is still a small percentage; of the total time and it may very well save a factor of 10 on disk; space. On the other hand if the time spend on I/O is large, compression; may slow down the program's performance. The standard test program; `$ROOTSYS/test/Event` was used in various configurations with 400; events. The data file contains a **`TTree`**. The program was invoked; with:. ``` {.cpp}; Event 400 comp split; ```. - comp = 0 means: no compression at all.; - comp = 1 means: compress everything if split = 0.; - comp = 1 means: compress only the tree branches with integers if; split = 1.; - comp = 2 means: compress everything if split=1.; - split = 0 : the full event is serialized into one single buffer.; - split = 1 : the event is split into branches. One branch for each; data member of the Event class. The list of tracks (a; **`TClonesArray`**) has the data members of the Track class also; split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. +------------+--------+---------------+---------------+----------------+----------------+; | Event | File | Total Time to | Effective | Total Time to | Total Time to |; | Parameters | Size | Write | Time to Write | Read All | Read Sample |; | | | (MB/sec) | (MB/sec) | (MB/sec) | (MB/sec) |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 0 | 19.75 | 6.84 s.(2.8 | 3.56 s.(5.4 | 0.79s.(24.2 | 0.79 s.(24.2 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 1 | 17.73 | 6.44 s.(3.0 | 4.02 s.(4.8 | 0.90 s.(21.3 | 0.90 s.(21.3 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 2 | 13.78 | 11.34s.(1.7 | 9.51 s.(2.0 | 2.17 s.(8.8 | 2.17 s.(8.8 |; | | MB | MB/s) | MB/s) | MB/s) | MB/",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:138526,Testability,benchmark,benchmark,138526,"(2.8 | 3.56 s.(5.4 | 0.79s.(24.2 | 0.79 s.(24.2 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 1 | 17.73 | 6.44 s.(3.0 | 4.02 s.(4.8 | 0.90 s.(21.3 | 0.90 s.(21.3 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 2 | 13.78 | 11.34s.(1.7 | 9.51 s.(2.0 | 2.17 s.(8.8 | 2.17 s.(8.8 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+. The **Total Time** is the real time in seconds to run the program.; **Effective time** is the real time minus the time spent in non I/O; operations (essentially the random number generator). The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:138675,Testability,test,test,138675,"/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 1 | 17.73 | 6.44 s.(3.0 | 4.02 s.(4.8 | 0.90 s.(21.3 | 0.90 s.(21.3 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 2 | 13.78 | 11.34s.(1.7 | 9.51 s.(2.0 | 2.17 s.(8.8 | 2.17 s.(8.8 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+. The **Total Time** is the real time in seconds to run the program.; **Effective time** is the real time minus the time spent in non I/O; operations (essentially the random number generator). The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:138853,Testability,test,test,138853," 0.90 s.(21.3 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 2 | 13.78 | 11.34s.(1.7 | 9.51 s.(2.0 | 2.17 s.(8.8 | 2.17 s.(8.8 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+. The **Total Time** is the real time in seconds to run the program.; **Effective time** is the real time minus the time spent in non I/O; operations (essentially the random number generator). The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for h",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139057,Testability,test,test,139057,"| MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+. The **Total Time** is the real time in seconds to run the program.; **Effective time** is the real time minus the time spent in non I/O; operations (essentially the random number generator). The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the p",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139859,Testability,test,test,139859,"his script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:558,Usability,simpl,simple,558,"# Trees. ## Why Should You Use a Tree?. In the ""Input/Output"" chapter, we saw how objects can be saved in ROOT; files. In case you want to store large quantities of same-class objects,; ROOT has designed the **`TTree`** and **`TNtuple`** classes specifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18926,Usability,simpl,simple,18926,"entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems,",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19404,Usability,simpl,simple,19404," one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21782,Usability,simpl,simply,21782,"has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:30693,Usability,simpl,simply,30693,"10-6). If we multiply the number of tracks by 7 s,; (1,000,000,000 \* 7 \* 10-6) we calculate that the time allocating and; freeing memory is about 2 hours. This is the chunk of time saved when a; **`TClonesArray`** is used rather than a **`TObjArray`**. If you do not; want to wait 2 hours for your tracks (or equivalent objects), be sure to; use a **`TClonesArray`** for same-class objects arrays. Branches with; **`TClonesArrays`** use the same method (`TTree::Branch`) as any other; object described above. If splitting is specified the objects in the; **`TClonesArray`** are split, not the **`TClonesArray`** itself. ### Identical Branch Names. When a top-level object (say `event`), has two data members of the same; class the sub branches end up with identical names. To distinguish the; sub branch we must associate them with the master branch by including a; ""`.`"" (a dot) at the end of the master branch name. This will force the; name of the sub branch to be `master.sub` branch instead of simply `sub`; branch. For example, a tree has two branches `Trigger` and; `MuonTrigger`, each containing an object of the same class (`Trigger`).; To identify uniquely the sub branches we add the dot:. ``` {.cpp}; tree->Branch(""Trigger."",""Trigger"",&b1,8000,1);; tree->Branch(""MuonTrigger."",""Trigger"",&b2,8000,1);; ```. If `Trigger` has three members, `T1`, `T2`, `T3`, the two instructions; above will generate sub branches called: `Trigger.T1`, `Trigger.T2`,; `Trigger.T3`, `MuonTrigger.T1`, `MuonTrigger.T2`, and` MuonTrigger.T3`. ## Adding a Branch with a Folder. Use the syntax below to add a branch from a folder:. ``` {.cpp}; tree->Branch(""/aFolder"");; ```. This method creates one branch for each element in the folder. The; method returns the total number of branches created. ## Adding a Branch with a Collection. This `Branch` method creates one branch for each element in the; collection. ``` {.cpp}; tree->Branch(*aCollection, 8000, 99);; // Int_t TTree::Branch(TCollection *list, Int_t ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33243,Usability,simpl,simple,33243," 2`, one top level branch is created for each array; element. If one of the array elements is a **`TCollection`**, one; top level branch will be created for each element of this; collection. In case a collection element is a **`TClonesArray`**, the special Tree; constructor for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the fu",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33499,Usability,simpl,simple,33499,"r for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34930,Usability,simpl,simple,34930,"riable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A sing",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35408,Usability,simpl,simple,35408,"n either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35425,Usability,simpl,simple,35425,"n either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:37642,Usability,simpl,simply,37642,"gma = 1 by calling; `gRandom->Rannor(px,py)`, and calculate` pz`. Then we call the; `TTree::Fill()` method. The call `t1.Fill()` fills all branches in the; tree because we have already organized the tree into branches and told; each branch where to get the value from. After this script is executed; we have a ROOT file called `tree1.root` with a tree called `t1`. There; is a possibility to fill branches one by one using the method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have bee",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:43464,Usability,simpl,simple,43464,"he generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; ```. ## Example 2: A Tree with a C Structure. The executable script for this example is; `$ROOTSYS/tutorials/tree/tree2.C. `In this example we show:. - how to build branches from a C structure; - how to make a branch with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The ca",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:51307,Usability,simpl,simple,51307,"ep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58014,Usability,simpl,simplified,58014,"xTrack-1);; ntrack = nt;; sumstat = 0;; // set the values in each track; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Belo",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62083,Usability,simpl,simple,62083,"bject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(et",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:65333,Usability,clear,clear,65333,"Event.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Clear();; }. if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ```. Now, let's see how the tree looks like in the tree viewer. ![The tree viewer with tree4 example](pictures/03000103.png). You can see the two branches in the tree in the left panel: the event; branch is split and hence expands when clicked on. The other branch; event not split is not expandable and we can not browse the data; members. The **`TClonesArray`** of tracks `fTracks` is also split because we set; the split level to 2. The output on the command line is the result of; `tree4->Show()`. It shows the first entry with more than 587 tracks:. ``` {.cpp}; ======> EVENT:26; event_split =; fUniqueID = 0; fBits = 50331648; fType[20] = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; fNtrack = 585; fNseg = 5834; fNvertex = 17; fFlag = 0; fTemperature = 20.044315; fEvtHdr.fEvtNum = 26; fEvtHdr.fRun = 200; fEvtHdr.fDate = 960312; fTracks = 585; fTracks.fUniqueI",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:66660,Usability,simpl,simply,66660,"he other branch; event not split is not expandable and we can not browse the data; members. The **`TClonesArray`** of tracks `fTracks` is also split because we set; the split level to 2. The output on the command line is the result of; `tree4->Show()`. It shows the first entry with more than 587 tracks:. ``` {.cpp}; ======> EVENT:26; event_split =; fUniqueID = 0; fBits = 50331648; fType[20] = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; fNtrack = 585; fNseg = 5834; fNvertex = 17; fFlag = 0; fTemperature = 20.044315; fEvtHdr.fEvtNum = 26; fEvtHdr.fRun = 200; fEvtHdr.fDate = 960312; fTracks = 585; fTracks.fUniqueID = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ...; ```. ## Example 5: Import an ASCII File into a TTree. The method `TTree::ReadFile` can be used to automatic define the; structure of the **`TTree`** and read the data from a formatted ascii; file. ``` {.cpp}; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); ```. Creates or simply read branches from the file named whose name is passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** metho",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67714,Usability,simpl,simple,67714,"s passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:69116,Usability,simpl,simply,69116,"o do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:70843,Usability,simpl,simple,70843,"ot[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In general, this parameter is; a string that contains up to three expressions, one for each dimension,; separated by a colon (""`e1:e2:e3`""). A list of examples follows this; introduction. ### Using Selection with TTree:Draw. Change the active pad to 3, and add a selection to the list of; parameters of the draw command. ``` {.cpp}; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); ```. This will draw the `Cost `vs. `Age` for the entries where the nation is; equal to ""`FR`"". You can use any C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates t",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:96052,Usability,simpl,simple,96052,"r2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and equally spaced. A point in n-dimensional; space is represented as a polyline with vertices on the parallel axes.; The position of the vertex on the i-th axis corresponds to the i-th; coordinate of the point. The three following figures show some very; simple examples:. ![The Parallel Coordinates representation of the six dimensional point `(-5,3,4,2,0,1)`.](pictures/para1.png). ![The line `y = -3x+20` and a circle in Parallel Coordinates.](pictures/para2.png). The Parallel Coordinates technique is good at: spotting irregular; events, seeing the data trend, finding correlations and clusters. Its; main weakness is the cluttering of the output. Because each “point” in; the multidimensional space is represented as a line, the output is very; quickly opaque and therefore it is difficult to see the data clusters.; Most of the work done about Parallel Coordinates is to find techniques; to reduce the output’s cluttering. The Parallel Coordinates plots in; ROOT have been implemented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TN",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99044,Usability,clear,clearly,99044,"produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99177,Usability,simpl,simple,99177,"ques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99362,Usability,clear,clearly,99362,"prove the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to defi",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99537,Usability,simpl,simple,99537," show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with log",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100043,Usability,clear,clearly,100043,"n the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100179,Usability,clear,clear,100179,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101029,Usability,clear,clearly,101029,"the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101600,Usability,clear,clearly,101600,"the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined allows to select exactly the two; correlated “random spheres”. ![Output of `nt->Draw(“x:y:z”)` and `nt->Draw(“u:v:w”)` after applying the selection.](pictures/para10.png). Another technique has been implemented in order to show clusters when; the picture is cluttered. A weight is assigned to each event. The weight; value is computed as:; $$; weight = \sum_{i=1}^{n} b_i; $$. Where:. - bi is the content of bin crossed by the event on the i-th axis.; - n is the number of axis. The events having the bigger weights are those belongin",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:103608,Usability,clear,clearly,103608,"r weights are those belonging to clusters.; It is possible to paint only the events having a weight above a given; value and the clusters appear. The next example “weight cut” applied on; the right plot is 50. Only the events with a weight greater than 50 are displayed. ![Applying a “weight cut” makes the clusters visible.](pictures/para11.png). In case only a few events are displayed, drawing them as smooth curves; instead of straight lines helps to differentiate them. ![Zoom on a Parallel Coordinates plot detail: curves differentiate better events.](pictures/para12.png). Interactivity and therefore the Graphical User Interface are very important; to manipulate the Parallel Coordinates plots. The ROOT framework allows; to easily implement the direct interactions on the graphical area and the; graphical editor facility provides dedicated GUI. ![Parallel Coordinates graphical editors.](pictures/para13.png). Transparency is very useful with parallel coordinates plots. It allows to; show clearly the clusters.; \index{transparency!parallel coordinates}. ![Parallel Coordinates with transparency.](pictures/para14.png). #### Box (Candle) Plots; \index{candle plot}; \index{candle stick plot}; \index{box-and whisker plot}. A Box Plot (also known as a “box-and whisker” plot or “candle stick” plot); is a convenient way to describe graphically a data distribution (D) with only; the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:105498,Usability,pause,pauses,105498,"ts) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* a",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:121752,Usability,simpl,simplified,121752," example if you want to; draw a graph connecting all the `x`, `y(or z)` points. Note that you may; have a tree (or chain) with 1 billion entries, but only a few may; survive the cuts and will fit without problems in these arrays. ## Using TTree::MakeClass; \index{tree!MakeClass}. The `TTree::Draw` method is convenient and easy to use; however it falls; short if you need to do some programming with the variable. For example, for plotting the masses of all oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; ",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:121977,Usability,simpl,simple,121977,". The `TTree::Draw` method is convenient and easy to use; however it falls; short if you need to do some programming with the variable. For example, for plotting the masses of all oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test i",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:124665,Usability,clear,clear,124665,"ree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the name of the class to be made. In the command; below, the name of our class will be ""`MyClass`"". ``` {.cpp}; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; ```. Cling informs us that it has created two files. `MyClass.`h contains the; class definition and `MyClass.C` contains the `MyClass::Loop()` method.; `MyClass` has more methods than just `Loop()`. The other methods are a; constructor, a destructor, `GetEntry()`, `LoadTree()`, `Notify()`,; `Cut()` and `Show()`. The implementations of these methods are in the .h; file. This division of methods was done intentionally. The .C file is; kept as short as possible, and contains only code that is intended for; you to customize. The .h file contains all the other methods. It is; clear that you want to be as independent as possible of the header file; (i.e. `MyClass.h`) generated by `MakeClass`. The solution is to; implement a derived class, for example `MyRealClass` deriving from; `MyClass` such that a change in your `Tree `or regeneration of; `MyClass.h` does not force you to change `MyRealClass.h`. You can; imagine deriving several classes from `MyClass.h`, each with a specific; algorithm. To understand both files, let's start with `MyClass.h` and; the class declaration:. ### MyClass.h. ``` {.cpp}; class MyClass {; public :; // Pointer to the analyzed TTree or TChain; TTree *fChain;; // Current Tree number in a TChain; Int_t fCurrent;; // Declaration of leaves types; UInt_t fUniqueID;; UInt_t fBits;; Char_t fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; Int_t fEvtHdr_fEvtNum;; // List of branches; TBranch *b_fUniqueID;; TBranch *b_fBits;; TBranch *b_fType;; TBranch *b_fNtrack;; TBranch *b_fNseg;; TBranch *b_fNvertex;; TBranch *b_fFlag;; TBran",MatchSource.DOCS,documentation/users-guide/Trees.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:86,Deployability,install,installation,86,"# The Tutorials and Tests. This chapter is a guide to the examples that come with the installation; of ROOT. They are located in two directories: `$ROOTSYS/tutorials` and; `$ROOTSYS/test`. ## \$ROOTSYS/tutorials. ![](pictures/030001F9.png). The tutorials directory contains many example; scripts. *To have all examples working you must have write permission; and you will need to execute`hsimple.C` first*. If you do not have write; permission in the directory` $ROOTSYS/tutorials`, copy the entire; directory to your area. The script `hsimple.C` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test progra",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:914,Deployability,patch,patches,914,"# The Tutorials and Tests. This chapter is a guide to the examples that come with the installation; of ROOT. They are located in two directories: `$ROOTSYS/tutorials` and; `$ROOTSYS/test`. ## \$ROOTSYS/tutorials. ![](pictures/030001F9.png). The tutorials directory contains many example; scripts. *To have all examples working you must have write permission; and you will need to execute`hsimple.C` first*. If you do not have write; permission in the directory` $ROOTSYS/tutorials`, copy the entire; directory to your area. The script `hsimple.C` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test progra",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:1602,Deployability,release,release,1602,"it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:1687,Deployability,release,release,1687,"it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:13716,Deployability,release,released,13716,"ng capabilities of the ROOT framework. - Functions, Random Numbers, Histogram Fits. - Size & compression factor of a ROOT file. - Purge, Reuse of gaps in **`TFile`**. - 2D Histograms, Functions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2540,Integrability,interface,interface,2540,"directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+; | ctorture.cxx | Test program for the class **`TComplex`** |; +-------------------+--------------------------------------------------------+; | `tstring.cxx` | Example usage of the ROOT string class |; +-------------------+--------------------------------------------------------+; | `vmatr",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:6131,Modifiability,variab,variable,6131,"--------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a ROOT file with a tree and two histograms. When running `Event`; we have four optional arguments with defaults:. +-----+---------------------------------------------------------+--------------+; | | Argument | Default |; +-----+---------------------------------------------------------+--------------+; | 1 | Number of Events (1 ... n) | 400 |; +-----+---------------------------------------------------------+--------------+; | 2 | Compression level: | 1 |; | | | |; | | 0: no compression at all. | |; | | | |; | | 1: If the split level is set to zero, everything is | |; | | compressed according to the `gzip` level 1. If split | |; | | lev",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:8087,Modifiability,variab,variable,8087,": no compression at all. | |; | | | |; | | 1: If the split level is set to zero, everything is | |; | | compressed according to the `gzip` level 1. If split | |; | | level is set to 1, leaves that are not floating point | |; | | numbers are compressed using the `gzip` level 1. | |; | | | |; | | 2: If the split level is set to zero, everything is | |; | | compressed according to the `gzip` level 2. If split | |; | | level is set to 1, all non floating point leaves are | |; | | compressed according to the `gzip` level 2 and the | |; | | floating point leaves are compressed according to the | |; | | `gzip` level 1 (`gzip` level -1). | |; | | | |; | | Floating point numbers are compressed differently | |; | | because the gain when compressing them is about 20 - | |; | | 30%. For other data types it is generally better and | |; | | around 100%. | |; +-----+---------------------------------------------------------+--------------+; | 3 | Split or not Split | 1 |; | | | |; | | 0: only one single branch is created and the complete | (Split) |; | | event is serialized in one single buffer | |; | | | |; | | 1: a branch per variable is created. | |; +-----+---------------------------------------------------------+--------------+; | 4 | Fill | 1 |; | | | |; | | 0: read the file | (Write, no |; | | | fill) |; | | 1: write the file, but don't fill the histograms | |; | | | |; | | 2: don't write, don't fill the histograms | |; | | | |; | | 10: fill the histograms, don't write the file | |; | | | |; | | 11: fill the histograms, write the file | |; | | | |; | | 20: read the file sequentially | |; | | | |; | | 25: read the file at random | |; +-----+---------------------------------------------------------+--------------+. #### Effect of Compression on File Size and Write Times. You may have noticed that a ROOT file has up to nine compression level,; but here only levels 0, 1, and 2 are described. Compression levels above; 2 are not competitive. They take up to much write time compared",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:14341,Performance,perform,performance,14341,"Cb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Ev",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:14538,Performance,perform,performance,14538," aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare h",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:182,Testability,test,test,182,"# The Tutorials and Tests. This chapter is a guide to the examples that come with the installation; of ROOT. They are located in two directories: `$ROOTSYS/tutorials` and; `$ROOTSYS/test`. ## \$ROOTSYS/tutorials. ![](pictures/030001F9.png). The tutorials directory contains many example; scripts. *To have all examples working you must have write permission; and you will need to execute`hsimple.C` first*. If you do not have write; permission in the directory` $ROOTSYS/tutorials`, copy the entire; directory to your area. The script `hsimple.C` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test progra",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:1495,Testability,test,test,1495,"e entire; directory to your area. The script `hsimple.C` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:1505,Testability,test,test,1505,"` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling inter",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:1674,Testability,test,test,1674,"it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:1867,Testability,test,test,1867,"://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` |",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:1990,Testability,test,test,1990,"----------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2159,Testability,test,test,2159,"lick on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2823,Testability,test,test,2823,"ms. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+; | ctorture.cxx | Test program for the class **`TComplex`** |; +-------------------+--------------------------------------------------------+; | `tstring.cxx` | Example usage of the ROOT string class |; +-------------------+--------------------------------------------------------+; | `vmatrix.cxx` | Verification program for the **`TMatrix`** class |; +-------------------+--------------------------------------------------------+; | `vvector.cxx` | Verification program for the **`TVector `**class |; +-------------------+--------------------------------------------------------+; | `vlazy.cxx` | Verification program for lazy matrices |; +----------------",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:4807,Testability,test,testing,4807,"y matrices |; +-------------------+--------------------------------------------------------+; | `hworld.cxx` | Small program showing basic graphics |; +-------------------+--------------------------------------------------------+; | `guitest.cxx` | Example usage of the ROOT GUI classes |; +-------------------+--------------------------------------------------------+; | `gui` `viewer` | Another ROOT GUI example program |; | `.cxx` | |; +-------------------+--------------------------------------------------------+; | `Hello.cxx` | Dancing text example |; +-------------------+--------------------------------------------------------+; | `Aclock.cxx` | Analog clock (a la X11 `xclock`) |; +-------------------+--------------------------------------------------------+; | `Tetris.cxx` | The known Tetris game based on the ROOT graphics |; +-------------------+--------------------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. I",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:4931,Testability,test,testing,4931,"raphics |; +-------------------+--------------------------------------------------------+; | `guitest.cxx` | Example usage of the ROOT GUI classes |; +-------------------+--------------------------------------------------------+; | `gui` `viewer` | Another ROOT GUI example program |; | `.cxx` | |; +-------------------+--------------------------------------------------------+; | `Hello.cxx` | Dancing text example |; +-------------------+--------------------------------------------------------+; | `Aclock.cxx` | Analog clock (a la X11 `xclock`) |; +-------------------+--------------------------------------------------------+; | `Tetris.cxx` | The known Tetris game based on the ROOT graphics |; +-------------------+--------------------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5087,Testability,test,test,5087,"+-------------------+--------------------------------------------------------+; | `gui` `viewer` | Another ROOT GUI example program |; | `.cxx` | |; +-------------------+--------------------------------------------------------+; | `Hello.cxx` | Dancing text example |; +-------------------+--------------------------------------------------------+; | `Aclock.cxx` | Analog clock (a la X11 `xclock`) |; +-------------------+--------------------------------------------------------+; | `Tetris.cxx` | The known Tetris game based on the ROOT graphics |; +-------------------+--------------------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variab",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5096,Testability,benchmark,benchmarking,5096,"+-------------------+--------------------------------------------------------+; | `gui` `viewer` | Another ROOT GUI example program |; | `.cxx` | |; +-------------------+--------------------------------------------------------+; | `Hello.cxx` | Dancing text example |; +-------------------+--------------------------------------------------------+; | `Aclock.cxx` | Analog clock (a la X11 `xclock`) |; +-------------------+--------------------------------------------------------+; | `Tetris.cxx` | The known Tetris game based on the ROOT graphics |; +-------------------+--------------------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variab",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5446,Testability,test,test,5446,"| `Aclock.cxx` | Analog clock (a la X11 `xclock`) |; +-------------------+--------------------------------------------------------+; | `Tetris.cxx` | The known Tetris game based on the ROOT graphics |; +-------------------+--------------------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a RO",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5676,Testability,test,test,5676,"---------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a ROOT file with a tree and two histograms. When running `Event`; we have four optional arguments with defaults:. +-----+---------------------------------------------------------+--------------+; | | Argument | Default |; +-----+--------",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5839,Testability,test,test,5839,"ng program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a ROOT file with a tree and two histograms. When running `Event`; we have four optional arguments with defaults:. +-----+---------------------------------------------------------+--------------+; | | Argument | Default |; +-----+---------------------------------------------------------+--------------+; | 1 | Number of Events (1 ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5900,Testability,test,test,5900,"stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a ROOT file with a tree and two histograms. When running `Event`; we have four optional arguments with defaults:. +-----+---------------------------------------------------------+--------------+; | | Argument | Default |; +-----+---------------------------------------------------------+--------------+; | 1 | Number of Events (1 ... n) | 400 |; +-----+---------------------------------------------------------+--------------+;",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5944,Testability,test,test,5944,"stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a ROOT file with a tree and two histograms. When running `Event`; we have four optional arguments with defaults:. +-----+---------------------------------------------------------+--------------+; | | Argument | Default |; +-----+---------------------------------------------------------+--------------+; | 1 | Number of Events (1 ... n) | 400 |; +-----+---------------------------------------------------------+--------------+;",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:12694,Testability,test,tests,12694,"-+-------------------+---------------+. #### Setting the Split Level. ![](pictures/080001FA.png). Split Level = 0: \; Now we execute Event with the split parameter set to 0:. ``` {.cpp}; > Event 400 1 0 1; > root; root[] TFile f(""Event.root""); root[] TBrowser T; ```. We notice that only one branch is visible (event). The individual data; members of the `Event` object are no longer visible in the browser. They; are contained in the event object on the event branch, because we; specified no splitting. Split Level = 1:. Setting the split level to 1 will create a branch for each data member; in the Event object. First we execute `Event` and set the split level to; 1 and start the browser to examine the split tree:. ``` {.cpp}; > Event 400 1 1 1; ```. ``` {.cpp}; > root; root[] TFile f(""Event.root""); root[] TBrowser browser; ```. ![](pictures/080001FB.png). ### stress - Test and Benchmark. The executable stress is created by compiling `stress.cxx`. It completes; sixteen tests covering the following capabilities of the ROOT framework. - Functions, Random Numbers, Histogram Fits. - Size & compression factor of a ROOT file. - Purge, Reuse of gaps in **`TFile`**. - 2D Histograms, Functions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:13237,Testability,test,test,13237,"= 1:. Setting the split level to 1 will create a branch for each data member; in the Event object. First we execute `Event` and set the split level to; 1 and start the browser to examine the split tree:. ``` {.cpp}; > Event 400 1 1 1; ```. ``` {.cpp}; > root; root[] TFile f(""Event.root""); root[] TBrowser browser; ```. ![](pictures/080001FB.png). ### stress - Test and Benchmark. The executable stress is created by compiling `stress.cxx`. It completes; sixteen tests covering the following capabilities of the ROOT framework. - Functions, Random Numbers, Histogram Fits. - Size & compression factor of a ROOT file. - Purge, Reuse of gaps in **`TFile`**. - 2D Histograms, Functions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:13323,Testability,test,test,13323,"object. First we execute `Event` and set the split level to; 1 and start the browser to examine the split tree:. ``` {.cpp}; > Event 400 1 1 1; ```. ``` {.cpp}; > root; root[] TFile f(""Event.root""); root[] TBrowser browser; ```. ![](pictures/080001FB.png). ### stress - Test and Benchmark. The executable stress is created by compiling `stress.cxx`. It completes; sixteen tests covering the following capabilities of the ROOT framework. - Functions, Random Numbers, Histogram Fits. - Size & compression factor of a ROOT file. - Purge, Reuse of gaps in **`TFile`**. - 2D Histograms, Functions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:13382,Testability,test,test,13382," browser to examine the split tree:. ``` {.cpp}; > Event 400 1 1 1; ```. ``` {.cpp}; > root; root[] TFile f(""Event.root""); root[] TBrowser browser; ```. ![](pictures/080001FB.png). ### stress - Test and Benchmark. The executable stress is created by compiling `stress.cxx`. It completes; sixteen tests covering the following capabilities of the ROOT framework. - Functions, Random Numbers, Histogram Fits. - Size & compression factor of a ROOT file. - Purge, Reuse of gaps in **`TFile`**. - 2D Histograms, Functions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a referenc",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:13879,Testability,test,test,13879,"tions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 :",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:13933,Testability,test,test,13933,"tions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 :",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:14102,Testability,test,test,14102,". - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subd",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:14145,Testability,test,test,14145,". - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subd",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:14233,Testability,test,test,14233,"and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with; 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : T",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:15541,Testability,test,test,15541,"; better performance. The reference machine has 200 ROOTMARKS, so the; sample run below with 53.7 ROOTMARKS is about four times slower than the; reference machine. Here is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; ```. ### guitest - A Graphical User Interface; \index{GUI application}. The `guitest` example, created by compiling `guitest.cxx`, tests and; illustrates the use of the native GUI widgets such as cascading menus,; dia",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:15696,Testability,test,test,15696,"e is a sample run:. ``` {.cpp}; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; ```. ### guitest - A Graphical User Interface; \index{GUI application}. The `guitest` example, created by compiling `guitest.cxx`, tests and; illustrates the use of the native GUI widgets such as cascading menus,; dialog boxes, sliders and tab panels. It is a very useful example to; study when designing a GUI. Some examples of the output of `guitest` are; shown next. To run it typ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:15801,Testability,test,test,15801," Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; ```. ### guitest - A Graphical User Interface; \index{GUI application}. The `guitest` example, created by compiling `guitest.cxx`, tests and; illustrates the use of the native GUI widgets such as cascading menus,; dialog boxes, sliders and tab panels. It is a very useful example to; study when designing a GUI. Some examples of the output of `guitest` are; shown next. To run it type `guitest` at the system prompt in the; `$ROOTSYS/test` directory. We have included an entire chapter on this; sub",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:16444,Testability,test,tests,16444,"d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; ```. ### guitest - A Graphical User Interface; \index{GUI application}. The `guitest` example, created by compiling `guitest.cxx`, tests and; illustrates the use of the native GUI widgets such as cascading menus,; dialog boxes, sliders and tab panels. It is a very useful example to; study when designing a GUI. Some examples of the output of `guitest` are; shown next. To run it type `guitest` at the system prompt in the; `$ROOTSYS/test` directory. We have included an entire chapter on this; subject where we explore `guitest` in detail and use it to explain how; to build our own ROOT application with a GUI. See ""Writing a Graphical; User Interface"". ![Native GUI widgets](pictures/030001FC.png); ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:16747,Testability,test,test,16747,"d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; ```. ### guitest - A Graphical User Interface; \index{GUI application}. The `guitest` example, created by compiling `guitest.cxx`, tests and; illustrates the use of the native GUI widgets such as cascading menus,; dialog boxes, sliders and tab panels. It is a very useful example to; study when designing a GUI. Some examples of the output of `guitest` are; shown next. To run it type `guitest` at the system prompt in the; `$ROOTSYS/test` directory. We have included an entire chapter on this; subject where we explore `guitest` in detail and use it to explain how; to build our own ROOT application with a GUI. See ""Writing a Graphical; User Interface"". ![Native GUI widgets](pictures/030001FC.png); ",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:45,Usability,guid,guide,45,"# The Tutorials and Tests. This chapter is a guide to the examples that come with the installation; of ROOT. They are located in two directories: `$ROOTSYS/tutorials` and; `$ROOTSYS/test`. ## \$ROOTSYS/tutorials. ![](pictures/030001F9.png). The tutorials directory contains many example; scripts. *To have all examples working you must have write permission; and you will need to execute`hsimple.C` first*. If you do not have write; permission in the directory` $ROOTSYS/tutorials`, copy the entire; directory to your area. The script `hsimple.C` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test progra",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2234,Usability,simpl,simple,2234,"lick on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+",MatchSource.DOCS,documentation/users-guide/TutorialsandTests.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:155,Integrability,interface,interface,155,"# Web-based display. In this chapter discussed how web-based display can be created in the ROOT. ## Basics. Idea of web displays is implementation of user interface, which can run remotely; or locally in the web-browsers, fully decoupled from the application code.; For the communication between application and browser websockets are used. ## Creating web-window. **`ROOT::RWebWindow`** class is represent window instance, which can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full ",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:1264,Integrability,message,messages,1264,"d browser websockets are used. ## Creating web-window. **`ROOT::RWebWindow`** class is represent window instance, which can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections c",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:1444,Integrability,message,message,1444,"ch can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides funct",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:3233,Integrability,message,message,3233,"e client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYPE HTML>; <html>; <head>; <meta charset=""utf-8"">; <title>RWebWindow Example</title>; </head>; <body>; <div id=""main""></div>; <script type=""module"">; import { connectWebWindow } from './jsrootsys/modules/webwindow.mjs';; connectWebWindow({; receiver: {; onWebsocketOpened(handle) {; console.log('Connected');; handle.send('Init msg from client');; },; onWebsocketMsg(handle, msg) {; console.log('Get message ' + msg);; document.getElementById('main').innerHTML = msg;; },; onWebsocketClosed(handle) {; // when connection closed, close panel as well; if (window) window.close();; }; }; });; </script>; </body>; </html>. ```; ",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:712,Modifiability,config,configure,712,"# Web-based display. In this chapter discussed how web-based display can be created in the ROOT. ## Basics. Idea of web displays is implementation of user interface, which can run remotely; or locally in the web-browsers, fully decoupled from the application code.; For the communication between application and browser websockets are used. ## Creating web-window. **`ROOT::RWebWindow`** class is represent window instance, which can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full ",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:1871,Modifiability,config,configured,1871,"allback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYP",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:2543,Modifiability,config,configured,2543,"e client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYPE HTML>; <html>; <head>; <meta charset=""utf-8"">; <title>RWebWindow Example</title>; </head>; <body>; <div id=""main""></div>; <script type=""module"">; import { connectWebWindow } from './jsrootsys/modules/webwindow.mjs';; connectWebWindow({; receiver: {; onWebsocketOpened(handle) {; console.log('Connected');; handle.send('Init msg from client');; },; onWebsocketMsg(handle, msg) {; console.log('Get message ' + msg);; document.getElementById('main').innerHTML = msg;; },; onWebsocketClosed(handle) {; // when connection closed, close panel as well; if (window) window.close();; }; }; });; </script>; </body>; </html>. ```; ",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:3124,Testability,log,log,3124,"e client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYPE HTML>; <html>; <head>; <meta charset=""utf-8"">; <title>RWebWindow Example</title>; </head>; <body>; <div id=""main""></div>; <script type=""module"">; import { connectWebWindow } from './jsrootsys/modules/webwindow.mjs';; connectWebWindow({; receiver: {; onWebsocketOpened(handle) {; console.log('Connected');; handle.send('Init msg from client');; },; onWebsocketMsg(handle, msg) {; console.log('Get message ' + msg);; document.getElementById('main').innerHTML = msg;; },; onWebsocketClosed(handle) {; // when connection closed, close panel as well; if (window) window.close();; }; }; });; </script>; </body>; </html>. ```; ",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:3224,Testability,log,log,3224,"e client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYPE HTML>; <html>; <head>; <meta charset=""utf-8"">; <title>RWebWindow Example</title>; </head>; <body>; <div id=""main""></div>; <script type=""module"">; import { connectWebWindow } from './jsrootsys/modules/webwindow.mjs';; connectWebWindow({; receiver: {; onWebsocketOpened(handle) {; console.log('Connected');; handle.send('Init msg from client');; },; onWebsocketMsg(handle, msg) {; console.log('Get message ' + msg);; document.getElementById('main').innerHTML = msg;; },; onWebsocketClosed(handle) {; // when connection closed, close panel as well; if (window) window.close();; }; }; });; </script>; </body>; </html>. ```; ",MatchSource.DOCS,documentation/users-guide/WebDisplay.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21597,Availability,avail,available,21597,"derstanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the widget's; events, the widget status flags and the assigned command (if there is; any). The general properties of **`TGWidget`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gathering via `GetCommand()` method. For example,; the third parameter in **`TGTextButton`** constructor can be omitted and; set later in your program, i.e. instead of:. ``` {.cpp}; TGTextButton *exit = new TGTextBu",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:38853,Availability,avail,available,38853,"HintsTop` | specifies the frame position to the top of the |; | | container frame, below any laid out frames with the |; | | same hint |; +------------------+---------------------------------------------------------+; | `kLHintsCenterY` | specifies the frame position centered vertically (with |; | | horizontal containers only) |; +------------------+---------------------------------------------------------+; | `kLHintsBottom` | specifies the frame position to the bottom of the |; | | container frame, above any laid out frames with the |; | | same hint |; +------------------+---------------------------------------------------------+; | `kLHintsExpandX` | specifies the frame to be expanded up to the width of |; | | the container frame. If the container frame is a |; | | vertical frame - it will fit the whole width. If it is |; | | a horizontal frame - after the positioning of all |; | | frames the available ""free"" width space is shared |; | | between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsExpandY` | specifies the frame to be expanded up to the height of |; | | the container frame. If the container frame is a |; | | horizontal frame - it will fit the whole height. If the |; | | container frame is a vertical frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:39305,Availability,avail,available,39305," bottom of the |; | | container frame, above any laid out frames with the |; | | same hint |; +------------------+---------------------------------------------------------+; | `kLHintsExpandX` | specifies the frame to be expanded up to the width of |; | | the container frame. If the container frame is a |; | | vertical frame - it will fit the whole width. If it is |; | | a horizontal frame - after the positioning of all |; | | frames the available ""free"" width space is shared |; | | between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsExpandY` | specifies the frame to be expanded up to the height of |; | | the container frame. If the container frame is a |; | | horizontal frame - it will fit the whole height. If the |; | | container frame is a vertical frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window sy",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56029,Availability,avail,available,56029,"wards. A text button is represented by the class **`TGTextButton`**. We already; used its constructor in the example. The button label indicates the; action to be taken when the button is selected or pressed. The text can; be a hot string defining a hot key (known as shortcut key also) for this; selection. The hot key is an underlined character in a button label that; shows the assigned keyboard mnemonic for its choice. A button that; prompts more information for users has the label generally followed by; ellipsis (...). ![](pictures/0300020D.png). As we saw the hot strings ""&Draw"" and ""&Exit"" define the text labels; ""Draw"" and ""Exit"" and keyboard mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed in",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:58658,Availability,down,down,58658," side. They are most frequently used to quickly; access commands, many of which are normally accessed through the tool; bar. For example, the picture buttons below can be used to provide; different styles of a histogram drawing. ![](pictures/0200020F.jpg). Here is the example how to create the first button:. ``` {.cpp}; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; ```. The picture of file h1\_s.xpm is used in the button. All `.xpm` files; are located in the directory `$ROOTSYS/icons`. You can assign a command; directly as a parameter of the picture button constructor. The picture; of **`TGPictureButton`** can be changed by:. ``` {.cpp}; fPicture->SetPicture(""h2_s.xpm"");; ```. The advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadvantage of the text and picture buttons is that they consume; considerable screen space if they are many. Having no more than six; command buttons per window or dialog box helps to appropriately balance; the application's effectiveness, its real efficiency, and the; operational simplicity. The classes **`TGRadioButton`** and **`TGCheckButton`** present the; option buttons in ROOT. Like the text buttons, they have text or hot; string as a label. Radio buttons are grouped in logical sets of two or; more and appear with a text label to the right. The choices are mutually; exclusive and only one setting is permitted at one time. They represent; visually all alternatives and it is easy to access and compare choices.; They facilitate the situations where all alternatives cannot be easily; remembered or where displaying the alternatives together helps to; understand and select the proper choice. It is very useful to provide a; de",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:64333,Availability,echo,echo,64333,"meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contains text; that is entered or modified through the keyboard. This text may be; displayed in different way according to the set echo mode. Users can; control them by` SetEchoMode()`, `GetEchoMode()` methods. - `kNormal` - display characters as they are entered (default);. - `kNoEcho` - do not display anything;. - `kPassword` - display asterisks instead of the characters actually; entered. The way in which typed characters are inserted in the text entry is; defined by `TGTextEntry::EInsertMode` and can be toggled by the Insert; key:. - `kInsert` - typed character are inserted (cursor has shape of short; line). - `kReplace` - entered characters substitute already typed ones; (cursor has the shape of filled rectangle). ![](pictures/03000214.png) ![](pictures/03000215.png). There ate different text alignment modes defined by; `TGWidget::ETextJustification`. They are valid until text fits the frame; width of the text entry field. - `kTextLeft` - left-side text alignment. - `kTextRight` - right-side text alignment. - `kTextCenterX` - center text alignment along x direction. - `kTextTop` - ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:65602,Availability,down,down,65602,"e characters actually; entered. The way in which typed characters are inserted in the text entry is; defined by `TGTextEntry::EInsertMode` and can be toggled by the Insert; key:. - `kInsert` - typed character are inserted (cursor has shape of short; line). - `kReplace` - entered characters substitute already typed ones; (cursor has the shape of filled rectangle). ![](pictures/03000214.png) ![](pictures/03000215.png). There ate different text alignment modes defined by; `TGWidget::ETextJustification`. They are valid until text fits the frame; width of the text entry field. - `kTextLeft` - left-side text alignment. - `kTextRight` - right-side text alignment. - `kTextCenterX` - center text alignment along x direction. - `kTextTop` - top-side text alignment. - `kTextBottom` - bottom-side text alignment. - `kTextCenterY` - center text alignment along y direction. ### Number Entries. The **`TGNumberEntry`** class present number entry widgets. A number; entry is a single-line field followed by two small, vertically arranged; up-down buttons. Its purpose is to make a selection by either scrolling; through a small set of meaningful predefined choices or typing numbers.; The **`TGNumberFormat`** class contains `enum` types to specify the; numeric format. The number entry widget is based on; **`TGTextEntry`**. It allows only numerical input. The widget supports; numerous formats including integers, hex numbers, real numbers, fixed; fraction real and time/date formats. It also allows to restrict input; values to non-negative or positive numbers and to specify explicit; limits. ![](pictures/03000216.png). The following styles are supported:. - `kNESInteger` - integer number. - `kNESRealOne` - real number with one digit (no exponent). - `kNESRealTwo` - real number with two digits (no exponent). - `kNESRealThree` - real number with three digits (no exponent). - `kNESRealFour` - real number with four digits (no exponent). - `kNESReal` - arbitrary real number. - `kNESDegree` - angle",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:68015,Availability,down,down,68015,"ber` - any number is allowed. - `kNEANonNegative` - only non-negative numbers are allowed. - `kNEAPositive` - only positive numbers are allowed. Explicit limits can be specified individually:. - `kNELNoLimits` - no limits. - `kNELLimitMin` - lower limit only. - `kNELLimitMax` - upper limit only. - `kNELLimitMinMax` - both lower and upper limits. ``` {.cpp}; fN1 = new TGNumberEntry(parent, 0.005, 9, kENTRY1,; TGNumberFormat::kNESRealThree, //style; TGNumberFormat::kNEAAnyNumber, //input value filter; TGNumberFormat::kNELLimitMinMax, //specify limits; -1.,1.); //limit values; ```. **`TGNumberEntryField`** is a number entry input widget. ``` {.cpp}; Nent = new TGNumberEntryField(hgrunf2, kNENT_ID, 0.6,; TGNumberFormat::kNESRealThree,; TGNumberFormat::kNEAAnyNumber);; ```. **`TGNumberEntryField`** is a plain vanilla entry field, whereas; **`TGNumberEntry`** adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values. The; step size can be selected with control and shift keys:. - --small step (1 unit/factor of 3). - Shift medium step (10 units/factor of 10). - Controllarge step (100 units/factor of 30). - Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set; when the entry field is created, but it can be changed by pressing the; alt key at the same time. ### Menus. Menus provide a list of commands or options helping the user to select; and to perform a task. The menu system classes are **`TGMenuBar`**,; **`TGMenuTitle`**, **`TGPopupMenu`**, and **`TGMenuEntry`**. The **`TGMenuBar`** class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions described in menu titles, implemented by **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Al",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76363,Availability,down,down,76363,"n = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; ```. To have a tool bar in your application you do not need to do anything; special - only to create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the `ToolBarData_t` structure is filled in; (if the ic",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76389,Availability,down,down,76389,"if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; ```. To have a tool bar in your application you do not need to do anything; special - only to create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the `ToolBarData_t` structure is filled in; (if the icon pixmap was valid). The fi",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:78379,Availability,avail,available,78379,"r is the window to; which the button messages will be sent. Lastly, we create an object of; class **`TGHorizontal3DLine`** - a horizontal 3D line. It will separate; the toolbar from the menu bar because the layout hints we define as; `kLHintsTop` | `kLHintsExpandX`. It is user friendly to allow the possibility for the tool bar to be; turned on or off (via a menu). If you use a single tool bar, it should; fill the complete width of its parent. When using more than one, you; should also think about setting the bar size to the end of the most; right button. This way other bars can be displayed in the same row below; the menu bar. Tool bar buttons should have equal size, meaningful and unique icons,; and short meaningful tool tip text. The related buttons should be; grouped together by frequency or sequence of use, or importance.; Potentially destructive buttons must be separated from them to avoid; accidental activation and potentially catastrophic results. Temporarily; not available items should be displayed grayed out. ### List Boxes. The purpose of a list box is to display a collection of items from which; single or multiple selection can be made. It is always visible, having a; scroll bar when the displayed area is not enough to show all items. The; choices may be mutually exclusive (a list box with single selection) or; not mutually exclusive (a list box with multiple selection). ![](pictures/02000219.jpg). The proper usage of the list boxes is for selecting values, or objects,; or setting attributes. You have to create them to display 4 to 8 choices; at one time (3 is a required minimum in case of lack of screen space).; The list should contain not more than 40 items accessible by scrolling; view (vertical scroll bar). If more are required, you should provide a; method for using search criteria or scoping the options. The best list; boxes use is for textual data or choices. They should be wide enough to; display fully all items. When it is not possible, break the ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:82628,Availability,down,downward,82628,"tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indicating the number of; selected choices (its position should be justified upper-right above; the list box). - if the actions `Select All` or `Deselect All` must be quickly or; frequently performed, use command buttons. ### Combo Boxes. A combo box is as single-selection list box that shows only the; currently selected entry and a prompt button displayed as a downward; arrow. The prompt button provides a visual cue that a list box is; hidden. Its main advantage is consuming of quite a bit of screen space.; When the user clicks on it, a list pops up, from which a new choice can; be made. After a new item is chosen the combo box folds again showing; the new selection. ![](pictures/0200021A.jpg). The combo box widget is represented by the user callable class; **`TGComboBox`**. The class **`TGComboBoxPopup`** is a service class.; The combo box constructor is very similar to the list box one. The first; parameter is a parent widget pointer again, the second - an integer; value that will be used as combo box ID. The method used for adding; entries is very similar to the list box method we used before. The; method `Select(entryID)` sets the current combo box entry. ``` {.cpp}; char tmp[20];; // combo box layout hints; fLcombo = new TGLayoutHints(kLHintsTop | kLHintsLeft,5,5,5,5);; // combo box",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:85020,Availability,down,down,85020," or `GetSelectedEntry` methods. The first one returns; the entry ID, the second - the current entry pointer; (**`TGLBEntry *`**). ### Sliders. A slider is a scale with an indicator (slider) that you can drag to; choose a value from a predefined range. It may be oriented horizontally; or vertically. In both cases it provides an excellent indication of; where a value exists within a range of values. ![](pictures/0200021B.jpg). The class **`TGHSlider`** represents the horizontal slider;; **`TGVSlider`** - the vertical one. Both inherit from the base class; **`TGSlider`** that creates the main slider parameters: the range of; values within a value can be selected; the indicator type; the tick mark; scale. Using its methods `SetRange`, `SetPosition` and `SetScale` you; can set these parameters. To retrieve the set slider value you can call; `GetPosition` method. Next sample code creates a horizontal slider `hslider` with a tick mark; of type `kSlider1`. Its width is 150 pixels, and its scale is placed; down (`kScaleDownRight`). The last parameter in the **`TGHSlider`**; constructor is the slider ID. It will be used for event processing. The; methods `SetRange` and `SetPosition` set the range and the current tick; mark position of the slider. ``` {.cpp}; hslider = new TGHSlider(parent,150,kSlider1|kScaleDownRight,sID);; hslider->SetRange(0,50);; hslider->SetPosition(39);; ```. Slider values can be set by using the mouse to drag the slider across; the scale until the desired value is reached. Another way is to click in; the slider trough instead of dragging. #### Double Slider. Double slider widgets allow easy selection of a min and a max value out; of a range. They can be either horizontal or vertical oriented. There is; a choice of different types of tick marks: `kDoubleScaleNo`,; `kScaleDownRight`, `kDoubleScaleBoth`. To change the `min` value you should press the left mouse button near to; the left (**`TGDoubleHSlider`**) or bottom (**`TGDoubleHSlider`**) edge; of the ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:98910,Availability,avail,available,98910,"ontainer. When all display information cannot be presented in a window, the; additional information must be found and made visible. A **`TGCanvas`**; is a frame containing two scrollbars (horizontal and vertical) and a; viewport (**`TGViewPort`**). The viewport acts as the window through; which we look at the contents of the container frame. A; **`TGContainer`** frame manages a content area. It can display and; control a hierarchy of multi-column items, and provides the ability to; add new items at any time. By default it doesn't map sub-windows, which; are items of the container. In this case sub-window must provide; `DrawCopy` method, see for example **`TGLVEntry`** class. It is also; possible to use option which allows mapping sub-windows. This option has; much slower drawing speed in case of more than 1000 items placed in; container. To activate this option the fMapSubwindows data member must; be set to `kTRUE` (for example **`TTVLVContainer`** class). A scroll bar only is available when scrolling is necessary. It consists; of three elements: a slider box and two directional scroll arrows; (buttons). ``` {.cpp}; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas, kHorizontalFrame);; fContents->Associate(parent);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; // or; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas->GetViewPort(),100,100,; kHorizontalFrame);; fContents->SetCanvas(fCanvas);; fContents->Associate(parent);; fCanvas->SetContainer(fContents);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; ```. The **`TGContainer`** class can handle the following keys:. F7, Ctnrl-Factivate a search dialog. F3, Ctnrl-Gcontinue to search. Endgo to the last item in container. Homego to the first item in container. PageUpnavigate up. PageDownnavigate down. arrow keysnavigate inside container. Return/Enterequivalent to double click of the mouse button. Contrl",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:99809,Availability,down,down,99809,"bwindows data member must; be set to `kTRUE` (for example **`TTVLVContainer`** class). A scroll bar only is available when scrolling is necessary. It consists; of three elements: a slider box and two directional scroll arrows; (buttons). ``` {.cpp}; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas, kHorizontalFrame);; fContents->Associate(parent);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; // or; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas->GetViewPort(),100,100,; kHorizontalFrame);; fContents->SetCanvas(fCanvas);; fContents->Associate(parent);; fCanvas->SetContainer(fContents);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; ```. The **`TGContainer`** class can handle the following keys:. F7, Ctnrl-Factivate a search dialog. F3, Ctnrl-Gcontinue to search. Endgo to the last item in container. Homego to the first item in container. PageUpnavigate up. PageDownnavigate down. arrow keysnavigate inside container. Return/Enterequivalent to double click of the mouse button. Contrl-Aselect all items. Spaceinvert selection. ### Embedded Canvas. This class creates a **`TGCanvas`** in which a well known ROOT; **`TCanvas`** is embedded. A pointer to the **`TCanvas`** can be; obtained via the `GetCanvas()` member function. ``` {.cpp}; fEc1 = new TRootEmbeddedCanvas(""ec1"",fParent,100,100);; fParent ->AddFrame(fEc1, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; fEc2 = new TRootEmbeddedCanvas(""ec2"",fParent,100,100);; fParent ->AddFrame(fEc2, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; fEc1->GetCanvas()->SetBorderMode(0);; fEc2->GetCanvas()->SetBorderMode(0);; fEc1->GetCanvas()->SetBit(kNoContextMenu);; fEc1->GetCanvas()->Connect(""ProcessedEvent(Int_t,Int_t,Int_t,TObject*)"",; ""MyClass"", this, ""HandleMyCanvas(Int_t,Int_t,Int_t,TObject*)"");; ```. ![](pictures/03000221.png). To embed a canvas derived from a **`TCanvas`** do the following:. `",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:107111,Availability,avail,available,107111," editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button someplace else. When the button is released the selected data is; ""dropped"" at that location. This way, a histogram from an opened ROOT; file in the browser can be dragged to any **`TCanvas`**. ![](pictures/03000223.png). A script file from the browser can be dropped to a *",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:61138,Deployability,toggle,toggle,61138,"uttonGroup(p,""Coordinate system"",kVerticalFrame);; fR[0] = new TGRadioButton(bg,new TGHotString(""&Pixel""));; fR[1] = new TGRadioButton(bg,new TGHotString(""&NDC ""));; fR[2] = new TGRadioButton(bg,new TGHotString(""&User ""));; fR[1]->SetState(kButtonDown);; br->Show();; ```. It is enough to change `kVerticalFrame` to `kHorizontalFrame` in; **`TGButtonGroup`** constructor and you will have radio buttons aligned; horizontally:. ![](pictures/03000211.png). The class **`TGButtonGroup`** will help you to organize button widgets; in a group. There is no need to call `AddFrame()` since the buttons are; added automatically with a default layout hint to their parent by; **`TGButtonGroup`**`::Show()` as shown in the previous example. The; buttons in the group have assigned identifiers. Any button in a group; emits a `Clicked()` signal with this identifier when it is clicked. This; giving an ideal solution to connect several `Clicked()` signals to one; slot. An exclusive button group switches off all toggle buttons except the; selected one. The group is by default non-exclusive but its entire radio; buttons will be mutually exclusive. **`TGHButtonGroup`** and **`TGVButtonGroup`** are convenience classes; that offer you a thin layer on top of **`TGButtonGroup`**.; **`TGHButtonGroup`** organize button widgets in a group of one; horizontal row, **`TGVButtonGroup`** in a group of one column. You can; also organize buttons in rows and columns using the provided constructor; and **`TGMatrixLayout`**. Do not use a radio button to indicate the presence or absence of a state; - use a check box instead. ![](pictures/03000212.png). To have the check button ""Event Status"" and to set it as selected we; need to write:. ``` {.cpp}; TGCheckButton *estat = new TGCheckButton(p, ""Event Status"",1);; estat->SetState(kButtonDown);; ```. Check boxes show the selected choices and any number of them can be; selected, including none. Their proper usage is for setting attributes,; properties or values; als",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:64715,Deployability,toggle,toggled,64715,"exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contains text; that is entered or modified through the keyboard. This text may be; displayed in different way according to the set echo mode. Users can; control them by` SetEchoMode()`, `GetEchoMode()` methods. - `kNormal` - display characters as they are entered (default);. - `kNoEcho` - do not display anything;. - `kPassword` - display asterisks instead of the characters actually; entered. The way in which typed characters are inserted in the text entry is; defined by `TGTextEntry::EInsertMode` and can be toggled by the Insert; key:. - `kInsert` - typed character are inserted (cursor has shape of short; line). - `kReplace` - entered characters substitute already typed ones; (cursor has the shape of filled rectangle). ![](pictures/03000214.png) ![](pictures/03000215.png). There ate different text alignment modes defined by; `TGWidget::ETextJustification`. They are valid until text fits the frame; width of the text entry field. - `kTextLeft` - left-side text alignment. - `kTextRight` - right-side text alignment. - `kTextCenterX` - center text alignment along x direction. - `kTextTop` - top-side text alignment. - `kTextBottom` - bottom-side text alignment. - `kTextCenterY` - center text alignment along y direction. ### Number Entries. The **`TGNumberEntry`** class present number entry widgets. A number; entry is a single-line field followed by two small, vertically arranged; up-down buttons. Its purpose is to make a selection by either scrolling",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:107813,Deployability,release,releases,107813,"cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button someplace else. When the button is released the selected data is; ""dropped"" at that location. This way, a histogram from an opened ROOT; file in the browser can be dragged to any **`TCanvas`**. ![](pictures/03000223.png). A script file from the browser can be dropped to a **`TGTextView`** or; TGTextEdit widget in **`TGTextEditor`**. On Linux, it is possible to drag objects between ROOT and an external; application. For example to drag a macro file from the ROOT browser to; the Kate editor. On Windows, drag and drop works only within a single; ROOT application (for the time being), but works also from Windows; Explorer to **`TCanvas`** ot to **`TGTextEdit`**. ### Drag and Drop Data Class. The Drag and Drop Cata class **`TDNDdata`** is used to describe and; handle the transferred data during an drag and drop operation. It; consists of:. `Atom_t fDataType`: atom describing the data type. `Atom_t fAction`: atom describin",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:107875,Deployability,release,released,107875," publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button someplace else. When the button is released the selected data is; ""dropped"" at that location. This way, a histogram from an opened ROOT; file in the browser can be dragged to any **`TCanvas`**. ![](pictures/03000223.png). A script file from the browser can be dropped to a **`TGTextView`** or; TGTextEdit widget in **`TGTextEditor`**. On Linux, it is possible to drag objects between ROOT and an external; application. For example to drag a macro file from the ROOT browser to; the Kate editor. On Windows, drag and drop works only within a single; ROOT application (for the time being), but works also from Windows; Explorer to **`TCanvas`** ot to **`TGTextEdit`**. ### Drag and Drop Data Class. The Drag and Drop Cata class **`TDNDdata`** is used to describe and; handle the transferred data during an drag and drop operation. It; consists of:. `Atom_t fDataType`: atom describing the data type. `Atom_t fAction`: atom describing the action (copy, move, link);; currently, only copy is used. `void *fData`: actual data (buffer). `Int_t` `fDataLength`: ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:39721,Energy Efficiency,adapt,adapt,39721," | vertical frame - it will fit the whole width. If it is |; | | a horizontal frame - after the positioning of all |; | | frames the available ""free"" width space is shared |; | | between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsExpandY` | specifies the frame to be expanded up to the height of |; | | the container frame. If the container frame is a |; | | horizontal frame - it will fit the whole height. If the |; | | container frame is a vertical frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mech",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:101891,Energy Efficiency,reduce,reduced,101891,"ring """"; Int_t wid = embed->GetCanvasWindowId();; TCanvas *myc = new TCanvas(""myname"",10,10,wid);; embed->AdoptCanvas(myc);; // the TCanvas is adopted by the embedded canvas and will be; // destroyed by it; ```. ## The ROOT Graphics Editor (GED). Everything drawn in a ROOT canvas is an object. There are classes for; all objects, and they fall into hierarchies. In addition, the ROOT has; fully cross-platform GUI classes and provides all standard components; for an application environment with common ‘look and feel'. The; object-oriented, event-driven programming model supports the modern; signals/slots communication mechanism. It handles user interface actions; and allows total independence of interacting objects and classes. This; mechanism uses the ROOT dictionary information and the Cling the C++; Interpreter to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:103895,Energy Efficiency,reduce,reduced,103895,"The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. ![Histogram, pad and axis editors](pictures/03000222.png). ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/slots communication mechanism for event processing. (e) Implement the virtual method `SetModel(TObject *obj)` where a",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:193,Integrability,interface,interface,193,"# Writing a Graphical User Interface; \index{Graphical User Interface}. The ROOT GUI classes support an extensive and rich set of widgets with; the Windows 95 look and feel. The widget classes interface to the; underlying graphics system via a single abstract class. Concrete; versions of this abstract class have been implemented for X11 and Win32,; thereby making the ROOT GUI fully cross-platform. Originally the GUI; classes were based on Hector Peraza's Xclass'95 widget library; <http://xclass.sourceforge.net/>. ## The ROOT GUI Classes. Features of the GUI classes in a nutshell:. - Originally based on the Xclass'95 widget library. - A rich and complete set of widgets. - Win'95 look and feel. - All machine dependent graphics calls abstracted via the; **`TVirtualX`** ""abstract"" class. - Completely scriptable via the C++ interpreter (fast prototyping). - Supports signal/slot event handling as pioneered by Trolltech's Qt. - Full class documentation is generated automatically (as for all ROOT; classes). - Code generation for variety of GUI's. ## Widgets and Frames. The ROOT GUI classes provide of set of components that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,;",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:716,Integrability,depend,dependent,716,"# Writing a Graphical User Interface; \index{Graphical User Interface}. The ROOT GUI classes support an extensive and rich set of widgets with; the Windows 95 look and feel. The widget classes interface to the; underlying graphics system via a single abstract class. Concrete; versions of this abstract class have been implemented for X11 and Win32,; thereby making the ROOT GUI fully cross-platform. Originally the GUI; classes were based on Hector Peraza's Xclass'95 widget library; <http://xclass.sourceforge.net/>. ## The ROOT GUI Classes. Features of the GUI classes in a nutshell:. - Originally based on the Xclass'95 widget library. - A rich and complete set of widgets. - Win'95 look and feel. - All machine dependent graphics calls abstracted via the; **`TVirtualX`** ""abstract"" class. - Completely scriptable via the C++ interpreter (fast prototyping). - Supports signal/slot event handling as pioneered by Trolltech's Qt. - Full class documentation is generated automatically (as for all ROOT; classes). - Code generation for variety of GUI's. ## Widgets and Frames. The ROOT GUI classes provide of set of components that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,;",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2129,Integrability,message,messages,2129,"nents that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost a",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2190,Integrability,message,messages,2190,"ows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed.",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2289,Integrability,interface,interface,2289,"adio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed v",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2315,Integrability,depend,dependent,2315,"adio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed v",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2565,Integrability,interface,interface,2565,"en/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:16066,Integrability,interface,interface,16066,"idget's layout and add it to the parent list of children. - Set main window attributes. - Map all sub windows. - Initialize the layout algorithm via `Resize(GetDefaultSize())`; method. - Map the main frame. - Execution of the even-processing loop. ### A Standalone Version. As usual a standalone program in C++ has to contain a main() function -; the starting point for the application execution. In this case it is; better to separate the program code creating a program header file; example2a.h with the `MyMainFrame` class declaration and; `example2a.cxx `- with the class methods implementation. To run our; simple example as a standalone application we need to create in addition; an object of class **`TApplication`**. It will make a correct; initialization of the dictionaries if it is not yet done. It will be; responsible for holding everything together and to handle all events in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; containing the line:. ``` {.cpp}; #pragma link C++ class MyMainFrame;; ```. We compile the example:. ``` {.cpp}; rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h; g++ -o example2a example2a.cxx ex2aDict.cxx `root-config --cflags --glibs`; ```. `example2a.h`. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; clas",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:19679,Integrability,contract,contraction,19679,"utton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFrame *hframe=new TGHorizontalFrame(this, 200,40);; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; hframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit "",; ""gApplication->Terminate()"");; hframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; AddFrame(hframe,new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; ```. ## Widgets Overview. The word widget is a contraction of windows and gadget. Almost all GUI; elements are widgets. A button is a widget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub cl",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:23126,Integrability,interface,interface,23126,"et`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gathering via `GetCommand()` method. For example,; the third parameter in **`TGTextButton`** constructor can be omitted and; set later in your program, i.e. instead of:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enable a widget depending on the situation of your; application. As a standard all disabled widgets are displayed ""grayed; out"". `HasFocus()` - returns `kTRUE` if the widget has the input focus; (i.e. flag `kWidgetHasFocus` is set). Remember that only one item in a; complex widget as a dialog can have the value of `HasFocus()` sets as; true. `WantFocus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the windo",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:23189,Integrability,depend,depending,23189,"et`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gathering via `GetCommand()` method. For example,; the third parameter in **`TGTextButton`** constructor can be omitted and; set later in your program, i.e. instead of:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enable a widget depending on the situation of your; application. As a standard all disabled widgets are displayed ""grayed; out"". `HasFocus()` - returns `kTRUE` if the widget has the input focus; (i.e. flag `kWidgetHasFocus` is set). Remember that only one item in a; complex widget as a dialog can have the value of `HasFocus()` sets as; true. `WantFocus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the windo",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:31426,Integrability,interface,interface,31426,"Size()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; ```. The state information about a child frame can be obtained from the; methods `GetState(TGframe *f)`, `IsArranged(TGFrame *f)`, and; `IsVisible(TGFrame *f)`. The method `Cleanup()` deletes all objects of the composite frame added; via `AddFrame()`. All **`TGFrameElement`** objects (frames and layout; hints) must be unique, i.e. cannot be shared. We already mentioned that **`TGMainFrame`** class defines top level; windows interacting with the system window manager. It handles; applications with a menu bar, toolbar, text entry fields and other; widgets surrounding a central area (e.g. a canvas widget). It lays out a; set of related widgets and provides the typical application main window; behavior. As you can see from the Figure above, it inherits from; **`TGCompositeFrame`** and is inherited by **`TGTransientFrame`** and; several ROOT interface classes: **`TViewerX3D`**,**` TRootBrowser`**,; **`TRootCanvas`**, **`TRootControlBar`**, **`TTreeViewer.`**. To fix the size of a top level window you have to use the method; `TGMainFrame::SetWMSize().` This call tells the Window Manager that it; should not resize the window. The option `kFixedSize` works only for; embedded frames like **`TGCompositeFrame`** and derived classes (in; combination with layout hints). The **`TGVerticalFrame`** and **`TGHorizontalFrame`** are composite; frames that lay out their child frames in vertical or horizontal way in; the same order as they were added and according to their hints; preferences. The **`TGTransientFrame`** class defines transient windows that; typically are used for dialogs. They extend and complete an interaction; within a limited context. Always transient frames are displayed from; another window or another dialog. They may appear because of a command; button being activated or a menu item being selected. They ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33681,Integrability,message,message,33681,"e functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/02000209.jpg). The base ""container"" class is **`TGCmpositeFrame`**. You can easily; change the layout manager using the; `SetLayoutManager(TGLayoutManager *l)",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:40191,Integrability,bridg,bridge,40191,"frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41522,Integrability,message,message,41522,"o the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFram",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:54038,Integrability,interface,interfaces,54038,"ain(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The first group is presented in ROOT by; **`TGPictureButton`** and **`TGTextButton`** classes. They yield an; action as soon as they are clicked. It can be opening/closing a dialog; box or invoking a specific function in an application. Remember the Draw; button from the example. The radio and check buttons from the second; group are used to select an option. There is a visual difference between; these two groups: the text buttons appear ""pressed in"" only while they; are clicked, while the radio and check buttons change their appearance; when they are selected and keep that appearance afte",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:73976,Integrability,depend,depends,73976,"s dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub application within an; application. All its functions can be obtained by application menus. It; is located horizontally at the top of the main window just below the; menu bar. All other subtask and sub-feature bars are positioned along; sides of window. ``` {.cpp}; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",; 0; };; // toolbar tool tip text; const char *tips[] = {; ""X Settings"",; ""Y Settings"",; ""Z Settings"",; 0; };; // toolbar button separator; int separator = 5;. // structure containing tool",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76229,Integrability,message,message,76229,"ps[i]; // tool tip text; t[i].fStayDown = kFALSE; // button behavior if clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; ```. To have a tool bar in your application you do not need to do anything; special - only to create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method wil",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:77430,Integrability,message,messages,77430," the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the `ToolBarData_t` structure is filled in; (if the icon pixmap was valid). The first parameter is the window to; which the button messages will be sent. Lastly, we create an object of; class **`TGHorizontal3DLine`** - a horizontal 3D line. It will separate; the toolbar from the menu bar because the layout hints we define as; `kLHintsTop` | `kLHintsExpandX`. It is user friendly to allow the possibility for the tool bar to be; turned on or off (via a menu). If you use a single tool bar, it should; fill the complete width of its parent. When using more than one, you; should also think about setting the bar size to the end of the most; right button. This way other bars can be displayed in the same row below; the menu bar. Tool bar buttons should have equal size, meaningful and unique icons,; and short meaningful tool tip text. The related buttons should be; grouped together by frequency or sequence of use, or importance.; Potentially destructive buttons must be separated from them to avoid; accidental activation and potentially catastrophic results. Temporarily; not available items should be displaye",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81304,Integrability,rout,routines,81304,"for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indi",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88470,Integrability,message,message,88470,"D_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:92090,Integrability,message,message,92090,"to improve the efficiency of the; client-server windowing systems. **`TGClient`** will check whether a; pixmap with the same name was already loaded before to register a new; picture object. If it finds it, it will return a pointer to the existing; object. Also, it will increase the usage counter for the object. All **`TGPicture`** objects are managed by the class; **`TGPicturePool`**. **`TGClient`** creates an object of this type upon; initialization. Normally your application program does not deal directly; with this class because all manipulations go through **`TGClient`**; class. Once you have finished with using of the **`TGPicture`** object, you; should call the method **`TGClient::FreePicture(const TGPicture *pic)`**; to free it. The usage counter of the picture object will be decreased; and when it reaches zero - the **`TGPicture`** object will be deleted. ### Status Bar. The status bar widget is used to display some information about the; current application state: what is being viewed in the window, a; descriptive message about selected objects, or other no interactive; information. It may also be used to explain highlighted menu and tool; bar items. ![](pictures/0200021F.jpg). An application can only have one status bar at a time. There is nothing special to create a status bar in your application. You; should decide how many fields you need to present the current; application state to the user. By default a status bar consists of one; part. Multiple parts can be created by `SetParts` method. Its first; parameter is an array of integers that give the percentage size of each; part. The second parameter gives the number of status bar parts. Using; `SetText` method you can set a text for any part. ``` {.cpp}; // status bar; Int_t parts[] = {33, 10, 10, 47};; fStatusBar = new TGStatusBar(fMain,50,10,kHorizontalFrame);; fStatusbar->SetParts(parts,4);; fMain->AddFrame(fStatusBar, new TGLayoutHints(kLHintsBottom |; kLHintsLeft | kLHintsExpandX, 0, 0, 2, 0));; . .",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:101566,Integrability,interface,interface,101566,"edEvent(Int_t,Int_t,Int_t,TObject*)"",; ""MyClass"", this, ""HandleMyCanvas(Int_t,Int_t,Int_t,TObject*)"");; ```. ![](pictures/03000221.png). To embed a canvas derived from a **`TCanvas`** do the following:. ``` {.cpp}; TRootEmbeddedCanvas *embed = new TRootEmbeddedCanvas(0, p, w, h);; // note name must be 0, not null string """"; Int_t wid = embed->GetCanvasWindowId();; TCanvas *myc = new TCanvas(""myname"",10,10,wid);; embed->AdoptCanvas(myc);; // the TCanvas is adopted by the embedded canvas and will be; // destroyed by it; ```. ## The ROOT Graphics Editor (GED). Everything drawn in a ROOT canvas is an object. There are classes for; all objects, and they fall into hierarchies. In addition, the ROOT has; fully cross-platform GUI classes and provides all standard components; for an application environment with common ‘look and feel'. The; object-oriented, event-driven programming model supports the modern; signals/slots communication mechanism. It handles user interface actions; and allows total independence of interacting objects and classes. This; mechanism uses the ROOT dictionary information and the Cling the C++; Interpreter to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the;",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102773,Integrability,interface,interface,102773," to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object follo",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:103626,Integrability,interface,interface,103626,"s the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. ![Histogram, pad and axis editors](pictures/03000222.png). ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct namin",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:106470,Integrability,depend,depending,106470," traversal of class hierarchy of the; selected object, executed from method **`TGedEditor`**`::SetModel()`.; When a new object of a different class is selected, the unneeded; GED-frames are cached in memory for potential reuse. The frames are; deleted automatically when the editor is closed. Note: A deep cleanup is assumed for all frames put into the editor. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; sh",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:107622,Integrability,protocol,protocol,107622,"itors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button someplace else. When the button is released the selected data is; ""dropped"" at that location. This way, a histogram from an opened ROOT; file in the browser can be dragged to any **`TCanvas`**. ![](pictures/03000223.png). A script file from the browser can be dropped to a **`TGTextView`** or; TGTextEdit widget in **`TGTextEditor`**. On Linux, it is possible to drag objects between ROOT and an external; application. For example to drag a macro file from the ROOT browser to; the Kate editor. On Windows, drag and drop works only within a single; ROOT application (for the time being), but works also from Windows; Explorer to **`TCanvas`** ot to **`TGTextEdit`**. ### Drag and Drop Data Class. The Drag and Drop Cata class **`TDNDdata`** is used to describe and; handle t",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:110775,Integrability,message,messages,110775," new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; ```. Then, set a GUI widget as DND Source, and associate the data. Source; widget can be any class inheriting from **`TGFrame`**. ``` {.cpp}; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; ```. Setting A Drop Target - set the widget as DND Target, and set the DND; types it must be aware of: as `SourceWidget`, `TargetWidget` can be any; class inheriting from **`TGFrame`**. ``` {.cpp}; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; ```. `gDNDManager->GetTypeList()` returns the list of types recognized by; ROOT. Note that the Widget may receive drag and drop messages with drop-data; it does not understand, and thus it should only accept drops of the; proper type. ### Handling Drag and Drop Events. Once a widget has been set as DND Target, it has to handle Drag and Drop; events. `Atom_t HandleDNDenter(Atom_t *typelist)` - this method is used to; handle a drag operation entering the widget. The typelist parameter is; the list of types the data contains. If the list contains one type the; widget understands, it should return this type to notify the manager; that the drop would be accepted, i.e. :. ``` {.cpp}; for (int i = 0; typelist[i] != kNone; ++i) {; if (typelist[i] == gVirtualX->InternAtom(""application/root"")); // accept ""application/root"" DND type; return typelist[i];; }; // other type not accepted; return kNone;; ```. `Atom_t HandleDNDposition(Int_t x,Int_t y,Atom_t action,Int_t xroot,; Int_t yroot)` - this; method should be used to handle the drag position in widget coordinates; (`x,y`) or in root coordinates (`xroot,yroot`). ``` {.cpp}; // get the pad over which",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:17003,Modifiability,config,config,17003,"nts in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; containing the line:. ``` {.cpp}; #pragma link C++ class MyMainFrame;; ```. We compile the example:. ``` {.cpp}; rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h; g++ -o example2a example2a.cxx ex2aDict.cxx `root-config --cflags --glibs`; ```. `example2a.h`. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; class TGMainFrame;; class TRootEmbeddedCanvas;. class MyMainFrame {; RQ_OBJECT(""MyMainFrame""); private:; TGMainFrame *fMain;; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; ```. `example2a.cxx`. ``` {.cpp}; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2a.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {...}; MyMainFrame::~MyMainFrame() { ... }; void MyMainFrame::DoDraw() { ... }; void example() { ... }. int main(int argc, char **argv) {; TApplication theApp(""App"",&argc,argv);; example();; theApp.Run();; return 0;; }; ```. The class `MyMainFrame` could derive from **`TGMainFrame`**. In that; case the `RQ_OBJECT` macro is not needed ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:18079,Modifiability,inherit,inheritance,18079,"mple2a.h`. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; class TGMainFrame;; class TRootEmbeddedCanvas;. class MyMainFrame {; RQ_OBJECT(""MyMainFrame""); private:; TGMainFrame *fMain;; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; ```. `example2a.cxx`. ``` {.cpp}; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2a.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {...}; MyMainFrame::~MyMainFrame() { ... }; void MyMainFrame::DoDraw() { ... }; void example() { ... }. int main(int argc, char **argv) {; TApplication theApp(""App"",&argc,argv);; example();; theApp.Run();; return 0;; }; ```. The class `MyMainFrame` could derive from **`TGMainFrame`**. In that; case the `RQ_OBJECT` macro is not needed anymore, since the; functionality it provides is obtained now via inheritance from; **`TGMainFrame`**. This will reflect in the `MyMainFrame` class; declaration and in the code of the `MyMainFrame::MyMainFrame`; constructor as follows:. `example2b.h`. ``` {.cpp}; #include <TGFrame.h>; class MyMainFrame : public TGMainFrame {; private:; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame() { ... }; void DoDraw(){ ... }; ClassDef(MyMainFrame,0); };; ```. `example2b.cxx`. ``` {.cpp}; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFram",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:20816,Modifiability,inherit,inheritance,20816,"dget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TG",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:20844,Modifiability,inherit,inherit,20844," have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGVi",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21020,Modifiability,inherit,inherits,21020," with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the wi",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21564,Modifiability,inherit,inheritances,21564,"ls/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the widget's; events, the widget status flags and the assigned command (if there is; any). The general properties of **`TGWidget`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gatherin",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:23654,Modifiability,inherit,inherits,23654,"f:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enable a widget depending on the situation of your; application. As a standard all disabled widgets are displayed ""grayed; out"". `HasFocus()` - returns `kTRUE` if the widget has the input focus; (i.e. flag `kWidgetHasFocus` is set). Remember that only one item in a; complex widget as a dialog can have the value of `HasFocus()` sets as; true. `WantFocus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the window system; and can paint a representation of itself on the screen. ![](pictures/02000205.jpg). ### Frames. Most of the frame classes are mainly created for arranging widgets in a; window. The class **`TGFrame`** is a subclass of **`TGWindow`**; providing additional window characteristics and overriding some methods; of **`TGWindow`**. It is a base class for the simple widgets as buttons,; labels, etc. Its only purpose is to draw a frame around widgets that do; not have a frame of their own. The main groups of **`TGFrame`** mem",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:29430,Modifiability,variab,variable,29430,"----------------------------------------------+. The method `ChangeOpton(UInt_t options)` allows you to change frame; options. Next example shows you how to change `kVerticalFrame` option to; `kHorizontalFrame`:. ``` {.cpp}; frame->ChangeOptions((frame->GetOptions()& ~kVerticalFrame) |; kHorizontalFrame);; ```. The class **`TGCompositeFrame`** is the base class of all composite; widgets as a menu bar, a list box, a combo box, etc. It subclasses; **`TGFrame`** and has in addition a layout manager and a list of child; frames/widgets. There are two steps to do the design using a composite; frame widget. First you put all widgets you need within this frame and; assign them desired properties using `AddFrame(),` then you lay them out; by the `Layout()` method according to the assigned layout manager. The; method `AddFrame()` creates an instance of **`TGFrameElement`** class; for every child widget of a composite frame. This class has three public; data members: the child pointer, its layout hints, and a status variable; showing if the child is visible or hidden. If no hints are specified,; the default layout hints are used. Because the layout is very important; part of any design we include a special section about layout management; and layout hints. You can set a layout manager for the composite frame via:. ``` {.cpp}; compFrame->SetLayoutManager(TGLayoutManager *l);; ```. The child widgets cannot be added to different composite frames. Any child frame can be removed from the parent list by:. ``` {.cpp}; compFrame->RemoveFrame(TGFrame *f);; ```. You can hide or show a child frame of a composite frame using the; methods: `HideFrame(TGFrame *f)` or `ShowFrame(TGFrame *f).` You should; call, for example `HideFrame(TGFrame *f),` only after the frames have; been laid out and the sub windows of the composite frame have been; mapped via method `MapSubwindows(),` i.e. ``` {.cpp}; frame->AddFrame(hFrame1,fLayout1);; frame->AddFrame(hFrame2,fLayout2);; frame->Resize(frame->GetDef",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:31327,Modifiability,inherit,inherits,31327,"Size()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; ```. The state information about a child frame can be obtained from the; methods `GetState(TGframe *f)`, `IsArranged(TGFrame *f)`, and; `IsVisible(TGFrame *f)`. The method `Cleanup()` deletes all objects of the composite frame added; via `AddFrame()`. All **`TGFrameElement`** objects (frames and layout; hints) must be unique, i.e. cannot be shared. We already mentioned that **`TGMainFrame`** class defines top level; windows interacting with the system window manager. It handles; applications with a menu bar, toolbar, text entry fields and other; widgets surrounding a central area (e.g. a canvas widget). It lays out a; set of related widgets and provides the typical application main window; behavior. As you can see from the Figure above, it inherits from; **`TGCompositeFrame`** and is inherited by **`TGTransientFrame`** and; several ROOT interface classes: **`TViewerX3D`**,**` TRootBrowser`**,; **`TRootCanvas`**, **`TRootControlBar`**, **`TTreeViewer.`**. To fix the size of a top level window you have to use the method; `TGMainFrame::SetWMSize().` This call tells the Window Manager that it; should not resize the window. The option `kFixedSize` works only for; embedded frames like **`TGCompositeFrame`** and derived classes (in; combination with layout hints). The **`TGVerticalFrame`** and **`TGHorizontalFrame`** are composite; frames that lay out their child frames in vertical or horizontal way in; the same order as they were added and according to their hints; preferences. The **`TGTransientFrame`** class defines transient windows that; typically are used for dialogs. They extend and complete an interaction; within a limited context. Always transient frames are displayed from; another window or another dialog. They may appear because of a command; button being activated or a menu item being selected. They ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:31372,Modifiability,inherit,inherited,31372,"Size()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; ```. The state information about a child frame can be obtained from the; methods `GetState(TGframe *f)`, `IsArranged(TGFrame *f)`, and; `IsVisible(TGFrame *f)`. The method `Cleanup()` deletes all objects of the composite frame added; via `AddFrame()`. All **`TGFrameElement`** objects (frames and layout; hints) must be unique, i.e. cannot be shared. We already mentioned that **`TGMainFrame`** class defines top level; windows interacting with the system window manager. It handles; applications with a menu bar, toolbar, text entry fields and other; widgets surrounding a central area (e.g. a canvas widget). It lays out a; set of related widgets and provides the typical application main window; behavior. As you can see from the Figure above, it inherits from; **`TGCompositeFrame`** and is inherited by **`TGTransientFrame`** and; several ROOT interface classes: **`TViewerX3D`**,**` TRootBrowser`**,; **`TRootCanvas`**, **`TRootControlBar`**, **`TTreeViewer.`**. To fix the size of a top level window you have to use the method; `TGMainFrame::SetWMSize().` This call tells the Window Manager that it; should not resize the window. The option `kFixedSize` works only for; embedded frames like **`TGCompositeFrame`** and derived classes (in; combination with layout hints). The **`TGVerticalFrame`** and **`TGHorizontalFrame`** are composite; frames that lay out their child frames in vertical or horizontal way in; the same order as they were added and according to their hints; preferences. The **`TGTransientFrame`** class defines transient windows that; typically are used for dialogs. They extend and complete an interaction; within a limited context. Always transient frames are displayed from; another window or another dialog. They may appear because of a command; button being activated or a menu item being selected. They ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:32176,Modifiability,extend,extend,32176,"set of related widgets and provides the typical application main window; behavior. As you can see from the Figure above, it inherits from; **`TGCompositeFrame`** and is inherited by **`TGTransientFrame`** and; several ROOT interface classes: **`TViewerX3D`**,**` TRootBrowser`**,; **`TRootCanvas`**, **`TRootControlBar`**, **`TTreeViewer.`**. To fix the size of a top level window you have to use the method; `TGMainFrame::SetWMSize().` This call tells the Window Manager that it; should not resize the window. The option `kFixedSize` works only for; embedded frames like **`TGCompositeFrame`** and derived classes (in; combination with layout hints). The **`TGVerticalFrame`** and **`TGHorizontalFrame`** are composite; frames that lay out their child frames in vertical or horizontal way in; the same order as they were added and according to their hints; preferences. The **`TGTransientFrame`** class defines transient windows that; typically are used for dialogs. They extend and complete an interaction; within a limited context. Always transient frames are displayed from; another window or another dialog. They may appear because of a command; button being activated or a menu item being selected. They may also; present automatically when an additional input and the user attention; are required by a certain condition. The **`TGGroupFrame`** class presents a very convenient frame which; surrounds visually a group of logically connected widgets: radio; buttons, related check boxes, two or more functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kC",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:39721,Modifiability,adapt,adapt,39721," | vertical frame - it will fit the whole width. If it is |; | | a horizontal frame - after the positioning of all |; | | frames the available ""free"" width space is shared |; | | between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsExpandY` | specifies the frame to be expanded up to the height of |; | | the container frame. If the container frame is a |; | | horizontal frame - it will fit the whole height. If the |; | | container frame is a vertical frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mech",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:42971,Modifiability,inherit,inherit,42971,"n with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; ```. Here is an abstract view of the signal/slots connections in `example.C`:. ![](pictures/0200020C.jpg). To benefit from this mechanism your classes must inherit from; **`TQObject`** or otherwise the class definition must start with; `RQ_OBJECT(""ClassName"") `macro. This macro allows the signals/slots; communication mechanism to be applied between compiled and interpreted; classes in an interactive ROOT session without having the class derive; from **`TQObject`**. Every signal method declaration is followed by a; comment `""*SIGNAL*"".` Only instances of a class that defines a signal or; instances of its subclasses can emit the signal. The ROOT implementation; of a popular example presenting signals and slots is the next. Let's; have a minimal class declaration:. ``` {.cpp}; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; ```. It will become the following as interpreted:. ``` {.cpp}; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; ```. Both cla",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:44174,Modifiability,inherit,inherited,44174,"d and interpreted; classes in an interactive ROOT session without having the class derive; from **`TQObject`**. Every signal method declaration is followed by a; comment `""*SIGNAL*"".` Only instances of a class that defines a signal or; instances of its subclasses can emit the signal. The ROOT implementation; of a popular example presenting signals and slots is the next. Let's; have a minimal class declaration:. ``` {.cpp}; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; ```. It will become the following as interpreted:. ``` {.cpp}; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; ```. Both class declarations have the same data member and public methods to; access the value. By placing the `RQ_OBJECT(""MyClass"")` macro inside the; `MyClass` body (`MyClass` is not inherited from **`TQObject`**) we allow; this class to use the signal/slot communication. Any instance of this; class can tell the outside world that the state of its data member has; changed by emitting a signal `SetValue(Int_t).` A possible; implementation of `MyClass::SetValue()` can be:. ``` {.cpp}; void MyClass::SetValue(Int_t v) {; if (v != fValue) {; fValue = v;; Emit(""SetValue(Int_t)"",v);; }; }; ```. The line `Emit(""SetValue(Int_t)"",v)` activates the signal; `SetValue(Int_t)` with argument v. You can use any of the methods; **`TQObject::Emit(""full_method_name"",arguments)`** to emit a signal. We; create two instances of `MyClass` and connect them together:. ``` {.cpp}; MyClass *objA = new MyClass();; MyClass *objB = new MyClass();; objA->Connect(""SetValue(Int_t)"",""MyClass"",objB,""SetValue(Int_t)"");; objB->SetValue(11);; objA->SetValue(79);; objB->GetValue(); // the value is 79; ```. By calling the method `objA->Connect()`, `objA` connects its signal; ""`SetValue(Int_t)`"" to the ""`",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:53616,Modifiability,config,config,53616,"e:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The first group is presented in ROOT by; **`TGPictureButton`** and **`TGTextButton`** classes. They yield an; action as soon as they are clicked. It can be opening/closing a dialog; box or invoking a sp",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:72875,Modifiability,flexible,flexible,72875,"Test, fMBItemLayout);; fMenuBar->AddPopup(""&Help"", fMenuHelp, fMBHelpLayout);; ```. Using the method `TGMenuBar::AddPopup` we add three **`TGPopupMenu`**; objects to the menu bar `fMenuBar`. The first parameter is a hot string; used by **`TGMenuTitle`** object. When you add a popup menu to the menu; bar, a **`TGMenuTitle`** object is created by the menu bar. It is the; name of the popup menu. A menu title should have a one-word name that; reflects the purpose of all items within the corresponding popup menu.; It should also have a defined character as its unique access key. The; second parameter is the popup menu we would like to add. The third one; is an object of **`TGLayoutHints`** type that defines how the menu title; will be laid out in the menu bar. In our example the *`File`* and `Test`; menus will be laid out to the left of the menu bar with 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kin",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76283,Modifiability,variab,variable,76283,"clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; ```. To have a tool bar in your application you do not need to do anything; special - only to create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76834,Modifiability,variab,variable,76834," create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the `ToolBarData_t` structure is filled in; (if the icon pixmap was valid). The first parameter is the window to; which the button messages will be sent. Lastly, we create an object of; class **`TGHorizontal3DLine`** - a horizontal 3D line. It will separate; the toolbar from the menu bar because the layout hints we define as; `kLHintsTop` | `kLHintsExpandX`. It is user friendly to allow the possibility for the tool bar to be; turned on or off (via a menu). If you use a single tool bar, it should; fill the complete width of its parent. When using more than one, you;",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:77066,Modifiability,variab,variable,77066,"r. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the `ToolBarData_t` structure is filled in; (if the icon pixmap was valid). The first parameter is the window to; which the button messages will be sent. Lastly, we create an object of; class **`TGHorizontal3DLine`** - a horizontal 3D line. It will separate; the toolbar from the menu bar because the layout hints we define as; `kLHintsTop` | `kLHintsExpandX`. It is user friendly to allow the possibility for the tool bar to be; turned on or off (via a menu). If you use a single tool bar, it should; fill the complete width of its parent. When using more than one, you; should also think about setting the bar size to the end of the most; right button. This way other bars can be displayed in the same row below; the menu bar. Tool bar buttons should have equal size, meaningful and unique icons,; and short meaningful tool ti",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81136,Modifiability,flexible,flexible,81136,"es; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box t",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81341,Modifiability,variab,variables,81341,"fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indicating the number of; selected choices (its position should be justified upper-right above; the list box). - i",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:84538,Modifiability,inherit,inherit,84538,",100);; for (i = 0; i < 10; i++) {; sprintf(tmp, ""Entry%i"", i+1);; fCombo->AddEntry(tmp, i+1);; }; fCombo->Resize(150, 20);; // Entry3 is selected as current; fCombo->Select(2);; parent->AddFrame(fCombo, fLcombo);; ```. You have the same flexibility to add, insert or remove entries. As with; list boxes you can retrieve the information for currently selected item; via `GetSelected` or `GetSelectedEntry` methods. The first one returns; the entry ID, the second - the current entry pointer; (**`TGLBEntry *`**). ### Sliders. A slider is a scale with an indicator (slider) that you can drag to; choose a value from a predefined range. It may be oriented horizontally; or vertically. In both cases it provides an excellent indication of; where a value exists within a range of values. ![](pictures/0200021B.jpg). The class **`TGHSlider`** represents the horizontal slider;; **`TGVSlider`** - the vertical one. Both inherit from the base class; **`TGSlider`** that creates the main slider parameters: the range of; values within a value can be selected; the indicator type; the tick mark; scale. Using its methods `SetRange`, `SetPosition` and `SetScale` you; can set these parameters. To retrieve the set slider value you can call; `GetPosition` method. Next sample code creates a horizontal slider `hslider` with a tick mark; of type `kSlider1`. Its width is 150 pixels, and its scale is placed; down (`kScaleDownRight`). The last parameter in the **`TGHSlider`**; constructor is the slider ID. It will be used for event processing. The; methods `SetRange` and `SetPosition` set the range and the current tick; mark position of the slider. ``` {.cpp}; hslider = new TGHSlider(parent,150,kSlider1|kScaleDownRight,sID);; hslider->SetRange(0,50);; hslider->SetPosition(39);; ```. Slider values can be set by using the mouse to drag the slider across; the scale until the desired value is reached. Another way is to click in; the slider trough instead of dragging. #### Double Slider. Double slider widget",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:86902,Modifiability,inherit,inherit,86902,"near to; the left (**`TGDoubleHSlider`**) or bottom (**`TGDoubleHSlider`**) edge; of the slider. Alternatively, to change the `max` value you need to; press the mouse near to the right (**`TGDoubleHSlider`**) or top; (**`TGDoubleHSlider`**) edge of the slider. To change both values; simultaneously you should press the left mouse button near to the center; of the slider. ![](pictures/0200021C.jpg). **`TGDoubleSlider`** is an abstract base class that creates the main; slider parameters. The concrete class to use for a vertical double; slider is **`TGDoubleVSlider`** and **`TGDoubleHSlider`** for a; horizontal one. The double slider constructors are similar to those of; the other sliders. If you set `kDoubleScaleNo` as a scale parameter no; scale will be drawn. Here is an example:. ``` {.cpp}; vDslider = new TGDoubleVSlider(p,100,kDoubleScaleNo,dsliderID);; vDslider->SetRange(-10,10);; ```. ### Triple Slider. The new **`TGTripleHSlider`** and **`TGTripleVSlider`** classes inherit; from the double slider widgets and allow easy selection of a range and a; pointer value. The pointer position can be constrained into the selected; range or can be relative to it. ![](pictures/0300021D.png). To change the slider range value press the left mouse button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:94366,Modifiability,inherit,inherit,94366,"s. A window can be split into two parts (panes) by using a horizontal or a; vertical splitter. A horizontal splitter resizes the frames above and; below of it; a vertical splitter resizes the frames left and right of; it. ![](pictures/02000220.jpg). This widget is represented by **`TGSplitter`**, **`TGHSplitter`**, and; **`TGVSplitter`** classes. Currently there is no special graphics; representation for splitter widgets; only the cursor changes when; crossing a splitter. There is nothing special to create a splitter - two lines of code only:. ``` {.cpp}; TGHSplitter *hsplitter = new TGHSplitter(fVf);; hsplitter->SetFrame(fH1,kTRUE);; ```. You call a horizontal **`TGHSplitter`** or a vertical **`TGVSplitter`**; splitter constructor and after you set the frame to be resized via; `SetFrame` method. In spite of that, there are rules to be followed when; you create a splitter in your application. For a `horizontal` splitter they are:. - the parent of a horizontal splitter must inherit from; **`TGCompoziteFrame`** and must have a vertical layout. - the `above` resized frame must have `kFixedHeight` option set. - use layout hints `kLHintsTop | kLHintsExpandX` when adding the; **`above`** resized frame to its parent. - use layout hints `kLHintsBottom | kLHintsExpandX | kLHintsExpandY`; when adding the bottom resized frame to its parent. - set the **`above`** frame to be resized using `SetFrame` method; the; second parameter should be `kTRUE`. You can see these rules in the code below:. ``` {.cpp}; // Create horizontal splitter; fVf = new TGVerticalFrame(fMain,10,10);; fH1 = new TGHorizontalFrame(fVf,10,10, kFixedHeight);; fH2 = new TGHorizontalFrame(fVf,10,10);; fFtop = new TGCompositeFrame(fH1,10,10, kSunkenFrame);; fFbottom = new TGCompositeFrame(fH2,10,10,kSunkenFrame);; fLtop = new TGLabel(fFtop,""Top Frame"");; fLbottom = new TGLabel(fFbottom,""Bottom Frame"");. fFtop->AddFrame(fLtop, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fFbottom->AddFrame(fLbottom, ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:96175,Modifiability,inherit,inherit,96175,"GLabel(fFtop,""Top Frame"");; fLbottom = new TGLabel(fFbottom,""Bottom Frame"");. fFtop->AddFrame(fLtop, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fFbottom->AddFrame(fLbottom, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fH1->AddFrame(fFtop, new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHintsExpandX,0,0,1,2));; fH2->AddFrame(fFbottom,new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHintsExpandX,0,0,1,2));; fH1->Resize(fFtop->GetDefaultWidth(),fH1->GetDefaultHeight()+20);; fH2->Resize(fFbottom->GetDefaultWidth(),fH2->GetDefaultHeight()+20);; fVf->AddFrame(fH1, new TGLayoutHints(kLHintsTop | kLHintsExpandX));. TGHSplitter *hsplitter = new TGHSplitter(fVf);; hsplitter->SetFrame(fH1,kTRUE);; fVf->AddFrame(hsplitter,new TGLayoutHints(kLHintsTop |; kLHintsExpandX));; fVf->AddFrame(fH2, new TGLayoutHints(kLHintsBottom |; kLHintsExpandX | kLHintsExpandY));; ```. For a `vertical` splitter the rules are:. - the parent of a vertical splitter must inherit from; **`TGCompoziteFrame`** and must have a horizontal layout. - the `left` resized frame must have `kFixedWidth` option set. - use layout hints `kLHintsLeft | kLHintsExpandY` when adding the; `left` resized frame to the parent. - use layout hints `kLHintsRight|kLHintsExpandX |kLHintsExpandY` when; adding the right resized frame to the parent. - set the `left` frame to be resized using `SetFrame` method; the; second parameter should be `kTRUE`. Next is a sample code for a vertical splitter:. ``` {.cpp}; // Create vertical splitter; fHf = new TGHorizontalFrame(fMain, 50, 50);; fV1 = new TGVerticalFrame(fHf, 10, 10, kFixedWidth);; fV2 = new TGVerticalFrame(fHf, 10, 10);; fFleft = new TGCompositeFrame(fV1, 10, 10, kSunkenFrame);; fFright = new TGCompositeFrame(fV2, 10, 10, kSunkenFrame);. fLleft = new TGLabel(fFleft, ""Left Frame"");; fLright = new TGLabel(fFright, ""Right Frame"");. fFleft->AddFrame(fLleft, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fFright->AddFrame(fLright, new ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:110086,Modifiability,inherit,inheriting,110086,"ier). A text/uri-list is a standard file listing format; for drag and drop that specifies a list of files (each file per line).; Each line ends with a carriage return and newline` rn`. File names have; to be valid, url-encoded URI's as shown below:. `file://localhost/usr/bin/opera` or; `file://localhost/c:/programs/myfile.txt`. `file://server/data/software.xml` or; `http://root.cern.ch/root/images/ftpstats.gif`. The atoms and the drag and drop manager (**`TGDNDManager`**), are; created at the main application creation time (class TGMainFrame). Setting a Drag Source - first, create and fill data:. ``` {.cpp}; TH1F *h = new TH1F(""h"",""h"",1000,-3,3);; h->FillRandom(""gaus"",50000);; TDNDdata data;; TBufferFile *buf = new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; ```. Then, set a GUI widget as DND Source, and associate the data. Source; widget can be any class inheriting from **`TGFrame`**. ``` {.cpp}; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; ```. Setting A Drop Target - set the widget as DND Target, and set the DND; types it must be aware of: as `SourceWidget`, `TargetWidget` can be any; class inheriting from **`TGFrame`**. ``` {.cpp}; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; ```. `gDNDManager->GetTypeList()` returns the list of types recognized by; ROOT. Note that the Widget may receive drag and drop messages with drop-data; it does not understand, and thus it should only accept drops of the; proper type. ### Handling Drag and Drop Events. Once a widget has been set as DND Target, it has to handle Drag and Drop; events. `Atom_t HandleDNDenter(Atom_t *typelist)` - this method is used to; handle a drag oper",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:110424,Modifiability,inherit,inheriting,110424,"ra` or; `file://localhost/c:/programs/myfile.txt`. `file://server/data/software.xml` or; `http://root.cern.ch/root/images/ftpstats.gif`. The atoms and the drag and drop manager (**`TGDNDManager`**), are; created at the main application creation time (class TGMainFrame). Setting a Drag Source - first, create and fill data:. ``` {.cpp}; TH1F *h = new TH1F(""h"",""h"",1000,-3,3);; h->FillRandom(""gaus"",50000);; TDNDdata data;; TBufferFile *buf = new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; ```. Then, set a GUI widget as DND Source, and associate the data. Source; widget can be any class inheriting from **`TGFrame`**. ``` {.cpp}; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; ```. Setting A Drop Target - set the widget as DND Target, and set the DND; types it must be aware of: as `SourceWidget`, `TargetWidget` can be any; class inheriting from **`TGFrame`**. ``` {.cpp}; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; ```. `gDNDManager->GetTypeList()` returns the list of types recognized by; ROOT. Note that the Widget may receive drag and drop messages with drop-data; it does not understand, and thus it should only accept drops of the; proper type. ### Handling Drag and Drop Events. Once a widget has been set as DND Target, it has to handle Drag and Drop; events. `Atom_t HandleDNDenter(Atom_t *typelist)` - this method is used to; handle a drag operation entering the widget. The typelist parameter is; the list of types the data contains. If the list contains one type the; widget understands, it should return this type to notify the manager; that the drop would be accepted, i.e. :. ``` {.cpp}; for (int i = 0; typelist[i] !=",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:11057,Performance,perform,performs,11057,"ertically in; a column. The next widget we create as a child of the main frame is the horizontal; frame `hframe`:. ``` {.cpp}; TGHorizontalFrame *hframe=new TGHorizontalFrame(fMain,200,40);; ```. The first parameter of its constructor is again the address of its; parent, `fMain`. The next ones define the frame width and height in; pixels. The name of the class **`TGHorizontalFrame`** gives a hint that; a horizontal layout will apply on its children widgets. The Draw and; Exit buttons will be laid out horizontally. Here are their constructors:. ``` {.cpp}; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; hframe ->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate(0)"");; hframe ->AddFrame(exit,new TGLayoutHints(kLHintsCenterX,5,5,3,4));; ```. They are created as objects of the **`TGTextButton`** class that; represent the command buttons with a text label. When you click on a; command button it performs the action shown on its label. These buttons; are well known as ""push buttons"" or just ""buttons"". The parent address; `hframe` is passed as first parameter. The second one defines the button; label and normally indicates the action to be taken when the button is; clicked. It is possible to define a hot key for the button at that point; using the hot string for its label. A hot string is a string with a; ""hot"" character underlined. This character we call the button hot key.; It shows the assigned keyboard mnemonic for the button choice. Following; our example, this means that you can use `Alt+D` to click on Draw button; and `Alt+E` to click on Exit. There is a possibility to specify a; command string as third parameter of the button constructor. We use it; to assign the command `gApplication->Terminate(0)`. The application will; be terminated when you click on the Exit button. We call again `AddFrame()` to add the buttons to their parent widget; giving layout hints for each of ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:34099,Performance,perform,performs,34099," the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/02000209.jpg). The base ""container"" class is **`TGCmpositeFrame`**. You can easily; change the layout manager using the; `SetLayoutManager(TGLayoutManager *l)` method. Setting the proper layout; manager for each container is the first step you have to do. The; container uses that layout manager to position and size the components; before they are painted. ROOT currently provides the layout managers; shown on the picture above. The next important step is to provide hints about every widget in the; container, i.e. to provide positions and right amount of space ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:53710,Performance,load,loaded,53710,"PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The first group is presented in ROOT by; **`TGPictureButton`** and **`TGTextButton`** classes. They yield an; action as soon as they are clicked. It can be opening/closing a dialog; box or invoking a specific function in an application. Remember the Draw; button from the example. The radio and check button",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56484,Performance,perform,performed,56484,"pts more information for users has the label generally followed by; ellipsis (...). ![](pictures/0300020D.png). As we saw the hot strings ""&Draw"" and ""&Exit"" define the text labels; ""Draw"" and ""Exit"" and keyboard mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the second one when there are more than three buttons. ![](pictures/0200020E.jpg",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:68567,Performance,perform,perform,68567,"LLimitMinMax, //specify limits; -1.,1.); //limit values; ```. **`TGNumberEntryField`** is a number entry input widget. ``` {.cpp}; Nent = new TGNumberEntryField(hgrunf2, kNENT_ID, 0.6,; TGNumberFormat::kNESRealThree,; TGNumberFormat::kNEAAnyNumber);; ```. **`TGNumberEntryField`** is a plain vanilla entry field, whereas; **`TGNumberEntry`** adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values. The; step size can be selected with control and shift keys:. - --small step (1 unit/factor of 3). - Shift medium step (10 units/factor of 10). - Controllarge step (100 units/factor of 30). - Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set; when the entry field is created, but it can be changed by pressing the; alt key at the same time. ### Menus. Menus provide a list of commands or options helping the user to select; and to perform a task. The menu system classes are **`TGMenuBar`**,; **`TGMenuTitle`**, **`TGPopupMenu`**, and **`TGMenuEntry`**. The **`TGMenuBar`** class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions described in menu titles, implemented by **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Also, it is always visible and; allows using the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar automatically; resizes itself so that it has the same width as its parent (typically; **`TGMainFrame`**). The menu bar is as a container for its menus - objects of the type; **`TGPopupMenu.`** Popup menus can appear in a menu bar. They can be a; sub-menu of another popup menu (cascading menus) or can be standalone; (as a context menu). They are made of one or mo",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:82454,Performance,perform,performed,82454,"st entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indicating the number of; selected choices (its position should be justified upper-right above; the list box). - if the actions `Select All` or `Deselect All` must be quickly or; frequently performed, use command buttons. ### Combo Boxes. A combo box is as single-selection list box that shows only the; currently selected entry and a prompt button displayed as a downward; arrow. The prompt button provides a visual cue that a list box is; hidden. Its main advantage is consuming of quite a bit of screen space.; When the user clicks on it, a list pops up, from which a new choice can; be made. After a new item is chosen the combo box folds again showing; the new selection. ![](pictures/0200021A.jpg). The combo box widget is represented by the user callable class; **`TGComboBox`**. The class **`TGComboBoxPopup`** is a service class.; The combo box constructor is very similar to the list box one. The first; parameter is a parent widget pointer again, the second - an integer; value that will be used as combo box ID. The method used for adding; entries is very similar to the list box method we used before. The; method `Select(entryID)` sets the current comb",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:87946,Performance,perform,performed,87946,"nherit; from the double slider widgets and allow easy selection of a range and a; pointer value. The pointer position can be constrained into the selected; range or can be relative to it. ![](pictures/0300021D.png). To change the slider range value press the left mouse button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progress",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:90980,Performance,cache,cached,90980,"ample creates an icon object. First we create an object of type; **`TGPicture`**. The **`TGPicture`** objects are never created directly; by the application code. We call **`TGClient`** telling it the pixmap's; file name to create a **`TGPicture`** object and, in turn, it will; return a pointer to the created object. If the pixmap file cannot be; found the returned pointer will be `NULL`. As usual, the first parameter; of a **`TGIcon`** constructor is the parent frame. The second one is the; **`TGPicture`** object holding the pixmap we want to show. Last two; parameters define the width and height of pixmap in pixels. In the end; we add the created icon object to its parent. ``` {.cpp}; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayoutHints(kLHintsLeft|kLHintsBottom,; 1, 15, 1, 1));; ```. The **`TGPicture`** objects are cached by **`TGClient`** in order to; keep the resource usage low and to improve the efficiency of the; client-server windowing systems. **`TGClient`** will check whether a; pixmap with the same name was already loaded before to register a new; picture object. If it finds it, it will return a pointer to the existing; object. Also, it will increase the usage counter for the object. All **`TGPicture`** objects are managed by the class; **`TGPicturePool`**. **`TGClient`** creates an object of this type upon; initialization. Normally your application program does not deal directly; with this class because all manipulations go through **`TGClient`**; class. Once you have finished with using of the **`TGPicture`** object, you; should call the method **`TGClient::FreePicture(const TGPicture *pic)`**; to free it. The usage counter of the picture object will be decreased; and when it reaches zero - the **`TGPicture`** object will be deleted. ### Status Bar. The status bar widget is used to display some information about the; current application ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:91192,Performance,load,loaded,91192,"plication code. We call **`TGClient`** telling it the pixmap's; file name to create a **`TGPicture`** object and, in turn, it will; return a pointer to the created object. If the pixmap file cannot be; found the returned pointer will be `NULL`. As usual, the first parameter; of a **`TGIcon`** constructor is the parent frame. The second one is the; **`TGPicture`** object holding the pixmap we want to show. Last two; parameters define the width and height of pixmap in pixels. In the end; we add the created icon object to its parent. ``` {.cpp}; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayoutHints(kLHintsLeft|kLHintsBottom,; 1, 15, 1, 1));; ```. The **`TGPicture`** objects are cached by **`TGClient`** in order to; keep the resource usage low and to improve the efficiency of the; client-server windowing systems. **`TGClient`** will check whether a; pixmap with the same name was already loaded before to register a new; picture object. If it finds it, it will return a pointer to the existing; object. Also, it will increase the usage counter for the object. All **`TGPicture`** objects are managed by the class; **`TGPicturePool`**. **`TGClient`** creates an object of this type upon; initialization. Normally your application program does not deal directly; with this class because all manipulations go through **`TGClient`**; class. Once you have finished with using of the **`TGPicture`** object, you; should call the method **`TGClient::FreePicture(const TGPicture *pic)`**; to free it. The usage counter of the picture object will be decreased; and when it reaches zero - the **`TGPicture`** object will be deleted. ### Status Bar. The status bar widget is used to display some information about the; current application state: what is being viewed in the window, a; descriptive message about selected objects, or other no interactive; information. It may also be use",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102721,Performance,load,loads,102721," to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object follo",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:104431,Performance,load,loaded,104431," the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. ![Histogram, pad and axis editors](pictures/03000222.png). ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/slots communication mechanism for event processing. (e) Implement the virtual method `SetModel(TObject *obj)` where all; widgets are set with the current object's attributes. This method is; called when the editor receives a signal from the canvas saying that an; object is the selected. (f) Implement all necessary slots and connect them to appropriate; signals that GUI widgets send out. The GUI classes in ROOT are developed; to emit signals whenever they change a state that others might be; interested. As we noted already, the signals/slots communication; mechanism allows total independence of",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:105677,Performance,cache,cached,105677,"e object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/slots communication mechanism for event processing. (e) Implement the virtual method `SetModel(TObject *obj)` where all; widgets are set with the current object's attributes. This method is; called when the editor receives a signal from the canvas saying that an; object is the selected. (f) Implement all necessary slots and connect them to appropriate; signals that GUI widgets send out. The GUI classes in ROOT are developed; to emit signals whenever they change a state that others might be; interested. As we noted already, the signals/slots communication; mechanism allows total independence of the interacting classes. #### Creation and Destruction. GED-frames are constructed during traversal of class hierarchy of the; selected object, executed from method **`TGedEditor`**`::SetModel()`.; When a new object of a different class is selected, the unneeded; GED-frames are cached in memory for potential reuse. The frames are; deleted automatically when the editor is closed. Note: A deep cleanup is assumed for all frames put into the editor. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-cl",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:112865,Performance,perform,performed,112865,"ce a widget has been set as DND Target, it has to handle Drag and Drop; events. `Atom_t HandleDNDenter(Atom_t *typelist)` - this method is used to; handle a drag operation entering the widget. The typelist parameter is; the list of types the data contains. If the list contains one type the; widget understands, it should return this type to notify the manager; that the drop would be accepted, i.e. :. ``` {.cpp}; for (int i = 0; typelist[i] != kNone; ++i) {; if (typelist[i] == gVirtualX->InternAtom(""application/root"")); // accept ""application/root"" DND type; return typelist[i];; }; // other type not accepted; return kNone;; ```. `Atom_t HandleDNDposition(Int_t x,Int_t y,Atom_t action,Int_t xroot,; Int_t yroot)` - this; method should be used to handle the drag position in widget coordinates; (`x,y`) or in root coordinates (`xroot,yroot`). ``` {.cpp}; // get the pad over which the cursor is; TPad *pad = fCanvas->Pick(x, y, 0);; if (pad) {; pad->cd();; gROOT->SetSelectedPad(pad);; }; return action;; ```. `Bool_t HandleDNDdrop(TDNDdata *data)` - this is the place where the; widget actually receives the data. First, check the data format (see; description of **`TDNDData`** - Drag and Drop data class) and then use; it accordingly. In the case of ROOT object, here is an example of how to; retrieve it:. ``` {.cpp}; if (data->fDataType == gVirtualX->InternAtom(""application/root"")) {; TBufferFile buf(TBuffer::kRead, data->fDataLength,; (void *)data->fData);; buf.SetReadMode();; TObject *obj = (TObject *)buf.ReadObjectAny(TObject::Class());; if (obj->IsA()->GetMethodAllAny(""Draw"")); obj->Draw();; }; ```. In the case of URI/list, the use is:. ``` {.cpp}; if (data->fDataType == gVirtualX->InternAtom(""text/uri-list"")) {; TString sfname((char *)data->fData);; TUrl uri(sfname.Data());; if (sfname.EndsWith("".jpg""); TImage *img = TImage::Open(uri.GetFile());; }; ```. `Bool_t HandleDNDleave()` is used if a specific action has to be; performed when the drag operation leaves the widget.; ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33575,Safety,avoid,avoid,33575,"class presents a very convenient frame which; surrounds visually a group of logically connected widgets: radio; buttons, related check boxes, two or more functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/020002",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:40257,Safety,detect,detect,40257,"frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:78295,Safety,avoid,avoid,78295," of the `ToolBarData_t` structure is filled in; (if the icon pixmap was valid). The first parameter is the window to; which the button messages will be sent. Lastly, we create an object of; class **`TGHorizontal3DLine`** - a horizontal 3D line. It will separate; the toolbar from the menu bar because the layout hints we define as; `kLHintsTop` | `kLHintsExpandX`. It is user friendly to allow the possibility for the tool bar to be; turned on or off (via a menu). If you use a single tool bar, it should; fill the complete width of its parent. When using more than one, you; should also think about setting the bar size to the end of the most; right button. This way other bars can be displayed in the same row below; the menu bar. Tool bar buttons should have equal size, meaningful and unique icons,; and short meaningful tool tip text. The related buttons should be; grouped together by frequency or sequence of use, or importance.; Potentially destructive buttons must be separated from them to avoid; accidental activation and potentially catastrophic results. Temporarily; not available items should be displayed grayed out. ### List Boxes. The purpose of a list box is to display a collection of items from which; single or multiple selection can be made. It is always visible, having a; scroll bar when the displayed area is not enough to show all items. The; choices may be mutually exclusive (a list box with single selection) or; not mutually exclusive (a list box with multiple selection). ![](pictures/02000219.jpg). The proper usage of the list boxes is for selecting values, or objects,; or setting attributes. You have to create them to display 4 to 8 choices; at one time (3 is a required minimum in case of lack of screen space).; The list should contain not more than 40 items accessible by scrolling; view (vertical scroll bar). If more are required, you should provide a; method for using search criteria or scoping the options. The best list; boxes use is for textual data or ch",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21259,Security,access,access,21259,"seful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the widget's; events, the widget status flags and the assigned command (if there is; any). The general properties of **`TGWidget`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWi",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:44067,Security,access,access,44067," start with; `RQ_OBJECT(""ClassName"") `macro. This macro allows the signals/slots; communication mechanism to be applied between compiled and interpreted; classes in an interactive ROOT session without having the class derive; from **`TQObject`**. Every signal method declaration is followed by a; comment `""*SIGNAL*"".` Only instances of a class that defines a signal or; instances of its subclasses can emit the signal. The ROOT implementation; of a popular example presenting signals and slots is the next. Let's; have a minimal class declaration:. ``` {.cpp}; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; ```. It will become the following as interpreted:. ``` {.cpp}; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; ```. Both class declarations have the same data member and public methods to; access the value. By placing the `RQ_OBJECT(""MyClass"")` macro inside the; `MyClass` body (`MyClass` is not inherited from **`TQObject`**) we allow; this class to use the signal/slot communication. Any instance of this; class can tell the outside world that the state of its data member has; changed by emitting a signal `SetValue(Int_t).` A possible; implementation of `MyClass::SetValue()` can be:. ``` {.cpp}; void MyClass::SetValue(Int_t v) {; if (v != fValue) {; fValue = v;; Emit(""SetValue(Int_t)"",v);; }; }; ```. The line `Emit(""SetValue(Int_t)"",v)` activates the signal; `SetValue(Int_t)` with argument v. You can use any of the methods; **`TQObject::Emit(""full_method_name"",arguments)`** to emit a signal. We; create two instances of `MyClass` and connect them together:. ``` {.cpp}; MyClass *objA = new MyClass();; MyClass *objB = new MyClass();; objA->Connect(""SetValue(Int_t)"",""MyClass"",objB,""SetValue(Int_t)"");; objB->SetValue(11);; objA->SetValue(79);; objB->",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:50190,Security,access,access,50190,"ot method in; the following way:. ``` {.cpp}; Connect(myButton, ""Pressed()"", ""TH1"", hist, ""SetMaximum(=123) "");; Connect(myButton, ""Pressed()"", ""TH1"", hist, ""Draw(=\""LEGO\"")"");; ```. As you see the parameter's value is preceded by the equation symbol (=).; Please note that this method of passing arguments by value works only; if the signal has less arguments than the slot.; If the signal method has the same number of arguments, then the slot; argument will be overwritten with the signal argument. In the; example below, the Draw option would be overwritten in the first line; by the emitted signal argument. The second line would be ok, the; argument passed by value would not be overwritten. ``` {.cpp}; Connect(myComboBox, ""Selected(const char*)"", ""TTree"", myTree, ""Draw(=\""x\"")"");; Connect(myComboBox, ""Selected(const char*)"", ""TTree"", myTree, ""Draw(const char*, =\"" y==1 \"")"");; ```. In addition, if the signal and slot arguments differ in argument type,; passing arguments by value leads to undefined behaviour and illegal; memory access, as the signal argument will be casted to another data; type. In the example below, if Selected emits Int_t = 1, then ChangeText; will try to read a TString at address 0x1. ``` {.cpp}; Connect(myComboBox, ""Selected(Int_t)"", ""TGTextButton"", myButton, ""ChangeText(=\""Hello\"")"");; ```. You have the possibility to destroy a signal/slot connection by using; `Disconnect()` methods. There are three ways to do this:. 1/ to destroy all connections to an object's signals;. 2/ to destroy all connections to a particular object's signal; 3/ to; detach an object from a specific receiver:. ``` {.cpp}; Disconnect(myObgect); // case 1; Disconnect(myObgect, ""mySignal""); // case 2; Disconnect(myObgect,0,myReceiver,0); // case 3; ```. Three parameters of these methods could be replaced by 0. The meaning in; these cases would be ""any signal"", ""any receiving object"", ""any slot of; the receiving object"", i.e. 0 is used as a wildcard. The sender; parameter cannot ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:55932,Security,access,access,55932," and check buttons change their appearance; when they are selected and keep that appearance afterwards. A text button is represented by the class **`TGTextButton`**. We already; used its constructor in the example. The button label indicates the; action to be taken when the button is selected or pressed. The text can; be a hot string defining a hot key (known as shortcut key also) for this; selection. The hot key is an underlined character in a button label that; shows the assigned keyboard mnemonic for its choice. A button that; prompts more information for users has the label generally followed by; ellipsis (...). ![](pictures/0300020D.png). As we saw the hot strings ""&Draw"" and ""&Exit"" define the text labels; ""Draw"" and ""Exit"" and keyboard mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window wi",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:57673,Security,access,access,57673,"es for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the second one when there are more than three buttons. ![](pictures/0200020E.jpg). Picture buttons are usually rectangular in shape with an icon or; graphics label. These buttons may appear alone or placed in a group at; the window's top or side. They are most frequently used to quickly; access commands, many of which are normally accessed through the tool; bar. For example, the picture buttons below can be used to provide; different styles of a histogram drawing. ![](pictures/0200020F.jpg). Here is the example how to create the first button:. ``` {.cpp}; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; ```. The picture of file h1\_s.xpm is used in the button. All `.xpm` files; are located in the directory `$ROOTSYS/icons`. You can assign a command; directly as a parameter of the picture button constructor. The picture; of **`TGPictureButton`** can be changed by:. ``` {.cpp}; fPicture->SetPicture(""h2_s.xpm"");; ```. The advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadv",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:57717,Security,access,accessed,57717,"es for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the second one when there are more than three buttons. ![](pictures/0200020E.jpg). Picture buttons are usually rectangular in shape with an icon or; graphics label. These buttons may appear alone or placed in a group at; the window's top or side. They are most frequently used to quickly; access commands, many of which are normally accessed through the tool; bar. For example, the picture buttons below can be used to provide; different styles of a histogram drawing. ![](pictures/0200020F.jpg). Here is the example how to create the first button:. ``` {.cpp}; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; ```. The picture of file h1\_s.xpm is used in the button. All `.xpm` files; are located in the directory `$ROOTSYS/icons`. You can assign a command; directly as a parameter of the picture button constructor. The picture; of **`TGPictureButton`** can be changed by:. ``` {.cpp}; fPicture->SetPicture(""h2_s.xpm"");; ```. The advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadv",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:59381,Security,access,access,59381,"advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadvantage of the text and picture buttons is that they consume; considerable screen space if they are many. Having no more than six; command buttons per window or dialog box helps to appropriately balance; the application's effectiveness, its real efficiency, and the; operational simplicity. The classes **`TGRadioButton`** and **`TGCheckButton`** present the; option buttons in ROOT. Like the text buttons, they have text or hot; string as a label. Radio buttons are grouped in logical sets of two or; more and appear with a text label to the right. The choices are mutually; exclusive and only one setting is permitted at one time. They represent; visually all alternatives and it is easy to access and compare choices.; They facilitate the situations where all alternatives cannot be easily; remembered or where displaying the alternatives together helps to; understand and select the proper choice. It is very useful to provide a; default setting whenever it is possible. When it is not possible to; establish a default setting because of the nature of the information, it; is better to leave all radio buttons blank. ![](pictures/03000210.png). A columnar orientation is the preferred manner of radio buttons; presentation. If the vertical space on the window is limited, they can; be oriented horizontally. Selection choices should be organized; logically in groups. Here is the example that produces the image above:. ``` {.cpp}; br = new TGButtonGroup(p,""Coordinate system"",kVerticalFrame);; fR[0] = new TGRadioButton(bg,new TGHotString(""&Pixel""));; fR[1] = new TGRadioButton(bg,new TGHotString(""&NDC ""));; fR[2] = new TGRadioButton(bg,new TGHotString(""&User ""));; fR[1",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:62290,Security,access,access,62290,"p`** and **`TGVButtonGroup`** are convenience classes; that offer you a thin layer on top of **`TGButtonGroup`**.; **`TGHButtonGroup`** organize button widgets in a group of one; horizontal row, **`TGVButtonGroup`** in a group of one column. You can; also organize buttons in rows and columns using the provided constructor; and **`TGMatrixLayout`**. Do not use a radio button to indicate the presence or absence of a state; - use a check box instead. ![](pictures/03000212.png). To have the check button ""Event Status"" and to set it as selected we; need to write:. ``` {.cpp}; TGCheckButton *estat = new TGCheckButton(p, ""Event Status"",1);; estat->SetState(kButtonDown);; ```. Check boxes show the selected choices and any number of them can be; selected, including none. Their proper usage is for setting attributes,; properties or values; also for data or choices that are discrete, small; and fixed in number, not easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, mus",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:68781,Security,access,access,68781," vanilla entry field, whereas; **`TGNumberEntry`** adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values. The; step size can be selected with control and shift keys:. - --small step (1 unit/factor of 3). - Shift medium step (10 units/factor of 10). - Controllarge step (100 units/factor of 30). - Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set; when the entry field is created, but it can be changed by pressing the; alt key at the same time. ### Menus. Menus provide a list of commands or options helping the user to select; and to perform a task. The menu system classes are **`TGMenuBar`**,; **`TGMenuTitle`**, **`TGPopupMenu`**, and **`TGMenuEntry`**. The **`TGMenuBar`** class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions described in menu titles, implemented by **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Also, it is always visible and; allows using the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar automatically; resizes itself so that it has the same width as its parent (typically; **`TGMainFrame`**). The menu bar is as a container for its menus - objects of the type; **`TGPopupMenu.`** Popup menus can appear in a menu bar. They can be a; sub-menu of another popup menu (cascading menus) or can be standalone; (as a context menu). They are made of one or more menu items choices.; When displayed, the menu items are arranged in a vertical list. Usually; they correspond to actions (e.g. `Open`**)**. These items can be labeled; with text, graphics or a combination of both. Each of them should have a; character defined as its unique key for acces",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:69820,Security,access,access,69820,"o common and frequently used application; actions described in menu titles, implemented by **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Also, it is always visible and; allows using the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar automatically; resizes itself so that it has the same width as its parent (typically; **`TGMainFrame`**). The menu bar is as a container for its menus - objects of the type; **`TGPopupMenu.`** Popup menus can appear in a menu bar. They can be a; sub-menu of another popup menu (cascading menus) or can be standalone; (as a context menu). They are made of one or more menu items choices.; When displayed, the menu items are arranged in a vertical list. Usually; they correspond to actions (e.g. `Open`**)**. These items can be labeled; with text, graphics or a combination of both. Each of them should have a; character defined as its unique key for access. Grouped logically by; their functionality, they are separated visually by menu separators in; groups. For example, The `File` menu is a common menu title for tasks; that apply to a file, as **`Open`**,**`Save`**,**`Close`**,**`Print`**... ``` {.cpp}; // a popup menu; fMenuFile = new TGPopupMenu(gClient->GetRoot());. // adding menu entries; fMenuFile->AddEntry(""&Open..."",M_FILE_OPEN);; fMenuFile->AddEntry(""&Save"",M_FILE_SAVE);; fMenuFile->AddEntry(""S&ave as..."",M_FILE_SAVEAS);; fMenuFile->AddEntry(""&Close"", -1);. // adding separator; fMenuFile->AddSeparator();. // next group of menu entries; fMenuFile->AddEntry(""&Print"",M_FILE_PRINT);; fMenuFile->AddEntry(""P&rint setup..."",M_FILE_PRINTSETUP);; . . .; fMenuFile->AddSeparator();; fMenuFile->AddEntry(""E&xit"",M_FILE_EXIT);; ```. First we create the File menu by creating an object of; class**` TGPopupMenu`** and adding menu entries with `AddEntry` method.; Its first parameter is a hot string, the second",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:72470,Security,access,access,72470,"in using more. Next lines show how to create a menu bar with; `File`**,**`Test` and `Help` menus:. ``` {.cpp}; // menu bar item layout hints; fMBItemLayout = new TGLayoutHints(kLHintsTop|kLHintsLeft,0,4,0,0);; fMBHelpLayout = new TGLayoutHints(kLHintsTop|kLHintsRight);. // menu bar; fMenuBar = new TGMenuBar(fMain,100,20,kHorizontalFrame);. // adding popup menus; fMenuBar->AddPopup(""&File"", fMenuFile, fMBItemLayout);; fMenuBar->AddPopup(""&Test"", fMenuTest, fMBItemLayout);; fMenuBar->AddPopup(""&Help"", fMenuHelp, fMBHelpLayout);; ```. Using the method `TGMenuBar::AddPopup` we add three **`TGPopupMenu`**; objects to the menu bar `fMenuBar`. The first parameter is a hot string; used by **`TGMenuTitle`** object. When you add a popup menu to the menu; bar, a **`TGMenuTitle`** object is created by the menu bar. It is the; name of the popup menu. A menu title should have a one-word name that; reflects the purpose of all items within the corresponding popup menu.; It should also have a defined character as its unique access key. The; second parameter is the popup menu we would like to add. The third one; is an object of **`TGLayoutHints`** type that defines how the menu title; will be laid out in the menu bar. In our example the *`File`* and `Test`; menus will be laid out to the left of the menu bar with 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All rela",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:73754,Security,access,access,73754,"th 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub application within an; application. All its functions can be obtained by application menus. It; is located horizontally at the top of the main window just below the; menu bar. All other subtask and sub-feature bars are positioned along; sides of window. ``` {.cpp}; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",;",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:74286,Security,access,access,74286,"; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub application within an; application. All its functions can be obtained by application menus. It; is located horizontally at the top of the main window just below the; menu bar. All other subtask and sub-feature bars are positioned along; sides of window. ``` {.cpp}; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",; 0; };; // toolbar tool tip text; const char *tips[] = {; ""X Settings"",; ""Y Settings"",; ""Z Settings"",; 0; };; // toolbar button separator; int separator = 5;. // structure containing toolbar button information; ToolBarData_t t[3];. // creation of a toolbar object as a child of main frame; TGToolBar *tb = new TGToolBar(fMain,520,80);. for (int i = 0; i < 3; i++) {; // filling the ToolBarData_t with information; t[i].fPixmap = xpms[i]; // icon file; t[i].fTipText = tips[i]; // tool tip text; t[i].fStayDown = kFALSE; // button behavior if clicked; t[i].",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:79092,Security,access,accessible,79092,"ons,; and short meaningful tool tip text. The related buttons should be; grouped together by frequency or sequence of use, or importance.; Potentially destructive buttons must be separated from them to avoid; accidental activation and potentially catastrophic results. Temporarily; not available items should be displayed grayed out. ### List Boxes. The purpose of a list box is to display a collection of items from which; single or multiple selection can be made. It is always visible, having a; scroll bar when the displayed area is not enough to show all items. The; choices may be mutually exclusive (a list box with single selection) or; not mutually exclusive (a list box with multiple selection). ![](pictures/02000219.jpg). The proper usage of the list boxes is for selecting values, or objects,; or setting attributes. You have to create them to display 4 to 8 choices; at one time (3 is a required minimum in case of lack of screen space).; The list should contain not more than 40 items accessible by scrolling; view (vertical scroll bar). If more are required, you should provide a; method for using search criteria or scoping the options. The best list; boxes use is for textual data or choices. They should be wide enough to; display fully all items. When it is not possible, break the long items; with ellipsis and provide tool tip that displays the full item text. The list box widget is represented by **`TGListBox`**,; **`TGLBContainer`**, **`TGLBEntry`** and **`TGTextLBEntry`** classes.; Currently entries are simple text strings (**`TGTextLBEntry`**). A; **`TGListBox`** looks a lot like a **`TGCanvas`**. It has a; **`TGViewPort`** containing a **`TGLBContainer`** which contains the; entries and it also has a vertical scrollbar which becomes visible if; there are more items than fit in the visible part of the container. The; **`TGListBox`** is user callable. The other classes are service classes; of the list box. Here is a sample code showing how to create a list box; wit",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:32630,Testability,log,logically,32630,"e().` This call tells the Window Manager that it; should not resize the window. The option `kFixedSize` works only for; embedded frames like **`TGCompositeFrame`** and derived classes (in; combination with layout hints). The **`TGVerticalFrame`** and **`TGHorizontalFrame`** are composite; frames that lay out their child frames in vertical or horizontal way in; the same order as they were added and according to their hints; preferences. The **`TGTransientFrame`** class defines transient windows that; typically are used for dialogs. They extend and complete an interaction; within a limited context. Always transient frames are displayed from; another window or another dialog. They may appear because of a command; button being activated or a menu item being selected. They may also; present automatically when an additional input and the user attention; are required by a certain condition. The **`TGGroupFrame`** class presents a very convenient frame which; surrounds visually a group of logically connected widgets: radio; buttons, related check boxes, two or more functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:59166,Testability,log,logical,59166,"and; directly as a parameter of the picture button constructor. The picture; of **`TGPictureButton`** can be changed by:. ``` {.cpp}; fPicture->SetPicture(""h2_s.xpm"");; ```. The advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadvantage of the text and picture buttons is that they consume; considerable screen space if they are many. Having no more than six; command buttons per window or dialog box helps to appropriately balance; the application's effectiveness, its real efficiency, and the; operational simplicity. The classes **`TGRadioButton`** and **`TGCheckButton`** present the; option buttons in ROOT. Like the text buttons, they have text or hot; string as a label. Radio buttons are grouped in logical sets of two or; more and appear with a text label to the right. The choices are mutually; exclusive and only one setting is permitted at one time. They represent; visually all alternatives and it is easy to access and compare choices.; They facilitate the situations where all alternatives cannot be easily; remembered or where displaying the alternatives together helps to; understand and select the proper choice. It is very useful to provide a; default setting whenever it is possible. When it is not possible to; establish a default setting because of the nature of the information, it; is better to leave all radio buttons blank. ![](pictures/03000210.png). A columnar orientation is the preferred manner of radio buttons; presentation. If the vertical space on the window is limited, they can; be oriented horizontally. Selection choices should be organized; logically in groups. Here is the example that produces the image above:. ``` {.cpp}; br = new TGButtonGroup(p,""Coordinate system"",kVerticalFrame);; ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:60039,Testability,log,logically,60039,"on`** present the; option buttons in ROOT. Like the text buttons, they have text or hot; string as a label. Radio buttons are grouped in logical sets of two or; more and appear with a text label to the right. The choices are mutually; exclusive and only one setting is permitted at one time. They represent; visually all alternatives and it is easy to access and compare choices.; They facilitate the situations where all alternatives cannot be easily; remembered or where displaying the alternatives together helps to; understand and select the proper choice. It is very useful to provide a; default setting whenever it is possible. When it is not possible to; establish a default setting because of the nature of the information, it; is better to leave all radio buttons blank. ![](pictures/03000210.png). A columnar orientation is the preferred manner of radio buttons; presentation. If the vertical space on the window is limited, they can; be oriented horizontally. Selection choices should be organized; logically in groups. Here is the example that produces the image above:. ``` {.cpp}; br = new TGButtonGroup(p,""Coordinate system"",kVerticalFrame);; fR[0] = new TGRadioButton(bg,new TGHotString(""&Pixel""));; fR[1] = new TGRadioButton(bg,new TGHotString(""&NDC ""));; fR[2] = new TGRadioButton(bg,new TGHotString(""&User ""));; fR[1]->SetState(kButtonDown);; br->Show();; ```. It is enough to change `kVerticalFrame` to `kHorizontalFrame` in; **`TGButtonGroup`** constructor and you will have radio buttons aligned; horizontally:. ![](pictures/03000211.png). The class **`TGButtonGroup`** will help you to organize button widgets; in a group. There is no need to call `AddFrame()` since the buttons are; added automatically with a default layout hint to their parent by; **`TGButtonGroup`**`::Show()` as shown in the previous example. The; buttons in the group have assigned identifiers. Any button in a group; emits a `Clicked()` signal with this identifier when it is clicked. This; giving an id",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:68337,Testability,log,logarithmic,68337,"- both lower and upper limits. ``` {.cpp}; fN1 = new TGNumberEntry(parent, 0.005, 9, kENTRY1,; TGNumberFormat::kNESRealThree, //style; TGNumberFormat::kNEAAnyNumber, //input value filter; TGNumberFormat::kNELLimitMinMax, //specify limits; -1.,1.); //limit values; ```. **`TGNumberEntryField`** is a number entry input widget. ``` {.cpp}; Nent = new TGNumberEntryField(hgrunf2, kNENT_ID, 0.6,; TGNumberFormat::kNESRealThree,; TGNumberFormat::kNEAAnyNumber);; ```. **`TGNumberEntryField`** is a plain vanilla entry field, whereas; **`TGNumberEntry`** adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values. The; step size can be selected with control and shift keys:. - --small step (1 unit/factor of 3). - Shift medium step (10 units/factor of 10). - Controllarge step (100 units/factor of 30). - Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set; when the entry field is created, but it can be changed by pressing the; alt key at the same time. ### Menus. Menus provide a list of commands or options helping the user to select; and to perform a task. The menu system classes are **`TGMenuBar`**,; **`TGMenuTitle`**, **`TGPopupMenu`**, and **`TGMenuEntry`**. The **`TGMenuBar`** class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions described in menu titles, implemented by **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Also, it is always visible and; allows using the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar automatically; resizes itself so that it has the same width as its parent (typically; **`TGMainFrame`**). The menu bar is as a container for its menus - obj",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:69836,Testability,log,logically,69836,"y **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Also, it is always visible and; allows using the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar automatically; resizes itself so that it has the same width as its parent (typically; **`TGMainFrame`**). The menu bar is as a container for its menus - objects of the type; **`TGPopupMenu.`** Popup menus can appear in a menu bar. They can be a; sub-menu of another popup menu (cascading menus) or can be standalone; (as a context menu). They are made of one or more menu items choices.; When displayed, the menu items are arranged in a vertical list. Usually; they correspond to actions (e.g. `Open`**)**. These items can be labeled; with text, graphics or a combination of both. Each of them should have a; character defined as its unique key for access. Grouped logically by; their functionality, they are separated visually by menu separators in; groups. For example, The `File` menu is a common menu title for tasks; that apply to a file, as **`Open`**,**`Save`**,**`Close`**,**`Print`**... ``` {.cpp}; // a popup menu; fMenuFile = new TGPopupMenu(gClient->GetRoot());. // adding menu entries; fMenuFile->AddEntry(""&Open..."",M_FILE_OPEN);; fMenuFile->AddEntry(""&Save"",M_FILE_SAVE);; fMenuFile->AddEntry(""S&ave as..."",M_FILE_SAVEAS);; fMenuFile->AddEntry(""&Close"", -1);. // adding separator; fMenuFile->AddSeparator();. // next group of menu entries; fMenuFile->AddEntry(""&Print"",M_FILE_PRINT);; fMenuFile->AddEntry(""P&rint setup..."",M_FILE_PRINTSETUP);; . . .; fMenuFile->AddSeparator();; fMenuFile->AddEntry(""E&xit"",M_FILE_EXIT);; ```. First we create the File menu by creating an object of; class**` TGPopupMenu`** and adding menu entries with `AddEntry` method.; Its first parameter is a hot string, the second - a menu ID. The; ampersand character (&) denotes shortcut for each menu entry; you can;",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:1469,Usability,progress bar,progress bars,1469,"GUI fully cross-platform. Originally the GUI; classes were based on Hector Peraza's Xclass'95 widget library; <http://xclass.sourceforge.net/>. ## The ROOT GUI Classes. Features of the GUI classes in a nutshell:. - Originally based on the Xclass'95 widget library. - A rich and complete set of widgets. - Win'95 look and feel. - All machine dependent graphics calls abstracted via the; **`TVirtualX`** ""abstract"" class. - Completely scriptable via the C++ interpreter (fast prototyping). - Supports signal/slot event handling as pioneered by Trolltech's Qt. - Full class documentation is generated automatically (as for all ROOT; classes). - Code generation for variety of GUI's. ## Widgets and Frames. The ROOT GUI classes provide of set of components that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract g",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2739,Usability,simpl,simple,2739,"nged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2871,Usability,simpl,simple,2871," x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; behavior for them. For example, if you want to hide several widgets, it; will be enough to hide their parent widget. Later you can show the; parent and the children will appear ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:4148,Usability,simpl,simple,4148,"ion in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; behavior for them. For example, if you want to hide several widgets, it; will be enough to hide their parent widget. Later you can show the; parent and the children will appear too. Writing your code you have to; specify the parent-child relationship. Usually in a child constructor; the address of the parent is passed as an argument. In general frames; are parents of simple widgets. In this example you will see how we; organize the parent-children relationship by using frame widgets in; addition to the canvas window and button widgets. Let's now go through the code of the `example.C`. The first lines include ROOT header files. The header file names are; almost always as the class names (**`TApplication`**, **`TF1`**,; **`TCanvas`**), but there are cases when similar classes are grouped; together in one header file: all frames are declared in `TGFrame.h`, all; buttons - in `TGButton.h`, etc. Our small example is based on an object; of the class `MyMainFrame`. ``` {.cpp}; new MyMainFrame(gClient->GetRoot(),200,200);; ```. The first parameter `gClient->GetRoot()` makes the initial connection to; the window server. It is a pointer to the root window of the screen,; which is obtained from ***`gClient`***. The next two parameters; initialize the width and height of the application window in pixels. Let; see what `MyMainFrame` is. The three argu",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:15741,Usability,simpl,simple,15741,"he connection to the system. - Definition of main frame (top level window). - Creation of widgets as children of the top-level frame; assign them; desired properties following the steps:. - Create a new widget passing its parent in the constructor. - Connect widget's signals with desired slots to ensure desired; functionality. - Define widget's layout and add it to the parent list of children. - Set main window attributes. - Map all sub windows. - Initialize the layout algorithm via `Resize(GetDefaultSize())`; method. - Map the main frame. - Execution of the even-processing loop. ### A Standalone Version. As usual a standalone program in C++ has to contain a main() function -; the starting point for the application execution. In this case it is; better to separate the program code creating a program header file; example2a.h with the `MyMainFrame` class declaration and; `example2a.cxx `- with the class methods implementation. To run our; simple example as a standalone application we need to create in addition; an object of class **`TApplication`**. It will make a correct; initialization of the dictionaries if it is not yet done. It will be; responsible for holding everything together and to handle all events in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; contain",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:20449,Usability,guid,guidelines,20449,"new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; ```. ## Widgets Overview. The word widget is a contraction of windows and gadget. Almost all GUI; elements are widgets. A button is a widget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system fo",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:24516,Usability,simpl,simple,24516,"Focus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the window system; and can paint a representation of itself on the screen. ![](pictures/02000205.jpg). ### Frames. Most of the frame classes are mainly created for arranging widgets in a; window. The class **`TGFrame`** is a subclass of **`TGWindow`**; providing additional window characteristics and overriding some methods; of **`TGWindow`**. It is a base class for the simple widgets as buttons,; labels, etc. Its only purpose is to draw a frame around widgets that do; not have a frame of their own. The main groups of **`TGFrame`** member; functions are:. - Window's functions: `DoRedraw()`, `DeleteWindow()`, `Activate()`,; etc. - Geometry functions: `Move()`, `Resize()`, `SetSize()`, etc. - Graphics handlers: `ChangeBackground()`, `ChangeOptions()`, etc. - Mouse and keyboard functions: `HandleButton()`,; `HandleFocusChange()`, `HandleKey()`, `HandleMotion()`, etc. - Event handlers: `HandleEvent()`, `ProcessEvent()`, `GetSender()`,; `SendMessage()`,` ProcessMessage()`, `GetLastClick()`, etc. ![The GUI classes hierarchy](pictures/02000206.jpg). Ones of **`TGFrame`** member functions provide direct functionality;; others - will be overridden by **`TGFrame`** subclasses to ensure; particular widget's functionality. There are two constructors provided; in **`TGFrame`** class. One creates a frame using an externally created; window:. ``` {.cpp}; TGFrame(TGClient ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33674,Usability,simpl,simple,33674,"e functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/02000209.jpg). The base ""container"" class is **`TGCmpositeFrame`**. You can easily; change the layout manager using the; `SetLayoutManager(TGLayoutManager *l)",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33751,Usability,simpl,simple,33751,"e functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/02000209.jpg). The base ""container"" class is **`TGCmpositeFrame`**. You can easily; change the layout manager using the; `SetLayoutManager(TGLayoutManager *l)",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41100,Usability,simpl,simple,41100,"he mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41572,Usability,simpl,simple,41572,"events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyM",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:41907,Usability,simpl,simple,41907,"s of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does not know whether anything is interested in this information. On; the other side there might be an object waiting for that signal and; ready to react to it. This object disposes of special instruments to; listen to the sent out signals. To have a communication we need a; message transmission between the objects. In this simple example we use; signals and slots. The code of the method **`TGButton::Clicked()`** is:. ``` {.cpp}; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; ```. I.e. any button emits the signal `Clicked()` any time someone clicks on; it. As you can see this method is virtual and could be overridden if you; need to. In our simple example we call the `Connect()` method to connect; the `Clicked()` signal of Draw button with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; ```. Here is an abstract view of the signal/slots connections in `example.C`:. ![](pictures/0200020C.jpg). To benefit from this mechanism your classes ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:53396,Usability,simpl,simplifies,53396,"ots mechanism in; a standalone executable program on `linux` platform with the `gcc`; compiler. `tst.C `. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56379,Usability,guid,guidelines,56379,"shows the assigned keyboard mnemonic for its choice. A button that; prompts more information for users has the label generally followed by; ellipsis (...). ![](pictures/0300020D.png). As we saw the hot strings ""&Draw"" and ""&Exit"" define the text labels; ""Draw"" and ""Exit"" and keyboard mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the sec",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:56681,Usability,guid,guidelines,56681,"mnemonics `Alt+D`, `Alt+E` for their; selection. The letter D and E appear underlined on the screen. All text; buttons should have a unique shortcut key with the exception of OK and; Cancel. These buttons are usually placed within a window to provide fast access; to frequently used or critical commands. They help in situations where a; command is not available through the menu bar. You already know that a; command string can be passed in the text button via the constructor:. ``` {.cpp}; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; ```. A button label can be changed by `SetText(new_label).` There are; important guidelines to be followed about a button label. The text has; to provide a meaningful description of the performed action. The; single-word label should be used whenever possible, only two-three words; for clarity, if necessary. Do not number labels. Always follow all; platform presentation and usage guidelines for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the second one when there are more than three buttons. ![](pictures/0200020E.jpg). Picture buttons are usually rectangular in shape with an icon or; graphics label. These buttons may appear alone or placed in a group at; the window's top or side. They are most frequently used to quickly; acc",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:58967,Usability,simpl,simplicity,58967," is the example how to create the first button:. ``` {.cpp}; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; ```. The picture of file h1\_s.xpm is used in the button. All `.xpm` files; are located in the directory `$ROOTSYS/icons`. You can assign a command; directly as a parameter of the picture button constructor. The picture; of **`TGPictureButton`** can be changed by:. ``` {.cpp}; fPicture->SetPicture(""h2_s.xpm"");; ```. The advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadvantage of the text and picture buttons is that they consume; considerable screen space if they are many. Having no more than six; command buttons per window or dialog box helps to appropriately balance; the application's effectiveness, its real efficiency, and the; operational simplicity. The classes **`TGRadioButton`** and **`TGCheckButton`** present the; option buttons in ROOT. Like the text buttons, they have text or hot; string as a label. Radio buttons are grouped in logical sets of two or; more and appear with a text label to the right. The choices are mutually; exclusive and only one setting is permitted at one time. They represent; visually all alternatives and it is easy to access and compare choices.; They facilitate the situations where all alternatives cannot be easily; remembered or where displaying the alternatives together helps to; understand and select the proper choice. It is very useful to provide a; default setting whenever it is possible. When it is not possible to; establish a default setting because of the nature of the information, it; is better to leave all radio buttons blank. ![](pictures/03000210.png). A columnar orientation is the preferred manner of",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63138,Usability,clear,clearly,63138,"s or values; also for data or choices that are discrete, small; and fixed in number, not easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined a",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63200,Usability,clear,clear,63200,"easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contain",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63297,Usability,clear,clear,63297,"cause they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contains text; that is entered or modified through the keyboard. This text may be; displayed in different way accordin",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:73432,Usability,simpl,simple,73432,"It should also have a defined character as its unique access key. The; second parameter is the popup menu we would like to add. The third one; is an object of **`TGLayoutHints`** type that defines how the menu title; will be laid out in the menu bar. In our example the *`File`* and `Test`; menus will be laid out to the left of the menu bar with 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub applicatio",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:79624,Usability,simpl,simple,79624,"enough to show all items. The; choices may be mutually exclusive (a list box with single selection) or; not mutually exclusive (a list box with multiple selection). ![](pictures/02000219.jpg). The proper usage of the list boxes is for selecting values, or objects,; or setting attributes. You have to create them to display 4 to 8 choices; at one time (3 is a required minimum in case of lack of screen space).; The list should contain not more than 40 items accessible by scrolling; view (vertical scroll bar). If more are required, you should provide a; method for using search criteria or scoping the options. The best list; boxes use is for textual data or choices. They should be wide enough to; display fully all items. When it is not possible, break the long items; with ellipsis and provide tool tip that displays the full item text. The list box widget is represented by **`TGListBox`**,; **`TGLBContainer`**, **`TGLBEntry`** and **`TGTextLBEntry`** classes.; Currently entries are simple text strings (**`TGTextLBEntry`**). A; **`TGListBox`** looks a lot like a **`TGCanvas`**. It has a; **`TGViewPort`** containing a **`TGLBContainer`** which contains the; entries and it also has a vertical scrollbar which becomes visible if; there are more items than fit in the visible part of the container. The; **`TGListBox`** is user callable. The other classes are service classes; of the list box. Here is a sample code showing how to create a list box; with ten entries:. ``` {.cpp}; // list box widget containing 10 entries; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:87755,Usability,progress bar,progress bar,87755,"ge(-10,10);; ```. ### Triple Slider. The new **`TGTripleHSlider`** and **`TGTripleVSlider`** classes inherit; from the double slider widgets and allow easy selection of a range and a; pointer value. The pointer position can be constrained into the selected; range or can be relative to it. ![](pictures/0300021D.png). To change the slider range value press the left mouse button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHP",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88206,Usability,progress bar,progress bar,88206,"use button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; f",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88267,Usability,progress bar,progress bar,88267,"utton near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,T",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88351,Usability,progress bar,progress bar,88351,"drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->Add",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88726,Usability,progress bar,progress bars,88726," a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; ```. ### Static Widgets. The classes **`TGLabel`** and **`TGIcon`** show some in",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:89860,Usability,simpl,simple,89860,"ntal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; ```. ### Static Widgets. The classes **`TGLabel`** and **`TGIcon`** show some information - text; or graphics. The line below creates a label object. The syntax is very; simple: you specify the parent widget and a string object holding the; desired text. ``` {.cpp}; TGLabel *label = new TGLabel(parentWidget, ""Label's string"");; ```. Next sample creates an icon object. First we create an object of type; **`TGPicture`**. The **`TGPicture`** objects are never created directly; by the application code. We call **`TGClient`** telling it the pixmap's; file name to create a **`TGPicture`** object and, in turn, it will; return a pointer to the created object. If the pixmap file cannot be; found the returned pointer will be `NULL`. As usual, the first parameter; of a **`TGIcon`** constructor is the parent frame. The second one is the; **`TGPicture`** object holding the pixmap we want to show. Last two; parameters define the width and height of pixmap in pixels. In the end; we add the created icon object to its parent. ``` {.cpp}; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayou",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102212,Usability,simpl,simple,102212,"and they fall into hierarchies. In addition, the ROOT has; fully cross-platform GUI classes and provides all standard components; for an application environment with common ‘look and feel'. The; object-oriented, event-driven programming model supports the modern; signals/slots communication mechanism. It handles user interface actions; and allows total independence of interacting objects and classes. This; mechanism uses the ROOT dictionary information and the Cling the C++; Interpreter to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, ",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102937,Usability,simpl,simple,102937,"editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' r",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:103790,Usability,intuit,intuitive,103790,"ay after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. ![Histogram, pad and axis editors](pictures/03000222.png). ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/slots commun",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:103848,Usability,feedback,feedback,103848,"ay after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. ![Histogram, pad and axis editors](pictures/03000222.png). ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/slots commun",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:106857,Usability,simpl,simply,106857,"r. This; implies:. - do not share the layout-hints among GUI components;. - do not delete child widgets in the destructor as this is done; automatically. #### Using Several Tabs. Sometimes you might need to use several tabs to organize properly your; class-editor. Each editor tab is a resource shared among all the; class-editors. Tabs must be created from the constructor of your; editor-class by using the method:. ``` {.cpp}; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; ```. It returns a pointer to a new tab container frame ready for use in your; class. If you need to hide/show this frame depending on the object's; status, you should store it in a data member. See for examples:; **`TH1Editor`**, **`TH2Editor`**. #### Base-Class Editors Control. Full control over base-class editors can be achieved by re-implementing; virtual method void `TGedFrame::ActivateBaseClassEditors(TClass` `*cl)`.; It is called during each compound editor rebuild and the default; implementation simply offers all base-classes to the publishing; mechanism. To prevent inclusion of a base-class into the compound editor, call:. ``` {.cpp}; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); ```. Pointer to the compound GED-editor is available in **`TGedFrame`**‘s; data-member:. ``` {.cpp}; TGedEditor *fGedEditor; ```. Ordering of base-class editor frames follows the order of the classes in; the class hierarchy. This order can be changed by modifying the value of; **`TGedFrame`**'s data member `Int_t fPriority`. The default value is; 50; smaller values move the frame towards to the top. This priority; should be set in the editor constructor. ## Drag and Drop. Drag and Drop support is introduced for Linux (via Xdnd - the drag and; drop protocol for X window system) and for Windows (via Clipboard).; Users can selects something in ROOT with a mouse press, drags it (moves; the mouse while keeping the mouse button pressed) and releases the mouse; button somepl",MatchSource.DOCS,documentation/users-guide/WritingGUI.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:449,Deployability,integrat,integrated,449,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:474,Deployability,install,installation,474,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:567,Deployability,install,installation,567,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:449,Integrability,integrat,integrated,449,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:2519,Integrability,interface,interfaced,2519,"as been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMaterials, dumpSolids and examineVol which need to be called in; order to export materials, solids and geometry tree respectively. The TGeo to GDML converter is now interfaced to the; TGeoManager::Export method which automatically calls the appropriate; Python scripts whenever the geometry output file has the .gdml; extension. Alternatively, one can also use the ROOT->GDML converter directly from; the Python prompt (assuming the TGeo geometry has already been loaded; into memory in one or another way), for example:. ~~~ {.cpp}; from math import *. import ROOT; import writer; import ROOTwriter. # get TGeoManager and; # get the top volume of the existing (in-memory) geometry tree; geomgr = ROOT.gGeoManager; topV = geomgr.GetTopVolume(). # instanciate writer; gdmlwriter = writer.writer('mygeo.gdml'); binding = ROOTwriter.ROOTwriter(gdmlwriter). # dump materials; matlist = geomgr.GetListOfMaterials(); binding.dumpMaterials(matlist). # dump solids; shapelist = geomgr.GetListOfShapes(); binding.dumpSolids(shapelist). # dump geo tree; print 'Traversing geometry tree'; gdmlwriter.addSetup('default', '1.0', topV.GetName()); binding.examineVol(topV). # write file; gdmlwriter.writeFile(); ~~~. For all other funct",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:538,Modifiability,config,configure,538,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:622,Modifiability,config,configure,622,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:1221,Modifiability,config,configure,1221," C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:2818,Performance,load,loaded,2818,"GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMaterials, dumpSolids and examineVol which need to be called in; order to export materials, solids and geometry tree respectively. The TGeo to GDML converter is now interfaced to the; TGeoManager::Export method which automatically calls the appropriate; Python scripts whenever the geometry output file has the .gdml; extension. Alternatively, one can also use the ROOT->GDML converter directly from; the Python prompt (assuming the TGeo geometry has already been loaded; into memory in one or another way), for example:. ~~~ {.cpp}; from math import *. import ROOT; import writer; import ROOTwriter. # get TGeoManager and; # get the top volume of the existing (in-memory) geometry tree; geomgr = ROOT.gGeoManager; topV = geomgr.GetTopVolume(). # instanciate writer; gdmlwriter = writer.writer('mygeo.gdml'); binding = ROOTwriter.ROOTwriter(gdmlwriter). # dump materials; matlist = geomgr.GetListOfMaterials(); binding.dumpMaterials(matlist). # dump solids; shapelist = geomgr.GetListOfShapes(); binding.dumpSolids(shapelist). # dump geo tree; print 'Traversing geometry tree'; gdmlwriter.addSetup('default', '1.0', topV.GetName()); binding.examineVol(topV). # write file; gdmlwriter.writeFile(); ~~~. For all other functionality questions or comments, or even GDML in general,; please email Witold.Pokorski@cern.ch; ",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:1381,Safety,detect,detecting,1381,"files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMa",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:1474,Testability,test,test,1474,"o the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMaterials, dumpSolids and examineVol which need to be called in; order to export materials, solids and geomet",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:1501,Testability,test,test,1501,"; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMaterials, dumpSolids and examineVol which need to be called in; order to export materials, solids and geometry tree respectively. The TGeo to GD",MatchSource.DOCS,geom/gdml/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:11588,Availability,avail,available,11588,"tion of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final TGeoVolume::Draw() call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ~~~{.cpp}; % root rootgeom.C; ~~~. \image html geometry001.png width=600px. Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; `gGeoManager` object. Note that right click opens the context menu; of the manager class where several global methods are available. ~~~{.cpp}; root[] new TBrowser;; ~~~. \image html geometry002.jpg width=600px. The folders `Materials`, `Media` and `Local transformations` are in fact; the containers where the geometry manager stores the corresponding; objects. The `Illegal overlaps` folder is empty but can be filled after; performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using `TGeo`, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes c",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:45852,Availability,error,error,45852,"a - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume is added to the family and positioned N times inside the; divided volume, otherwise, each slice will be represented by a distinct; volume in the family. Divisions can be also performed in a given range of one axis. For that,; one has to specify also the starting coordinate value and the step:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; ~~~. A check is always done on the resulting division range: if not fitting; into the container limits, an error message is posted. If we will browse; the divided volume we will notice that it will contain N nodes starting; with index 1 up to N. The first one has the lower X limit at `START`; position, while the last one will have the upper X limit at; `START+N*STEP`. The resulting slices cannot be positioned inside another; volume (they are by default positioned inside the divided one) but can; be further divided and may contain other volumes:. ~~~{.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; ~~~. When doing that, we have to remember that `SLICEY` represents a family,; therefore all members of the family will be divided on Y and the other; volume will be added as node inside all. In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance,; dividing a volume with `TUBE` shape on `PHI `axis will create equal; slices",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:58800,Availability,error,error,58800,"ns can be added or subtracted. ~~~{.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ~~~. - Rotations (TGeoRotation class) represent a pure rotation. Data; members are `Double_t fRotationMatrix[3*3]`. Rotations can be; defined either by Euler angles, either, by GEANT3 angles:. ~~~{.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; ~~~. This represents the composition of: first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with `psi` about the new Z axis. ~~~{.cpp}; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); ~~~. This is a rotation defined in GEANT3 style. Theta and phi are the; spherical angles of each axis of the rotated coordinate system with; respect to the initial one. This construction allows definition of; malformed rotations, e.g. not orthogonal. A check is performed and an; error message is issued in this case. Specific utilities: determinant, inverse. - Scale transformations (TGeoScale class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3]`, `TGeoRotation *fRotation`. ~~~{.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ~~~. - General transformations: (TGeoHMatrix class) represent; combined transformations in any order.; - Identity transformation: (TGeoIdentity class) is a generic; identity transformation represented by a singleton class object; `gGeoIdentity`. \anchor GP01d; ### Ownership of Geometry Objects. The class TGeoManager class contains the entire API needed for; building and tracking ge",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:81848,Availability,avail,available,81848," step is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; by a previous TGeoManager::FindNextBoundary() call. Due to; floating-point boundary uncertainties, making a step corresponding; ""exactly"" to the distance to next boundary does not insure boundary; crossing. If the method is called with this purpose, an extra small; step will be made in order to make the crossing the most probable; event (`epsil=10-6cm`). Even with this extra small step cannot; insure 100% boundary crossing for specific crossed shapes at big; incident angles. After such a step is made, additional cross-checks; become available:. ~~~{.cpp}; gGeoManager->FindNextBoundary(pstep);; Double_t snext = gGeoManager->GetStep();; // The geometrical step is taken; TGeoNode *newNode = gGeoManager->Step();; // The step=snext+epsil is made; Bool_t hasCrossed = gGeoManager->IsEntering();; // Is the boundary crossed or not?; Bool_t isOnBoundary = gGeoManager->IsOnBoundary(); // The proposed; // geometrically limited step to be made was smaller; // than epsil value.; Bool_t isOutside = gGeoManager->IsOutside();; //Did we exit geometry ?; ~~~. In case the desired end-point of the step should be in the same starting; volume, the input flag `cross` should be set to `kFALSE`. In this case,; the `epsil` value will be subtracted from the current step. - Making a step of arbitrary value (`is_geom=kFALSE`, `cross=`no; matter). In this case, the step to be made can be either resulting; from a `next` computation, either set by hand:. ~~~{.cpp}; gGeoManager->SetStep(stepvalue);; gGeoManager->Step(kFALSE",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:84455,Availability,avail,available,84455,"g convention: we define; as `normal` (\f$\vec{n}\f$) the unit vector perpendicular; to a surface in the `next crossing point`, having the orientation such; that: \f$\vec{n}.\vec{d}>0\f$. Here \f$\vec{d}\f$; represents the current direction. The next crossing point represents the; point where a ray shot from the current point along the current; direction crosses the surface. ~~~{.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ~~~. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. \anchor GP02h; ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; TVirtualGeoTrack provides this functionality. It currently has one; implementation inside the drawing package (TGeoTrack class). A; track can be defined like:. ~~~{.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ~~~. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following m",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:92620,Availability,error,errors,92620,"ide the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort o",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:93739,Availability,reliab,reliability,93739,"mage html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. On",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:95991,Availability,down,down,95991,"overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeoManager->PrintOverlaps() prints the list of overlaps. \anchor GP03b; ### Graphical Checking Methods. \image html geometry009.png ""Safety computation checking"" width=500px. In order to check a given point, `CheckPoint(x,y,z)` method of; TGeoManager draws the daughters of the volume containing the point; one level down, printing the path to the deepest physical node holding; this point. It also computes the closest distance to any boundary. \image html geometry010.png ""Random points"" width=500px. A method to check the validity of a given geometry is shooting random; points. This can be called with the method; TGeoVolume::RandomPoints() and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. \image html geometry011.png ""Random rays"" width=500px. A ray tracing method can be called TGeoVolume::RandomRays(). This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. \anchor GP04; ## The Drawing Package. \image html geometry012.png. The modeller provides a",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:97515,Availability,avail,available,97515," visible nodes are drawn. \image html geometry011.png ""Random rays"" width=500px. A ray tracing method can be called TGeoVolume::RandomRays(). This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. \anchor GP04; ## The Drawing Package. \image html geometry012.png. The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ~~~{.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ~~~. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your s",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:99077,Availability,down,down,99077,"stest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ~~~{.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ~~~. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. **Q:** ""The picture is strangely rotated; where are the coordinate axes?"". **A:** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. **Q:** ""Every line is black! I cannot figure out what is what..."". **A:** Volumes can have different colors (those known by %ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black. **Q:** ""The top volume of my geometry is a box but I see only its content."". **A:** By default the drawn volume is not displayed just because we; do not want to hide its content when changing the view to HLR or solid; mode. In order to see it in the default wire frame picture one has to; call TGeoManager::SetTopVisible(). **Q:** ""I do not see all volumes in my tree but just something inside."". **A:** By default, TGeoVolume::Draw() paints the content of; a given volume three level",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:100046,Availability,down,down,100046," pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. **Q:** ""Every line is black! I cannot figure out what is what..."". **A:** Volumes can have different colors (those known by %ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black. **Q:** ""The top volume of my geometry is a box but I see only its content."". **A:** By default the drawn volume is not displayed just because we; do not want to hide its content when changing the view to HLR or solid; mode. In order to see it in the default wire frame picture one has to; call TGeoManager::SetTopVisible(). **Q:** ""I do not see all volumes in my tree but just something inside."". **A:** By default, TGeoVolume::Draw() paints the content of; a given volume three levels down. You can change this by using:; gGeoManager::SetVisLevel(n);. Not only that, but none of the volumes at intermediate levels (0-2) are; visible on the drawing unless they are final ‘leaves' on their branch; (e.g. have no other volumes positioned inside). This behavior is the; default one and corresponds to ‘leaves' global visualization mode; (`TGeoManager::fVisOption = 1`). In order to see on the screen the; intermediate containers, one can change this mode:; gGeoManager->SetVisOption(0). **Q:** ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?"". **A:** Indeed, moving the mouse close to some volume vertices; selects it. By checking the `Event Status` entry in the root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. drawing it). **Q:** ""OK, but now",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:101398,Availability,avail,available,101398,"to ‘leaves' global visualization mode; (`TGeoManager::fVisOption = 1`). In order to see on the screen the; intermediate containers, one can change this mode:; gGeoManager->SetVisOption(0). **Q:** ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?"". **A:** Indeed, moving the mouse close to some volume vertices; selects it. By checking the `Event Status` entry in the root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. drawing it). **Q:** ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?"". **A:** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. \anchor GP04b; ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. \anchor GP04ba; #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ~~~{.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ~~~. When drawing in solid mode, the color of the drawn",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:102954,Availability,down,down,102954,"even when the; picture is already drawn) and see immediately the result. \anchor GP04ba; #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ~~~{.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ~~~. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. \anchor GP04bb; #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ~~~{.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ~~~. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: ""Visible daughters"". By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. \anchor GP04c; ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. Whil",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:103257,Availability,down,down,103257,");; myVolume->SetLineStyle(kDotted);; ~~~. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. \anchor GP04bb; #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ~~~{.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ~~~. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: ""Visible daughters"". By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. \anchor GP04c; ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; `TGeo` is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:117778,Availability,down,down,117778," (in our case let us suppose it is `B\_3`). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. ""Deepest"" means that `B\_3` still; contains point `P` (as well as `A\_1` and `TOP\_1`), but none of the; daughters of volume `B` does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ~~~{.cpp}; Bool_t *TGeoManager::IsSameLocation(); ~~~. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. \image html geometry016.png ""Finding the location of a point in the geom",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:118085,Availability,down,downwards,118085," (in our case let us suppose it is `B\_3`). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. ""Deepest"" means that `B\_3` still; contains point `P` (as well as `A\_1` and `TOP\_1`), but none of the; daughters of volume `B` does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ~~~{.cpp}; Bool_t *TGeoManager::IsSameLocation(); ~~~. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. \image html geometry016.png ""Finding the location of a point in the geom",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:132974,Availability,down,down,132974,"a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""All"" allows viewing all volumes down; to the selected depth. ""Leaves"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""Only"" will allow drawing only the edited; volume. The check button ""Raytrace"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. \image html geometry024.jpg width=600px; \image html geometry025.jpg ""Volume visualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to val",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:32572,Deployability,A/B,A/B,32572,"ly used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D`, `E`, and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class TGeoVolumeAssembly, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ""unnecessary"" volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ~~~{.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ~~~. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. \anchor GP01be; #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We s",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:88826,Deployability,update,updated,88826,"At any step made by the current track, one is able to add control points; to either primary or secondary:. ~~~{.cpp}; track->AddPoint(x,y,z,t);; ~~~. After tracks were defined and filled during tracking, one will be able; to browse directly the list of tracks held by the manager class. Any; track can be drawn using its `Draw()` and `Animate()` methods, but there; are also global methods for drawing or animation that can be accessed; from TGeoManager context menu:. ~~~{.cpp}; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; ~~~. The drawing/animation time range is a global variable that can be; directly set:. ~~~{.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ~~~. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. \anchor GP03; ## Checking th",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:113907,Deployability,update,update,113907,"instance, the painter and checker objects are not written,; as well as the temporary current navigation properties: current node; path, point or direction. On the other hand, all objects belonging to; the geometrical hierarchy will always be written. The idea is to be able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given TGeoVolume in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; TGeoVolume objects):. ~~~{.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ~~~. Importing will append the volume to the current TGeoManager or will; create one:. ~~~{.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ~~~. \anchor GP06a; ### GDML. Few lines above word GDML was used. GDML stands for Geometry; Description Markup Language. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between %ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file for",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:114958,Deployability,install,installation,114958," // to the same file; ~~~. Importing will append the volume to the current TGeoManager or will; create one:. ~~~{.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ~~~. \anchor GP06a; ### GDML. Few lines above word GDML was used. GDML stands for Geometry; Description Markup Language. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between %ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; %ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. \anchor GP07; ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. \anchor GP07a; ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: `/TOP\_1/A\_1/B\_3/C\_1`,; where `B\_3` for instance is a copy of volume `B` positioned inside; volume `A`. A state is always associated to a transformation matrix; `M` of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global m",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:115927,Deployability,update,updated,115927,"at) is disabled by default in; %ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. \anchor GP07; ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. \anchor GP07a; ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: `/TOP\_1/A\_1/B\_3/C\_1`,; where `B\_3` for instance is a copy of volume `B` positioned inside; volume `A`. A state is always associated to a transformation matrix; `M` of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; current branch are kept in an array: (`MTOP\_1, MA\_1, MB\_3, ...`). \image html geometry015.png ""Navigation in the geometry hierarchy"" width=600px. The elementary operations for changing the state are:. ~~~{.cpp}; TGeoManager::CdUp();; TGeoManager::CdDown(i);; TGeoManager::CdTop(); ~~~. The current state accounting and global matrix handling after these; operations are depicted in the figure below. Now let us suppose that we; have a particle at position *P(x,y,z)*. The first thing needed for; transporting it is the current object our particle is into, so that we; can retrieve its material properties. This task is done by:. ~~~{.cpp}; TGeoNode *TGeoManager::FindNode(x,y,z); ~~~. Note that the current particle position can be set using; SetCurrentPosition(x,y,z) method of the manager class, in which; case FindNode() can be called without arguments. The method; returns a p",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:117694,Deployability,continuous,continuously,117694,"eoManager::FindNode(x,y,z); ~~~. Note that the current particle position can be set using; SetCurrentPosition(x,y,z) method of the manager class, in which; case FindNode() can be called without arguments. The method; returns a pointer to the ""deepest node"" that geometrically contains *P*; (in our case let us suppose it is `B\_3`). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. ""Deepest"" means that `B\_3` still; contains point `P` (as well as `A\_1` and `TOP\_1`), but none of the; daughters of volume `B` does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ~~~{.cpp}; Bool_t *TGeoManager::IsSameLocation(); ~~~. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fu",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:124204,Deployability,update,updated,124204,"urned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; TGeoManager::ComputeNormalFast() to get the normal vector to the; crossed surface, after propagating the current point with the; TGeoManager::GetStep() value. This propagation can be done like:. ~~~{.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ~~~. Note: The method TGeoManager::FindNextBoundary() does not modify the; current point/direction nor the current volume/s",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:26392,Energy Efficiency,reduce,reduce,26392,",rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); ~~~. \anchor GP01bc; #### Positioned Volumes (Nodes). Geometrical modeling is a difficult task when the number of different; geometrical objects is 106-108. This is more or less the case for; detector geometries of complex experiments, where a ‘flat' CSG model; description cannot scale with the current CPU performances. This is the; reason why models like GEANT [1] introduced an additional dimension; (depth) in order to reduce the complexity of the problem. This concept; is also preserved by the ROOT modeller and introduces a pure geometrical; constraint between objects (volumes in our case) - containment. This; means in fact that any positioned volume has to be contained by another.; Now what means contained and positioned?. - We will say that a volume `contains` a point if this is inside the; shape associated to the volume. For instance, a volume having a box; shape will contain all points `P=(X,Y,Z)` verifying the conditions:; `Abs(Pi)dXi`. The points on the shape boundaries are considered as; inside the volume. The volume contains a daughter if it contains all; the points contained by the daughter.; - The definition of containment works of course only with points; defined in the local coordinate system of the considered volume.; `Positioning` a volume inside another have to introduce a; geometrical transformation between the two. If `M` defines this; transformation",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:40709,Energy Efficiency,efficient,efficient,40709,"tion(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ~~~. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. \anchor GP01bh; #### Volume Families. A volume family is represented by the class TGeoVolumeMulti. It; represents a class of volumes having the same shape type and each member; will be identified b",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:95526,Energy Efficiency,green,green,95526,"ne vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeoManager->PrintOverlaps() prints the list of overlaps. \anchor GP03b; ### Graphical Checking Methods. \image html geometry009.png ""Safety computation checking"" width=500px. In order to check a given point, `CheckPoint(x,y,z)` method of; TGeoManager draws the daughters of the volume containing the point; one level down, printing the path to the deepest physical node holding; this point. It also computes the closest distance to any boundary. \image html geometry010.png ""Random points"" width=500px. A method to check the validity of a given geometry is shooting random; points. This can be called with the method; TGeoVolume::RandomPoints() and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the co",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:96957,Energy Efficiency,power,powerful,96957,"level down, printing the path to the deepest physical node holding; this point. It also computes the closest distance to any boundary. \image html geometry010.png ""Random points"" width=500px. A method to check the validity of a given geometry is shooting random; points. This can be called with the method; TGeoVolume::RandomPoints() and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. \image html geometry011.png ""Random rays"" width=500px. A ray tracing method can be called TGeoVolume::RandomRays(). This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. \anchor GP04; ## The Drawing Package. \image html geometry012.png. The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geome",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:109606,Energy Efficiency,consumption,consumption,109606,"e corresponds; to the level 0 in the stored array, while the last node will correspond; to level `n`. For each level, the node, volume and global matrix can be; retrieved using corresponding getters:. ~~~{.cpp}; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; ~~~. By default the object at level n is retrieved (the align-able object). Once created, a physical node can be misaligned, meaning that its; positioning matrix or even the shape.:. ~~~{.cpp}; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); ~~~. The convention used is that newmat represents the new local matrix of; the last node in the branch with respect to its mother volume. The; `Align()` method will actually duplicate the corresponding branch within; the logical hierarchy, creating new volumes and nodes. This is mandatory; in order to avoid problems due to replicated volumes and can create; exhaustive memory consumption if used abusively. Once aligned, a physical node is ready to be tracked. The operation can; be done only after the geometry was closed. Important NOTE: Calling the `Align()` method for a physical node changes; the node pointers for the stored node branch in the active geometry, Due; to this the other defined physical nodes containing elements of this; path will be invalid. Example:. ~~~{.cpp}; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; ~~~. The call to `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nodes:. ~~~{.cpp}; void RefreshPhysicalNodes(Bool_t lock = kTRUE); ~~~. The method above will optionally lock the possibility of doing any; ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:123945,Energy Efficiency,efficient,efficient,123945,"rformed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; TGeoManager::ComputeNormalFast() to get the normal vector to the; crossed surface, after propagating the current point with the; TGeoManager::GetStep() value. This propagation can be done like:. ~~~{.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = g",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:5256,Integrability,interface,interface,5256,"on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. \anchor GP00a; ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does ""make map"" in root folder. ~~~{.cpp}; root[] gSystem->Load(""libGeom"");; ~~~. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; `gGeoManager`:. ~~~{.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ~~~. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:6603,Integrability,message,messages,6603,". You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ~~~{.cpp}; root[] gGeoManager->SetTopVolume(top);; ~~~. This should be enough, but it is not since always after defining some; geometry hierarchy, TGeo needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example mi",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:45858,Integrability,message,message,45858,"a - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume is added to the family and positioned N times inside the; divided volume, otherwise, each slice will be represented by a distinct; volume in the family. Divisions can be also performed in a given range of one axis. For that,; one has to specify also the starting coordinate value and the step:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; ~~~. A check is always done on the resulting division range: if not fitting; into the container limits, an error message is posted. If we will browse; the divided volume we will notice that it will contain N nodes starting; with index 1 up to N. The first one has the lower X limit at `START`; position, while the last one will have the upper X limit at; `START+N*STEP`. The resulting slices cannot be positioned inside another; volume (they are by default positioned inside the divided one) but can; be further divided and may contain other volumes:. ~~~{.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; ~~~. When doing that, we have to remember that `SLICEY` represents a family,; therefore all members of the family will be divided on Y and the other; volume will be added as node inside all. In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance,; dividing a volume with `TUBE` shape on `PHI `axis will create equal; slices",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:54819,Integrability,interface,interface,54819,"\f$r_{ij}\f$ are the 3x3 rotation matrix components; - \f$t_x\f$,\f$t_y\f$,\f$t_z\f$ are the translation components; - \f$s_x\f$, \f$s_y\f$, \f$s_z\f$ are arbitrary scale constants on each axis. The disadvantage in using this approach is that computation for 4x4; matrices is expensive. Even combining two translations would become a; multiplication of their corresponding matrices, which is quite an; undesired effect. On the other hand, it is not a good idea to store a; translation as a block of 16 numbers. We have therefore chosen to; implement each basic transformation type as a class deriving from the; same basic abstract class and handling its specific data and; point/vector transformation algorithms. The base class TGeoMatrix defines abstract methods for:. - Translation, rotation and scale getters. Every derived class stores; only its specific data, e.g. a translation stores an array of 3; doubles and a rotation an array of 9. However, getting the; TGeoTranslation rotation array through the base; TGeoMatrix interface is a legal operation. The answer in this; case is a pointer to a global constant array representing an; identity rotation. ~~~{.cpp}; Double_t *TGeoMatrix::GetTranslation() const;; Double_t *TGeoMatrix::GetRotation() const;; Double_t *TGeoMatrix::GetScale() const;; ~~~. - Master-to-local and local-to-master point and vector transformations:. ~~~{.cpp}; void TGeoMatrix::MasterToLocal(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local,; Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local,; Double_t *master); ~~~. Here `master` and `local` are arrays of size 3. These methods allow; correct conversion also for reflections. - Transformation type finding:. ~~~{.cpp}; Bool_t TGeoMatrix::IsIdentity() const;; Bool_t TGeoMatrix::IsTranslation() const;; Bool_t TGeoMatrix::IsRotation() const;; Bool_t TGeoMatrix::IsSca",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:58806,Integrability,message,message,58806,"ns can be added or subtracted. ~~~{.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ~~~. - Rotations (TGeoRotation class) represent a pure rotation. Data; members are `Double_t fRotationMatrix[3*3]`. Rotations can be; defined either by Euler angles, either, by GEANT3 angles:. ~~~{.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; ~~~. This represents the composition of: first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with `psi` about the new Z axis. ~~~{.cpp}; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); ~~~. This is a rotation defined in GEANT3 style. Theta and phi are the; spherical angles of each axis of the rotated coordinate system with; respect to the initial one. This construction allows definition of; malformed rotations, e.g. not orthogonal. A check is performed and an; error message is issued in this case. Specific utilities: determinant, inverse. - Scale transformations (TGeoScale class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3]`, `TGeoRotation *fRotation`. ~~~{.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ~~~. - General transformations: (TGeoHMatrix class) represent; combined transformations in any order.; - Identity transformation: (TGeoIdentity class) is a generic; identity transformation represented by a singleton class object; `gGeoIdentity`. \anchor GP01d; ### Ownership of Geometry Objects. The class TGeoManager class contains the entire API needed for; building and tracking ge",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62106,Integrability,interface,interface,62106,"s linked with %ROOT graphical libraries loaded on demand in order to; control visualization actions. \anchor GP02; ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62338,Integrability,interface,interface,62338,"nd direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62540,Integrability,interface,interface,62540,"fication of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator ho",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:64296,Integrability,interface,interfaced,64296,"via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by TGeoNavigator; are interfaced by TGeoManager and will act on the current; navigator. \anchor GP02b; ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ~~~{.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ~~~. Initializing this point can be done like:. ~~~{.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ~~~. \anchor GP02c; ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ~~~{.cpp}; Const Double_t *cdir = gGeoManager->GetCurren",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:67917,Integrability,interface,interface,67917,"ager->FindNode();; ~~~. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ~~~{.cpp}; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; ~~~. Note that the current point coordinates can be changed and the state; re-initialized at any time. This represents the `‘Where am I?'`; geometrical query representing the basic navigation functionality; provided by the modeller. \anchor GP02e; ### Checking the Current State. The current state and all variables related to this are essential during; tracking and have to be checked several times. Besides the current point; and direction, the following additional information can be retrieved; from TGeoManager interface:. - The `current path`. This represents a string containing the names; and copy numbers of all positioned objects in the current `branch`; written in the /folder/folder/.../folder/file fashion. The final node; pointed by the path is the deepest object containing the current; point and is representative for the current state. All intermediate; `folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ~~~{.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ~~~. - The `current node`, `volume` and `material`. In order to; take decisions on post-step or further stepping actions, one has to; know these. In order to get a pointer to the current node one can; do:. ~~~{.cpp}; T",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:72345,Integrability,interface,interfaces,72345,"urrent node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ~~~{.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ~~~. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ~~~{.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ~~~. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ~~~{.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ~~~. \anchor GP02f; ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigati",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:84813,Integrability,interface,interfaced,84813,"ses the surface. ~~~{.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ~~~. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. \anchor GP02h; ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; TVirtualGeoTrack provides this functionality. It currently has one; implementation inside the drawing package (TGeoTrack class). A; track can be defined like:. ~~~{.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ~~~. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ~~~{.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ~~~. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; TVirtualGeoTrack class. We will describe the structure and; functionality provided by the default implemen",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:91407,Integrability,depend,dependent,91407," volume have to be also contained by the; mother therefore are overlapping in that sense. This category of; overlaps is ignored due to the fact that any such point is treated as; belonging to the deepest node in the hierarchy. \image html geometry007.png ""Extruding volumes"". A volume containment region is in fact the result of the subtraction of; all daughters. On the other hand, there are two other categories of; overlaps that are considered illegal since they lead to unpredictable; results during tracking. *A)* If a positioned volume contains points that are not also contained; by its mother, we will call the corresponding region as an ""extrusion"".; When navigating from outside to inside (trying to enter such a node); these regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that e",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:91915,Integrability,depend,depends,91915,"e; results during tracking. *A)* If a positioned volume contains points that are not also contained; by its mother, we will call the corresponding region as an ""extrusion"".; When navigating from outside to inside (trying to enter such a node); these regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:114179,Integrability,depend,depending,114179,"able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given TGeoVolume in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; TGeoVolume objects):. ~~~{.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ~~~. Importing will append the volume to the current TGeoManager or will; create one:. ~~~{.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ~~~. \anchor GP06a; ### GDML. Few lines above word GDML was used. GDML stands for Geometry; Description Markup Language. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between %ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; %ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. \anchor GP07; ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:126017,Integrability,interface,interface,126017,"tDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ~~~. Note: The method TGeoManager::FindNextBoundary() does not modify the; current point/direction nor the current volume/state. The returned node; is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; TGeoManager::Step(), described in ""Making a Step"", but users may; implement more precise methods to insure post-step boundary crossing. \anchor GP08; ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class `TGeoXXX` have a correspondent editor; `TGeoXXXEditor` that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. \anchor GP08a; ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ~~~. The lines above will create a new TGeoManager class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:126196,Integrability,interface,interfaces,126196," the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; TGeoManager::Step(), described in ""Making a Step"", but users may; implement more precise methods to insure post-step boundary crossing. \anchor GP08; ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class `TGeoXXX` have a correspondent editor; `TGeoXXXEditor` that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. \anchor GP08a; ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ~~~. The lines above will create a new TGeoManager class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. \image html geometry018.png ""The geometry manager editor"". \anchor GP08b; ### The Geometry Manager Editor. \image html geom",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:127921,Integrability,interface,interface,127921,"ed to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. \image html geometry018.png ""The geometry manager editor"". \anchor GP08b; ### The Geometry Manager Editor. \image html geometry019.png ""Accessing/creating different categories of editable objects"" width=600px. The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the TGeoManager class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of proper",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:128255,Integrability,depend,depending,128255,"s of editable objects"" width=600px. The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the TGeoManager class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes fi",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:128451,Integrability,interface,interface,128451,"hod; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the TGeoManager class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The di",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:129265,Integrability,interface,interface,129265,"etry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. \image html geometry020.png ""Selection dialogs for different TGeo objects"". Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is att",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:129467,Integrability,interface,interfaces,129467,"ape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. \image html geometry020.png ""Selection dialogs for different TGeo objects"". Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. \image html geometry021.png ""Editors for shapes, materials, media, matrices"" width=600px. For most editors, the functionalities Apply and Undo are provided. For shapes",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:131914,Integrability,depend,depend,131914,"he ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settin",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:132095,Integrability,interface,interface,132095,"anges are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""All"" allows viewing all volumes down; to the selected depth. ""Leaves"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daught",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:133422,Integrability,interface,interface,133422,"lecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""All"" allows viewing all volumes down; to the selected depth. ""Leaves"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""Only"" will allow drawing only the edited; volume. The check button ""Raytrace"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. \image html geometry024.jpg width=600px; \image html geometry025.jpg ""Volume visualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - on",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:134342,Integrability,interface,interface,134342,"isualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""Shapes"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""Volumes"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""General"" category and select the newly created volume; as the top one (you can do it also from the volume c",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:135570,Integrability,interface,interface,135570,"Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""Volumes"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""General"" category and select the newly created volume; as the top one (you can do it also from the volume category). This is; just for starting. To create some hierarchy, one has to create several; other volumes and the matrices to position them. Once this is done, use; the volume editor interface to:; - add/remove daughters, change shape, edit position of daughters; - change visualization settings; - divide the volume (only if there are no daughters yet). 7. Close the geometry from the ""General"" category. \defgroup Geometry_classes Geometry classes; \ingroup Geometry; \brief The Geometry related classes. Several documents describing these classes are listed below:. - The main geometry class is documented in class TGeoManager.; - [Presentation/article at CHEP'03](http://www.slac.stanford.edu/econf/C0303241/proc/papers/THMT001.PDF); - [Presentation at ROOT 2004](http://www.slac.stanford.edu/BFROOT/www/Computing/Distributed/ROOT2004/files/gheata.ppt); - [Presentation at ROOT 2005](http://indico.cern.ch/getFile.py/access?contribId=s1t14&sessionId=1&resId=1&materialId=0&confId=a055638); - [Presentation at ROOT 2007](http://indico.cern.ch/materialDisplay.py?contribId=35&materialId=slides&confId=13356). See also [the use of the geometry classes in AliROOT package of ALICE](https://alice-offline.web.cern.ch/AliRoot/Manual.html). ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:30381,Modifiability,inherit,inherit,30381,"~~~{.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ~~~. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. \anchor GP01bd; #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ""invisible"" (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C`'; and `C`\"", having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation co",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:63616,Modifiability,variab,variables,63616,"ng the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by TGeoNavigator; are interfaced by TGeoManager and will act on the current; navigator. \anchor GP02b; ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ~~~{.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ~~~. Initializing this point can be don",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:63962,Modifiability,variab,variables,63962,"ometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by TGeoNavigator; are interfaced by TGeoManager and will act on the current; navigator. \anchor GP02b; ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ~~~{.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ~~~. Initializing this point can be done like:. ~~~{.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ~~~. \anchor GP02c; ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to k",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:67708,Modifiability,variab,variables,67708,"e the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ~~~{.cpp}; gGeoManager->FindNode();; ~~~. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ~~~{.cpp}; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; ~~~. Note that the current point coordinates can be changed and the state; re-initialized at any time. This represents the `‘Where am I?'`; geometrical query representing the basic navigation functionality; provided by the modeller. \anchor GP02e; ### Checking the Current State. The current state and all variables related to this are essential during; tracking and have to be checked several times. Besides the current point; and direction, the following additional information can be retrieved; from TGeoManager interface:. - The `current path`. This represents a string containing the names; and copy numbers of all positioned objects in the current `branch`; written in the /folder/folder/.../folder/file fashion. The final node; pointed by the path is the deepest object containing the current; point and is representative for the current state. All intermediate; `folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ~~~{.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ~~~. - The `current node`, `volume` and `material`. In order to; take decisions on post-step or",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:85760,Modifiability,inherit,inheriting,85760,"eating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; TVirtualGeoTrack provides this functionality. It currently has one; implementation inside the drawing package (TGeoTrack class). A; track can be defined like:. ~~~{.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ~~~. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ~~~{.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ~~~. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; TVirtualGeoTrack class. We will describe the structure and; functionality provided by the default implementation of these, which are; TGeoTrack objects. A TGeoTrack is storing a list of `control points` `(x,y,z)`; belonging to the track, having also time information `(t)`. The painting; algorithm of such tracks allows drawing them in any time interval after; their creation. The track position at a given time is computed by; interpolation between control points. ~~~{.cpp}; myTrack->AddPoint(x,y,z,t);; ~~~. The creation and management of tracks is in fact fully controlled by the; TGeoManager class. This holds a list of `primary tracks` that is; also visible during browsing as `Tracks` folder. Primary tracks are; tracks having no parent in the tracking history (for instance the output; of particle generators may be considered as primaries from tracking; point of view). The manager class holds; in TGeoManager::fCurrentTrack a pointer to the current track. When; starting ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:88487,Modifiability,variab,variable,88487,"Id(user_id);; ptrTrack = gGeoManager->GetTrack(index);; ~~~. Supposing a particle represented by a primary track decays or interacts,; one should not create new primaries as described before, but rather add; them as secondary:. ~~~{.cpp}; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; ~~~. At any step made by the current track, one is able to add control points; to either primary or secondary:. ~~~{.cpp}; track->AddPoint(x,y,z,t);; ~~~. After tracks were defined and filled during tracking, one will be able; to browse directly the list of tracks held by the manager class. Any; track can be drawn using its `Draw()` and `Animate()` methods, but there; are also global methods for drawing or animation that can be accessed; from TGeoManager context menu:. ~~~{.cpp}; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; ~~~. The drawing/animation time range is a global variable that can be; directly set:. ~~~{.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ~~~. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient.",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:97209,Modifiability,plug-in,plug-in,97209,"en geometry is shooting random; points. This can be called with the method; TGeoVolume::RandomPoints() and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. \image html geometry011.png ""Random rays"" width=500px. A ray tracing method can be called TGeoVolume::RandomRays(). This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. \anchor GP04; ## The Drawing Package. \image html geometry012.png. The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:102120,Modifiability,inherit,inherit,102120,"ent global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. \anchor GP04b; ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. \anchor GP04ba; #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ~~~{.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ~~~. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. \anchor GP04bb; #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ~~~{.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ~~~. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:113263,Modifiability,variab,variables,113263,"); ~~~. Example:. ~~~{.cpp}; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; ~~~. Note that not all-current information held by the modeller is written on; the file. For instance, the painter and checker objects are not written,; as well as the temporary current navigation properties: current node; path, point or direction. On the other hand, all objects belonging to; the geometrical hierarchy will always be written. The idea is to be able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given TGeoVolume in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; TGeoVolume objects):. ~~~{.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ~~~. Importing will append the volume to the current TGeoManager or will; create one:. ~~~{.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:115029,Modifiability,config,configure,115029,"oManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ~~~. \anchor GP06a; ### GDML. Few lines above word GDML was used. GDML stands for Geometry; Description Markup Language. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between %ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; %ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. \anchor GP07; ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. \anchor GP07a; ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: `/TOP\_1/A\_1/B\_3/C\_1`,; where `B\_3` for instance is a copy of volume `B` positioned inside; volume `A`. A state is always associated to a transformation matrix; `M` of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; c",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:126389,Modifiability,plug-in,plug-in,126389,"r to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; TGeoManager::Step(), described in ""Making a Step"", but users may; implement more precise methods to insure post-step boundary crossing. \anchor GP08; ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class `TGeoXXX` have a correspondent editor; `TGeoXXXEditor` that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. \anchor GP08a; ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ~~~. The lines above will create a new TGeoManager class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. \image html geometry018.png ""The geometry manager editor"". \anchor GP08b; ### The Geometry Manager Editor. \image html geometry019.png ""Accessing/creating different categories of editable objects"" width=600px. The second use case a",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:369,Performance,optimiz,optimize,369,"\defgroup Geometry The Geometry Package. The %ROOT geometry package is a tool for building, browsing,; navigating and visualizing detector geometries. The code works; standalone with respect to any tracking Monte-Carlo engine; therefore,; it does not contain any constraints related to physics. However, the; navigation features provided by the package are designed to optimize; particle transport through complex geometries, working in correlation; with simulation packages such as GEANT3, GEANT4 and FLUKA. - [Quick Start: Creating the world](\ref GP00); - [Example 1: Creating the World](\ref GP00a); - [Example 2: A Geometrical Hierarchy Look and Feel](\ref GP00b); - [Selecting the System of Units in ROOT](\ref GPUNITS); - [Geometry Creation](\ref GP01); - [The Volume Hierarchy](\ref GP01a); - [Creating and Positioning Volumes](\ref GP01b); - [Making Volumes](\ref GP01ba); - [Example of Volume Creation](\ref GP01bb); - [Positioned Volumes (Nodes)](\ref GP01bc); - [Virtual Containers and Assemblies of Volumes](\ref GP01bd); - [Examples of Volume Positioning](\ref GP01be); - [Overlapping Volumes](\ref GP01bf); - [Replicating Volumes](\ref GP01bg); - [Volume Families](\ref GP01bh); - [Dividing Volumes](\ref GP01bi); - [Volume Assemblies](\ref GP01bj); - [Geometrical Transformations](\ref GP01c); - [Matrix Creation Example](\ref GP01ca); - [Rule for Creation of Transformations](\ref GP01cb); - [Available Geometrical Transformations](\ref GP01cc); - [Ownership of Geometry Objects](\ref GP01d); - [Navigation and Tracking](\ref GP02); - [TGeoNavigator Class](\ref GP02a); - [Initializing the Starting Point](\ref GP02b); - [Initializing the Direction](\ref GP02c); - [Initializing the State](\ref GP02d); - [Checking the Current State](\ref GP02e); - [Saving and Restoring the Current State](\ref GP02f); - [Navigation Queries](\ref GP02g); - [Finding If Current State Is Changed For a New Point](\ref GP02ga); - [Finding the Distance to the Next Boundary](\ref GP02gb); - [Computing th",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:3442,Performance,optimiz,optimize,3442,"\ref GP04a); - [Visualization Settings and Attributes](\ref GP04b); - [Colors and Line Styles](\ref GP04ba); - [Visibility Settings](\ref GP04bb); - [Ray Tracing](\ref GP04c); - [Clipping Ray-traced Images](\ref GP04ca); - [Representing Misalignments of the Ideal Geometry](\ref GP05); - [Physical Nodes](\ref GP05a); - [Geometry I/O](\ref GP06); - [GDML](\ref GP06a); - [Navigation Algorithms](\ref GP07); - [Finding the State Corresponding to a Location (x,y,z)](\ref GP07a); - [Finding the Distance to Next Crossed Boundary](\ref GP07b); - [Output Values](\ref GP07c); - [Geometry Graphical User Interface](\ref GP08); - [Editing a Geometry](\ref GP08a); - [The Geometry Manager Editor](\ref GP08b); - [Editing Existing Objects](\ref GP08c); - [Creation of New Objects](\ref GP08d); - [Editing Volumes](\ref GP08e); - [How to Create a Valid Geometry with Geometry Editors](\ref GP08f). \anchor GP00; ## Quick Start: Creating the ""world"". This chapter will provide a detailed description on how to build valid; geometries as well as the ways to optimize them. There are several; components gluing together the geometrical model, but for the time being; let us get used with the most basic concepts. The basic bricks for building-up the model are called; ""volumes"". These represent the un-positioned pieces of the geometry; puzzle. The difference is just that the relationship between the pieces; is not defined by neighbors, but by ""containment"". In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""world"" of the; model. We will often call this ""master reference system (MARS)"". Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:4924,Performance,load,load,4924,"om; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""world"" of the; model. We will often call this ""master reference system (MARS)"". Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. \anchor GP00a; ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does ""make map"" in root folder. ~~~{.cpp}; root[] gSystem->Load(""libGeom"");; ~~~. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; `gGeoManager`:. ~~~{.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ~~~. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:5178,Performance,perform,performing,5178,"on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. \anchor GP00a; ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does ""make map"" in root folder. ~~~{.cpp}; root[] gSystem->Load(""libGeom"");; ~~~. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; `gGeoManager`:. ~~~{.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ~~~. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:6544,Performance,optimiz,optimization,6544,"gle volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ~~~{.cpp}; root[] gGeoManager->SetTopVolume(top);; ~~~. This should be enough, but it is not since always after defining some; geometry hierarchy, TGeo needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:6573,Performance,perform,perform,6573,"gle volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ~~~{.cpp}; root[] gGeoManager->SetTopVolume(top);; ~~~. This should be enough, but it is not since always after defining some; geometry hierarchy, TGeo needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:7845,Performance,load,load,7845,"rld:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word %ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. **Q:** ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?"". **A:** As explained before, the model that we are trying to create; is a hierarchy of volumes based on ""containment"". This is; accomplished by ""positioning"" some volumes ""inside"" others.; Any volume is an un-positioned object in the sense that it defines only; a ""local frame"" (matching the one of its ""shape""). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a ""local geometrical transformation"" of; the daughter with respect to the mother coordinate system. These; transformations will be subsequently used in the example. **Q:** ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes named REPLICA and R",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:10674,Performance,perform,performing,10674,"e have to define so many volumes to make an R?"". **A:** Well, in real life some objects have much more complex shapes; that an ""R"". The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ""primitive shapes""). Gluing these; together in the appropriate way is the user responsibility. **Q:** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". **A:** A volume is positioned inside another one by using this; method. The relative geometrical transformation as well as a copy number; must be specified. When positioned, a volume becomes a ""node"" of; its container and a new object of the class TGeoNode is; automatically created. This method is therefore the key element for the; creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final TGeoVolume::Draw() call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ~~~{.cpp}; % root rootgeom.C; ~~~. \image html geometry001.png width=600px. Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; `gGeoManager` object. Note that right click opens the context menu; of the manager class where several global methods are available. ~~~{.cpp}; root[] new TBrowser;; ~~~. \image html geometry002.jpg width=",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:11893,Performance,perform,performing,11893,"e. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ~~~{.cpp}; % root rootgeom.C; ~~~. \image html geometry001.png width=600px. Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; `gGeoManager` object. Note that right click opens the context menu; of the manager class where several global methods are available. ~~~{.cpp}; root[] new TBrowser;; ~~~. \image html geometry002.jpg width=600px. The folders `Materials`, `Media` and `Local transformations` are in fact; the containers where the geometry manager stores the corresponding; objects. The `Illegal overlaps` folder is empty but can be filled after; performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using `TGeo`, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. The vo",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:11986,Performance,perform,performed,11986,"ust need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ~~~{.cpp}; % root rootgeom.C; ~~~. \image html geometry001.png width=600px. Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; `gGeoManager` object. Note that right click opens the context menu; of the manager class where several global methods are available. ~~~{.cpp}; root[] new TBrowser;; ~~~. \image html geometry002.jpg width=600px. The folders `Materials`, `Media` and `Local transformations` are in fact; the containers where the geometry manager stores the corresponding; objects. The `Illegal overlaps` folder is empty but can be filled after; performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using `TGeo`, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. The volume objects are nodes inside this graph; and the same volume can be accessed starting from different branches. On the other hand, the real geometrical objects that are see",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:14066,Performance,perform,performed,14066,"n when; visualizing or tracking the geometry are depicted in the `TOP_1` branch.; These are the nodes of the `physical` `tree` of positioned volumes; represented by TGeoNode objects. This hierarchy is a tree since a; node can have only one parent and several daughters. For a better; understanding of the hierarchy, have a look at TGeoManage. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you will see in the bottom right size of the %ROOT; canvas its name, shape type and corresponding path in the physical tree.; Right clicking on the screen when a volume is selected will also open; its context menu (picking). Note that there are several actions that can; be performed both at view (no volume selected) and volume level. TView (mouse not selecting any volume):. - Click-and-drag rotates the view.; - Pressing some keys perform different actions:; - J/K - zoom / unzoom; - H, L, U, I - move the viewpoint; - Right click + `SetParallel` `()/SetPerspective` `()` - switch from; parallel to perspective view.; - Right click + `ShowAxis()` - show coordinate axes.; - Right click + `Centered/Left/Side/Top` - change view direction. TGeoVolume (mouse selecting a volume):. - Double click will focus the corresponding volume.; - Right click + `CheckOverlaps()` - run overlap checker on current; volume.; - Right click + `Draw` `()` - draw that volume according current; global visualization options; - Right click + `DrawOnly()` - draw only the selected volume.; - Right click + `InspectShape/Material()` - print info about shape or; material.; - Right click + `Raytrace()` - initiate a ray tracing algorithm on; current view.; - Right click + `RandomPoints/Rays()` - shoot",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:14226,Performance,perform,perform,14226,"one parent and several daughters. For a better; understanding of the hierarchy, have a look at TGeoManage. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you will see in the bottom right size of the %ROOT; canvas its name, shape type and corresponding path in the physical tree.; Right clicking on the screen when a volume is selected will also open; its context menu (picking). Note that there are several actions that can; be performed both at view (no volume selected) and volume level. TView (mouse not selecting any volume):. - Click-and-drag rotates the view.; - Pressing some keys perform different actions:; - J/K - zoom / unzoom; - H, L, U, I - move the viewpoint; - Right click + `SetParallel` `()/SetPerspective` `()` - switch from; parallel to perspective view.; - Right click + `ShowAxis()` - show coordinate axes.; - Right click + `Centered/Left/Side/Top` - change view direction. TGeoVolume (mouse selecting a volume):. - Double click will focus the corresponding volume.; - Right click + `CheckOverlaps()` - run overlap checker on current; volume.; - Right click + `Draw` `()` - draw that volume according current; global visualization options; - Right click + `DrawOnly()` - draw only the selected volume.; - Right click + `InspectShape/Material()` - print info about shape or; material.; - Right click + `Raytrace()` - initiate a ray tracing algorithm on; current view.; - Right click + `RandomPoints/Rays()` - shoot random points or rays; inside the bounding box of the clicked volume and display only those; inside visible volumes.; - Right click + `Weight()` - estimates the weight of a volume within a; given precision. Note that there are several",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:17828,Performance,load,loaded,17828,"onstructed. If for whatever reason it is necessary to change the; system of units later, this is feasible disabling the otherwise fatal exception:. ``` {.cpp}; TGeoManager::LockDefaultUnits(kFALSE);; ```. followed later by a corresponding call to again lock the system of units:. ``` {.cpp}; TGeoManager::LockDefaultUnits(kTRUE);; ```. \anchor GP01; ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes can be provided both at; build time or after geometry is closed, but global visualization; settings (see section: ""The Drawing Package"") should not be provided; at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. - Positioned volumes should not extrude their container or intersect; with others within this unless it is specified (see section:; Overlapping Volumes).; - The top volume (containing all geometry trees) must be specified; before closing the geometry and must not be positioned - it; represents the global reference frame.; - After building the full geometry tree, the geometry must be closed; (see the method **`TGeoManager::CloseGeometry()`**). Voxelization; can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry; creation procedure in the following sections. Provided that geometry was; successfully built and closed, the **`TGeoManager`** class will register; itself to ROOT and the logical/physical structures will become; immediately browsable. \anchor ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:23282,Performance,perform,perform,23282," can be asked for at a given moment, but; rather represented by the combination: current node/current global; matrix. However, physical nodes have unique ID's that can be retrieved; for a given modeller state. These can be fed back to the modeller in; order to force a physical node to become current. The advantage of this; comes from the fact that all navigation queries check first the current; node; therefore the location of a point in the geometry can be saved as; a starting state for later use. Nodes can be declared as `overlapping` in case they do overlap with; other nodes inside the same container or extrude this container (see; also ‘Checking the Geometry'). Non-overlapping nodes can be created; with:. ~~~{.cpp}; TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,; TGeoMatrix *matr);; ~~~. The creation of overlapping nodes can be done with a similar prototype:. ~~~{.cpp}; TGeoVolume::AddNodeOverlap(/*same arguments*/);; ~~~. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbors. These are stored and checked all the time; during navigation; therefore, navigation is slower when embedding such; nodes into geometry. Nodes have visualization attributes as the volume; has. When undefined by users, painting a node on a pad will take the; corresponding volume attributes. \anchor GP01b; ### Creating and Positioning Volumes. \anchor GP01ba; #### Making Volumes. As mentioned before, volumes are the basic objects used in building the; geometrical hierarchy. They represent objects that are not positioned,; but store all information about the placement of the other volumes they; may contain. Therefore a volume can be replicated several times in the; geometry. As it was explained, in order to create a volume, one has to; put together a shape and a medium, which are already defined. Volumes have to be named by users at creation time. Every different name; may represent a unique volume object, but may also represent more; ge",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:26276,Performance,perform,performances,26276," with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); ~~~. \anchor GP01bc; #### Positioned Volumes (Nodes). Geometrical modeling is a difficult task when the number of different; geometrical objects is 106-108. This is more or less the case for; detector geometries of complex experiments, where a ‘flat' CSG model; description cannot scale with the current CPU performances. This is the; reason why models like GEANT [1] introduced an additional dimension; (depth) in order to reduce the complexity of the problem. This concept; is also preserved by the ROOT modeller and introduces a pure geometrical; constraint between objects (volumes in our case) - containment. This; means in fact that any positioned volume has to be contained by another.; Now what means contained and positioned?. - We will say that a volume `contains` a point if this is inside the; shape associated to the volume. For instance, a volume having a box; shape will contain all points `P=(X,Y,Z)` verifying the conditions:; `Abs(Pi)dXi`. The points on the shape boundaries are considered as; inside the volume. The volume contains a daughter if it contains all; the points contained by the daughter.; - The definition of containment works of course only with points; defined in the local coordinate system of the consid",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:28932,Performance,optimiz,optimization,28932,"trix=gGeoIdentity); ~~~. The objects referencing a volume and a transformation are called `NODES`; and their creation is fully handled by the modeller. They represent the; link elements in the hierarchy of volumes. Nodes are unique and distinct; geometrical objects ONLY from their container point of view. Since; volumes can be replicated in the geometry, the same node may be found on; different branches. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame.; This can be the volume itself, one of its positioned daughter volumes or; none if the point is actually outside. On the other hand, volumes have; to provide also other navigation methods such as finding the distances; to its shape boundaries or which daughter will be crossed first. The; implementation of these features is done at shape level, but the local; mother-daughters management is handled by volumes. These build; additional optimization structures upon geometry closure. In order to; have navigation features properly working one has to follow some rules; for building a valid geometry. - The daughter volume(s) must not extrude the mother shape. They are; allowed however to have a common boundaries.; - The volumes positioned in the same container must not overlap with; each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ~~~{.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ~~~. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-div",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:30286,Performance,optimiz,optimizes,30286,". They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ~~~{.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ~~~. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. \anchor GP01bd; #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ""invisible"" (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C`'; and `C`\"", having the same shape but different media matching the; corresponding cont",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:30306,Performance,perform,performance,30306,". They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ~~~{.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ~~~. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. \anchor GP01bd; #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ""invisible"" (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C`'; and `C`\"", having the same shape but different media matching the; corresponding cont",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:31510,Performance,optimiz,optimize,31510,"e ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ""invisible"" (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C`'; and `C`\"", having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation comes from the fact that any container is directly used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D`, `E`, and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class TGeoVolumeAssembly, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually posi",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:40857,Performance,optimiz,optimization,40857,"ompletely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. \anchor GP01bh; #### Volume Families. A volume family is represented by the class TGeoVolumeMulti. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a TGeoVolumeMulti equally affects all volumes in that family.; The creation of a family is generally not a user task, but can ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:41047,Performance,perform,performance,41047,"ompletely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. \anchor GP01bh; #### Volume Families. A volume family is represented by the class TGeoVolumeMulti. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a TGeoVolumeMulti equally affects all volumes in that family.; The creation of a family is generally not a user task, but can ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:45554,Performance,perform,performed,45554,"de(""SLICEX"",1,N);; ~~~. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume is added to the family and positioned N times inside the; divided volume, otherwise, each slice will be represented by a distinct; volume in the family. Divisions can be also performed in a given range of one axis. For that,; one has to specify also the starting coordinate value and the step:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; ~~~. A check is always done on the resulting division range: if not fitting; into the container limits, an error message is posted. If we will browse; the divided volume we will notice that it will contain N nodes starting; with index 1 up to N. The first one has the lower X limit at `START`; position, while the last one will have the upper X limit at; `START+N*STEP`. The resulting slices cannot be positioned inside another; volume (they are by default positioned inside the divided one) but can; be further divided and may contain other volumes:. ~~~{.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; ~~~. When doing that, we have to remember that `SLICEY` represents a family,; therefore all members of the family will be divided on Y and the other; volu",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:49420,Performance,perform,performance,49420," handled together, for different possible reasons. One; of these is that the structure has to be replicated in several parts of; the geometry, or it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; ""Overlapping Volumes""); - Representing the container as a composite shape - the Boolean union; of all components (see also ""Composite Shapes""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-related navigation optimizations. The; class TGeoVolumeAssembly represents an assembly volume. Its shape; is represented by TGeoShapeAssembly class that is the union of all; components. It uses volume voxelization to perform navigation tasks. An assembly volume creates a hierarchical level and it geometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a TGeoShapeAssembly is always inside one of; the components, so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an a",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:49603,Performance,optimiz,optimizations,49603,"etry, or it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; ""Overlapping Volumes""); - Representing the container as a composite shape - the Boolean union; of all components (see also ""Composite Shapes""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-related navigation optimizations. The; class TGeoVolumeAssembly represents an assembly volume. Its shape; is represented by TGeoShapeAssembly class that is the union of all; components. It uses volume voxelization to perform navigation tasks. An assembly volume creates a hierarchical level and it geometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a TGeoShapeAssembly is always inside one of; the components, so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an assembly is very easy: one has just to create a; TGeoVolumeAssembly object and position the components inside as; for any volume:. ~~~{.cpp",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:49801,Performance,perform,perform,49801,"tainer volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; ""Overlapping Volumes""); - Representing the container as a composite shape - the Boolean union; of all components (see also ""Composite Shapes""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-related navigation optimizations. The; class TGeoVolumeAssembly represents an assembly volume. Its shape; is represented by TGeoShapeAssembly class that is the union of all; components. It uses volume voxelization to perform navigation tasks. An assembly volume creates a hierarchical level and it geometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a TGeoShapeAssembly is always inside one of; the components, so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an assembly is very easy: one has just to create a; TGeoVolumeAssembly object and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:50925,Performance,optimiz,optimizing,50925,"eometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a TGeoShapeAssembly is always inside one of; the components, so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an assembly is very easy: one has just to create a; TGeoVolumeAssembly object and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used f",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:50940,Performance,perform,performance,50940,"eometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a TGeoShapeAssembly is always inside one of; the components, so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an assembly is very easy: one has just to create a; TGeoVolumeAssembly object and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used f",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:51002,Performance,perform,performance,51002,", so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an assembly is very easy: one has just to create a; TGeoVolumeAssembly object and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversi",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:51072,Performance,perform,performing,51072,", so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an assembly is very easy: one has just to create a; TGeoVolumeAssembly object and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversi",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:51487,Performance,optimiz,optimize,51487,"ct and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A g",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:51496,Performance,perform,performance,51496,"ct and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A g",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:51971,Performance,perform,perform,51971,"n performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:. \f[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Translation:. \f[; \left|\begi",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:52743,Performance,perform,performed,52743,"cement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:. \f[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Translation:. \f[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|; \f]. Scale:. \f[; \left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Inverse rotation:. \f[; \left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Inverse translation:. \f[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|; \f]. Inverse scale:. \f[; \left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:58782,Performance,perform,performed,58782,"ns can be added or subtracted. ~~~{.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ~~~. - Rotations (TGeoRotation class) represent a pure rotation. Data; members are `Double_t fRotationMatrix[3*3]`. Rotations can be; defined either by Euler angles, either, by GEANT3 angles:. ~~~{.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; ~~~. This represents the composition of: first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with `psi` about the new Z axis. ~~~{.cpp}; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); ~~~. This is a rotation defined in GEANT3 style. Theta and phi are the; spherical angles of each axis of the rotated coordinate system with; respect to the initial one. This construction allows definition of; malformed rotations, e.g. not orthogonal. A check is performed and an; error message is issued in this case. Specific utilities: determinant, inverse. - Scale transformations (TGeoScale class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3]`, `TGeoRotation *fRotation`. ~~~{.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ~~~. - General transformations: (TGeoHMatrix class) represent; combined transformations in any order.; - Identity transformation: (TGeoIdentity class) is a generic; identity transformation represented by a singleton class object; `gGeoIdentity`. \anchor GP01d; ### Ownership of Geometry Objects. The class TGeoManager class contains the entire API needed for; building and tracking ge",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:60983,Performance,cache,cache,60983,"jects defined in a; session; therefore, users must not try to control their deletion. It; contains lists of media, materials, transformations, shapes and volumes.; A special case is the one of geometrical transformations. When creating; a matrix or a translation, this is by default owned by external objects.; The manager class becomes owner of all transformations used for; positioning volumes. In order to force the ownership for other; transformations, one can use TGeoMatrix::RegisterYourself() method. Do; not be therefore surprised that some transformations cannot be found by; name when creating a composite shape for instance if you did not; register them after creation. Logical nodes (positioned volumes) are created and destroyed by the; TGeoVolume class. Physical nodes and their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of TGeoManager. The manager class also; controls the drawing/checking package (TGeoPainter client). This; is linked with %ROOT graphical libraries loaded on demand in order to; control visualization actions. \anchor GP02; ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propa",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:61156,Performance,load,loaded,61156,"transformations. When creating; a matrix or a translation, this is by default owned by external objects.; The manager class becomes owner of all transformations used for; positioning volumes. In order to force the ownership for other; transformations, one can use TGeoMatrix::RegisterYourself() method. Do; not be therefore surprised that some transformations cannot be found by; name when creating a composite shape for instance if you did not; register them after creation. Logical nodes (positioned volumes) are created and destroyed by the; TGeoVolume class. Physical nodes and their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of TGeoManager. The manager class also; controls the drawing/checking package (TGeoPainter client). This; is linked with %ROOT graphical libraries loaded on demand in order to; control visualization actions. \anchor GP02; ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. T",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:72115,Performance,perform,perform,72115,"tates-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ~~~{.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ~~~. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ~~~{.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ~~~. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ~~~{.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ~~~. \anchor GP02f; ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there i",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:72984,Performance,perform,performed,72984,"ed:. ~~~{.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ~~~. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ~~~{.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ~~~. \anchor GP02f; ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigation algorithms, but user code is also allowed to access it. This; works on any stack principle by using PUSH and POP calls and user code; is responsible for popping the pushed states in order to keep the stack; clean. ~~~{.cpp}; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index wit",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:75418,Performance,perform,perform,75418,"t node or path has not; been changed by the user. \anchor GP02ga; #### Finding If Current State Is Changed For a New Point. One can find fast if a point different from the current one has or not; the same location inside the geometry tree. To do that, the new point; should not be introduced by using TGeoManager::SetCurrentPoint(); method, but rather by calling the specific method:. ~~~{.cpp}; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; ~~~. In the prototype above, `x, y` and `z` are the coordinates of the new; point. The modeller will check whether the current volume still contains; the new point or its location has changed in the geometry hierarchy. If; the new location is different, two actions are possible according to the; value of `change`:. - `change = kFALSE` (default) - the modeller does not change the; current state but just inform the caller about this change.; - `change = kTRUE` - the modeller will actually perform a new; `‘Where am I?' `search after finding out that the location has; changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state; after changing the current point coordinates (e.g.; `gGeoManager->FindNode(newX,newY,newZ)`), users can always query if the; previous state has changed by using a method having the same name but; without parameters:. ~~~{.cpp}; Bool_t TGeoManager::IsSameLocation();; ~~~. \anchor GP02gb; #### Finding the Distance to the Next Boundary. All tracking engines need to compare the currently proposed physical; step with the maximum allowed distance in the current material. The; modeller provides this information by computing the distance to the; first boundary starting from the current point along a straight line.; The starting point and direction for this procedure are the ones; corresponding to the current state. The boundary search is initialized; inside the current volume and the crossed boundary can belo",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:75576,Performance,perform,performing,75576,"t one has or not; the same location inside the geometry tree. To do that, the new point; should not be introduced by using TGeoManager::SetCurrentPoint(); method, but rather by calling the specific method:. ~~~{.cpp}; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; ~~~. In the prototype above, `x, y` and `z` are the coordinates of the new; point. The modeller will check whether the current volume still contains; the new point or its location has changed in the geometry hierarchy. If; the new location is different, two actions are possible according to the; value of `change`:. - `change = kFALSE` (default) - the modeller does not change the; current state but just inform the caller about this change.; - `change = kTRUE` - the modeller will actually perform a new; `‘Where am I?' `search after finding out that the location has; changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state; after changing the current point coordinates (e.g.; `gGeoManager->FindNode(newX,newY,newZ)`), users can always query if the; previous state has changed by using a method having the same name but; without parameters:. ~~~{.cpp}; Bool_t TGeoManager::IsSameLocation();; ~~~. \anchor GP02gb; #### Finding the Distance to the Next Boundary. All tracking engines need to compare the currently proposed physical; step with the maximum allowed distance in the current material. The; modeller provides this information by computing the distance to the; first boundary starting from the current point along a straight line.; The starting point and direction for this procedure are the ones; corresponding to the current state. The boundary search is initialized; inside the current volume and the crossed boundary can belong either to; the current node or to one of its daughters. The full prototype of the; method is:. ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; ~~~. I",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:84319,Performance,scalab,scalability,84319,"t Crossing Point. Supposing we have found out that a particle will cross a boundary during; the next step, it is sometimes useful to compute the normal to the; crossed surface. The modeller uses the following convention: we define; as `normal` (\f$\vec{n}\f$) the unit vector perpendicular; to a surface in the `next crossing point`, having the orientation such; that: \f$\vec{n}.\vec{d}>0\f$. Here \f$\vec{d}\f$; represents the current direction. The next crossing point represents the; point where a ray shot from the current point along the current; direction crosses the surface. ~~~{.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ~~~. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. \anchor GP02h; ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; TVirtualGeoTrack provides this functionality. It currently has one; implementation inside the drawing package (TGeoTrack class). A; track can be defined like:. ~~~{.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ~~~. Where: `id` is user-defined id of the track, `pdg` - `pdg`",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:84335,Performance,perform,performance,84335,"t Crossing Point. Supposing we have found out that a particle will cross a boundary during; the next step, it is sometimes useful to compute the normal to the; crossed surface. The modeller uses the following convention: we define; as `normal` (\f$\vec{n}\f$) the unit vector perpendicular; to a surface in the `next crossing point`, having the orientation such; that: \f$\vec{n}.\vec{d}>0\f$. Here \f$\vec{d}\f$; represents the current direction. The next crossing point represents the; point where a ray shot from the current point along the current; direction crosses the surface. ~~~{.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ~~~. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. \anchor GP02h; ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; TVirtualGeoTrack provides this functionality. It currently has one; implementation inside the drawing package (TGeoTrack class). A; track can be defined like:. ~~~{.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ~~~. Where: `id` is user-defined id of the track, `pdg` - `pdg`",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:89427,Performance,perform,perform,89427,"*option="""");; ~~~. The drawing/animation time range is a global variable that can be; directly set:. ~~~{.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ~~~. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. \anchor GP03; ## Checking the Geometry. Several checking methods are accessible from the context menu of volume; objects or of the manager class. They generally apply only to the; visible parts of the drawn geometry in order to ease geometry checking,; and their implementation is in the TGeoChecker class. The checking; package contains an overlap checker and several utility methods that; generally have visualization outputs. \anchor GP03a; ### The Overlap Checker. An overlap is any region in the Euclidian space being contained by more; than one positioned volume. Due to the containment scheme used by the; modeller, all points inside a ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:92128,Performance,perform,performed,92128," regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(preci",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:92223,Performance,perform,perform,92223," not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired m",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:92373,Performance,optimiz,optimize,92373," behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given vol",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:92490,Performance,perform,performance,92490," behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given vol",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:92759,Performance,load,loaded,92759,"When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the lev",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:93464,Performance,perform,performed,93464,"n the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a posit",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:93760,Performance,perform,perform,93760,"mage html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. On",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:93865,Performance,perform,perform,93865,"mage html geometry008.png ""Overlap checking"". This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ~~~{.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ~~~. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. On",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:94662,Performance,perform,performed,94662," faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeo",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:94726,Performance,optimiz,optimized,94726,"eck at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeoManager->PrintOverlaps() prints the list of overlaps. \anchor GP03b; ### Graphical Checking Method",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:94796,Performance,perform,performing,94796,"eck at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion *A)* is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap *B)* is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a TBrowser) held; by the manager class will be filled with TGeoOverlap objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a TBrowser produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; gGeoManager->PrintOverlaps() prints the list of overlaps. \anchor GP03b; ### Graphical Checking Method",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:97195,Performance,load,loaded,97195,"en geometry is shooting random; points. This can be called with the method; TGeoVolume::RandomPoints() and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. \image html geometry011.png ""Random rays"" width=500px. A ray tracing method can be called TGeoVolume::RandomRays(). This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. \anchor GP04; ## The Drawing Package. \image html geometry012.png. The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:97669,Performance,load,loads,97669,"domRays(). This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. \anchor GP04; ## The Drawing Package. \image html geometry012.png. The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ~~~{.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ~~~. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here ar",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:98885,Performance,perform,perform,98885,"rarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ~~~{.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ~~~. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. **Q:** ""The picture is strangely rotated; where are the coordinate axes?"". **A:** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. **Q:** ""Every line is black! I cannot figure out what is what..."". **A:** Volumes can have different colors (those known by %ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black. **Q:** ""The top volume of my geometry is a box but I see only its content."". **A:** By default the drawn volume is not displayed just because we; do not want to hide its content when changing the view to HLR or solid; mode. In order to see it in the default wire frame picture one has to; call TGeoManager::SetTopVisible(). **Q:** ""I do not s",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:100956,Performance,perform,performed,100956,"mes in my tree but just something inside."". **A:** By default, TGeoVolume::Draw() paints the content of; a given volume three levels down. You can change this by using:; gGeoManager::SetVisLevel(n);. Not only that, but none of the volumes at intermediate levels (0-2) are; visible on the drawing unless they are final ‘leaves' on their branch; (e.g. have no other volumes positioned inside). This behavior is the; default one and corresponds to ‘leaves' global visualization mode; (`TGeoManager::fVisOption = 1`). In order to see on the screen the; intermediate containers, one can change this mode:; gGeoManager->SetVisOption(0). **Q:** ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?"". **A:** Indeed, moving the mouse close to some volume vertices; selects it. By checking the `Event Status` entry in the root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. drawing it). **Q:** ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?"". **A:** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. \anchor GP04b; ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even ",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:101770,Performance,tune,tune,101770,"root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. drawing it). **Q:** ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?"". **A:** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. \anchor GP04b; ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. \anchor GP04ba; #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ~~~{.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ~~~. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. \anchor GP04bb; #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:103126,Performance,tune,tune,103126,"herit from TAttLine class so the line style or; width can also be changed:. ~~~{.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ~~~. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. \anchor GP04bb; #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ~~~{.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ~~~. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: ""Visible daughters"". By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. \anchor GP04c; ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; `TGeo` is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; ref",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:106482,Performance,perform,performing,106482,"lipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`; 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; rootgeom.C example looks clipped with a tube. \image html geometry014.png ""Ray-tracing example with box-clipping"". \anchor GP05; ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; `TGeo` offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. \anchor GP05a; ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In `TGeo`, physical nodes are represented by; the class TGeoPhysicalNode and can be created on demand for; alignment purposes:. ~~~{.cpp}; TGeoPhysicalNode(const char* path); ~~~. The knowledge of the path to the objects that ne",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:111205,Performance,load,loading,111205," `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nodes:. ~~~{.cpp}; void RefreshPhysicalNodes(Bool_t lock = kTRUE); ~~~. The method above will optionally lock the possibility of doing any; further misalignment. \anchor GP06; ## Geometry I/O. Once geometry is successfully built, it can be saved in a root file, as; C++ macro or as GDML file by calling:. ~~~{.cpp}; TGeoManager::Export(const char *filename,const char*keyname="""",; Option_t *opt=""vg""); ~~~. - `Filename` is the name of the file to be written (mandatory).; Depending on the extension of the file, the geometry is exported; either as ,root file or .C(.cxx) macro or GDML file in case; extension is .gdml.; - `keyname`is the name of the key in the file (default """"); - `opt` = `""v""` is an export voxelization (default), otherwise; voxelization is recomputed after loading the geometry, `""g""` this; option (default) is taken into account only for exporting to gdml; file and it ensures compatibility with Geant4 (e.g. it adds extra; plane to incorrectly set polycone, it checks whether offset of Phi; division is in (-360;0\> range, ...), for this gdml export there are; two more option, that are not set by default: `""f""` and `""n""`. If; none of this two options are set, then names of solids and volumes; in resulting gdml file will have incremental suffix (e.g.; TGeoBBox\_0x1, TGeoBBox\_0x2, ...). If `""f""` option is set then then; suffix will contain pointer of object (e.g. TGeoBBox\_0xAAAAA01,; ...). Finally if option `""n""` is set then no suffix will be added,; though in this case uniqueness of the names is not ensured and it can; cause that file will be invalid. Loading geometry from a root file can be done in the same way as for any; other ROOT object, but a static method is also provided:. ~~~{.cpp}; TGeoManager::Import(const char *filename,cons",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:115314,Performance,optimiz,optimization,115314,"odule2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ~~~. \anchor GP06a; ### GDML. Few lines above word GDML was used. GDML stands for Geometry; Description Markup Language. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between %ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; %ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. \anchor GP07; ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. \anchor GP07a; ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: `/TOP\_1/A\_1/B\_3/C\_1`,; where `B\_3` for instance is a copy of volume `B` positioned inside; volume `A`. A state is always associated to a transformation matrix; `M` of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; current branch are kept in an array: (`MTOP\_1, MA\_1, MB\_3, ...`). \image html geometry015.png ""Navigation in the geometry hierarchy"" width=600px. The elementary operations for changing the state are:. ~~~{.cpp}; TGeoManager::CdUp();; TGeoManag",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:117668,Performance,optimiz,optimizes,117668,"eoManager::FindNode(x,y,z); ~~~. Note that the current particle position can be set using; SetCurrentPosition(x,y,z) method of the manager class, in which; case FindNode() can be called without arguments. The method; returns a pointer to the ""deepest node"" that geometrically contains *P*; (in our case let us suppose it is `B\_3`). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. ""Deepest"" means that `B\_3` still; contains point `P` (as well as `A\_1` and `TOP\_1`), but none of the; daughters of volume `B` does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ~~~{.cpp}; Bool_t *TGeoManager::IsSameLocation(); ~~~. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fu",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:117746,Performance,perform,performed,117746,"rent particle position can be set using; SetCurrentPosition(x,y,z) method of the manager class, in which; case FindNode() can be called without arguments. The method; returns a pointer to the ""deepest node"" that geometrically contains *P*; (in our case let us suppose it is `B\_3`). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. ""Deepest"" means that `B\_3` still; contains point `P` (as well as `A\_1` and `TOP\_1`), but none of the; daughters of volume `B` does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ~~~{.cpp}; Bool_t *TGeoManager::IsSameLocation(); ~~~. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlap",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:118302,Performance,optimiz,optimization,118302,"of volume `B` does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ~~~{.cpp}; Bool_t *TGeoManager::IsSameLocation(); ~~~. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. \image html geometry016.png ""Finding the location of a point in the geometry hierarchy"" width=600px. \anchor GP07b; ### Finding the Distance to Next Crossed Boundary. The most important feature provided by the modeller related to track; propagation is the computation of the distance to the next boundary; along a straight line. The relevant state parameters",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:120565,Performance,perform,perform,120565,"xt boundary is:. ~~~{.cpp}; TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); ~~~. The output node returned by the method is the object which shape; boundary will be crossed first. The distance to the next crossing can be; retrieved after the call:. ~~~{.cpp}; Double_t TGeoManager::GetStep(); ~~~. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning ""step approved"". The default value for `stepmax` is; TGeoShape::Big with the meaning that boundaries are looked for; without limitation. \image html geometry017.png ""Finding the distance to the next crossed boundary"" width=600px. According the values of the input parameters the method will perform; additional optional tasks:. `|stepmax| < TGeoShape::Big()`. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. `stepmax < 0`. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: TGeoManager::GetNextMatrix(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ~~~{.cpp}; Double_t *TGeoManager::FindNormalFast(); ~~~. `path 0`. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. \anchor GP07c; #### Output Values. TGeoManager::GetStep(): distance to next boundary. TGeoMana",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:122972,Performance,perform,performed,122972,"d; TGeoManager::Safety () is invoked. A safety value less than; TGeoShape::Tolerance() will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:123335,Performance,perform,performed,123335,"s; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as p",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:123474,Performance,optimiz,optimization,123474," point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to TGeoManager::FindNode() was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix de",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:124058,Performance,perform,performed,124058,"eference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; TGeoManager::FindNextDaughterBoundary(). This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; TGeoManager::ComputeNormalFast() to get the normal vector to the; crossed surface, after propagating the current point with the; TGeoManager::GetStep() value. This propagation can be done like:. ~~~{.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ~~~. Note: The met",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:125527,Performance,perform,performs,125527," the proposed step is; negative. In this case, one can subsequently call; TGeoManager::ComputeNormalFast() to get the normal vector to the; crossed surface, after propagating the current point with the; TGeoManager::GetStep() value. This propagation can be done like:. ~~~{.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ~~~. Note: The method TGeoManager::FindNextBoundary() does not modify the; current point/direction nor the current volume/state. The returned node; is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; TGeoManager::Step(), described in ""Making a Step"", but users may; implement more precise methods to insure post-step boundary crossing. \anchor GP08; ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class `TGeoXXX` have a correspondent editor; `TGeoXXXEditor` that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. \anchor GP08a; ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:126371,Performance,load,loaded,126371,"r to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; TGeoManager::Step(), described in ""Making a Step"", but users may; implement more precise methods to insure post-step boundary crossing. \anchor GP08; ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class `TGeoXXX` have a correspondent editor; `TGeoXXXEditor` that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. \anchor GP08a; ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ~~~. The lines above will create a new TGeoManager class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. \image html geometry018.png ""The geometry manager editor"". \anchor GP08b; ### The Geometry Manager Editor. \image html geometry019.png ""Accessing/creating different categories of editable objects"" width=600px. The second use case a",MatchSource.DOCS,geom/geom/doc/index.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md
