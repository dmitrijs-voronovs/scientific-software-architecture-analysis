id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/qutip/qutip/issues/2:74,Testability,test,test,74,"Some of the istests (like isoper) raise exceptions, when the object under test is not a Qobj, e.g. ioper raises an AttributeError exception, because it assumes that the object has a dims attribute. Shall I just modify the tests such that. ```; if isinstance(obj, Qobj):; # current test code; else:; return False; ```. Or is there a smarter way to do that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2
https://github.com/qutip/qutip/issues/2:222,Testability,test,tests,222,"Some of the istests (like isoper) raise exceptions, when the object under test is not a Qobj, e.g. ioper raises an AttributeError exception, because it assumes that the object has a dims attribute. Shall I just modify the tests such that. ```; if isinstance(obj, Qobj):; # current test code; else:; return False; ```. Or is there a smarter way to do that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2
https://github.com/qutip/qutip/issues/2:281,Testability,test,test,281,"Some of the istests (like isoper) raise exceptions, when the object under test is not a Qobj, e.g. ioper raises an AttributeError exception, because it assumes that the object has a dims attribute. Shall I just modify the tests such that. ```; if isinstance(obj, Qobj):; # current test code; else:; return False; ```. Or is there a smarter way to do that?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/2
https://github.com/qutip/qutip/pull/4:99,Safety,avoid,avoid,99,"istests now return False if the object is not a Qobj instead of; raising an exception. In order to avoid a cyclical import qobj.py ->; istests.py -> qobj.py the istests have been moved to qobj.py and are; imported in istests.py for backwards compatability, closes #2. Sorry for the first failed attempt. I should also add some tests before that goes in I suppose. Just wanted to start the discussion about the cyclical import issue",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/4
https://github.com/qutip/qutip/pull/4:327,Testability,test,tests,327,"istests now return False if the object is not a Qobj instead of; raising an exception. In order to avoid a cyclical import qobj.py ->; istests.py -> qobj.py the istests have been moved to qobj.py and are; imported in istests.py for backwards compatability, closes #2. Sorry for the first failed attempt. I should also add some tests before that goes in I suppose. Just wanted to start the discussion about the cyclical import issue",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/4
https://github.com/qutip/qutip/pull/5:242,Testability,test,test,242,"With this PR mesolve and mcsolve accept single operators as input for the collapse operator or the operator for which the expectation value is calculated. Internally, a list containing only that operator is constructed and passed on. I added test cases, by just copying a test that was already there and changing the input to a single operator for the collapse and expectation value respectively. For mcsolve the tests take quite some time, so a simpler test might be better. Any idea?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/5
https://github.com/qutip/qutip/pull/5:272,Testability,test,test,272,"With this PR mesolve and mcsolve accept single operators as input for the collapse operator or the operator for which the expectation value is calculated. Internally, a list containing only that operator is constructed and passed on. I added test cases, by just copying a test that was already there and changing the input to a single operator for the collapse and expectation value respectively. For mcsolve the tests take quite some time, so a simpler test might be better. Any idea?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/5
https://github.com/qutip/qutip/pull/5:413,Testability,test,tests,413,"With this PR mesolve and mcsolve accept single operators as input for the collapse operator or the operator for which the expectation value is calculated. Internally, a list containing only that operator is constructed and passed on. I added test cases, by just copying a test that was already there and changing the input to a single operator for the collapse and expectation value respectively. For mcsolve the tests take quite some time, so a simpler test might be better. Any idea?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/5
https://github.com/qutip/qutip/pull/5:454,Testability,test,test,454,"With this PR mesolve and mcsolve accept single operators as input for the collapse operator or the operator for which the expectation value is calculated. Internally, a list containing only that operator is constructed and passed on. I added test cases, by just copying a test that was already there and changing the input to a single operator for the collapse and expectation value respectively. For mcsolve the tests take quite some time, so a simpler test might be better. Any idea?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/5
https://github.com/qutip/qutip/pull/5:446,Usability,simpl,simpler,446,"With this PR mesolve and mcsolve accept single operators as input for the collapse operator or the operator for which the expectation value is calculated. Internally, a list containing only that operator is constructed and passed on. I added test cases, by just copying a test that was already there and changing the input to a single operator for the collapse and expectation value respectively. For mcsolve the tests take quite some time, so a simpler test might be better. Any idea?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/5
https://github.com/qutip/qutip/pull/6:151,Availability,fault,faults,151,"Thought I pitch that to you before continuing with the work. I use pep8 and pyflakes to check my python code on the fly. Currently there are plenty of faults that the two find and anything new I introduce would be drowned in the noise. Instead of turning it off I thought I might as well run through the main files and fix the errors. In principle this should not break anything because it is mostly things like trailing whitespaces, long lines and whitespaces around operators. Making these changes will touch a lot of lines though, so if you'd rather stick with the current codebase that's fine too. I'll just turn off the checkers and mothball this pull request :). So far I came as far as changing about.py and bloch.py",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/6
https://github.com/qutip/qutip/pull/6:327,Availability,error,errors,327,"Thought I pitch that to you before continuing with the work. I use pep8 and pyflakes to check my python code on the fly. Currently there are plenty of faults that the two find and anything new I introduce would be drowned in the noise. Instead of turning it off I thought I might as well run through the main files and fix the errors. In principle this should not break anything because it is mostly things like trailing whitespaces, long lines and whitespaces around operators. Making these changes will touch a lot of lines though, so if you'd rather stick with the current codebase that's fine too. I'll just turn off the checkers and mothball this pull request :). So far I came as far as changing about.py and bloch.py",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/6
https://github.com/qutip/qutip/issues/7:16,Availability,down,down,16,"Failed to break down the line. ```; f.write(""# Generated by QuTiP: %dx%d %s matrix in %s format ['%s' separated values].\n"" % (M, N, numtype, numformat, sep)); ```. to less then 80 chars without breaking the unit tests. Needs to be done later.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/7
https://github.com/qutip/qutip/issues/7:213,Testability,test,tests,213,"Failed to break down the line. ```; f.write(""# Generated by QuTiP: %dx%d %s matrix in %s format ['%s' separated values].\n"" % (M, N, numtype, numformat, sep)); ```. to less then 80 chars without breaking the unit tests. Needs to be done later.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/7
https://github.com/qutip/qutip/issues/9:122,Availability,error,error,122,"In gates.py there are a few examples in the docstrings. The output is sometimes longer then 79 chars, which yields a pep8 error. Are these examples somehow doctests? And if so, do I trip the doctest mechanism if I format the output of the examples?. If they are either not doctests, or the doctest mechanism is fine with linebreaks in the output, the examples should be pep8-ified",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/9
https://github.com/qutip/qutip/issues/10:267,Availability,error,error,267,"According to pep8 comparisons should be. ```; if Object is None:; ```. instead of . ```; if Object == None:; ```. I'm not 100% sure whether changing the comparisons will break anything so I left it untouched for now. If you have pep8 installed you can check for this error with. ```; pep8 --select=E711 *.py; ```. inside the qutip dir, which currently yields. ./bloch.py:443:17: E711 comparison to None should be 'if cond is None:'; ./bloch_redfield.py:141:16: E711 comparison to None should be 'if cond is None:'; ./bloch_redfield.py:176:14: E711 comparison to None should be 'if cond is not None:'; ./continous_variables.py:106:10: E711 comparison to None should be 'if cond is not None:'; ./continous_variables.py:117:13: E711 comparison to None should be 'if cond is not None:'; ./continous_variables.py:119:16: E711 comparison to None should be 'if cond is not None:'; ./correlation.py:130:14: E711 comparison to None should be 'if cond is None:'; ./correlation.py:180:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:198:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:227:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:257:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:307:13: E711 comparison to None should be 'if cond is None:'; ./eseries.py:230:22: E711 comparison to None should be 'if cond is None:'; ./essolve.py:73:18: E711 comparison to None should be 'if cond is None:'; ./fileio.py:48:17: E711 comparison to None should be 'if cond is None:'; ./fileio.py:141:17: E711 comparison to None should be 'if cond is None:'; ./fileio.py:155:27: E711 comparison to None should be 'if cond is None:'; ./floquet.py:492:24: E711 comparison to None should be 'if cond is None:'; ./floquet.py:651:16: E711 comparison to None should be 'if cond is None:'; ./floquet.py:703:14: E711 comparison to None should be 'if cond is not None:'; ./floquet.py:815:10: E711 comparison to None should be",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/10
https://github.com/qutip/qutip/issues/10:234,Deployability,install,installed,234,"According to pep8 comparisons should be. ```; if Object is None:; ```. instead of . ```; if Object == None:; ```. I'm not 100% sure whether changing the comparisons will break anything so I left it untouched for now. If you have pep8 installed you can check for this error with. ```; pep8 --select=E711 *.py; ```. inside the qutip dir, which currently yields. ./bloch.py:443:17: E711 comparison to None should be 'if cond is None:'; ./bloch_redfield.py:141:16: E711 comparison to None should be 'if cond is None:'; ./bloch_redfield.py:176:14: E711 comparison to None should be 'if cond is not None:'; ./continous_variables.py:106:10: E711 comparison to None should be 'if cond is not None:'; ./continous_variables.py:117:13: E711 comparison to None should be 'if cond is not None:'; ./continous_variables.py:119:16: E711 comparison to None should be 'if cond is not None:'; ./correlation.py:130:14: E711 comparison to None should be 'if cond is None:'; ./correlation.py:180:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:198:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:227:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:257:13: E711 comparison to None should be 'if cond is None:'; ./correlation.py:307:13: E711 comparison to None should be 'if cond is None:'; ./eseries.py:230:22: E711 comparison to None should be 'if cond is None:'; ./essolve.py:73:18: E711 comparison to None should be 'if cond is None:'; ./fileio.py:48:17: E711 comparison to None should be 'if cond is None:'; ./fileio.py:141:17: E711 comparison to None should be 'if cond is None:'; ./fileio.py:155:27: E711 comparison to None should be 'if cond is None:'; ./floquet.py:492:24: E711 comparison to None should be 'if cond is None:'; ./floquet.py:651:16: E711 comparison to None should be 'if cond is None:'; ./floquet.py:703:14: E711 comparison to None should be 'if cond is not None:'; ./floquet.py:815:10: E711 comparison to None should be",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/10
https://github.com/qutip/qutip/pull/11:272,Modifiability,refactor,refactoring,272,"Some more clean up of the code. Unit tests still pass. I touched some lines in bloch.py to make things more readable. Is there a generic example that I can run, to make sure the plotting still looks the same. For now the the change to bloch.py is minor, but thought about refactoring some things along the way and didn't want to break anything without a proper test.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/11
https://github.com/qutip/qutip/pull/11:37,Testability,test,tests,37,"Some more clean up of the code. Unit tests still pass. I touched some lines in bloch.py to make things more readable. Is there a generic example that I can run, to make sure the plotting still looks the same. For now the the change to bloch.py is minor, but thought about refactoring some things along the way and didn't want to break anything without a proper test.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/11
https://github.com/qutip/qutip/pull/11:361,Testability,test,test,361,"Some more clean up of the code. Unit tests still pass. I touched some lines in bloch.py to make things more readable. Is there a generic example that I can run, to make sure the plotting still looks the same. For now the the change to bloch.py is minor, but thought about refactoring some things along the way and didn't want to break anything without a proper test.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/11
https://github.com/qutip/qutip/issues/12:47,Testability,test,test,47,During PR #11 it came up that we might want to test that bloch.py produces the correct figures. Personally I have no idea how to test for correct plotting in a unit test kind of way. Any ideas?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/12
https://github.com/qutip/qutip/issues/12:129,Testability,test,test,129,During PR #11 it came up that we might want to test that bloch.py produces the correct figures. Personally I have no idea how to test for correct plotting in a unit test kind of way. Any ideas?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/12
https://github.com/qutip/qutip/issues/12:165,Testability,test,test,165,During PR #11 it came up that we might want to test that bloch.py produces the correct figures. Personally I have no idea how to test for correct plotting in a unit test kind of way. Any ideas?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/12
https://github.com/qutip/qutip/pull/14:282,Deployability,release,release,282,"Restructed the benchmark scripts so that matlab and qutip benchmarks can be run separately, and the comparison be done with two arbitrary benchmark results. The point of this is to make it possible to compare the benchmark results of two qutip versions, for example the last stable release and the current development code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/14
https://github.com/qutip/qutip/pull/14:15,Testability,benchmark,benchmark,15,"Restructed the benchmark scripts so that matlab and qutip benchmarks can be run separately, and the comparison be done with two arbitrary benchmark results. The point of this is to make it possible to compare the benchmark results of two qutip versions, for example the last stable release and the current development code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/14
https://github.com/qutip/qutip/pull/14:58,Testability,benchmark,benchmarks,58,"Restructed the benchmark scripts so that matlab and qutip benchmarks can be run separately, and the comparison be done with two arbitrary benchmark results. The point of this is to make it possible to compare the benchmark results of two qutip versions, for example the last stable release and the current development code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/14
https://github.com/qutip/qutip/pull/14:138,Testability,benchmark,benchmark,138,"Restructed the benchmark scripts so that matlab and qutip benchmarks can be run separately, and the comparison be done with two arbitrary benchmark results. The point of this is to make it possible to compare the benchmark results of two qutip versions, for example the last stable release and the current development code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/14
https://github.com/qutip/qutip/pull/14:213,Testability,benchmark,benchmark,213,"Restructed the benchmark scripts so that matlab and qutip benchmarks can be run separately, and the comparison be done with two arbitrary benchmark results. The point of this is to make it possible to compare the benchmark results of two qutip versions, for example the last stable release and the current development code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/14
https://github.com/qutip/qutip/issues/18:63,Integrability,depend,dependent,63,"It appears that qutip assumes that you are using the same time-dependent function(s) when computing the propagator using the rhs_reuse flag. As a result you can get an incorrect answer if one isn't aware of this assumption. Here is a demonstration of the issue:. import qutip as qtp. S = qtp.jmat(1/2.); I = qtp.qeye(2); odeOpts = qtp.Odeoptions(1e-10, 1e-8). H0 = qtp.tensor(S[2], I) + 0.1_qtp.tensor(I, S[2]); Hint = 0.1_sum([qtp.tensor(S[i], S[i]) for i in xrange(3)]); print ""H0:"", H0; print ""Hint:"", Hint. print ""Turning interaction on linearly:""; print qtp.propagator([H0, [Hint, 'w*t']], 5, [], {'w':1/5.}, opt=odeOpts). print ""Turning interaction off linearly with rhs_reuse (bug):""; odeOpts.rhs_reuse = True; print qtp.propagator([H0, [Hint, '1-w*t']], 5, [], {'w':1/5.}, opt=odeOpts). print ""Turning interaction off linearly without rhs_reuse (more like it):""; odeOpts = qtp.Odeoptions(1e-10, 1e-8); odeOpts.rhs_reuse = False; print qtp.propagator([H0, [Hint, '1-w*t']], 5, [], {'w':1/5.}, opt=odeOpts). print ""A solution is to keep the time function the same but change the arguments.""; print ""Turning interaction on linearly 'a+b_t':""; print qtp.propagator([H0, [Hint, 'a+b_t']], 5, [], {'a':0, 'b':1/5.}, opt=odeOpts). odeOpts.rhs_reuse = True; print ""Turning interaction off linearly with rhs_reuse but same 'a+b_t':""; print qtp.propagator([H0, [Hint, 'a+b_t']], 5, [], {'a':1, 'b':-1/5.}, opt=odeOpts)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/18
https://github.com/qutip/qutip/issues/19:64,Availability,error,error,64,Many of the demo examples doesn't work with current master. The error messages are for example. ```; NameError: global name 'mcsolve' is not defined; ```. or. ```; NameError: global name 'mesolve' is not defined; ```. Seen on Linux and OS X.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/19
https://github.com/qutip/qutip/issues/19:70,Integrability,message,messages,70,Many of the demo examples doesn't work with current master. The error messages are for example. ```; NameError: global name 'mcsolve' is not defined; ```. or. ```; NameError: global name 'mesolve' is not defined; ```. Seen on Linux and OS X.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/19
https://github.com/qutip/qutip/issues/20:713,Availability,error,error,713,"Currently e_ops argument is a list of expectation values to be calculated, and the result is stored as a list of ndarray in result.expect (where result is the Odedata instance returned by the solver). If expectation values for a lot of different operators are requested it becomes a bit tedious to keep track of which order the operators appear in e_ops, and which index show be used in result.expect. A solution could be to make all evolution solvers support that e_ops is given as a dictionary, for example:. ```; e_ops = {'a' : destroy(N), 'N': num(N), 'X': destroy(N) + create(N)}; ```. If e_ops is a dictionary, result.expect should also be a dictionary with the same keys, which would make it easy and less error prone to retrieve the results from result.expect.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/20
https://github.com/qutip/qutip/issues/21:393,Deployability,release,release,393,"Currently it's not easy to interrupt the mcsolve solver. Ctrl-C does not work well either because child processes are not killed when the controlling process receive the STOP or KILLL signals. This is especially problematic when using mcsolve from within the IPython notebook, but this problem also occurs when running a program directly from the prompt using the python interpreter. For next release we should try to make interrupting mcsolve a bit smoother.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/21
https://github.com/qutip/qutip/pull/22:444,Energy Efficiency,efficient,efficient,444,"Hi all, . A little while back, we had [this conversation](https://groups.google.com/forum/?fromgroups#!topic/qutip/AlMMzkRtijo) about adding some code I recently wrote to QuTiP. I've got a fairly primitive version of the code working now, so I'd like to see what you think. I tried to mimic the appearance of partial_transpose as much as possible, for familiarity to QuTiP users. Things yet to be done include:; - Rewriting the 'kernel' of the efficient application code in Fortran 90, f2py-ing and wrapping for increased speed; - Ensuring that no un-needed copies of the various arrays involved are being made; - (Perhaps, if you're so inclined) adding more structure to superoperators objects, so that they can be more easily handled. I think we've got a good start, let me know what I can do to bring the code up to your standards. Cheers,. Ben",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/22
https://github.com/qutip/qutip/pull/22:499,Integrability,wrap,wrapping,499,"Hi all, . A little while back, we had [this conversation](https://groups.google.com/forum/?fromgroups#!topic/qutip/AlMMzkRtijo) about adding some code I recently wrote to QuTiP. I've got a fairly primitive version of the code working now, so I'd like to see what you think. I tried to mimic the appearance of partial_transpose as much as possible, for familiarity to QuTiP users. Things yet to be done include:; - Rewriting the 'kernel' of the efficient application code in Fortran 90, f2py-ing and wrapping for increased speed; - Ensuring that no un-needed copies of the various arrays involved are being made; - (Perhaps, if you're so inclined) adding more structure to superoperators objects, so that they can be more easily handled. I think we've got a good start, let me know what I can do to bring the code up to your standards. Cheers,. Ben",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/22
https://github.com/qutip/qutip/issues/23:246,Security,access,accessible,246,"What should we do with the qutip/examples directory? It contains a lot of old stuff which is not really maintained anymore, but there are still some useful tests examples there. The current situation is:. qutip/qutip/examples - official examples accessible through the GUI and used in the docs; qutip/qutip/tests - unit tests; qutip/notebooks - development tests and benchmarks; qutip/examples - no clear purpose and not well maintained. We need to think about what we want to do with the examples directory and what purpose these example scripts have. I'm inclined to getting rid of these examples in favor or more contextual development examples in notebook form stored in qutip/notebooks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/23
https://github.com/qutip/qutip/issues/23:156,Testability,test,tests,156,"What should we do with the qutip/examples directory? It contains a lot of old stuff which is not really maintained anymore, but there are still some useful tests examples there. The current situation is:. qutip/qutip/examples - official examples accessible through the GUI and used in the docs; qutip/qutip/tests - unit tests; qutip/notebooks - development tests and benchmarks; qutip/examples - no clear purpose and not well maintained. We need to think about what we want to do with the examples directory and what purpose these example scripts have. I'm inclined to getting rid of these examples in favor or more contextual development examples in notebook form stored in qutip/notebooks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/23
https://github.com/qutip/qutip/issues/23:307,Testability,test,tests,307,"What should we do with the qutip/examples directory? It contains a lot of old stuff which is not really maintained anymore, but there are still some useful tests examples there. The current situation is:. qutip/qutip/examples - official examples accessible through the GUI and used in the docs; qutip/qutip/tests - unit tests; qutip/notebooks - development tests and benchmarks; qutip/examples - no clear purpose and not well maintained. We need to think about what we want to do with the examples directory and what purpose these example scripts have. I'm inclined to getting rid of these examples in favor or more contextual development examples in notebook form stored in qutip/notebooks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/23
https://github.com/qutip/qutip/issues/23:320,Testability,test,tests,320,"What should we do with the qutip/examples directory? It contains a lot of old stuff which is not really maintained anymore, but there are still some useful tests examples there. The current situation is:. qutip/qutip/examples - official examples accessible through the GUI and used in the docs; qutip/qutip/tests - unit tests; qutip/notebooks - development tests and benchmarks; qutip/examples - no clear purpose and not well maintained. We need to think about what we want to do with the examples directory and what purpose these example scripts have. I'm inclined to getting rid of these examples in favor or more contextual development examples in notebook form stored in qutip/notebooks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/23
https://github.com/qutip/qutip/issues/23:357,Testability,test,tests,357,"What should we do with the qutip/examples directory? It contains a lot of old stuff which is not really maintained anymore, but there are still some useful tests examples there. The current situation is:. qutip/qutip/examples - official examples accessible through the GUI and used in the docs; qutip/qutip/tests - unit tests; qutip/notebooks - development tests and benchmarks; qutip/examples - no clear purpose and not well maintained. We need to think about what we want to do with the examples directory and what purpose these example scripts have. I'm inclined to getting rid of these examples in favor or more contextual development examples in notebook form stored in qutip/notebooks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/23
https://github.com/qutip/qutip/issues/23:367,Testability,benchmark,benchmarks,367,"What should we do with the qutip/examples directory? It contains a lot of old stuff which is not really maintained anymore, but there are still some useful tests examples there. The current situation is:. qutip/qutip/examples - official examples accessible through the GUI and used in the docs; qutip/qutip/tests - unit tests; qutip/notebooks - development tests and benchmarks; qutip/examples - no clear purpose and not well maintained. We need to think about what we want to do with the examples directory and what purpose these example scripts have. I'm inclined to getting rid of these examples in favor or more contextual development examples in notebook form stored in qutip/notebooks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/23
https://github.com/qutip/qutip/issues/23:399,Usability,clear,clear,399,"What should we do with the qutip/examples directory? It contains a lot of old stuff which is not really maintained anymore, but there are still some useful tests examples there. The current situation is:. qutip/qutip/examples - official examples accessible through the GUI and used in the docs; qutip/qutip/tests - unit tests; qutip/notebooks - development tests and benchmarks; qutip/examples - no clear purpose and not well maintained. We need to think about what we want to do with the examples directory and what purpose these example scripts have. I'm inclined to getting rid of these examples in favor or more contextual development examples in notebook form stored in qutip/notebooks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/23
https://github.com/qutip/qutip/issues/26:363,Integrability,interface,interface,363,"Qobj currently use sparse matrix representation for operators and kets/bras, which is optimal for large systen but suboptimal for small systems. We want Qobj to support both sparse and dense matrix representation for the quantum object it represents. This should probably be implemented with two different classes, QobjSparse and QobjDense which inherit a common interface from a parent class Qobj.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/26
https://github.com/qutip/qutip/issues/26:346,Modifiability,inherit,inherit,346,"Qobj currently use sparse matrix representation for operators and kets/bras, which is optimal for large systen but suboptimal for small systems. We want Qobj to support both sparse and dense matrix representation for the quantum object it represents. This should probably be implemented with two different classes, QobjSparse and QobjDense which inherit a common interface from a parent class Qobj.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/26
https://github.com/qutip/qutip/pull/27:283,Deployability,patch,patch,283,"Currently, _correlation_me_2op_2t calculates <A(t+tau)B(t)> when reverse=True, and <A(t)B(t+tau)>. This is the opposite of what it should be, and causes qutip.correlation.correlation and qutip.correlation.correlation_2op_2t to give incorrect results when using the ""me"" solver. This patch fixes the problem, making the behaviour of _correlation_me_2op_2t consistent with the other qutip.correlation functions and with the documentation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/27
https://github.com/qutip/qutip/issues/29:733,Integrability,depend,depend,733,"I have also found that using the iterative SS solver with the preconditioner gives invalid answers for large systems. The following code will give negative numbers of particles for both oscillators (the correct values should be 0.1 and 9.7 for a and b respectively :. from scipy import *; from qutip import *; from pylab import *; import time. Nc=6 #Number of cavity states; Nm=46 #Number of mechanical states; alpha=0.311 #Coherent state amplitude; g0=0.36 #Coupling strength; kappa=0.3 #Cavity damping rate; gamma=0.00147 #Mech damping rate; xvec=linspace(-10,10,500) #Wigner area and sampling; delta=0; # operators. idc=qeye(Nc); idm=qeye(Nm); a=tensor(destroy(Nc),idm); b=tensor(idc,destroy(Nm)); # Hamiltonian terms that do not depend on detuning or coupling. H=(-delta+g0_(b.dag()+b))_(a.dag()_a)+b.dag()_b+alpha*(a.dag()+a); # collapse operators. cc=sqrt(kappa)_a; cm=sqrt(gamma)_b; c_op_list=[cc,cm]; print('Beginning SS'); s=time.time(); # rho_ss=steadystate_direct(H,c_op_list,use_umfpack=True). rho_ss=steadystate_iterative(H,c_op_list,use_precond=False); print('SS Elapsed time: ',time.time()-s); numa=expect(a.dag()_a,rho_ss); numb=expect(b.dag()_b,rho_ss); print('cavity number ',numa); print('mech. number ',numb); rho_b=ptrace(rho_ss,1); W=wigner(rho_b,xvec,xvec); wmap=wigner_cmap(W); contourf(xvec,xvec,W,100,cmap=wmap); colorbar(); show()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/29
https://github.com/qutip/qutip/issues/29:459,Modifiability,Coupling,Coupling,459,"I have also found that using the iterative SS solver with the preconditioner gives invalid answers for large systems. The following code will give negative numbers of particles for both oscillators (the correct values should be 0.1 and 9.7 for a and b respectively :. from scipy import *; from qutip import *; from pylab import *; import time. Nc=6 #Number of cavity states; Nm=46 #Number of mechanical states; alpha=0.311 #Coherent state amplitude; g0=0.36 #Coupling strength; kappa=0.3 #Cavity damping rate; gamma=0.00147 #Mech damping rate; xvec=linspace(-10,10,500) #Wigner area and sampling; delta=0; # operators. idc=qeye(Nc); idm=qeye(Nm); a=tensor(destroy(Nc),idm); b=tensor(idc,destroy(Nm)); # Hamiltonian terms that do not depend on detuning or coupling. H=(-delta+g0_(b.dag()+b))_(a.dag()_a)+b.dag()_b+alpha*(a.dag()+a); # collapse operators. cc=sqrt(kappa)_a; cm=sqrt(gamma)_b; c_op_list=[cc,cm]; print('Beginning SS'); s=time.time(); # rho_ss=steadystate_direct(H,c_op_list,use_umfpack=True). rho_ss=steadystate_iterative(H,c_op_list,use_precond=False); print('SS Elapsed time: ',time.time()-s); numa=expect(a.dag()_a,rho_ss); numb=expect(b.dag()_b,rho_ss); print('cavity number ',numa); print('mech. number ',numb); rho_b=ptrace(rho_ss,1); W=wigner(rho_b,xvec,xvec); wmap=wigner_cmap(W); contourf(xvec,xvec,W,100,cmap=wmap); colorbar(); show()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/29
https://github.com/qutip/qutip/issues/29:755,Modifiability,coupling,coupling,755,"I have also found that using the iterative SS solver with the preconditioner gives invalid answers for large systems. The following code will give negative numbers of particles for both oscillators (the correct values should be 0.1 and 9.7 for a and b respectively :. from scipy import *; from qutip import *; from pylab import *; import time. Nc=6 #Number of cavity states; Nm=46 #Number of mechanical states; alpha=0.311 #Coherent state amplitude; g0=0.36 #Coupling strength; kappa=0.3 #Cavity damping rate; gamma=0.00147 #Mech damping rate; xvec=linspace(-10,10,500) #Wigner area and sampling; delta=0; # operators. idc=qeye(Nc); idm=qeye(Nm); a=tensor(destroy(Nc),idm); b=tensor(idc,destroy(Nm)); # Hamiltonian terms that do not depend on detuning or coupling. H=(-delta+g0_(b.dag()+b))_(a.dag()_a)+b.dag()_b+alpha*(a.dag()+a); # collapse operators. cc=sqrt(kappa)_a; cm=sqrt(gamma)_b; c_op_list=[cc,cm]; print('Beginning SS'); s=time.time(); # rho_ss=steadystate_direct(H,c_op_list,use_umfpack=True). rho_ss=steadystate_iterative(H,c_op_list,use_precond=False); print('SS Elapsed time: ',time.time()-s); numa=expect(a.dag()_a,rho_ss); numb=expect(b.dag()_b,rho_ss); print('cavity number ',numa); print('mech. number ',numb); rho_b=ptrace(rho_ss,1); W=wigner(rho_b,xvec,xvec); wmap=wigner_cmap(W); contourf(xvec,xvec,W,100,cmap=wmap); colorbar(); show()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/29
https://github.com/qutip/qutip/issues/30:258,Availability,error,errors,258,"Since the PR merge of Ben's (@bcriger) code for Efficient Application of CPTP Maps to Subsystems, there has been a number of failing unit tests. I have fixed some of the tests and ported Ben's code to be python3 compatible, but there are still two remaining errors, which I have traced to the fact that `subsystem_apply(..., reference=True)` does not give the expected results (some normalization problem? perhaps with the eigenvectors?). ```; In [1]: from qutip import *; In [2]: rho_3 = rand_dm(3); In [3]: superop = kraus_to_super(rand_kraus_map(3)); In [4]: analytic_result = vector_to_operator(superop * operator_to_vector(rho_3)); In [5]: analytic_result; Out[5]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; |(0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 |. In [6]: ref_result = subsystem_apply(rho_3, superop, [True], reference=True); In [7]: ref_result; Out[7]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.354 (0.067−0.036j) (0.058+0.004j) |; |(0.067+0.036j) 0.407 (0.039−0.041j) |; |(0.058−0.004j) (0.039+0.041j) 0.240 ⎟. In [8]: efficient_result = subsystem_apply(rho_3, superop, [True]); In [9]: efficient_result; Out[9]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; | (0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 ⎟; ```. Probably @bcriger would be the best person to fix this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/30
https://github.com/qutip/qutip/issues/30:48,Energy Efficiency,Efficient,Efficient,48,"Since the PR merge of Ben's (@bcriger) code for Efficient Application of CPTP Maps to Subsystems, there has been a number of failing unit tests. I have fixed some of the tests and ported Ben's code to be python3 compatible, but there are still two remaining errors, which I have traced to the fact that `subsystem_apply(..., reference=True)` does not give the expected results (some normalization problem? perhaps with the eigenvectors?). ```; In [1]: from qutip import *; In [2]: rho_3 = rand_dm(3); In [3]: superop = kraus_to_super(rand_kraus_map(3)); In [4]: analytic_result = vector_to_operator(superop * operator_to_vector(rho_3)); In [5]: analytic_result; Out[5]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; |(0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 |. In [6]: ref_result = subsystem_apply(rho_3, superop, [True], reference=True); In [7]: ref_result; Out[7]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.354 (0.067−0.036j) (0.058+0.004j) |; |(0.067+0.036j) 0.407 (0.039−0.041j) |; |(0.058−0.004j) (0.039+0.041j) 0.240 ⎟. In [8]: efficient_result = subsystem_apply(rho_3, superop, [True]); In [9]: efficient_result; Out[9]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; | (0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 ⎟; ```. Probably @bcriger would be the best person to fix this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/30
https://github.com/qutip/qutip/issues/30:138,Testability,test,tests,138,"Since the PR merge of Ben's (@bcriger) code for Efficient Application of CPTP Maps to Subsystems, there has been a number of failing unit tests. I have fixed some of the tests and ported Ben's code to be python3 compatible, but there are still two remaining errors, which I have traced to the fact that `subsystem_apply(..., reference=True)` does not give the expected results (some normalization problem? perhaps with the eigenvectors?). ```; In [1]: from qutip import *; In [2]: rho_3 = rand_dm(3); In [3]: superop = kraus_to_super(rand_kraus_map(3)); In [4]: analytic_result = vector_to_operator(superop * operator_to_vector(rho_3)); In [5]: analytic_result; Out[5]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; |(0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 |. In [6]: ref_result = subsystem_apply(rho_3, superop, [True], reference=True); In [7]: ref_result; Out[7]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.354 (0.067−0.036j) (0.058+0.004j) |; |(0.067+0.036j) 0.407 (0.039−0.041j) |; |(0.058−0.004j) (0.039+0.041j) 0.240 ⎟. In [8]: efficient_result = subsystem_apply(rho_3, superop, [True]); In [9]: efficient_result; Out[9]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; | (0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 ⎟; ```. Probably @bcriger would be the best person to fix this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/30
https://github.com/qutip/qutip/issues/30:170,Testability,test,tests,170,"Since the PR merge of Ben's (@bcriger) code for Efficient Application of CPTP Maps to Subsystems, there has been a number of failing unit tests. I have fixed some of the tests and ported Ben's code to be python3 compatible, but there are still two remaining errors, which I have traced to the fact that `subsystem_apply(..., reference=True)` does not give the expected results (some normalization problem? perhaps with the eigenvectors?). ```; In [1]: from qutip import *; In [2]: rho_3 = rand_dm(3); In [3]: superop = kraus_to_super(rand_kraus_map(3)); In [4]: analytic_result = vector_to_operator(superop * operator_to_vector(rho_3)); In [5]: analytic_result; Out[5]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; |(0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 |. In [6]: ref_result = subsystem_apply(rho_3, superop, [True], reference=True); In [7]: ref_result; Out[7]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.354 (0.067−0.036j) (0.058+0.004j) |; |(0.067+0.036j) 0.407 (0.039−0.041j) |; |(0.058−0.004j) (0.039+0.041j) 0.240 ⎟. In [8]: efficient_result = subsystem_apply(rho_3, superop, [True]); In [9]: efficient_result; Out[9]: Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; ⎜0.396 (0.069−5.343×10−04j) (−0.003+0.030j) |; | (0.069+5.343×10−04j) 0.407 (−0.029−0.076j) |; |(−0.003−0.030j) (−0.029+0.076j) 0.293 ⎟; ```. Probably @bcriger would be the best person to fix this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/30
https://github.com/qutip/qutip/pull/32:32,Energy Efficiency,efficient,efficient,32,hello world!. a new but no more efficient spectrum calculation,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/32
https://github.com/qutip/qutip/issues/35:1224,Modifiability,flexible,flexible,1224,"Hi all,. I'm not sure how to do pull request in this case so let it be a new Issue. I have implemented Milstein method for solving SME for homodyne detection scheme. For my problems it works much better than the simple Euler-Maruyama method. In case of a single Wiener increment all what is required is the new rhs function (see notebook attached). For multiple Wiener increments the provided infrastructure of QuTiP is not enough. One needs to provide all of the A_ops to the rhs. The modified stochastic.py file is also attached (from qutip.stochastic import smesolve_mil). The attached Notebook contains an example of SME with an analytical solution. Which allows to test smesolver for a single quantum trajectory. The notebook and the modified stochastic.py is here:; http://db.tt/dJNjGo3g. P.S. Due to nonlinearity in the stochastic term of quantum SME the simple Euler-Maruyama scheme doesn't work properly sometimes. Even Milstein struggles. From my experience semi implicit methods help. But in order to implement it in a convenient way one needs to modify QuTiP approach to the problem. Maybe instead of rhs function it would be better to have a function which returns \rho_{n+1} instead of d\rho. It could be more flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/35
https://github.com/qutip/qutip/issues/35:148,Safety,detect,detection,148,"Hi all,. I'm not sure how to do pull request in this case so let it be a new Issue. I have implemented Milstein method for solving SME for homodyne detection scheme. For my problems it works much better than the simple Euler-Maruyama method. In case of a single Wiener increment all what is required is the new rhs function (see notebook attached). For multiple Wiener increments the provided infrastructure of QuTiP is not enough. One needs to provide all of the A_ops to the rhs. The modified stochastic.py file is also attached (from qutip.stochastic import smesolve_mil). The attached Notebook contains an example of SME with an analytical solution. Which allows to test smesolver for a single quantum trajectory. The notebook and the modified stochastic.py is here:; http://db.tt/dJNjGo3g. P.S. Due to nonlinearity in the stochastic term of quantum SME the simple Euler-Maruyama scheme doesn't work properly sometimes. Even Milstein struggles. From my experience semi implicit methods help. But in order to implement it in a convenient way one needs to modify QuTiP approach to the problem. Maybe instead of rhs function it would be better to have a function which returns \rho_{n+1} instead of d\rho. It could be more flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/35
https://github.com/qutip/qutip/issues/35:670,Testability,test,test,670,"Hi all,. I'm not sure how to do pull request in this case so let it be a new Issue. I have implemented Milstein method for solving SME for homodyne detection scheme. For my problems it works much better than the simple Euler-Maruyama method. In case of a single Wiener increment all what is required is the new rhs function (see notebook attached). For multiple Wiener increments the provided infrastructure of QuTiP is not enough. One needs to provide all of the A_ops to the rhs. The modified stochastic.py file is also attached (from qutip.stochastic import smesolve_mil). The attached Notebook contains an example of SME with an analytical solution. Which allows to test smesolver for a single quantum trajectory. The notebook and the modified stochastic.py is here:; http://db.tt/dJNjGo3g. P.S. Due to nonlinearity in the stochastic term of quantum SME the simple Euler-Maruyama scheme doesn't work properly sometimes. Even Milstein struggles. From my experience semi implicit methods help. But in order to implement it in a convenient way one needs to modify QuTiP approach to the problem. Maybe instead of rhs function it would be better to have a function which returns \rho_{n+1} instead of d\rho. It could be more flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/35
https://github.com/qutip/qutip/issues/35:212,Usability,simpl,simple,212,"Hi all,. I'm not sure how to do pull request in this case so let it be a new Issue. I have implemented Milstein method for solving SME for homodyne detection scheme. For my problems it works much better than the simple Euler-Maruyama method. In case of a single Wiener increment all what is required is the new rhs function (see notebook attached). For multiple Wiener increments the provided infrastructure of QuTiP is not enough. One needs to provide all of the A_ops to the rhs. The modified stochastic.py file is also attached (from qutip.stochastic import smesolve_mil). The attached Notebook contains an example of SME with an analytical solution. Which allows to test smesolver for a single quantum trajectory. The notebook and the modified stochastic.py is here:; http://db.tt/dJNjGo3g. P.S. Due to nonlinearity in the stochastic term of quantum SME the simple Euler-Maruyama scheme doesn't work properly sometimes. Even Milstein struggles. From my experience semi implicit methods help. But in order to implement it in a convenient way one needs to modify QuTiP approach to the problem. Maybe instead of rhs function it would be better to have a function which returns \rho_{n+1} instead of d\rho. It could be more flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/35
https://github.com/qutip/qutip/issues/35:862,Usability,simpl,simple,862,"Hi all,. I'm not sure how to do pull request in this case so let it be a new Issue. I have implemented Milstein method for solving SME for homodyne detection scheme. For my problems it works much better than the simple Euler-Maruyama method. In case of a single Wiener increment all what is required is the new rhs function (see notebook attached). For multiple Wiener increments the provided infrastructure of QuTiP is not enough. One needs to provide all of the A_ops to the rhs. The modified stochastic.py file is also attached (from qutip.stochastic import smesolve_mil). The attached Notebook contains an example of SME with an analytical solution. Which allows to test smesolver for a single quantum trajectory. The notebook and the modified stochastic.py is here:; http://db.tt/dJNjGo3g. P.S. Due to nonlinearity in the stochastic term of quantum SME the simple Euler-Maruyama scheme doesn't work properly sometimes. Even Milstein struggles. From my experience semi implicit methods help. But in order to implement it in a convenient way one needs to modify QuTiP approach to the problem. Maybe instead of rhs function it would be better to have a function which returns \rho_{n+1} instead of d\rho. It could be more flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/35
https://github.com/qutip/qutip/issues/37:470,Safety,risk,risk,470,"I just did a fresh instlal of qutip today and ran the tests. mcsolve (and mcsolve_f90) tests involving collapse operators fail. Probably this is due to a recent change in the code where averaging of states is turned off by default for the solver:. > commit fb40b4675bb454089a08087c64a07f83be44cd99; > Author: Robert Johansson jrjohansson@gmail.com; > Date: Mon Aug 5 11:24:26 2013 +0900; > ; > do not average states by default. I think this change in general involves a risk of not being backwards compatible with a lot of old code. What do you think?. Cheers, Arne",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/37
https://github.com/qutip/qutip/issues/37:54,Testability,test,tests,54,"I just did a fresh instlal of qutip today and ran the tests. mcsolve (and mcsolve_f90) tests involving collapse operators fail. Probably this is due to a recent change in the code where averaging of states is turned off by default for the solver:. > commit fb40b4675bb454089a08087c64a07f83be44cd99; > Author: Robert Johansson jrjohansson@gmail.com; > Date: Mon Aug 5 11:24:26 2013 +0900; > ; > do not average states by default. I think this change in general involves a risk of not being backwards compatible with a lot of old code. What do you think?. Cheers, Arne",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/37
https://github.com/qutip/qutip/issues/37:87,Testability,test,tests,87,"I just did a fresh instlal of qutip today and ran the tests. mcsolve (and mcsolve_f90) tests involving collapse operators fail. Probably this is due to a recent change in the code where averaging of states is turned off by default for the solver:. > commit fb40b4675bb454089a08087c64a07f83be44cd99; > Author: Robert Johansson jrjohansson@gmail.com; > Date: Mon Aug 5 11:24:26 2013 +0900; > ; > do not average states by default. I think this change in general involves a risk of not being backwards compatible with a lot of old code. What do you think?. Cheers, Arne",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/37
https://github.com/qutip/qutip/issues/39:41,Availability,error,error,41,qutip import now fail with the following error message. ```; /usr/local/lib/python3.3/dist-packages/qutip/cyQ/__init__.py in <module>(); 1 from qutip.cyQ.spmatfuncs import *; ----> 2 from qutip.cyQ.blas_funcs import *. ImportError: /usr/local/lib/python3.3/dist-packages/qutip/cyQ/blas_funcs.cpython-33m.so: undefined symbol: dznrm2_; ```,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/39
https://github.com/qutip/qutip/issues/39:47,Integrability,message,message,47,qutip import now fail with the following error message. ```; /usr/local/lib/python3.3/dist-packages/qutip/cyQ/__init__.py in <module>(); 1 from qutip.cyQ.spmatfuncs import *; ----> 2 from qutip.cyQ.blas_funcs import *. ImportError: /usr/local/lib/python3.3/dist-packages/qutip/cyQ/blas_funcs.cpython-33m.so: undefined symbol: dznrm2_; ```,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/39
https://github.com/qutip/qutip/pull/42:11,Deployability,install,install,11,I couldn't install qutip after commit a748fdcf9e9e15e16816d3304d3f448d3efd084b. These changes helped but I don't really have a clue what I'm doing :),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/42
https://github.com/qutip/qutip/issues/1515:25,Usability,clear,clearly,25,We need to document more clearly what kind of spectrum spectrum_ss calculates and have more examples.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1515
https://github.com/qutip/qutip/issues/46:63,Deployability,install,installing,63,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:157,Deployability,install,installing,157,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:198,Deployability,install,installation,198,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:248,Deployability,install,installation,248,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:324,Deployability,install,installation,324,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:481,Deployability,install,installed,481,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:311,Integrability,message,message,311,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:6,Testability,test,testing,6,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:35,Testability,test,tests,35,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:215,Testability,test,testing,215,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/46:285,Testability,test,testing,285,"qutip.testing.run() returns ""Ran 0 tests in 0.000s \ OK"" after installing QuTip 2.2.0 with f90 solver on OSX 10.8. This was reproducible on two macs. Before installing with fortran solver the QuTip installation and testing function normally. After installation with fortran solver the testing returns the above message. The installation seems to be fine though: mcsolve_f90 ran successfully in my simulation, and QuTip examples appear to work normally. To get fortran to compile I installed Xcode developer tools, and gfortran for OSX Mountain Lion from HPC following instructions from http://web.mit.edu/mfloyd/www/computing/mac/gfortran/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/46
https://github.com/qutip/qutip/issues/50:127,Deployability,continuous,continuous-benchmark,127,The commit af17ded3dec6d712eb852575bf6d5a6c5bbaf832 introduced a performance regression in Qobj.expm. https://github.com/qutip/continuous-benchmark#qobj_expm_20,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/50
https://github.com/qutip/qutip/issues/50:65,Performance,perform,performance,65,The commit af17ded3dec6d712eb852575bf6d5a6c5bbaf832 introduced a performance regression in Qobj.expm. https://github.com/qutip/continuous-benchmark#qobj_expm_20,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/50
https://github.com/qutip/qutip/issues/50:138,Testability,benchmark,benchmark,138,The commit af17ded3dec6d712eb852575bf6d5a6c5bbaf832 introduced a performance regression in Qobj.expm. https://github.com/qutip/continuous-benchmark#qobj_expm_20,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/50
https://github.com/qutip/qutip/issues/54:69,Safety,detect,detection,69,Why is heterodyne considered as a special case? To me the heterodyne detection scheme looks like a case of the homodyne detection. What do I miss?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/54
https://github.com/qutip/qutip/issues/54:120,Safety,detect,detection,120,Why is heterodyne considered as a special case? To me the heterodyne detection scheme looks like a case of the homodyne detection. What do I miss?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/54
https://github.com/qutip/qutip/issues/62:31,Deployability,install,install,31,"As of now the preferred way to install qutip on Mac OS X is using MacPorts. . Could you add a formula to [Homebrew](http://brew.sh/), ; https://github.com/mxcl/homebrew ?. By most users, Homebrew is considered better solution than MacPorts. See e.g. here http://apple.stackexchange.com/questions/32724/what-are-pros-and-cons-for-macports-fink-and-homebrew.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/62
https://github.com/qutip/qutip/issues/68:520,Availability,error,error,520,"As reported by Dan Hu on the mailing list, the cython code generated by Codegen fails to compile if args contains complex valued variables. The following minimal example reproduces the problem:. ```; from qutip import *; a = destroy(10); H0 = a.dag() * a; #H = [H0, [a.dag(), 'exp(1j * w * t) '], [a, 'exp(-1j * w * t)']]; args = {'w': 1} # works ; H = [H0, [a.dag(), 'exp(delta * t) '], [a, 'exp(-delta * t)']]; args = {'delta': 1j} # fails; mesolve(H, basis(10, 2), linspace(0, 10, 100), [a], [], args=args); ```. The error from the cython code is:. ```; spmvpy(data1, idx1, ptr1, vec, np.exp(-delta * t), out); ^; ------------------------------------------------------------; rhs9.pyx:20:39: Invalid operand type for '-' (complex_t); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/68
https://github.com/qutip/qutip/issues/68:129,Modifiability,variab,variables,129,"As reported by Dan Hu on the mailing list, the cython code generated by Codegen fails to compile if args contains complex valued variables. The following minimal example reproduces the problem:. ```; from qutip import *; a = destroy(10); H0 = a.dag() * a; #H = [H0, [a.dag(), 'exp(1j * w * t) '], [a, 'exp(-1j * w * t)']]; args = {'w': 1} # works ; H = [H0, [a.dag(), 'exp(delta * t) '], [a, 'exp(-delta * t)']]; args = {'delta': 1j} # fails; mesolve(H, basis(10, 2), linspace(0, 10, 100), [a], [], args=args); ```. The error from the cython code is:. ```; spmvpy(data1, idx1, ptr1, vec, np.exp(-delta * t), out); ^; ------------------------------------------------------------; rhs9.pyx:20:39: Invalid operand type for '-' (complex_t); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/68
https://github.com/qutip/qutip/issues/1516:295,Testability,Log,Log,295,"Most of the time when I search on Google for `qutip [something]` first hits are on the old documentation:. http://qutip.googlecode.com/svn/doc/2.0.0/html/index.html#. This is misleading, since it is:; - not up to date,; - makes impression that it is an abandoned project (since there is ""Change Log; Version 2.0.0 [SVN-2354](June 01, 2012)""). How about adding a header ""Check the new site (Version 2.2.) - http://qutip.org/"" or something like that (too make newcomers less confused)?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1516
https://github.com/qutip/qutip/issues/73:79,Availability,ERROR,ERROR,79,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:127,Availability,ERROR,ERROR,127,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:156,Availability,ERROR,ERROR,156,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:191,Availability,ERROR,ERROR,191,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:951,Availability,ERROR,ERROR,951,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:1719,Availability,ERROR,ERROR,1719,"e ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 144, in test_sparse_bandwidth; out2=sparse_bandwidth(B); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 603, in sparse_bandwidth; return _sparse_bandwidth(A.indices, A.indptr, nrows); File ""sparse_utils.pyx"", line 42, in qutip.cy.sparse_utils._sparse_bandwidth (qutip/cy/sparse_utils.c:1458); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:27,Testability,test,tests,27,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:394,Testability,test,test,394,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:479,Testability,test,tests,479,"On my system the following tests fails:. Sparse: Symmetric Reverse Permute ... ERROR; Sparse: Nonsymmetric Reverse Permute ... ERROR; Sparse: Bandwidth ... ERROR. More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:1157,Testability,test,test,1157," More detailed info:; # ; ## ERROR: Sparse: Symmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 144, in test_sparse_bandwidth; out2=sparse_bandwidth(B); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 60",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:1242,Testability,test,tests,1242,"ck (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 144, in test_sparse_bandwidth; out2=sparse_bandwidth(B); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 603, in sparse_bandwidth; return _sparse_bandwidth(A.indices, A.indptr, nrows);",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:1906,Testability,test,test,1906,"e ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 144, in test_sparse_bandwidth; out2=sparse_bandwidth(B); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 603, in sparse_bandwidth; return _sparse_bandwidth(A.indices, A.indptr, nrows); File ""sparse_utils.pyx"", line 42, in qutip.cy.sparse_utils._sparse_bandwidth (qutip/cy/sparse_utils.c:1458); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/issues/73:1991,Testability,test,tests,1991,"e ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 73, in test_sparse_symmetric_reverse_permute; B=sparse_reverse_permute(x,perm,perm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Nonsymmetric Reverse Permute. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 89, in test_sparse_nonsymmetric_reverse_permute; B=sparse_reverse_permute(x,rperm,cperm); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 566, in sparse_reverse_permute; A.indptr, nrows, ncols, rperm, cperm, flag); File ""sparse_utils.pyx"", line 266, in qutip.cy.sparse_utils._sparse_reverse_permute_complex (qutip/cy/sparse_utils.c:5740); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'; # ; ## ERROR: Sparse: Bandwidth. Traceback (most recent call last):; File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/nose-1.3.0-py3.3.egg/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/tests/test_Sparse.py"", line 144, in test_sparse_bandwidth; out2=sparse_bandwidth(B); File ""/home/rob/py-envs/py3-devel/lib/python3.3/site-packages/qutip/sparse.py"", line 603, in sparse_bandwidth; return _sparse_bandwidth(A.indices, A.indptr, nrows); File ""sparse_utils.pyx"", line 42, in qutip.cy.sparse_utils._sparse_bandwidth (qutip/cy/sparse_utils.c:1458); ValueError: Buffer dtype mismatch, expected 'int' but got 'long'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/73
https://github.com/qutip/qutip/pull/76:130,Availability,error,error,130,"This tries to address https://github.com/qutip/qutip/issues/73 using some type conversion and some fused types. I see a unit test error due to some fortran thing, and a couple of unit test failures, but I don't know if they are related.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/76
https://github.com/qutip/qutip/pull/76:189,Availability,failure,failures,189,"This tries to address https://github.com/qutip/qutip/issues/73 using some type conversion and some fused types. I see a unit test error due to some fortran thing, and a couple of unit test failures, but I don't know if they are related.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/76
https://github.com/qutip/qutip/pull/76:125,Testability,test,test,125,"This tries to address https://github.com/qutip/qutip/issues/73 using some type conversion and some fused types. I see a unit test error due to some fortran thing, and a couple of unit test failures, but I don't know if they are related.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/76
https://github.com/qutip/qutip/pull/76:184,Testability,test,test,184,"This tries to address https://github.com/qutip/qutip/issues/73 using some type conversion and some fused types. I see a unit test error due to some fortran thing, and a couple of unit test failures, but I don't know if they are related.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/76
https://github.com/qutip/qutip/issues/80:47,Deployability,install,installed,47,"The qutip.fortran module seems to be built and installed in the TravisCI environment, but for some reason loading it after install fails, so the tests are skipped. . See for example the build log at https://travis-ci.org/qutip/qutip/jobs/19551778",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/80
https://github.com/qutip/qutip/issues/80:123,Deployability,install,install,123,"The qutip.fortran module seems to be built and installed in the TravisCI environment, but for some reason loading it after install fails, so the tests are skipped. . See for example the build log at https://travis-ci.org/qutip/qutip/jobs/19551778",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/80
https://github.com/qutip/qutip/issues/80:106,Performance,load,loading,106,"The qutip.fortran module seems to be built and installed in the TravisCI environment, but for some reason loading it after install fails, so the tests are skipped. . See for example the build log at https://travis-ci.org/qutip/qutip/jobs/19551778",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/80
https://github.com/qutip/qutip/issues/80:145,Testability,test,tests,145,"The qutip.fortran module seems to be built and installed in the TravisCI environment, but for some reason loading it after install fails, so the tests are skipped. . See for example the build log at https://travis-ci.org/qutip/qutip/jobs/19551778",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/80
https://github.com/qutip/qutip/issues/80:192,Testability,log,log,192,"The qutip.fortran module seems to be built and installed in the TravisCI environment, but for some reason loading it after install fails, so the tests are skipped. . See for example the build log at https://travis-ci.org/qutip/qutip/jobs/19551778",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/80
https://github.com/qutip/qutip/issues/84:220,Testability,test,tests,220,"I'm curious if this [expm-vector product](http://eprints.ma.man.ac.uk/1591/) I implemented in scipy would speed up the `qutip.states.coherent(..., method='operator')` function? Maybe this could be checked after the unit tests with TravisCI are sorted out.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/84
https://github.com/qutip/qutip/pull/85:72,Energy Efficiency,efficient,efficient,72,"Made a new fork, applied change to super_to_choi which ought to fix the efficient subsystem channel application tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/85
https://github.com/qutip/qutip/pull/85:112,Testability,test,tests,112,"Made a new fork, applied change to super_to_choi which ought to fix the efficient subsystem channel application tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/85
https://github.com/qutip/qutip/issues/88:672,Integrability,depend,depending,672,"Several functions in `qutip.superoperator` return Qobj instances with `type=""super""` (though notably not `spre` and `spost`, which return `type=""oper""`). While this is very useful for distinguishing quantum maps from other quantum objects, additional metadata to tell apart Liouville (supermatrix) and Choi representations would be very useful in writing functions that act on quantum maps. For instance, the average gate fidelity of a map is easily calculated in terms of its Kraus decomposition, such that to find the fidelity of the map represented by a `Qobj`, one would either call `super_to_choi` and then `choi_to_kraus`, or would skip directly to `choi_to_kraus`, depending on how the map was represented. Moreover, having this metadata would be especially important if more superoperator representations are added, such as system+environment or Steinspring pairs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/88
https://github.com/qutip/qutip/pull/90:96,Testability,test,tests,96,"This is a quick proof of concept for the approach listed in qutip/qutip#88. I've added and unit tests and modified those made by @bcriger, but one of them is currently failing for something deep in `norm()` that I'm not yet sure how to fix, sorry.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/90
https://github.com/qutip/qutip/pull/94:301,Integrability,depend,dependencies,301,"In my earlier PR, I had forgotten to add a check for trace preservation in the `iscptp` property. This has now been added, along with test cases for the new `istp` and `iscp` properties. I'm not entirely satisfied with importing within the property bodies, but I'm not sure how else to avoid circular dependencies.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/94
https://github.com/qutip/qutip/pull/94:286,Safety,avoid,avoid,286,"In my earlier PR, I had forgotten to add a check for trace preservation in the `iscptp` property. This has now been added, along with test cases for the new `istp` and `iscp` properties. I'm not entirely satisfied with importing within the property bodies, but I'm not sure how else to avoid circular dependencies.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/94
https://github.com/qutip/qutip/pull/94:134,Testability,test,test,134,"In my earlier PR, I had forgotten to add a check for trace preservation in the `iscptp` property. This has now been added, along with test cases for the new `istp` and `iscp` properties. I'm not entirely satisfied with importing within the property bodies, but I'm not sure how else to avoid circular dependencies.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/94
https://github.com/qutip/qutip/pull/95:20,Performance,optimiz,optimization,20,"WIP: Qobj cleanups, optimization and improvements.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/95
https://github.com/qutip/qutip/issues/96:19,Testability,test,testing,19,"Doing some further testing of `type='super'` `Qobj`s, I ran into a simple test case in which operator multiplication fails to be associative. ```; >>> rho_psi = operator_to_vector(Qobj(np.diag(np.array([0.9, 0.1], dtype=complex))))>>> E_psi = rho_psi.dag(); >>> S = to_super(sigmax()); >>> (E_psi * S) * rho_psi; Traceback (most recent call last):; File ""<ipython-input-22-90cbfac2a43e>"", line 1, in <module>; (E_psi * S) * rho_psi; File ""qutip/qobj.py"", line 416, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes. >>> E_psi * (S * rho_psi); Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.18]]; >>> E_psi; Quantum object: dims = [[1], [[2], [2]]], shape = [1, 4], type = bra; Qobj data =; [[ 0.9 0. 0. 0.1]]; >>> rho_psi; Quantum object: dims = [[[2], [2]], [1]], shape = [4, 1], type = operator-vector; Qobj data =; [[ 0.9]; [ 0. ]; [ 0. ]; [ 0.1]]; >>> S; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]; ```. I'm not sure why this is happening yet, but I'll keep looking.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/96
https://github.com/qutip/qutip/issues/96:74,Testability,test,test,74,"Doing some further testing of `type='super'` `Qobj`s, I ran into a simple test case in which operator multiplication fails to be associative. ```; >>> rho_psi = operator_to_vector(Qobj(np.diag(np.array([0.9, 0.1], dtype=complex))))>>> E_psi = rho_psi.dag(); >>> S = to_super(sigmax()); >>> (E_psi * S) * rho_psi; Traceback (most recent call last):; File ""<ipython-input-22-90cbfac2a43e>"", line 1, in <module>; (E_psi * S) * rho_psi; File ""qutip/qobj.py"", line 416, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes. >>> E_psi * (S * rho_psi); Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.18]]; >>> E_psi; Quantum object: dims = [[1], [[2], [2]]], shape = [1, 4], type = bra; Qobj data =; [[ 0.9 0. 0. 0.1]]; >>> rho_psi; Quantum object: dims = [[[2], [2]], [1]], shape = [4, 1], type = operator-vector; Qobj data =; [[ 0.9]; [ 0. ]; [ 0. ]; [ 0.1]]; >>> S; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]; ```. I'm not sure why this is happening yet, but I'll keep looking.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/96
https://github.com/qutip/qutip/issues/96:67,Usability,simpl,simple,67,"Doing some further testing of `type='super'` `Qobj`s, I ran into a simple test case in which operator multiplication fails to be associative. ```; >>> rho_psi = operator_to_vector(Qobj(np.diag(np.array([0.9, 0.1], dtype=complex))))>>> E_psi = rho_psi.dag(); >>> S = to_super(sigmax()); >>> (E_psi * S) * rho_psi; Traceback (most recent call last):; File ""<ipython-input-22-90cbfac2a43e>"", line 1, in <module>; (E_psi * S) * rho_psi; File ""qutip/qobj.py"", line 416, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes. >>> E_psi * (S * rho_psi); Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.18]]; >>> E_psi; Quantum object: dims = [[1], [[2], [2]]], shape = [1, 4], type = bra; Qobj data =; [[ 0.9 0. 0. 0.1]]; >>> rho_psi; Quantum object: dims = [[[2], [2]], [1]], shape = [4, 1], type = operator-vector; Qobj data =; [[ 0.9]; [ 0. ]; [ 0. ]; [ 0.1]]; >>> S; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]; ```. I'm not sure why this is happening yet, but I'll keep looking.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/96
https://github.com/qutip/qutip/pull/97:162,Testability,test,tests,162,"This PR continues to expand on superoperator representation support by adding `superrep=""chi""` for chi (process) matrices in the Pauli basis. Currently, the unit tests fail on my system due to me misunderstanding how `dims` and `tensor` work together for `type=""super""` `Qobj`s (see line 92 of `test_superop_reps.py` and lines 161 and 173 of `superop_reps.py`), but hopefully this should be a straightforward fix. Once we have it working for qubits, we should be able to generalize to arbitrary dimensions by using the Heisenberg-Weyl group.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/97
https://github.com/qutip/qutip/pull/99:37,Testability,test,test,37,"As promised in #95, I added some new test cases to make sure that for all binary arithmetic operations and all superreps, the superrep metadata is preserved.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/99
https://github.com/qutip/qutip/pull/100:21,Modifiability,Refactor,Refactor,21,Work in progress:; - Refactor tensor so that it plays better with tensor products of superoperators (see PR #99); - Simplify and cleanup the code,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/100
https://github.com/qutip/qutip/pull/100:116,Usability,Simpl,Simplify,116,Work in progress:; - Refactor tensor so that it plays better with tensor products of superoperators (see PR #99); - Simplify and cleanup the code,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/100
https://github.com/qutip/qutip/issues/101:8,Energy Efficiency,reduce,reduce,8,"One can reduce the number of variables of the DM by N(N+1)/2 when operating on the upper (or lower) triangle of the DM only. This leads to a overdetermined least-squares problem that can be solved in SciPy. Since the scaling of these solution methods depends heavily on N, this should hopefully lead to a good speed up.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/101
https://github.com/qutip/qutip/issues/101:251,Integrability,depend,depends,251,"One can reduce the number of variables of the DM by N(N+1)/2 when operating on the upper (or lower) triangle of the DM only. This leads to a overdetermined least-squares problem that can be solved in SciPy. Since the scaling of these solution methods depends heavily on N, this should hopefully lead to a good speed up.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/101
https://github.com/qutip/qutip/issues/101:29,Modifiability,variab,variables,29,"One can reduce the number of variables of the DM by N(N+1)/2 when operating on the upper (or lower) triangle of the DM only. This leads to a overdetermined least-squares problem that can be solved in SciPy. Since the scaling of these solution methods depends heavily on N, this should hopefully lead to a good speed up.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/101
https://github.com/qutip/qutip/pull/102:0,Energy Efficiency,Reduce,Reduce,0,Reduce namespace pollution by adding plot_ prefixes to qubit plot functions. Also restructed the imports a bit.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/102
https://github.com/qutip/qutip/pull/103:125,Modifiability,config,configuring,125,Added functions for expanding 1 and 2 qubit gates to larger qubit spaces. Added optional arguments to all gate functions for configuring the gates to operate in a such a N-qubit space.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/103
https://github.com/qutip/qutip/issues/106:60,Testability,test,test,60,"""denstity matrices"" on line 84 in the basis transformations test. Just my two cents for using the library :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/106
https://github.com/qutip/qutip/issues/111:891,Energy Efficiency,efficient,efficient,891,"In the mcsolver function, it seems that (read from tutorial) the **quantum jumps** happen when a random number is generated larger than **(1-dp)**, where **dp** is no jump probability. And this is the only option for jumping in the algorithm. . In theory, there is another strategy to choose **jump**--that is to use the concept of **waiting time** (see Dum and Zoller's PRA **45** (7), 1992 paper, for example). That is to say, we check the no jump time **t** to see if it is longer than the waiting time $\tau$: if **t** is longer, then a quantum jump happens; otherwise, there is no jump. . Could anyone make the mcsolver flexible enough to let users freely to choose which strategy to use in the algorithm? Each of these two strategies have different meanings and their own advantages: the jumping probability strategy is good for simulating measurement models; the waiting time is more efficient if one just wants to know the averaged result. . If currently none can implement this idea, could you provide a direction for me to write another mcsolver to use the counterpart strategy of jumping? Thanks. Regards,; Qi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/111
https://github.com/qutip/qutip/issues/111:625,Modifiability,flexible,flexible,625,"In the mcsolver function, it seems that (read from tutorial) the **quantum jumps** happen when a random number is generated larger than **(1-dp)**, where **dp** is no jump probability. And this is the only option for jumping in the algorithm. . In theory, there is another strategy to choose **jump**--that is to use the concept of **waiting time** (see Dum and Zoller's PRA **45** (7), 1992 paper, for example). That is to say, we check the no jump time **t** to see if it is longer than the waiting time $\tau$: if **t** is longer, then a quantum jump happens; otherwise, there is no jump. . Could anyone make the mcsolver flexible enough to let users freely to choose which strategy to use in the algorithm? Each of these two strategies have different meanings and their own advantages: the jumping probability strategy is good for simulating measurement models; the waiting time is more efficient if one just wants to know the averaged result. . If currently none can implement this idea, could you provide a direction for me to write another mcsolver to use the counterpart strategy of jumping? Thanks. Regards,; Qi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/111
https://github.com/qutip/qutip/pull/117:29,Security,access,access,29,that provides a nicer API to access the jmat function. Made helper functions jplus and lz internal.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/117
https://github.com/qutip/qutip/issues/119:274,Deployability,release,release,274,"Two suggestions: ; 1. QuTiP uses an environment variable `NUM_THREADS`. We should probably name-space this variable, calling it `QUTIP_NUM_THREADS` (consistent with how other packages name their variables, like `MKL_NUM_THREADS` and `OPENBLAS_NUM_THREADS`. The upcoming 3.0 release would be a good time to make this change.; 2. Considering that QuTiP does not use thread but processes, it would be even better to call the variable `QUTIP_NUM_PROCESSES`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/119
https://github.com/qutip/qutip/issues/119:48,Modifiability,variab,variable,48,"Two suggestions: ; 1. QuTiP uses an environment variable `NUM_THREADS`. We should probably name-space this variable, calling it `QUTIP_NUM_THREADS` (consistent with how other packages name their variables, like `MKL_NUM_THREADS` and `OPENBLAS_NUM_THREADS`. The upcoming 3.0 release would be a good time to make this change.; 2. Considering that QuTiP does not use thread but processes, it would be even better to call the variable `QUTIP_NUM_PROCESSES`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/119
https://github.com/qutip/qutip/issues/119:107,Modifiability,variab,variable,107,"Two suggestions: ; 1. QuTiP uses an environment variable `NUM_THREADS`. We should probably name-space this variable, calling it `QUTIP_NUM_THREADS` (consistent with how other packages name their variables, like `MKL_NUM_THREADS` and `OPENBLAS_NUM_THREADS`. The upcoming 3.0 release would be a good time to make this change.; 2. Considering that QuTiP does not use thread but processes, it would be even better to call the variable `QUTIP_NUM_PROCESSES`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/119
https://github.com/qutip/qutip/issues/119:195,Modifiability,variab,variables,195,"Two suggestions: ; 1. QuTiP uses an environment variable `NUM_THREADS`. We should probably name-space this variable, calling it `QUTIP_NUM_THREADS` (consistent with how other packages name their variables, like `MKL_NUM_THREADS` and `OPENBLAS_NUM_THREADS`. The upcoming 3.0 release would be a good time to make this change.; 2. Considering that QuTiP does not use thread but processes, it would be even better to call the variable `QUTIP_NUM_PROCESSES`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/119
https://github.com/qutip/qutip/issues/119:422,Modifiability,variab,variable,422,"Two suggestions: ; 1. QuTiP uses an environment variable `NUM_THREADS`. We should probably name-space this variable, calling it `QUTIP_NUM_THREADS` (consistent with how other packages name their variables, like `MKL_NUM_THREADS` and `OPENBLAS_NUM_THREADS`. The upcoming 3.0 release would be a good time to make this change.; 2. Considering that QuTiP does not use thread but processes, it would be even better to call the variable `QUTIP_NUM_PROCESSES`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/119
https://github.com/qutip/qutip/issues/120:380,Integrability,depend,dependent,380,"I might want to have a Hamiltonian that is two consecutive different pulses. To do this in `mesolve` I just call it like this:. ```; mid_state = mesolve(H1, init_state, ...).states[-1]; end_state = mesolve(H2, mid_state, ...).states[-1]; ```. However in `mcsolve` I can not give a thousand initial states each to be considered as a single trajectory, so I have to use slower time dependent Hamiltonians. Would such an enhancement be welcomed? I will probably have to implemented it for myself anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/120
https://github.com/qutip/qutip/issues/120:418,Modifiability,enhance,enhancement,418,"I might want to have a Hamiltonian that is two consecutive different pulses. To do this in `mesolve` I just call it like this:. ```; mid_state = mesolve(H1, init_state, ...).states[-1]; end_state = mesolve(H2, mid_state, ...).states[-1]; ```. However in `mcsolve` I can not give a thousand initial states each to be considered as a single trajectory, so I have to use slower time dependent Hamiltonians. Would such an enhancement be welcomed? I will probably have to implemented it for myself anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/120
https://github.com/qutip/qutip/pull/121:107,Deployability,update,update,107,Now it is an actual progressbar. It uses the '\r' character; in order to erase the entire line before each update. It works in the IPython notebook as well. Tested in 3.4. It should work in 2.7. Not sure about 2.6 (because of // division operator?),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/121
https://github.com/qutip/qutip/pull/121:157,Testability,Test,Tested,157,Now it is an actual progressbar. It uses the '\r' character; in order to erase the entire line before each update. It works in the IPython notebook as well. Tested in 3.4. It should work in 2.7. Not sure about 2.6 (because of // division operator?),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/121
https://github.com/qutip/qutip/issues/123:73,Availability,failure,failure,73,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:594,Deployability,integrat,integrate,594,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:709,Deployability,integrat,integrate,709,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:742,Deployability,integrat,integrate,742,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:873,Deployability,integrat,integrate,873,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:594,Integrability,integrat,integrate,594,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:709,Integrability,integrat,integrate,709,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:742,Integrability,integrat,integrate,742,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/123:873,Integrability,integrat,integrate,873,"`mesolve([],...)` fails while `mesolve(identity,...)` works. There is no failure if `rhs_reuse` is not involved. ```; File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 269, in mesolve; progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 602, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/qutip/mesolve.py"", line 949, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/lustre/home/client/fas/jiang/sk943/python_lab/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 866, in run; args[5:])); File ""rhs0.pyx"", line 13, in rhs0.cy_td_ode_rhs (/home/fas/jiang/sk943/.pyxbld/temp.linux-x86_64-3.4/pyrex/rhs0.c:1427); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0):; ValueError: Buffer dtype mismatch, expected 'double complex' but got 'double'; ```. Offtopic: is qutip trying to decide on its own when to use `rhs_reuse`? I had this phantom bug that never appeared in the ipython notebook, but appeared in batch scripts.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/123
https://github.com/qutip/qutip/issues/126:251,Availability,error,errors,251,"Hi,; I'm running qutip on the latest Ubuntu LTS version in 64 bit. All required packages (gfortran etc.) are installed from the repository. No matter if I use the qutip package from the repository or compile it from source, the testing results into 3 errors:. > > > import qutip.testing as qt; > > > qt.run(); > > > Qobj data ... ok; > > > Qobj type ... ok; > > > Qobj Hermicity ... ok; > > > Qobj shape ... ok; > > > Qobj addition ... ok; > > > Qobj subtraction ... ok; > > > Qobj multiplication ... ok; > > > Qobj division ... ok; > > > Qobj power ... ok; > > > Qobj negation ... ok; > > > Qobj equals ... ok; > > > Qobj getitem ... ok; > > > Qobj multiplication type ... ok; > > > Qobj conjugate ... ok; > > > Qobj adjoint (dagger) ... ok; > > > Qobj diagonals ... ok; > > > Qobj eigenenergies ... ok; > > > Qobj eigenstates ... ok; > > > Qobj expm ... ok; > > > Qobj full ... ok; > > > Qobj ket type ... ok; > > > Qobj bra type ... ok; > > > Qobj operator type ... ok; > > > Qobj superoperator type ... ok; > > > Transform 2-level to eigenbasis and back ... ok; > > > Transform 10-level real-values to eigenbasis and back ... ok; > > > Transform 10-level to eigenbasis and back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Consistency between transformations of kets and denstity matrices ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.84e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:2798,Availability,Failure,Failure,2798,"e/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:2873,Availability,ERROR,ERROR,2873,"ix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:3910,Availability,ERROR,ERROR,3910,"expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qub",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:4066,Availability,ERROR,ERROR,4066,"ve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, n",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:14268,Availability,ERROR,ERROR,14268,"e/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 8.35e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-p",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:14275,Availability,Failure,Failure,14275,"e/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 8.35e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-p",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:15179,Availability,ERROR,ERROR,15179," > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_me",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:15872,Availability,ERROR,ERROR,15872,"ose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs1. ---. Ran 111 tests in 33.425s. FAILED (errors=3). I can reproduce this on 2 different systems (both 64 bit and 14.04).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:16592,Availability,error,errors,16592,"ose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs1. ---. Ran 111 tests in 33.425s. FAILED (errors=3). I can reproduce this on 2 different systems (both 64 bit and 14.04).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:109,Deployability,install,installed,109,"Hi,; I'm running qutip on the latest Ubuntu LTS version in 64 bit. All required packages (gfortran etc.) are installed from the repository. No matter if I use the qutip package from the repository or compile it from source, the testing results into 3 errors:. > > > import qutip.testing as qt; > > > qt.run(); > > > Qobj data ... ok; > > > Qobj type ... ok; > > > Qobj Hermicity ... ok; > > > Qobj shape ... ok; > > > Qobj addition ... ok; > > > Qobj subtraction ... ok; > > > Qobj multiplication ... ok; > > > Qobj division ... ok; > > > Qobj power ... ok; > > > Qobj negation ... ok; > > > Qobj equals ... ok; > > > Qobj getitem ... ok; > > > Qobj multiplication type ... ok; > > > Qobj conjugate ... ok; > > > Qobj adjoint (dagger) ... ok; > > > Qobj diagonals ... ok; > > > Qobj eigenenergies ... ok; > > > Qobj eigenstates ... ok; > > > Qobj expm ... ok; > > > Qobj full ... ok; > > > Qobj ket type ... ok; > > > Qobj bra type ... ok; > > > Qobj operator type ... ok; > > > Qobj superoperator type ... ok; > > > Transform 2-level to eigenbasis and back ... ok; > > > Transform 10-level real-values to eigenbasis and back ... ok; > > > Transform 10-level to eigenbasis and back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Consistency between transformations of kets and denstity matrices ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.84e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:544,Energy Efficiency,power,power,544,"Hi,; I'm running qutip on the latest Ubuntu LTS version in 64 bit. All required packages (gfortran etc.) are installed from the repository. No matter if I use the qutip package from the repository or compile it from source, the testing results into 3 errors:. > > > import qutip.testing as qt; > > > qt.run(); > > > Qobj data ... ok; > > > Qobj type ... ok; > > > Qobj Hermicity ... ok; > > > Qobj shape ... ok; > > > Qobj addition ... ok; > > > Qobj subtraction ... ok; > > > Qobj multiplication ... ok; > > > Qobj division ... ok; > > > Qobj power ... ok; > > > Qobj negation ... ok; > > > Qobj equals ... ok; > > > Qobj getitem ... ok; > > > Qobj multiplication type ... ok; > > > Qobj conjugate ... ok; > > > Qobj adjoint (dagger) ... ok; > > > Qobj diagonals ... ok; > > > Qobj eigenenergies ... ok; > > > Qobj eigenstates ... ok; > > > Qobj expm ... ok; > > > Qobj full ... ok; > > > Qobj ket type ... ok; > > > Qobj bra type ... ok; > > > Qobj operator type ... ok; > > > Qobj superoperator type ... ok; > > > Transform 2-level to eigenbasis and back ... ok; > > > Transform 10-level real-values to eigenbasis and back ... ok; > > > Transform 10-level to eigenbasis and back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Consistency between transformations of kets and denstity matrices ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.84e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:2757,Integrability,depend,dependent,2757,"tained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:3817,Integrability,depend,dependence,3817,"or (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:3880,Integrability,depend,dependence,3880,"R; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:15207,Integrability,depend,dependence,15207," > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_me",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:2175,Performance,Concurren,Concurrence,2175," back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Consistency between transformations of kets and denstity matrices ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.84e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H w",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:14427,Performance,load,loader,14427," > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:14452,Performance,load,loadTestsFromName,14452,"ing); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:2693,Safety,detect,detection,2693,"n(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. num",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:228,Testability,test,testing,228,"Hi,; I'm running qutip on the latest Ubuntu LTS version in 64 bit. All required packages (gfortran etc.) are installed from the repository. No matter if I use the qutip package from the repository or compile it from source, the testing results into 3 errors:. > > > import qutip.testing as qt; > > > qt.run(); > > > Qobj data ... ok; > > > Qobj type ... ok; > > > Qobj Hermicity ... ok; > > > Qobj shape ... ok; > > > Qobj addition ... ok; > > > Qobj subtraction ... ok; > > > Qobj multiplication ... ok; > > > Qobj division ... ok; > > > Qobj power ... ok; > > > Qobj negation ... ok; > > > Qobj equals ... ok; > > > Qobj getitem ... ok; > > > Qobj multiplication type ... ok; > > > Qobj conjugate ... ok; > > > Qobj adjoint (dagger) ... ok; > > > Qobj diagonals ... ok; > > > Qobj eigenenergies ... ok; > > > Qobj eigenstates ... ok; > > > Qobj expm ... ok; > > > Qobj full ... ok; > > > Qobj ket type ... ok; > > > Qobj bra type ... ok; > > > Qobj operator type ... ok; > > > Qobj superoperator type ... ok; > > > Transform 2-level to eigenbasis and back ... ok; > > > Transform 10-level real-values to eigenbasis and back ... ok; > > > Transform 10-level to eigenbasis and back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Consistency between transformations of kets and denstity matrices ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.84e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:279,Testability,test,testing,279,"Hi,; I'm running qutip on the latest Ubuntu LTS version in 64 bit. All required packages (gfortran etc.) are installed from the repository. No matter if I use the qutip package from the repository or compile it from source, the testing results into 3 errors:. > > > import qutip.testing as qt; > > > qt.run(); > > > Qobj data ... ok; > > > Qobj type ... ok; > > > Qobj Hermicity ... ok; > > > Qobj shape ... ok; > > > Qobj addition ... ok; > > > Qobj subtraction ... ok; > > > Qobj multiplication ... ok; > > > Qobj division ... ok; > > > Qobj power ... ok; > > > Qobj negation ... ok; > > > Qobj equals ... ok; > > > Qobj getitem ... ok; > > > Qobj multiplication type ... ok; > > > Qobj conjugate ... ok; > > > Qobj adjoint (dagger) ... ok; > > > Qobj diagonals ... ok; > > > Qobj eigenenergies ... ok; > > > Qobj eigenstates ... ok; > > > Qobj expm ... ok; > > > Qobj full ... ok; > > > Qobj ket type ... ok; > > > Qobj bra type ... ok; > > > Qobj operator type ... ok; > > > Qobj superoperator type ... ok; > > > Transform 2-level to eigenbasis and back ... ok; > > > Transform 10-level real-values to eigenbasis and back ... ok; > > > Transform 10-level to eigenbasis and back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Consistency between transformations of kets and denstity matrices ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.84e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:2726,Testability,test,test,2726,"tained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:4714,Testability,test,tests,4714,"n(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ok; > > > random density matrix ... ok; > > > random hermitian ... ok; > > > random ket ... ok; > > > Sparse eigs Hermitian ... ok; > > > Sparse eigs non-Hermitian ... ok; > > > Sparse eigvals only Hermitian. ... ok; > > > Dense eigs Hermitian. ... ok; > > > Dense eigs non-Hermitian ... ok; > > > Dense eigvals only Hermitian ... ok; > > > states: coherent density matrix ... ok; > > > states: Fock density matrix ... ok; > > > states: thermal density matrix ... ok; > > > Steady state: Thermal qubit ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:4865,Testability,Test,Test,4865,"e-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ok; > > > random density matrix ... ok; > > > random hermitian ... ok; > > > random ket ... ok; > > > Sparse eigs Hermitian ... ok; > > > Sparse eigs non-Hermitian ... ok; > > > Sparse eigvals only Hermitian. ... ok; > > > Dense eigs Hermitian. ... ok; > > > Dense eigs non-Hermitian ... ok; > > > Dense eigvals only Hermitian ... ok; > > > states: coherent density matrix ... ok; > > > states: Fock density matrix ... ok; > > > states: thermal density matrix ... ok; > > > Steady state: Thermal qubit ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 4.37e+12); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-pack",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:4916,Testability,Test,Test,4916,"ve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ok; > > > random density matrix ... ok; > > > random hermitian ... ok; > > > random ket ... ok; > > > Sparse eigs Hermitian ... ok; > > > Sparse eigs non-Hermitian ... ok; > > > Sparse eigvals only Hermitian. ... ok; > > > Dense eigs Hermitian. ... ok; > > > Dense eigs non-Hermitian ... ok; > > > Dense eigvals only Hermitian ... ok; > > > states: coherent density matrix ... ok; > > > states: Fock density matrix ... ok; > > > states: thermal density matrix ... ok; > > > Steady state: Thermal qubit ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 4.37e+12); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:4965,Testability,Test,Test,4965,"onstant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ok; > > > random density matrix ... ok; > > > random hermitian ... ok; > > > random ket ... ok; > > > Sparse eigs Hermitian ... ok; > > > Sparse eigs non-Hermitian ... ok; > > > Sparse eigvals only Hermitian. ... ok; > > > Dense eigs Hermitian. ... ok; > > > Dense eigs non-Hermitian ... ok; > > > Dense eigvals only Hermitian ... ok; > > > states: coherent density matrix ... ok; > > > states: Fock density matrix ... ok; > > > states: thermal density matrix ... ok; > > > Steady state: Thermal qubit ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 4.37e+12); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:5016,Testability,Test,Test,5016,"e: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ok; > > > random density matrix ... ok; > > > random hermitian ... ok; > > > random ket ... ok; > > > Sparse eigs Hermitian ... ok; > > > Sparse eigs non-Hermitian ... ok; > > > Sparse eigvals only Hermitian. ... ok; > > > Dense eigs Hermitian. ... ok; > > > Dense eigs non-Hermitian ... ok; > > > Dense eigvals only Hermitian ... ok; > > > states: coherent density matrix ... ok; > > > states: Fock density matrix ... ok; > > > states: thermal density matrix ... ok; > > > Steady state: Thermal qubit ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 4.37e+12); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.08e+13); > > > warnings.wa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:5067,Testability,Test,Test,5067,"mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ok; > > > random density matrix ... ok; > > > random hermitian ... ok; > > > random ket ... ok; > > > Sparse eigs Hermitian ... ok; > > > Sparse eigs non-Hermitian ... ok; > > > Sparse eigvals only Hermitian. ... ok; > > > Dense eigs Hermitian. ... ok; > > > Dense eigs non-Hermitian ... ok; > > > Dense eigvals only Hermitian ... ok; > > > states: coherent density matrix ... ok; > > > states: Fock density matrix ... ok; > > > states: thermal density matrix ... ok; > > > Steady state: Thermal qubit ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 4.37e+12); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.08e+13); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:13769,Testability,Test,Test,13769,"+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 6.76e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 7.81e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 8.35e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:13986,Testability,test,test,13986,"> warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 7.81e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 8.35e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py""",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:14061,Testability,test,test,14061,"ges/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 7.81e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 8.35e+14); > > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:14819,Testability,test,tests,14819,"n and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:15351,Testability,test,test,15351," (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options);",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:15419,Testability,test,tests,15419,"ages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.p",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:15456,Testability,test,testMESimpleTDDecayAsStrList,15456," addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File """,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:16036,Testability,test,test,16036,"ose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs1. ---. Ran 111 tests in 33.425s. FAILED (errors=3). I can reproduce this on 2 different systems (both 64 bit and 14.04).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:16104,Testability,test,tests,16104,"ose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs1. ---. Ran 111 tests in 33.425s. FAILED (errors=3). I can reproduce this on 2 different systems (both 64 bit and 14.04).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:16141,Testability,test,testMESimpleConstDecayAsStrList,16141,"ose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs1. ---. Ran 111 tests in 33.425s. FAILED (errors=3). I can reproduce this on 2 different systems (both 64 bit and 14.04).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:16566,Testability,test,tests,16566,"ose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 349, in testMESimpleConstDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs1. ---. Ran 111 tests in 33.425s. FAILED (errors=3). I can reproduce this on 2 different systems (both 64 bit and 14.04).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:3805,Usability,simpl,simple,3805,"or (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:3868,Usability,simpl,simple,3868,"R; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:3932,Usability,simpl,simple,3932,"expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qub",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:4088,Usability,simpl,simple,4088,"ve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, n",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:4133,Usability,simpl,simple,4133,"or ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ERROR; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite system ... ok; > > > quantum process tomography for snot gate ... ok; > > > quantum process tomography for cnot gate ... ok; > > > Test mesolve qubit, with dissipation ... ok; > > > Test mesolve qubit, no dissipation ... ok; > > > Test essolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, with dissipation ... ok; > > > Test mcsolve qubit, no dissipation ... ok; > > > random Unitary ... ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/issues/126:15195,Usability,simpl,simple,15195," > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in testMESimpleTDDecayAsStrList; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() \* a], args=args); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 209, in mesolve; expt_ops, args, options); File ""/usr/local/lib/python2.7/dist-packages/qutip/mesolve.py"", line 525, in _mesolve_list_str_td; exec(code, globals()); File ""<string>"", line 1, in <module>; ImportError: No module named rhs0; # ; ## ERROR: mesolve: constant decay as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_me",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/126
https://github.com/qutip/qutip/pull/129:24,Availability,error,error,24,- occasional unit tests error due to tight tolerance; - warning when calling `choi_to_chi`,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/129
https://github.com/qutip/qutip/pull/129:43,Availability,toler,tolerance,43,- occasional unit tests error due to tight tolerance; - warning when calling `choi_to_chi`,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/129
https://github.com/qutip/qutip/pull/129:18,Testability,test,tests,18,- occasional unit tests error due to tight tolerance; - warning when calling `choi_to_chi`,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/129
https://github.com/qutip/qutip/pull/136:46,Usability,simpl,simplified,46,"Added CSIGN, SWAPalpha and Berkeley gates and simplified base case of other gates.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/136
https://github.com/qutip/qutip/pull/141:55,Deployability,patch,patches,55,"Hi,. Thanks a lot for this great package. Here are two patches I would like to suggest:; - support for numpy arrays as cython args to allow time dependence using arrays. I use this in the following way: H.append([op/1e9, '(0 if (t<0 or t>100) else ch0[round(t)])']), where ch0 is a numpy array containing the actual waveform. It will be in the args dictionary given to mesolve/sesolve. Tensor:; - Add back support for the following: tensor([1, Qobj(...)]), which makes life easier when constructing operators programmatically (and used to work in earlier versions). I'd be happy to hear what you think. Regards,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/141
https://github.com/qutip/qutip/pull/141:145,Integrability,depend,dependence,145,"Hi,. Thanks a lot for this great package. Here are two patches I would like to suggest:; - support for numpy arrays as cython args to allow time dependence using arrays. I use this in the following way: H.append([op/1e9, '(0 if (t<0 or t>100) else ch0[round(t)])']), where ch0 is a numpy array containing the actual waveform. It will be in the args dictionary given to mesolve/sesolve. Tensor:; - Add back support for the following: tensor([1, Qobj(...)]), which makes life easier when constructing operators programmatically (and used to work in earlier versions). I'd be happy to hear what you think. Regards,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/141
https://github.com/qutip/qutip/pull/143:99,Availability,error,error,99,- Made qutip.entropy.concurrence work for pure states in addition to density matrices.; - Improved error checks.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/143
https://github.com/qutip/qutip/pull/143:21,Performance,concurren,concurrence,21,- Made qutip.entropy.concurrence work for pure states in addition to density matrices.; - Improved error checks.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/143
https://github.com/qutip/qutip/pull/145:24,Availability,error,error,24,Work in progress. Fixed error in globalphase,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/145
https://github.com/qutip/qutip/pull/149:16,Availability,error,errors,16,Also fixed some errors in the docstring and indentation.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/149
https://github.com/qutip/qutip/pull/153:37,Usability,simpl,simplifications,37,This PR also includes fixes and code simplifications in qutip.cy.codegen.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/153
https://github.com/qutip/qutip/issues/159:33,Testability,benchmark,benchmark,33,"I think we should move the qutip/benchmark from qutip repo to its on repository, say qutip-benchmarks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/159
https://github.com/qutip/qutip/issues/159:91,Testability,benchmark,benchmarks,91,"I think we should move the qutip/benchmark from qutip repo to its on repository, say qutip-benchmarks.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/159
https://github.com/qutip/qutip/issues/160:118,Deployability,configurat,configuration,118,"The qutip/debian directory should also be moved out of the qutip main repository, but this would require changing the configuration in launchpad and could be a bit tricky.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/160
https://github.com/qutip/qutip/issues/160:118,Modifiability,config,configuration,118,"The qutip/debian directory should also be moved out of the qutip main repository, but this would require changing the configuration in launchpad and could be a bit tricky.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/160
https://github.com/qutip/qutip/pull/162:89,Integrability,depend,dependent,89,This is an extension of PR #141 which adds a simplified way of defining array based time-dependent hamiltonians and collapse operators.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/162
https://github.com/qutip/qutip/pull/162:45,Usability,simpl,simplified,45,This is an extension of PR #141 which adds a simplified way of defining array based time-dependent hamiltonians and collapse operators.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/162
https://github.com/qutip/qutip/issues/163:261,Security,access,access,261,"As it stands now, all of the steady state solvers treat the solution vector as a dense array. However, often times the steady state density matrix is sparse and therefore the current implementation is not optimal. As of SciPy 0.14, the sparse LU solver can now access the underlying L and U sparse matrices. Therefore, we should be able to do some kind of sparse forward and backward substitution to get the solution vector. In particular, since the RHS vector has only a single nonzero entry, the substitutions are greatly simplified,and we could also see a speed up.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/163
https://github.com/qutip/qutip/issues/163:524,Usability,simpl,simplified,524,"As it stands now, all of the steady state solvers treat the solution vector as a dense array. However, often times the steady state density matrix is sparse and therefore the current implementation is not optimal. As of SciPy 0.14, the sparse LU solver can now access the underlying L and U sparse matrices. Therefore, we should be able to do some kind of sparse forward and backward substitution to get the solution vector. In particular, since the RHS vector has only a single nonzero entry, the substitutions are greatly simplified,and we could also see a speed up.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/163
https://github.com/qutip/qutip/pull/166:26,Deployability,update,updated,26,"Added ARPACK eigensolver, updated power method to use RCM, start from; maximally mixed state, and not recalculate LU factors everytime solver; is called.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/166
https://github.com/qutip/qutip/pull/166:34,Energy Efficiency,power,power,34,"Added ARPACK eigensolver, updated power method to use RCM, start from; maximally mixed state, and not recalculate LU factors everytime solver; is called.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/166
https://github.com/qutip/qutip/pull/168:147,Modifiability,config,config,147,"Cleanup API of generic solver related support classes and functions (Odeoptions -> Options, Odedata -> SolverResult, odeconfig.odeconfig -> solver.config)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/168
https://github.com/qutip/qutip/pull/170:106,Testability,test,test,106,"sp_eigs now return a 2d ndarray instead of a list of 1d ndarray. Fix sqrtm accordingly, and adding a unit test for it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/170
https://github.com/qutip/qutip/pull/173:107,Testability,test,test,107,"For consideration. For backwards compatibility I think steady should be kept, and the old liouvillian unit test should also be kept in my opinion.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/173
https://github.com/qutip/qutip/pull/182:122,Testability,test,tests,122,Defaulting to using dense solver for small/dense problems and the sparse solver only for large and sparse problems. In my tests the dense solver is actually quite a bit faster up to pretty large system (several hundreds of quantum states at least).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/182
https://github.com/qutip/qutip/pull/184:186,Deployability,update,updated,186,"Changing keyword argument for Qobj.expm from bool to str, and adding support for using scpys sparse/dense expm function in addition to the existing qutip implementations. Default choice updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/184
https://github.com/qutip/qutip/pull/186:116,Deployability,update,update,116,"- Remove the README.txt for CPC from the repository: only needed for CPC submission, and no need to keep it here; - update meta info in debial/control",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/186
https://github.com/qutip/qutip/pull/191:14,Deployability,release,release,14,...C files in release dists,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/191
https://github.com/qutip/qutip/pull/194:6,Testability,test,test,6,Added test to verify,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/194
https://github.com/qutip/qutip/pull/196:35,Modifiability,config,config,35,in setup.py (could not find a good config that included the pyx files in the source distribion file produced by setup.py),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/196
https://github.com/qutip/qutip/issues/199:26,Availability,error,error,26,"I found a probably severe error in qutip 3.0.0 (worked fine in previous versions). When using mesolve, a function in ""rhs_generate.py"" (_td_wrap_array_str) checks if arguments exist. So far so good, however the if clause using. if args:; .... does not work when the argument is a numpy array, which raises the error:. ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). Is not hard to fix, but an annoying error. Keep up the good work!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/199
https://github.com/qutip/qutip/issues/199:310,Availability,error,error,310,"I found a probably severe error in qutip 3.0.0 (worked fine in previous versions). When using mesolve, a function in ""rhs_generate.py"" (_td_wrap_array_str) checks if arguments exist. So far so good, however the if clause using. if args:; .... does not work when the argument is a numpy array, which raises the error:. ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). Is not hard to fix, but an annoying error. Keep up the good work!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/199
https://github.com/qutip/qutip/issues/199:459,Availability,error,error,459,"I found a probably severe error in qutip 3.0.0 (worked fine in previous versions). When using mesolve, a function in ""rhs_generate.py"" (_td_wrap_array_str) checks if arguments exist. So far so good, however the if clause using. if args:; .... does not work when the argument is a numpy array, which raises the error:. ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(). Is not hard to fix, but an annoying error. Keep up the good work!!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/199
https://github.com/qutip/qutip/pull/202:32,Modifiability,variab,variable,32,- Bug in use of NUM_THREADS env variable; - Bug in storing collapse times and collapse operators in Result class,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/202
https://github.com/qutip/qutip/pull/206:54,Integrability,depend,dependence,54,Modified 4op 2t correlator for hamiltonians with time dependence; works with cython or function td format. Added relevant test functions.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/206
https://github.com/qutip/qutip/pull/206:122,Testability,test,test,122,Modified 4op 2t correlator for hamiltonians with time dependence; works with cython or function td format. Added relevant test functions.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/206
https://github.com/qutip/qutip/issues/207:425,Availability,robust,robust,425,"I built latest cython, which happens to be version 0.21a1. Running any qutip code throws a warning:; QuTiP warning: Cython setup failed: invalid literal for int() with base 10: '21a1'. This is due to _version2int() not properly parsing the version info in __init__.py. commenting it out, works (and qutip code runs). Is this on purpose (so say only certain, non-dev, versions are supported)? or should _version2int() be more robust? . .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/207
https://github.com/qutip/qutip/issues/213:479,Energy Efficiency,monitor,monitor,479,"In mcsolve_f90; `ptrace_sel` specifies which dimensions you want to keep after calculation, and it's a useful feature, but suppose you have a system containing 100 electrons, and what you need is to know evolution of density matrix of each electron. You cant keep the state of the whole system in memory as it will take too much memory. ; The problem is that with ptrace_sel you can get only one partially traced density matrix.(if we consider the system with electrons, you can monitor only one electron or several electrons); So it would be nice to have functionality which will allow to get many partially traced matrixes simultaneously.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/213
https://github.com/qutip/qutip/issues/215:515,Energy Efficiency,energy,energy,515,"I have not been using qutip for a long time yet, so I apologize in case I am missing something stupid. I'm solving a simple problem with t-dependent Hamiltonian. I have simplified up to the point where the solution should actually just be a constant occupation of ground and first excited state. Here is the setup:. ``` python; from qutip import *; from pylab import *. dim = 40 # number of harmonic oscillator states kept in decomposition; # -- always need to check convergence w.r.t. this. E_j = 20.0 # Josephson energy. a = destroy(dim) # definition of the annihilation operator via qutip. exponent = 1j * (a + a.dag()) # argument of the matrix exponential; exp_iphi = exponent.expm(); cos_phi = 0.5*(exp_iphi + exp_iphi.dag()). H_0 = a.dag() * a # Hamiltonian of LC harmonic oscillator; h_j = - cos_phi # Hamiltonian for the Josephson tunneling contribution; prefactor E_j(t) to be provided separately . energies, states = (H_0 + E_j * h_j).eigenstates() . jump_op_list = [] # no jump operators. # monitor projectors onto the ground and first excited eigenstates; projector0 = states[0] * states[0].dag(); projector1 = states[1] * states[1].dag(). monitor_ops = [projector0, projector1]. psi_0 = states[0] # initial state is the ground state . # tlist = np.linspace(0, Delta_t_min + Delta_t_max + 6*dt, 300) # evenly-spaced time values; tlist = np.linspace(0, 0.5, 300) # evenly-spaced time values; ```. The crucial piece comes now:. ``` python; timefunc_string1 = '20.0'; H1 = [H_0, [h_j, timefunc_string1]]; odesolution1 = mcsolve(H1, psi_0, tlist, jump_op_list, monitor_ops). # NOTE: ONLY ""DIFFERENCE"" W.R.T. PREVIOUS EXAMPLE IS ADDING ZERO!; timefunc_string2 = '0.0*20.0 + 20.0'; H2 = [H_0, [h_j, timefunc_string2]]; odesolution2 = mcsolve(H2, psi_0, tlist, jump_op_list, monitor_ops). plot(tlist, odesolution1.expect[0], tlist, odesolution1.expect[1], lw=2); legend(('Ground state','1st exc.')); ylabel('Occupation probability'); xlabel('Time'). show(). plot(tlist, odesolution2.expect[0], tl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/215
https://github.com/qutip/qutip/issues/215:1002,Energy Efficiency,monitor,monitor,1002," I apologize in case I am missing something stupid. I'm solving a simple problem with t-dependent Hamiltonian. I have simplified up to the point where the solution should actually just be a constant occupation of ground and first excited state. Here is the setup:. ``` python; from qutip import *; from pylab import *. dim = 40 # number of harmonic oscillator states kept in decomposition; # -- always need to check convergence w.r.t. this. E_j = 20.0 # Josephson energy. a = destroy(dim) # definition of the annihilation operator via qutip. exponent = 1j * (a + a.dag()) # argument of the matrix exponential; exp_iphi = exponent.expm(); cos_phi = 0.5*(exp_iphi + exp_iphi.dag()). H_0 = a.dag() * a # Hamiltonian of LC harmonic oscillator; h_j = - cos_phi # Hamiltonian for the Josephson tunneling contribution; prefactor E_j(t) to be provided separately . energies, states = (H_0 + E_j * h_j).eigenstates() . jump_op_list = [] # no jump operators. # monitor projectors onto the ground and first excited eigenstates; projector0 = states[0] * states[0].dag(); projector1 = states[1] * states[1].dag(). monitor_ops = [projector0, projector1]. psi_0 = states[0] # initial state is the ground state . # tlist = np.linspace(0, Delta_t_min + Delta_t_max + 6*dt, 300) # evenly-spaced time values; tlist = np.linspace(0, 0.5, 300) # evenly-spaced time values; ```. The crucial piece comes now:. ``` python; timefunc_string1 = '20.0'; H1 = [H_0, [h_j, timefunc_string1]]; odesolution1 = mcsolve(H1, psi_0, tlist, jump_op_list, monitor_ops). # NOTE: ONLY ""DIFFERENCE"" W.R.T. PREVIOUS EXAMPLE IS ADDING ZERO!; timefunc_string2 = '0.0*20.0 + 20.0'; H2 = [H_0, [h_j, timefunc_string2]]; odesolution2 = mcsolve(H2, psi_0, tlist, jump_op_list, monitor_ops). plot(tlist, odesolution1.expect[0], tlist, odesolution1.expect[1], lw=2); legend(('Ground state','1st exc.')); ylabel('Occupation probability'); xlabel('Time'). show(). plot(tlist, odesolution2.expect[0], tlist, odesolution2.expect[1], lw=2); legend(('Groun",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/215
https://github.com/qutip/qutip/issues/215:139,Integrability,depend,dependent,139,"I have not been using qutip for a long time yet, so I apologize in case I am missing something stupid. I'm solving a simple problem with t-dependent Hamiltonian. I have simplified up to the point where the solution should actually just be a constant occupation of ground and first excited state. Here is the setup:. ``` python; from qutip import *; from pylab import *. dim = 40 # number of harmonic oscillator states kept in decomposition; # -- always need to check convergence w.r.t. this. E_j = 20.0 # Josephson energy. a = destroy(dim) # definition of the annihilation operator via qutip. exponent = 1j * (a + a.dag()) # argument of the matrix exponential; exp_iphi = exponent.expm(); cos_phi = 0.5*(exp_iphi + exp_iphi.dag()). H_0 = a.dag() * a # Hamiltonian of LC harmonic oscillator; h_j = - cos_phi # Hamiltonian for the Josephson tunneling contribution; prefactor E_j(t) to be provided separately . energies, states = (H_0 + E_j * h_j).eigenstates() . jump_op_list = [] # no jump operators. # monitor projectors onto the ground and first excited eigenstates; projector0 = states[0] * states[0].dag(); projector1 = states[1] * states[1].dag(). monitor_ops = [projector0, projector1]. psi_0 = states[0] # initial state is the ground state . # tlist = np.linspace(0, Delta_t_min + Delta_t_max + 6*dt, 300) # evenly-spaced time values; tlist = np.linspace(0, 0.5, 300) # evenly-spaced time values; ```. The crucial piece comes now:. ``` python; timefunc_string1 = '20.0'; H1 = [H_0, [h_j, timefunc_string1]]; odesolution1 = mcsolve(H1, psi_0, tlist, jump_op_list, monitor_ops). # NOTE: ONLY ""DIFFERENCE"" W.R.T. PREVIOUS EXAMPLE IS ADDING ZERO!; timefunc_string2 = '0.0*20.0 + 20.0'; H2 = [H_0, [h_j, timefunc_string2]]; odesolution2 = mcsolve(H2, psi_0, tlist, jump_op_list, monitor_ops). plot(tlist, odesolution1.expect[0], tlist, odesolution1.expect[1], lw=2); legend(('Ground state','1st exc.')); ylabel('Occupation probability'); xlabel('Time'). show(). plot(tlist, odesolution2.expect[0], tl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/215
https://github.com/qutip/qutip/issues/215:2494,Integrability,depend,dependence,2494,"ator via qutip. exponent = 1j * (a + a.dag()) # argument of the matrix exponential; exp_iphi = exponent.expm(); cos_phi = 0.5*(exp_iphi + exp_iphi.dag()). H_0 = a.dag() * a # Hamiltonian of LC harmonic oscillator; h_j = - cos_phi # Hamiltonian for the Josephson tunneling contribution; prefactor E_j(t) to be provided separately . energies, states = (H_0 + E_j * h_j).eigenstates() . jump_op_list = [] # no jump operators. # monitor projectors onto the ground and first excited eigenstates; projector0 = states[0] * states[0].dag(); projector1 = states[1] * states[1].dag(). monitor_ops = [projector0, projector1]. psi_0 = states[0] # initial state is the ground state . # tlist = np.linspace(0, Delta_t_min + Delta_t_max + 6*dt, 300) # evenly-spaced time values; tlist = np.linspace(0, 0.5, 300) # evenly-spaced time values; ```. The crucial piece comes now:. ``` python; timefunc_string1 = '20.0'; H1 = [H_0, [h_j, timefunc_string1]]; odesolution1 = mcsolve(H1, psi_0, tlist, jump_op_list, monitor_ops). # NOTE: ONLY ""DIFFERENCE"" W.R.T. PREVIOUS EXAMPLE IS ADDING ZERO!; timefunc_string2 = '0.0*20.0 + 20.0'; H2 = [H_0, [h_j, timefunc_string2]]; odesolution2 = mcsolve(H2, psi_0, tlist, jump_op_list, monitor_ops). plot(tlist, odesolution1.expect[0], tlist, odesolution1.expect[1], lw=2); legend(('Ground state','1st exc.')); ylabel('Occupation probability'); xlabel('Time'). show(). plot(tlist, odesolution2.expect[0], tlist, odesolution2.expect[1], lw=2); legend(('Ground state','1st exc.')); ylabel('Occupation probability'); xlabel('Time'). show(); ```. I obtain two different results, the second one being wrong (and indicating that somehow 0.0*20.0 + 20.0 is not the same as 20.0). There's a separate issue that I have run into but that's mostly harmless: to get consistent results, it seems that I have to choose the opposite sign for the coefficient function in the function-based version of including time dependence as compared to the cython based version. Thanks in advance for any help.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/215
https://github.com/qutip/qutip/issues/215:117,Usability,simpl,simple,117,"I have not been using qutip for a long time yet, so I apologize in case I am missing something stupid. I'm solving a simple problem with t-dependent Hamiltonian. I have simplified up to the point where the solution should actually just be a constant occupation of ground and first excited state. Here is the setup:. ``` python; from qutip import *; from pylab import *. dim = 40 # number of harmonic oscillator states kept in decomposition; # -- always need to check convergence w.r.t. this. E_j = 20.0 # Josephson energy. a = destroy(dim) # definition of the annihilation operator via qutip. exponent = 1j * (a + a.dag()) # argument of the matrix exponential; exp_iphi = exponent.expm(); cos_phi = 0.5*(exp_iphi + exp_iphi.dag()). H_0 = a.dag() * a # Hamiltonian of LC harmonic oscillator; h_j = - cos_phi # Hamiltonian for the Josephson tunneling contribution; prefactor E_j(t) to be provided separately . energies, states = (H_0 + E_j * h_j).eigenstates() . jump_op_list = [] # no jump operators. # monitor projectors onto the ground and first excited eigenstates; projector0 = states[0] * states[0].dag(); projector1 = states[1] * states[1].dag(). monitor_ops = [projector0, projector1]. psi_0 = states[0] # initial state is the ground state . # tlist = np.linspace(0, Delta_t_min + Delta_t_max + 6*dt, 300) # evenly-spaced time values; tlist = np.linspace(0, 0.5, 300) # evenly-spaced time values; ```. The crucial piece comes now:. ``` python; timefunc_string1 = '20.0'; H1 = [H_0, [h_j, timefunc_string1]]; odesolution1 = mcsolve(H1, psi_0, tlist, jump_op_list, monitor_ops). # NOTE: ONLY ""DIFFERENCE"" W.R.T. PREVIOUS EXAMPLE IS ADDING ZERO!; timefunc_string2 = '0.0*20.0 + 20.0'; H2 = [H_0, [h_j, timefunc_string2]]; odesolution2 = mcsolve(H2, psi_0, tlist, jump_op_list, monitor_ops). plot(tlist, odesolution1.expect[0], tlist, odesolution1.expect[1], lw=2); legend(('Ground state','1st exc.')); ylabel('Occupation probability'); xlabel('Time'). show(). plot(tlist, odesolution2.expect[0], tl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/215
https://github.com/qutip/qutip/issues/215:169,Usability,simpl,simplified,169,"I have not been using qutip for a long time yet, so I apologize in case I am missing something stupid. I'm solving a simple problem with t-dependent Hamiltonian. I have simplified up to the point where the solution should actually just be a constant occupation of ground and first excited state. Here is the setup:. ``` python; from qutip import *; from pylab import *. dim = 40 # number of harmonic oscillator states kept in decomposition; # -- always need to check convergence w.r.t. this. E_j = 20.0 # Josephson energy. a = destroy(dim) # definition of the annihilation operator via qutip. exponent = 1j * (a + a.dag()) # argument of the matrix exponential; exp_iphi = exponent.expm(); cos_phi = 0.5*(exp_iphi + exp_iphi.dag()). H_0 = a.dag() * a # Hamiltonian of LC harmonic oscillator; h_j = - cos_phi # Hamiltonian for the Josephson tunneling contribution; prefactor E_j(t) to be provided separately . energies, states = (H_0 + E_j * h_j).eigenstates() . jump_op_list = [] # no jump operators. # monitor projectors onto the ground and first excited eigenstates; projector0 = states[0] * states[0].dag(); projector1 = states[1] * states[1].dag(). monitor_ops = [projector0, projector1]. psi_0 = states[0] # initial state is the ground state . # tlist = np.linspace(0, Delta_t_min + Delta_t_max + 6*dt, 300) # evenly-spaced time values; tlist = np.linspace(0, 0.5, 300) # evenly-spaced time values; ```. The crucial piece comes now:. ``` python; timefunc_string1 = '20.0'; H1 = [H_0, [h_j, timefunc_string1]]; odesolution1 = mcsolve(H1, psi_0, tlist, jump_op_list, monitor_ops). # NOTE: ONLY ""DIFFERENCE"" W.R.T. PREVIOUS EXAMPLE IS ADDING ZERO!; timefunc_string2 = '0.0*20.0 + 20.0'; H2 = [H_0, [h_j, timefunc_string2]]; odesolution2 = mcsolve(H2, psi_0, tlist, jump_op_list, monitor_ops). plot(tlist, odesolution1.expect[0], tlist, odesolution1.expect[1], lw=2); legend(('Ground state','1st exc.')); ylabel('Occupation probability'); xlabel('Time'). show(). plot(tlist, odesolution2.expect[0], tl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/215
https://github.com/qutip/qutip/pull/216:29,Integrability,depend,dependent,29,which demonstrates that time-dependent expressions with multiple terms are not properly handled (missing parentheses),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/216
https://github.com/qutip/qutip/pull/217:13,Availability,avail,available,13,they are now available in the qutip/qutip-benchmark repository,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/217
https://github.com/qutip/qutip/pull/217:42,Testability,benchmark,benchmark,42,they are now available in the qutip/qutip-benchmark repository,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/217
https://github.com/qutip/qutip/pull/221:312,Performance,perform,performed,312,- Restructure code to avoid multiple copies of code snippets.; - Optionally return dict with details on solution and solver details.; - Allow for building preconditioner separately so that different; iterative methods can be applied.; - Calculates inf-norm of residual at output.; - Returns number of iterations performed.; - Allow for inputing initial guess vector.; - Calculate a lower bound on the condition number of a preconditioner.; - Residual norm is given when iterative method fails to converge.; - Removed bicg method since it is not compatible.; - General docstring edits.; - Add tests for bicgstab method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/221
https://github.com/qutip/qutip/pull/221:22,Safety,avoid,avoid,22,- Restructure code to avoid multiple copies of code snippets.; - Optionally return dict with details on solution and solver details.; - Allow for building preconditioner separately so that different; iterative methods can be applied.; - Calculates inf-norm of residual at output.; - Returns number of iterations performed.; - Allow for inputing initial guess vector.; - Calculate a lower bound on the condition number of a preconditioner.; - Residual norm is given when iterative method fails to converge.; - Removed bicg method since it is not compatible.; - General docstring edits.; - Add tests for bicgstab method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/221
https://github.com/qutip/qutip/pull/221:592,Testability,test,tests,592,- Restructure code to avoid multiple copies of code snippets.; - Optionally return dict with details on solution and solver details.; - Allow for building preconditioner separately so that different; iterative methods can be applied.; - Calculates inf-norm of residual at output.; - Returns number of iterations performed.; - Allow for inputing initial guess vector.; - Calculate a lower bound on the condition number of a preconditioner.; - Residual norm is given when iterative method fails to converge.; - Removed bicg method since it is not compatible.; - General docstring edits.; - Add tests for bicgstab method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/221
https://github.com/qutip/qutip/issues/226:67,Usability,simpl,simplify,67,"I ran into this while working on a different project, but tried to simplify the bug in another simple [example](http://nbviewer.ipython.org/github/ComradeVVA/qutip/blob/master/time_dep_supers.ipynb). It compares some of the ways to input the same thing, with the last part (which uses list callback format) obtaining different results. Thanks to @krastanov for encouraging me to submit my first bug report.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/226
https://github.com/qutip/qutip/issues/226:95,Usability,simpl,simple,95,"I ran into this while working on a different project, but tried to simplify the bug in another simple [example](http://nbviewer.ipython.org/github/ComradeVVA/qutip/blob/master/time_dep_supers.ipynb). It compares some of the ways to input the same thing, with the last part (which uses list callback format) obtaining different results. Thanks to @krastanov for encouraging me to submit my first bug report.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/226
https://github.com/qutip/qutip/pull/235:200,Availability,failure,failures,200,"remove settings.qutip_graphics flag and conditional imports of matplotlib based on DISPLAY variable, to allow head-less generation of graphics. if matpotlib is unavailable, a warning is given, but no failures until a function that actually uses matplotlib is called",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/235
https://github.com/qutip/qutip/pull/235:91,Modifiability,variab,variable,91,"remove settings.qutip_graphics flag and conditional imports of matplotlib based on DISPLAY variable, to allow head-less generation of graphics. if matpotlib is unavailable, a warning is given, but no failures until a function that actually uses matplotlib is called",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/235
https://github.com/qutip/qutip/issues/236:57,Deployability,update,update,57,"I just pulled from https://github.com/qutip/qutip.git to update my qutip. The main setup.py (in the root directory of qutip) have the following lines:. ```; # all information about QuTiP goes here-------; MAJOR = 3; MINOR = 1; MICRO = 0; ISRELEASED = False; ```. However, qutip.about() returns. ```; In [19]: qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.0.0.dev-7eb81e7; Numpy Version: 1.7.1; Scipy Version: 0.12.0; Cython Version: 0.19; Matplotlib Version: 1.2.1; Fortran mcsolver: True; scikits.umfpack: False; Python Version: 2.7.4; Platform Info: Darwin (x86_64); Installation path: /Users/arnelg/git/qutip/qutip; ```. I thought the latest version on github was 3.0.1?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/236
https://github.com/qutip/qutip/issues/236:658,Deployability,Install,Installation,658,"I just pulled from https://github.com/qutip/qutip.git to update my qutip. The main setup.py (in the root directory of qutip) have the following lines:. ```; # all information about QuTiP goes here-------; MAJOR = 3; MINOR = 1; MICRO = 0; ISRELEASED = False; ```. However, qutip.about() returns. ```; In [19]: qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.0.0.dev-7eb81e7; Numpy Version: 1.7.1; Scipy Version: 0.12.0; Cython Version: 0.19; Matplotlib Version: 1.2.1; Fortran mcsolver: True; scikits.umfpack: False; Python Version: 2.7.4; Platform Info: Darwin (x86_64); Installation path: /Users/arnelg/git/qutip/qutip; ```. I thought the latest version on github was 3.0.1?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/236
https://github.com/qutip/qutip/issues/239:85,Availability,error,error,85,I am trying to use heterodyne simulation using built in milstein solver. It gives me error. . Looking at the code it seems that internally milstein solver is converting heterodyne problem into two homodyne problems. Which is fine. But not quite implemented correctly. Can you please update me on this? I will be willing to provide a patch.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/239
https://github.com/qutip/qutip/issues/239:283,Deployability,update,update,283,I am trying to use heterodyne simulation using built in milstein solver. It gives me error. . Looking at the code it seems that internally milstein solver is converting heterodyne problem into two homodyne problems. Which is fine. But not quite implemented correctly. Can you please update me on this? I will be willing to provide a patch.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/239
https://github.com/qutip/qutip/issues/239:333,Deployability,patch,patch,333,I am trying to use heterodyne simulation using built in milstein solver. It gives me error. . Looking at the code it seems that internally milstein solver is converting heterodyne problem into two homodyne problems. Which is fine. But not quite implemented correctly. Can you please update me on this? I will be willing to provide a patch.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/239
https://github.com/qutip/qutip/pull/241:36,Modifiability,extend,extends,36,"See #238 for more details, but this extends `_permute` and `super_tensor` to act correctly on `operator-ket` as well as `super, superrep=""super""`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/241
https://github.com/qutip/qutip/pull/243:12,Availability,error,error,12,"The current error handling for failure in ode integration, in mesolve/sesolve, is very bad. Now exceptions are raised when this occur, so that these errors can be caught more easily by users.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/243
https://github.com/qutip/qutip/pull/243:31,Availability,failure,failure,31,"The current error handling for failure in ode integration, in mesolve/sesolve, is very bad. Now exceptions are raised when this occur, so that these errors can be caught more easily by users.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/243
https://github.com/qutip/qutip/pull/243:149,Availability,error,errors,149,"The current error handling for failure in ode integration, in mesolve/sesolve, is very bad. Now exceptions are raised when this occur, so that these errors can be caught more easily by users.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/243
https://github.com/qutip/qutip/pull/243:46,Deployability,integrat,integration,46,"The current error handling for failure in ode integration, in mesolve/sesolve, is very bad. Now exceptions are raised when this occur, so that these errors can be caught more easily by users.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/243
https://github.com/qutip/qutip/pull/243:46,Integrability,integrat,integration,46,"The current error handling for failure in ode integration, in mesolve/sesolve, is very bad. Now exceptions are raised when this occur, so that these errors can be caught more easily by users.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/243
https://github.com/qutip/qutip/pull/246:572,Modifiability,config,configurable,572,"Main module control.ctrlpulseoptim provides functions for optimising control; pulses for quantum systems. Relies on the other classes for processing. Uses the BFGS (actually primarily the L-BFGS-B) algorthim, which is a quasi-second order Newton method for multivar function optimisation. Examples in the 'examples' folder to demonstrate usage.; 1. Hadamard - a simple example of Hadamard gate synthesis; 2. Lindbladian (open systems) - amplitude damping channel example; 3. Symplectic - a coupled oscillator example; 4. QFT - a 2 qubit example, showing alternative (more configurable) method for invoking the optimisation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/246
https://github.com/qutip/qutip/pull/246:362,Usability,simpl,simple,362,"Main module control.ctrlpulseoptim provides functions for optimising control; pulses for quantum systems. Relies on the other classes for processing. Uses the BFGS (actually primarily the L-BFGS-B) algorthim, which is a quasi-second order Newton method for multivar function optimisation. Examples in the 'examples' folder to demonstrate usage.; 1. Hadamard - a simple example of Hadamard gate synthesis; 2. Lindbladian (open systems) - amplitude damping channel example; 3. Symplectic - a coupled oscillator example; 4. QFT - a 2 qubit example, showing alternative (more configurable) method for invoking the optimisation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/246
https://github.com/qutip/qutip/pull/248:342,Availability,avail,available,342,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:353,Availability,Error,Errors,353,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:533,Integrability,depend,dependency,533,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:169,Modifiability,refactor,refactored,169,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:225,Modifiability,config,configobj,225,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:243,Modifiability,config,configobj,243,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:523,Modifiability,config,configobj,523,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:439,Security,access,accessed,439,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:47,Testability,log,logging,47,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:151,Testability,log,logging,151,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:420,Testability,log,logged,420,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/248:463,Testability,log,logging,463,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/248
https://github.com/qutip/qutip/pull/249:208,Deployability,Update,Updated,208,"- Moved functions that enhance matplotlib (colormaps, normalizations; etc.) to new module. Module is imported with try-except statement since; functions require matplotlib which may or may not be present.; - Updated wigner_cmap to allow for custom colors that can be defined in; any format acceptable to the Matplotib.colors.ColorConverter.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/249
https://github.com/qutip/qutip/pull/249:23,Modifiability,enhance,enhance,23,"- Moved functions that enhance matplotlib (colormaps, normalizations; etc.) to new module. Module is imported with try-except statement since; functions require matplotlib which may or may not be present.; - Updated wigner_cmap to allow for custom colors that can be defined in; any format acceptable to the Matplotib.colors.ColorConverter.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/249
https://github.com/qutip/qutip/pull/253:448,Deployability,rolling,rolling,448,"Status: Completed.; - New functions for parallelization: parallel_map in parfor module (using multiprocessing) and ipynbtools module (using IPython.parallel). These functions are designed to be as general as possible, and to support the qutip.ui.progressbar interface for displaying progress.; - They will be used to parallelize solvers in qutip.stochastic ; - Perhaps qutip.mcsolve could use this interface too, sometime in the future, instead of rolling its own parallelization using multiprocessing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/253
https://github.com/qutip/qutip/pull/253:258,Integrability,interface,interface,258,"Status: Completed.; - New functions for parallelization: parallel_map in parfor module (using multiprocessing) and ipynbtools module (using IPython.parallel). These functions are designed to be as general as possible, and to support the qutip.ui.progressbar interface for displaying progress.; - They will be used to parallelize solvers in qutip.stochastic ; - Perhaps qutip.mcsolve could use this interface too, sometime in the future, instead of rolling its own parallelization using multiprocessing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/253
https://github.com/qutip/qutip/pull/253:398,Integrability,interface,interface,398,"Status: Completed.; - New functions for parallelization: parallel_map in parfor module (using multiprocessing) and ipynbtools module (using IPython.parallel). These functions are designed to be as general as possible, and to support the qutip.ui.progressbar interface for displaying progress.; - They will be used to parallelize solvers in qutip.stochastic ; - Perhaps qutip.mcsolve could use this interface too, sometime in the future, instead of rolling its own parallelization using multiprocessing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/253
https://github.com/qutip/qutip/issues/254:13,Deployability,integrat,integration,13,"The coverall integration is nice, but could we configure it not to comment each and every travis build on every PR? I think is is rather noisy and generates a lot of email notifications... Perhaps the badge in the README file would be sufficient?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/254
https://github.com/qutip/qutip/issues/254:13,Integrability,integrat,integration,13,"The coverall integration is nice, but could we configure it not to comment each and every travis build on every PR? I think is is rather noisy and generates a lot of email notifications... Perhaps the badge in the README file would be sufficient?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/254
https://github.com/qutip/qutip/issues/254:47,Modifiability,config,configure,47,"The coverall integration is nice, but could we configure it not to comment each and every travis build on every PR? I think is is rather noisy and generates a lot of email notifications... Perhaps the badge in the README file would be sufficient?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/254
https://github.com/qutip/qutip/pull/255:323,Energy Efficiency,monitor,monitoring,323,"This pull request is very much a proof of concept for a weekend hack, but I thought it might be of interest at least for discussion. As such, the code is decidedly a mess still (notably, I've not yet tried to get it working under Python 3). At any rate, this PR adds a new subclass of `BaseProgressBar` that uploads status monitoring information to a small web app that I started, [tskmon](https://tskmon.herokuapp.com) (also a mess). A screenshot of this in use by one of the GRAPE notebooks can be found [here](http://imgur.com/6xBt4Ic). The idea for this functionality is to make it easier to remotely monitor long computations from a phone or tablet, without having to worry about SSHing to a server. If you find this interesting, let me know, and I can try to start cleaning some things up as a spare-time project. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/255
https://github.com/qutip/qutip/pull/255:605,Energy Efficiency,monitor,monitor,605,"This pull request is very much a proof of concept for a weekend hack, but I thought it might be of interest at least for discussion. As such, the code is decidedly a mess still (notably, I've not yet tried to get it working under Python 3). At any rate, this PR adds a new subclass of `BaseProgressBar` that uploads status monitoring information to a small web app that I started, [tskmon](https://tskmon.herokuapp.com) (also a mess). A screenshot of this in use by one of the GRAPE notebooks can be found [here](http://imgur.com/6xBt4Ic). The idea for this functionality is to make it easier to remotely monitor long computations from a phone or tablet, without having to worry about SSHing to a server. If you find this interesting, let me know, and I can try to start cleaning some things up as a spare-time project. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/255
https://github.com/qutip/qutip/pull/256:40,Modifiability,Enhance,EnhancedTextProgressBar,40,keep the new text based progress bar as EnhancedTextProgressBar. Related to #121,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/256
https://github.com/qutip/qutip/pull/256:24,Usability,progress bar,progress bar,24,keep the new text based progress bar as EnhancedTextProgressBar. Related to #121,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/256
https://github.com/qutip/qutip/issues/257:78,Testability,Test,Tested,78,The qip.hadamard_transform function does not return return expected output. . Tested with N=1 in Python 2.7 and factor is 0.5 rather than 1/sqrt(2). . The 2*_(-N / 2) would need to be something like 2_(-N / 2.0) to ensure float division,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/257
https://github.com/qutip/qutip/issues/260:129,Modifiability,variab,variable,129,"I think it would be nice to change the number of cpus to cpus_threads. I would image something like there would be a num_threads variable and then something like num_processes = num_threads_num_cpus, but that looks like it would require a lot of lines to be changed across many files?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/260
https://github.com/qutip/qutip/pull/261:53,Performance,load,loading,53,"- The debug setting is off by default so conditional loading of the; logging feature does not work. Here we load the logger by default, but; do not log anything unless the debug feature is set.; - Also got rid of the inspect stack as I do not see the point of that.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/261
https://github.com/qutip/qutip/pull/261:108,Performance,load,load,108,"- The debug setting is off by default so conditional loading of the; logging feature does not work. Here we load the logger by default, but; do not log anything unless the debug feature is set.; - Also got rid of the inspect stack as I do not see the point of that.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/261
https://github.com/qutip/qutip/pull/261:69,Testability,log,logging,69,"- The debug setting is off by default so conditional loading of the; logging feature does not work. Here we load the logger by default, but; do not log anything unless the debug feature is set.; - Also got rid of the inspect stack as I do not see the point of that.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/261
https://github.com/qutip/qutip/pull/261:117,Testability,log,logger,117,"- The debug setting is off by default so conditional loading of the; logging feature does not work. Here we load the logger by default, but; do not log anything unless the debug feature is set.; - Also got rid of the inspect stack as I do not see the point of that.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/261
https://github.com/qutip/qutip/pull/261:148,Testability,log,log,148,"- The debug setting is off by default so conditional loading of the; logging feature does not work. Here we load the logger by default, but; do not log anything unless the debug feature is set.; - Also got rid of the inspect stack as I do not see the point of that.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/261
https://github.com/qutip/qutip/pull/263:13,Performance,optimiz,optimize,13,- Attempt to optimize the mcsolve algorithms before an eventual move to cython.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/263
https://github.com/qutip/qutip/pull/264:252,Deployability,integrat,integrator,252,- Fixed num_cpus not properly set for multiprocessing.; - Fixed compiler args not recognized by clang.; - Avoid data copy in cy_expect_psi_csr.; - Add ability to reuse seeds [Options(seeds=xxx)].; - Clean up numpy imports.; - Fast reset of scipy zvode integrator and change stepping mode.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/264
https://github.com/qutip/qutip/pull/264:252,Integrability,integrat,integrator,252,- Fixed num_cpus not properly set for multiprocessing.; - Fixed compiler args not recognized by clang.; - Avoid data copy in cy_expect_psi_csr.; - Add ability to reuse seeds [Options(seeds=xxx)].; - Clean up numpy imports.; - Fast reset of scipy zvode integrator and change stepping mode.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/264
https://github.com/qutip/qutip/pull/264:106,Safety,Avoid,Avoid,106,- Fixed num_cpus not properly set for multiprocessing.; - Fixed compiler args not recognized by clang.; - Avoid data copy in cy_expect_psi_csr.; - Add ability to reuse seeds [Options(seeds=xxx)].; - Clean up numpy imports.; - Fast reset of scipy zvode integrator and change stepping mode.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/264
https://github.com/qutip/qutip/issues/265:35,Deployability,install,install,35,"I was recently helping a colleague install qutip on his macbook. We had a lot of trouble installing the requisites scipy and cython, with issues relating to their dependencies (gcc). We were following the instructions in INSTALL.txt and using Mac Ports version 2.3.2 on OSX Yosemite and Xcode 6.1. In the end we had to use 'brew' to install these packages. I know that this is not an issue with qutip, but rather scipy / cython. However, I am sure that we not like to put off mac users, so perhaps offering alternative INSTALL instructions to 'brew' rather than 'port' might help. . As a disclaimer, please note I have very limited experience on mac.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/265
https://github.com/qutip/qutip/issues/265:89,Deployability,install,installing,89,"I was recently helping a colleague install qutip on his macbook. We had a lot of trouble installing the requisites scipy and cython, with issues relating to their dependencies (gcc). We were following the instructions in INSTALL.txt and using Mac Ports version 2.3.2 on OSX Yosemite and Xcode 6.1. In the end we had to use 'brew' to install these packages. I know that this is not an issue with qutip, but rather scipy / cython. However, I am sure that we not like to put off mac users, so perhaps offering alternative INSTALL instructions to 'brew' rather than 'port' might help. . As a disclaimer, please note I have very limited experience on mac.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/265
https://github.com/qutip/qutip/issues/265:221,Deployability,INSTALL,INSTALL,221,"I was recently helping a colleague install qutip on his macbook. We had a lot of trouble installing the requisites scipy and cython, with issues relating to their dependencies (gcc). We were following the instructions in INSTALL.txt and using Mac Ports version 2.3.2 on OSX Yosemite and Xcode 6.1. In the end we had to use 'brew' to install these packages. I know that this is not an issue with qutip, but rather scipy / cython. However, I am sure that we not like to put off mac users, so perhaps offering alternative INSTALL instructions to 'brew' rather than 'port' might help. . As a disclaimer, please note I have very limited experience on mac.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/265
https://github.com/qutip/qutip/issues/265:333,Deployability,install,install,333,"I was recently helping a colleague install qutip on his macbook. We had a lot of trouble installing the requisites scipy and cython, with issues relating to their dependencies (gcc). We were following the instructions in INSTALL.txt and using Mac Ports version 2.3.2 on OSX Yosemite and Xcode 6.1. In the end we had to use 'brew' to install these packages. I know that this is not an issue with qutip, but rather scipy / cython. However, I am sure that we not like to put off mac users, so perhaps offering alternative INSTALL instructions to 'brew' rather than 'port' might help. . As a disclaimer, please note I have very limited experience on mac.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/265
https://github.com/qutip/qutip/issues/265:519,Deployability,INSTALL,INSTALL,519,"I was recently helping a colleague install qutip on his macbook. We had a lot of trouble installing the requisites scipy and cython, with issues relating to their dependencies (gcc). We were following the instructions in INSTALL.txt and using Mac Ports version 2.3.2 on OSX Yosemite and Xcode 6.1. In the end we had to use 'brew' to install these packages. I know that this is not an issue with qutip, but rather scipy / cython. However, I am sure that we not like to put off mac users, so perhaps offering alternative INSTALL instructions to 'brew' rather than 'port' might help. . As a disclaimer, please note I have very limited experience on mac.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/265
https://github.com/qutip/qutip/issues/265:163,Integrability,depend,dependencies,163,"I was recently helping a colleague install qutip on his macbook. We had a lot of trouble installing the requisites scipy and cython, with issues relating to their dependencies (gcc). We were following the instructions in INSTALL.txt and using Mac Ports version 2.3.2 on OSX Yosemite and Xcode 6.1. In the end we had to use 'brew' to install these packages. I know that this is not an issue with qutip, but rather scipy / cython. However, I am sure that we not like to put off mac users, so perhaps offering alternative INSTALL instructions to 'brew' rather than 'port' might help. . As a disclaimer, please note I have very limited experience on mac.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/265
https://github.com/qutip/qutip/pull/268:25,Integrability,contract,contraction,25,"This PR adds support for contraction along arbitrary dimensions of a qobj, whether those dimensions are state, operator or superoperator indices. The generalization is provided by a small number of utility functions for manipulation `dims` properties with few assumptions. Unfortunately, due to the limitations of `scipy.sparse`, this functionality is implemented on dense arrays, but for small matrices, it works suitably fast.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/268
https://github.com/qutip/qutip/issues/269:154,Availability,ERROR,ERROR,154,"``` bash; correlation: comparing TLS emission correlations (str-list td format) ... capi_return is NULL; Call-back cb_f_in_zvode__user__routines failed.; ERROR; ```. It seems that we are passing an extra arg to the td cython ode function, but this error does not occur when running the tests once, only twice in a row. ``` bash; Traceback (most recent call last):; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/tests/test_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Librar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:248,Availability,error,error,248,"``` bash; correlation: comparing TLS emission correlations (str-list td format) ... capi_return is NULL; Call-back cb_f_in_zvode__user__routines failed.; ERROR; ```. It seems that we are passing an extra arg to the td cython ode function, but this error does not occur when running the tests once, only twice in a row. ``` bash; Traceback (most recent call last):; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/tests/test_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Librar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:1773,Deployability,integrat,integrate,1773,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:1901,Deployability,integrat,integrate,1901,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:1934,Deployability,integrat,integrate,1934,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:2078,Deployability,integrat,integrate,2078,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:1773,Integrability,integrat,integrate,1773,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:1901,Integrability,integrat,integrate,1901,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:1934,Integrability,integrat,integrate,1934,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:2078,Integrability,integrat,integrate,2078,"_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 867, in run; args[5:])); File ""rhs4877011.pyx"", line 19, in rhs4877011.cy_td_ode_rhs (/Users/paul/.pyxbld/temp.macosx-10.10-x86_64-3.4/pyrex/rhs4877011.c:2080); def cy_td_ode_rhs(double t, np.ndarray[CTYPE_t, ndim=1] vec, np.ndarray[CTYPE_t, ndim=1] data0, np.ndarray[int, ndim=1] idx0, np.ndarray[int, ndim=1] ptr0, np.ndarray[CTYPE_t, ndim=1] data1, np.ndarray[int, ndim=1] idx1, np.ndarray[int, ndim=1] ptr1, np.float_t tp, np.int_t t_off):; TypeError: cy_td_ode_rhs() takes exactly 10 positional arguments (11 given); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:286,Testability,test,tests,286,"``` bash; correlation: comparing TLS emission correlations (str-list td format) ... capi_return is NULL; Call-back cb_f_in_zvode__user__routines failed.; ERROR; ```. It seems that we are passing an extra arg to the td cython ode function, but this error does not occur when running the tests once, only twice in a row. ``` bash; Traceback (most recent call last):; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/tests/test_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Librar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:501,Testability,test,test,501,"``` bash; correlation: comparing TLS emission correlations (str-list td format) ... capi_return is NULL; Call-back cb_f_in_zvode__user__routines failed.; ERROR; ```. It seems that we are passing an extra arg to the td cython ode function, but this error does not occur when running the tests once, only twice in a row. ``` bash; Traceback (most recent call last):; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/tests/test_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Librar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/issues/269:618,Testability,test,tests,618,"``` bash; correlation: comparing TLS emission correlations (str-list td format) ... capi_return is NULL; Call-back cb_f_in_zvode__user__routines failed.; ERROR; ```. It seems that we are passing an extra arg to the td cython ode function, but this error does not occur when running the tests once, only twice in a row. ``` bash; Traceback (most recent call last):; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/nose/case.py"", line 198, in runTest; self.test(*self.arg); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/tests/test_correlation.py"", line 278, in test_str_list_td_corr; sm.dag(), sm.dag() * sm, sm, args=args); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 392, in correlation_3op_2t; solver=solver, args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1086, in _correlation_2t; args=args, options=options); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/correlation.py"", line 1135, in _correlation_me_2t; ).expect[0]; File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 280, in mesolve; progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 618, in _mesolve_list_str_td; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/qutip/mesolve.py"", line 867, in _generic_ode_solve; r.integrate(r.t + dt[t_idx]); File ""/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages/scipy/integrate/_ode.py"", line 388, in integrate; self.f_params, self.jac_params); File ""/opt/local/Librar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/269
https://github.com/qutip/qutip/pull/275:51,Testability,test,test,51,- Fixed seeds inadvertently being reused.; - Added test to verify seeds not being reused.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/275
https://github.com/qutip/qutip/pull/276:104,Usability,simpl,simplified,104,"This is a proof of principle and work in progress, demonstrating that parallelization in mcsolve can be simplified significantly by using qutip.parallel.parallel_map.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/276
https://github.com/qutip/qutip/pull/279:69,Deployability,Install,Installs,69,- This is Py3 as to not avoid conflicts with the built in Python.; - Installs master branch of qutip.; - Shamelessly adapted from the SciPy Superpack.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/279
https://github.com/qutip/qutip/pull/279:117,Energy Efficiency,adapt,adapted,117,- This is Py3 as to not avoid conflicts with the built in Python.; - Installs master branch of qutip.; - Shamelessly adapted from the SciPy Superpack.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/279
https://github.com/qutip/qutip/pull/279:117,Modifiability,adapt,adapted,117,- This is Py3 as to not avoid conflicts with the built in Python.; - Installs master branch of qutip.; - Shamelessly adapted from the SciPy Superpack.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/279
https://github.com/qutip/qutip/pull/279:24,Safety,avoid,avoid,24,- This is Py3 as to not avoid conflicts with the built in Python.; - Installs master branch of qutip.; - Shamelessly adapted from the SciPy Superpack.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/279
https://github.com/qutip/qutip/pull/280:214,Deployability,Update,Updated,214,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/280:222,Deployability,install,installation,222,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/280:239,Deployability,release,release,239,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/280:9,Integrability,depend,dependence,9,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/280:49,Testability,test,test,49,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/280:62,Testability,test,test,62,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/280:147,Testability,test,tests,147,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/280:174,Testability,test,tests,174,- Remove dependence on networkx for graph_degree test.; - Add test to check list input for ntraj in mcsolver.; - Added fidelity and trace distance tests.; - Shorten names of tests that are longer than 80 chars.; - Updated installation and release notes.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/280
https://github.com/qutip/qutip/pull/281:202,Availability,error,error,202,This resolves issue where running subsequent optimisations with pulses; where the number of timeslots changes; Also updated the save_amps method to allow for excluding the time column; and handling any error saving the file,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/281
https://github.com/qutip/qutip/pull/281:116,Deployability,update,updated,116,This resolves issue where running subsequent optimisations with pulses; where the number of timeslots changes; Also updated the save_amps method to allow for excluding the time column; and handling any error saving the file,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/281
https://github.com/qutip/qutip/issues/283:404,Availability,error,errors,404,"The version of qutip in the macports repository is outdated (2.2.0), which is unfortunate especially since it is still included in the documentation as an ""official"" installation path (http://qutip.org/docs/3.0.1/installation.html#installation-on-mac-os-x-10-6). ; I saw that a patch to 3.0.1 was submitted to MacPorts a while ago (https://trac.macports.org/ticket/44555), but apparently there were some errors and then nothing further happened. It would be great if this could be updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/283
https://github.com/qutip/qutip/issues/283:166,Deployability,install,installation,166,"The version of qutip in the macports repository is outdated (2.2.0), which is unfortunate especially since it is still included in the documentation as an ""official"" installation path (http://qutip.org/docs/3.0.1/installation.html#installation-on-mac-os-x-10-6). ; I saw that a patch to 3.0.1 was submitted to MacPorts a while ago (https://trac.macports.org/ticket/44555), but apparently there were some errors and then nothing further happened. It would be great if this could be updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/283
https://github.com/qutip/qutip/issues/283:213,Deployability,install,installation,213,"The version of qutip in the macports repository is outdated (2.2.0), which is unfortunate especially since it is still included in the documentation as an ""official"" installation path (http://qutip.org/docs/3.0.1/installation.html#installation-on-mac-os-x-10-6). ; I saw that a patch to 3.0.1 was submitted to MacPorts a while ago (https://trac.macports.org/ticket/44555), but apparently there were some errors and then nothing further happened. It would be great if this could be updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/283
https://github.com/qutip/qutip/issues/283:231,Deployability,install,installation-on-mac-os-x-,231,"The version of qutip in the macports repository is outdated (2.2.0), which is unfortunate especially since it is still included in the documentation as an ""official"" installation path (http://qutip.org/docs/3.0.1/installation.html#installation-on-mac-os-x-10-6). ; I saw that a patch to 3.0.1 was submitted to MacPorts a while ago (https://trac.macports.org/ticket/44555), but apparently there were some errors and then nothing further happened. It would be great if this could be updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/283
https://github.com/qutip/qutip/issues/283:278,Deployability,patch,patch,278,"The version of qutip in the macports repository is outdated (2.2.0), which is unfortunate especially since it is still included in the documentation as an ""official"" installation path (http://qutip.org/docs/3.0.1/installation.html#installation-on-mac-os-x-10-6). ; I saw that a patch to 3.0.1 was submitted to MacPorts a while ago (https://trac.macports.org/ticket/44555), but apparently there were some errors and then nothing further happened. It would be great if this could be updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/283
https://github.com/qutip/qutip/issues/283:481,Deployability,update,updated,481,"The version of qutip in the macports repository is outdated (2.2.0), which is unfortunate especially since it is still included in the documentation as an ""official"" installation path (http://qutip.org/docs/3.0.1/installation.html#installation-on-mac-os-x-10-6). ; I saw that a patch to 3.0.1 was submitted to MacPorts a while ago (https://trac.macports.org/ticket/44555), but apparently there were some errors and then nothing further happened. It would be great if this could be updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/283
https://github.com/qutip/qutip/pull/284:0,Deployability,Install,Install,0,"Install qutip from pypi instead of github, which makes it always point to the most current release.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/284
https://github.com/qutip/qutip/pull/284:91,Deployability,release,release,91,"Install qutip from pypi instead of github, which makes it always point to the most current release.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/284
https://github.com/qutip/qutip/pull/288:42,Availability,avail,available,42,- use the serial_map function that is now available in qutip.parallel,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/288
https://github.com/qutip/qutip/pull/289:3,Energy Efficiency,reduce,reduce,3,to reduce load on travis system and shorten test times ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/289
https://github.com/qutip/qutip/pull/289:10,Performance,load,load,10,to reduce load on travis system and shorten test times ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/289
https://github.com/qutip/qutip/pull/289:44,Testability,test,test,44,to reduce load on travis system and shorten test times ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/289
https://github.com/qutip/qutip/issues/298:112,Deployability,install,installing,112,"For some reason the wheels for scipy has disappeared from the astropy server, so our travis setup fails because installing and building scipy from source takes too long time. Perhaps this will resolve itself at some point, or maybe we have to find an alternative source for a scipy wheel for linux to use on travis.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/298
https://github.com/qutip/qutip/pull/300:24,Testability,test,tests,24,Use anaconda for Travis tests,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/300
https://github.com/qutip/qutip/pull/301:0,Modifiability,Enhance,Enhance,0,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/301
https://github.com/qutip/qutip/pull/301:139,Modifiability,Enhance,Enhance,139,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/301
https://github.com/qutip/qutip/pull/301:221,Modifiability,Enhance,Enhance,221,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/301
https://github.com/qutip/qutip/pull/301:238,Modifiability,config,config,238,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/301
https://github.com/qutip/qutip/pull/301:337,Modifiability,config,config,337,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/301
https://github.com/qutip/qutip/pull/301:350,Modifiability,Enhance,Enhance,350,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/301
https://github.com/qutip/qutip/pull/301:58,Testability,test,test,58,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/301
https://github.com/qutip/qutip/issues/304:1661,Deployability,Install,Installation,1661,"Hey QiTiP community,; I wanted to make a simple bloch sphere animation, but can only get one image from the save() function.; Only the first .png image has a bloch sphere in it, the others are empty. ; ..............................................................; bloch_0.png; ![bloch_0](https://cloud.githubusercontent.com/assets/8253676/5883346/bca4bdf6-a351-11e4-8d04-9f1ba385a42c.png); ..............................................................; bloch_1.png; ![bloch_3](https://cloud.githubusercontent.com/assets/8253676/5883348/bca8d08a-a351-11e4-88b6-8c97800aedc3.png); ..............................................................; bloch_2.png; ![bloch_2](https://cloud.githubusercontent.com/assets/8253676/5883349/bca9d25a-a351-11e4-8b10-eacea1b7437f.png); ..............................................................; bloch_3.png; ![bloch_1](https://cloud.githubusercontent.com/assets/8253676/5883347/bca637ee-a351-11e4-8495-b5f12557ad6d.png); .............................................................. Here is my simple piece of code mainly coped from the tutorial. ```; import numpy as np; from qutip import *; from scipy import *. b = Bloch(). for i in range(30):; print i; b.add_vectors([np.sin(i),0,np.cos(i)]); b.save(dirc='temp'); ```. I would be glad if someone could help me. ```; >>> about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.1.0.dev-23e5259; Numpy Version: 1.8.2; Scipy Version: 0.14.0; Cython Version: 0.21.1; Matplotlib Version: 1.3.1; Fortran mcsolver: False; scikits.umfpack: False; Python Version: 2.7.8; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python2.7/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/304
https://github.com/qutip/qutip/issues/304:41,Usability,simpl,simple,41,"Hey QiTiP community,; I wanted to make a simple bloch sphere animation, but can only get one image from the save() function.; Only the first .png image has a bloch sphere in it, the others are empty. ; ..............................................................; bloch_0.png; ![bloch_0](https://cloud.githubusercontent.com/assets/8253676/5883346/bca4bdf6-a351-11e4-8d04-9f1ba385a42c.png); ..............................................................; bloch_1.png; ![bloch_3](https://cloud.githubusercontent.com/assets/8253676/5883348/bca8d08a-a351-11e4-88b6-8c97800aedc3.png); ..............................................................; bloch_2.png; ![bloch_2](https://cloud.githubusercontent.com/assets/8253676/5883349/bca9d25a-a351-11e4-8b10-eacea1b7437f.png); ..............................................................; bloch_3.png; ![bloch_1](https://cloud.githubusercontent.com/assets/8253676/5883347/bca637ee-a351-11e4-8495-b5f12557ad6d.png); .............................................................. Here is my simple piece of code mainly coped from the tutorial. ```; import numpy as np; from qutip import *; from scipy import *. b = Bloch(). for i in range(30):; print i; b.add_vectors([np.sin(i),0,np.cos(i)]); b.save(dirc='temp'); ```. I would be glad if someone could help me. ```; >>> about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.1.0.dev-23e5259; Numpy Version: 1.8.2; Scipy Version: 0.14.0; Cython Version: 0.21.1; Matplotlib Version: 1.3.1; Fortran mcsolver: False; scikits.umfpack: False; Python Version: 2.7.8; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python2.7/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/304
https://github.com/qutip/qutip/issues/304:1036,Usability,simpl,simple,1036,"Hey QiTiP community,; I wanted to make a simple bloch sphere animation, but can only get one image from the save() function.; Only the first .png image has a bloch sphere in it, the others are empty. ; ..............................................................; bloch_0.png; ![bloch_0](https://cloud.githubusercontent.com/assets/8253676/5883346/bca4bdf6-a351-11e4-8d04-9f1ba385a42c.png); ..............................................................; bloch_1.png; ![bloch_3](https://cloud.githubusercontent.com/assets/8253676/5883348/bca8d08a-a351-11e4-88b6-8c97800aedc3.png); ..............................................................; bloch_2.png; ![bloch_2](https://cloud.githubusercontent.com/assets/8253676/5883349/bca9d25a-a351-11e4-8b10-eacea1b7437f.png); ..............................................................; bloch_3.png; ![bloch_1](https://cloud.githubusercontent.com/assets/8253676/5883347/bca637ee-a351-11e4-8495-b5f12557ad6d.png); .............................................................. Here is my simple piece of code mainly coped from the tutorial. ```; import numpy as np; from qutip import *; from scipy import *. b = Bloch(). for i in range(30):; print i; b.add_vectors([np.sin(i),0,np.cos(i)]); b.save(dirc='temp'); ```. I would be glad if someone could help me. ```; >>> about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.1.0.dev-23e5259; Numpy Version: 1.8.2; Scipy Version: 0.14.0; Cython Version: 0.21.1; Matplotlib Version: 1.3.1; Fortran mcsolver: False; scikits.umfpack: False; Python Version: 2.7.8; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python2.7/dist-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/304
https://github.com/qutip/qutip/pull/306:34,Availability,error,errors,34,Attempt to solve issue with false errors in Qobj division tests on 32 bit system by using comparison that is more robust to floating-point errors.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/306
https://github.com/qutip/qutip/pull/306:114,Availability,robust,robust,114,Attempt to solve issue with false errors in Qobj division tests on 32 bit system by using comparison that is more robust to floating-point errors.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/306
https://github.com/qutip/qutip/pull/306:139,Availability,error,errors,139,Attempt to solve issue with false errors in Qobj division tests on 32 bit system by using comparison that is more robust to floating-point errors.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/306
https://github.com/qutip/qutip/pull/306:58,Testability,test,tests,58,Attempt to solve issue with false errors in Qobj division tests on 32 bit system by using comparison that is more robust to floating-point errors.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/306
https://github.com/qutip/qutip/pull/308:48,Performance,optimiz,optimizations,48,Simply setting compiler flags and add link-time optimizations.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/308
https://github.com/qutip/qutip/pull/308:0,Usability,Simpl,Simply,0,Simply setting compiler flags and add link-time optimizations.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/308
https://github.com/qutip/qutip/issues/309:1605,Availability,error,error,1605,"running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c qutip/cy/spmatfuncs.c -o build/temp.linux-armv7l-2.7/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -mfpmath=sse"" failed with exit status 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:1686,Availability,error,error,1686,"running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c qutip/cy/spmatfuncs.c -o build/temp.linux-armv7l-2.7/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -mfpmath=sse"" failed with exit status 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:1742,Availability,error,error,1742,"running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c qutip/cy/spmatfuncs.c -o build/temp.linux-armv7l-2.7/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -mfpmath=sse"" failed with exit status 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:137,Deployability,install,install,137,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:146,Deployability,Install,Installing,146,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:196,Deployability,install,install,196,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:258,Modifiability,config,config,258,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:362,Modifiability,config,config,362,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:801,Modifiability,config,config,801,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/309:938,Modifiability,config,config,938,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/309
https://github.com/qutip/qutip/issues/315:565,Modifiability,enhance,enhancement,565,"I think it would make sense to add to the current random quantum objects functionality support for sampling from a few more commonly-used distributions. In particular, the Ginibre and Haar distributions for density operators as well as the [Bruzda et al distribution for CPTP maps](http://www.sciencedirect.com/science/article/pii/S0375960108016885) would be quite nice to have sampling support for. I've written up all three of these based on existing QuTiP functions, such that if there's interest, it would be rather straightforward for me to make a PR for this enhancement.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/315
https://github.com/qutip/qutip/pull/316:192,Testability,test,tests,192,"This PR addresses #315 by providing sampling for Haar (unitary), Hilbert-Schmidt (DMs), Ginibre (DMs) and BCSZ (superoperators) distributions. Some more documentation is needed still, but the tests pass locally on Python 2.7 and 3.4.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/316
https://github.com/qutip/qutip/pull/317:56,Availability,error,error,56,Fix in load params where 'pulsegen' was 'optim'; Fix to error handing when creating output directory; FileExistsError is new in Python 3; Hence swapped to OSError using errno for Python 2 compatability,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/317
https://github.com/qutip/qutip/pull/317:7,Performance,load,load,7,Fix in load params where 'pulsegen' was 'optim'; Fix to error handing when creating output directory; FileExistsError is new in Python 3; Hence swapped to OSError using errno for Python 2 compatability,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/317
https://github.com/qutip/qutip/pull/318:271,Modifiability,variab,variable,271,"gcc 4.4 does not support the `-flto` option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6. In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to `setup.py` to enable or disable link time optimization. I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/318
https://github.com/qutip/qutip/pull/318:58,Performance,optimiz,optimization,58,"gcc 4.4 does not support the `-flto` option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6. In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to `setup.py` to enable or disable link time optimization. I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/318
https://github.com/qutip/qutip/pull/318:394,Performance,optimiz,optimization,394,"gcc 4.4 does not support the `-flto` option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6. In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to `setup.py` to enable or disable link time optimization. I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/318
https://github.com/qutip/qutip/pull/318:470,Testability,test,test,470,"gcc 4.4 does not support the `-flto` option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6. In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to `setup.py` to enable or disable link time optimization. I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/318
https://github.com/qutip/qutip/pull/318:606,Testability,test,tested,606,"gcc 4.4 does not support the `-flto` option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6. In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to `setup.py` to enable or disable link time optimization. I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/318
https://github.com/qutip/qutip/issues/319:184,Availability,error,error,184,Hi!; Assume that the system will reach a steady state.; Is there an efficient method to estimate the time it takes to reach the steady state (or to enter and remain within a specified error band)? ; My wish is that I do not have to calculate the steady state (using the steadystate function or others) to achieve that. Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/319
https://github.com/qutip/qutip/issues/319:68,Energy Efficiency,efficient,efficient,68,Hi!; Assume that the system will reach a steady state.; Is there an efficient method to estimate the time it takes to reach the steady state (or to enter and remain within a specified error band)? ; My wish is that I do not have to calculate the steady state (using the steadystate function or others) to achieve that. Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/319
https://github.com/qutip/qutip/pull/322:81,Availability,error,errors,81,"This seems to fix the issue reported by Vlad on the Google group. This fixes the errors when using complex cmath header and typedef variables. Variables must be of float, int, or complex, not np.kind_t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/322
https://github.com/qutip/qutip/pull/322:132,Modifiability,variab,variables,132,"This seems to fix the issue reported by Vlad on the Google group. This fixes the errors when using complex cmath header and typedef variables. Variables must be of float, int, or complex, not np.kind_t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/322
https://github.com/qutip/qutip/pull/322:143,Modifiability,Variab,Variables,143,"This seems to fix the issue reported by Vlad on the Google group. This fixes the errors when using complex cmath header and typedef variables. Variables must be of float, int, or complex, not np.kind_t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/322
https://github.com/qutip/qutip/pull/325:113,Availability,down,down,113,"hi,; i think there was a bug in the computation of gradients for unitary problems. im not sure if i tracked them down correctly, but the gradients seem to be more consistent now. this can be checked with the following code after initialization of an Optimizer object `optim`. ``` python; from scipy.optimize import check_grad; func = optim.fid_err_func_wrapper; grad = optim.fid_err_grad_wrapper; x0 = optim.dynamics.ctrl_amps.flatten(); check_grad(func, grad, x0); ```. also, im new to github and im not sure if im doing this correctly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/325
https://github.com/qutip/qutip/pull/325:250,Performance,Optimiz,Optimizer,250,"hi,; i think there was a bug in the computation of gradients for unitary problems. im not sure if i tracked them down correctly, but the gradients seem to be more consistent now. this can be checked with the following code after initialization of an Optimizer object `optim`. ``` python; from scipy.optimize import check_grad; func = optim.fid_err_func_wrapper; grad = optim.fid_err_grad_wrapper; x0 = optim.dynamics.ctrl_amps.flatten(); check_grad(func, grad, x0); ```. also, im new to github and im not sure if im doing this correctly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/325
https://github.com/qutip/qutip/pull/325:299,Performance,optimiz,optimize,299,"hi,; i think there was a bug in the computation of gradients for unitary problems. im not sure if i tracked them down correctly, but the gradients seem to be more consistent now. this can be checked with the following code after initialization of an Optimizer object `optim`. ``` python; from scipy.optimize import check_grad; func = optim.fid_err_func_wrapper; grad = optim.fid_err_grad_wrapper; x0 = optim.dynamics.ctrl_amps.flatten(); check_grad(func, grad, x0); ```. also, im new to github and im not sure if im doing this correctly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/325
https://github.com/qutip/qutip/pull/328:11,Energy Efficiency,power,power,11,- Separate power Liouvillian creation to its own function.; - build_preconditoner now works for power method when using; method=‘power’ kwarg.; - Fixed missing RCM time calculation in power method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/328
https://github.com/qutip/qutip/pull/328:96,Energy Efficiency,power,power,96,- Separate power Liouvillian creation to its own function.; - build_preconditoner now works for power method when using; method=‘power’ kwarg.; - Fixed missing RCM time calculation in power method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/328
https://github.com/qutip/qutip/pull/328:129,Energy Efficiency,power,power,129,- Separate power Liouvillian creation to its own function.; - build_preconditoner now works for power method when using; method=‘power’ kwarg.; - Fixed missing RCM time calculation in power method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/328
https://github.com/qutip/qutip/pull/328:184,Energy Efficiency,power,power,184,- Separate power Liouvillian creation to its own function.; - build_preconditoner now works for power method when using; method=‘power’ kwarg.; - Fixed missing RCM time calculation in power method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/328
https://github.com/qutip/qutip/pull/332:617,Testability,test,tested,617,"This feature starts work towards implementing diamond norms between quantum channels by providing Stinespring dilations of `type=""super""` Qobjs. This requires generalizing the current `to_kraus` feature, since the left and right Kraus operators are the same only for CP maps, whereas the arguments to diamond norms are very often not CP (in particular, will often be a difference, || \Lambda_1 - \Lambda_2 ||_\diamond). The pull request is currently in an incomplete state, so as to solicit feedback before solidifying the design. The docstrings are missing or are incomplete, Python 3 compatibility has not yet been tested, and I still need to make unit tests. Most importantly, the `dims` attribute of the input Qobj is not yet preserved, in lieu of solving #331.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/332
https://github.com/qutip/qutip/pull/332:655,Testability,test,tests,655,"This feature starts work towards implementing diamond norms between quantum channels by providing Stinespring dilations of `type=""super""` Qobjs. This requires generalizing the current `to_kraus` feature, since the left and right Kraus operators are the same only for CP maps, whereas the arguments to diamond norms are very often not CP (in particular, will often be a difference, || \Lambda_1 - \Lambda_2 ||_\diamond). The pull request is currently in an incomplete state, so as to solicit feedback before solidifying the design. The docstrings are missing or are incomplete, Python 3 compatibility has not yet been tested, and I still need to make unit tests. Most importantly, the `dims` attribute of the input Qobj is not yet preserved, in lieu of solving #331.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/332
https://github.com/qutip/qutip/pull/332:491,Usability,feedback,feedback,491,"This feature starts work towards implementing diamond norms between quantum channels by providing Stinespring dilations of `type=""super""` Qobjs. This requires generalizing the current `to_kraus` feature, since the left and right Kraus operators are the same only for CP maps, whereas the arguments to diamond norms are very often not CP (in particular, will often be a difference, || \Lambda_1 - \Lambda_2 ||_\diamond). The pull request is currently in an incomplete state, so as to solicit feedback before solidifying the design. The docstrings are missing or are incomplete, Python 3 compatibility has not yet been tested, and I still need to make unit tests. Most importantly, the `dims` attribute of the input Qobj is not yet preserved, in lieu of solving #331.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/332
https://github.com/qutip/qutip/pull/333:42,Testability,test,tests,42,This commit should fix #331 and add extra tests to prevent regression. The new tests are of the form encountered in #332.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/333
https://github.com/qutip/qutip/pull/333:79,Testability,test,tests,79,This commit should fix #331 and add extra tests to prevent regression. The new tests are of the form encountered in #332.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/333
https://github.com/qutip/qutip/pull/336:411,Integrability,interface,interface,411,"Mostly by replacing explicit loops with vectorized numpy expressions. For a simple test Hamiltonian with a single N-level bosonic operator, it is faster by a factor of ~40 for N=100 (Hamiltonian 100x100), i.e., it takes 12 seconds instead of 460 seconds. The speedup improves about linearly with N for this system. I checked for some test systems that the results are the same as before. The only difference in interface is that c_ops is [] by default, and c_ops=None is not accepted anymore. This seems to me more in line with the rest of qutip, but could be changed back trivially.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/336
https://github.com/qutip/qutip/pull/336:83,Testability,test,test,83,"Mostly by replacing explicit loops with vectorized numpy expressions. For a simple test Hamiltonian with a single N-level bosonic operator, it is faster by a factor of ~40 for N=100 (Hamiltonian 100x100), i.e., it takes 12 seconds instead of 460 seconds. The speedup improves about linearly with N for this system. I checked for some test systems that the results are the same as before. The only difference in interface is that c_ops is [] by default, and c_ops=None is not accepted anymore. This seems to me more in line with the rest of qutip, but could be changed back trivially.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/336
https://github.com/qutip/qutip/pull/336:334,Testability,test,test,334,"Mostly by replacing explicit loops with vectorized numpy expressions. For a simple test Hamiltonian with a single N-level bosonic operator, it is faster by a factor of ~40 for N=100 (Hamiltonian 100x100), i.e., it takes 12 seconds instead of 460 seconds. The speedup improves about linearly with N for this system. I checked for some test systems that the results are the same as before. The only difference in interface is that c_ops is [] by default, and c_ops=None is not accepted anymore. This seems to me more in line with the rest of qutip, but could be changed back trivially.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/336
https://github.com/qutip/qutip/pull/336:76,Usability,simpl,simple,76,"Mostly by replacing explicit loops with vectorized numpy expressions. For a simple test Hamiltonian with a single N-level bosonic operator, it is faster by a factor of ~40 for N=100 (Hamiltonian 100x100), i.e., it takes 12 seconds instead of 460 seconds. The speedup improves about linearly with N for this system. I checked for some test systems that the results are the same as before. The only difference in interface is that c_ops is [] by default, and c_ops=None is not accepted anymore. This seems to me more in line with the rest of qutip, but could be changed back trivially.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/336
https://github.com/qutip/qutip/pull/337:90,Testability,test,test,90,"In writing the documentation for #332, I noticed that the chi-matrix produced for several test channels was incorrect due to my placing the dagger in the wrong place. I apologize for that mistake--- this PR should fix it, and add unit tests that ensure that the chi matrix produced by to_chi agrees with that for some known Pauli channels and a unitary rotation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/337
https://github.com/qutip/qutip/pull/337:235,Testability,test,tests,235,"In writing the documentation for #332, I noticed that the chi-matrix produced for several test channels was incorrect due to my placing the dagger in the wrong place. I apologize for that mistake--- this PR should fix it, and add unit tests that ensure that the chi matrix produced by to_chi agrees with that for some known Pauli channels and a unitary rotation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/337
https://github.com/qutip/qutip/pull/338:534,Availability,error,error,534,"An additional algorithm has been added. The existing GRAPE algorithm remains the default; The CRAB algorithm was developed at the University of Ulm; The main difference is that it reduces the number of optimisation variables by defining the control pulses by expansions of basis functions, where the variables are the coefficients. Typically a Fourier series is chosen, i.e. the variables are the Fourier coefficients. Therefore it does not need to compute an explicit gradient. By default it uses the Nelder-Mead method for fidelity error minimisation. Further explanation is given in the comments. Significant changes were required to many of the classes in order to support another alg option in a tidy way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/338
https://github.com/qutip/qutip/pull/338:180,Energy Efficiency,reduce,reduces,180,"An additional algorithm has been added. The existing GRAPE algorithm remains the default; The CRAB algorithm was developed at the University of Ulm; The main difference is that it reduces the number of optimisation variables by defining the control pulses by expansions of basis functions, where the variables are the coefficients. Typically a Fourier series is chosen, i.e. the variables are the Fourier coefficients. Therefore it does not need to compute an explicit gradient. By default it uses the Nelder-Mead method for fidelity error minimisation. Further explanation is given in the comments. Significant changes were required to many of the classes in order to support another alg option in a tidy way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/338
https://github.com/qutip/qutip/pull/338:215,Modifiability,variab,variables,215,"An additional algorithm has been added. The existing GRAPE algorithm remains the default; The CRAB algorithm was developed at the University of Ulm; The main difference is that it reduces the number of optimisation variables by defining the control pulses by expansions of basis functions, where the variables are the coefficients. Typically a Fourier series is chosen, i.e. the variables are the Fourier coefficients. Therefore it does not need to compute an explicit gradient. By default it uses the Nelder-Mead method for fidelity error minimisation. Further explanation is given in the comments. Significant changes were required to many of the classes in order to support another alg option in a tidy way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/338
https://github.com/qutip/qutip/pull/338:300,Modifiability,variab,variables,300,"An additional algorithm has been added. The existing GRAPE algorithm remains the default; The CRAB algorithm was developed at the University of Ulm; The main difference is that it reduces the number of optimisation variables by defining the control pulses by expansions of basis functions, where the variables are the coefficients. Typically a Fourier series is chosen, i.e. the variables are the Fourier coefficients. Therefore it does not need to compute an explicit gradient. By default it uses the Nelder-Mead method for fidelity error minimisation. Further explanation is given in the comments. Significant changes were required to many of the classes in order to support another alg option in a tidy way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/338
https://github.com/qutip/qutip/pull/338:379,Modifiability,variab,variables,379,"An additional algorithm has been added. The existing GRAPE algorithm remains the default; The CRAB algorithm was developed at the University of Ulm; The main difference is that it reduces the number of optimisation variables by defining the control pulses by expansions of basis functions, where the variables are the coefficients. Typically a Fourier series is chosen, i.e. the variables are the Fourier coefficients. Therefore it does not need to compute an explicit gradient. By default it uses the Nelder-Mead method for fidelity error minimisation. Further explanation is given in the comments. Significant changes were required to many of the classes in order to support another alg option in a tidy way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/338
https://github.com/qutip/qutip/pull/339:42,Integrability,message,messages,42,A few very minor fixes; Details in commit messages,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/339
https://github.com/qutip/qutip/pull/342:35,Performance,Optimiz,Optimizer,35,"approx_grad attribute added to the Optimizer object that forces the; optimisation method to use the gradient approximation; (rather than any exact method). The motivation for this is to allow adding of custom fidelities that do not have an exact gradient formula.; As an aside: The CRAB algorithm already used these approximate gradient methods, and is most likely to be faster with these custom fidelities",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/342
https://github.com/qutip/qutip/issues/343:357,Availability,error,error,357,"Hi,. I'm having some trouble installing QuTiP onto my computer. I'm running Python 2.7 on Windows 7 and using Anaconda 2.10 64 bit and PyCharm 4.0.4.; I tried installing QuTiP in PyCharm by using file->settings->project interpreter and that successfully installed. However, when I go to the python console and type; from qutip import \* I get the following error message:. Backend Qt4Agg is interactive backend. Turning interactive mode on.; Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-2-674d9281af88>"", line 1, in <module>; from qutip import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""C:\Program Files (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:5007,Availability,down,downloading,5007,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:5153,Availability,error,error,5153,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:29,Deployability,install,installing,29,"Hi,. I'm having some trouble installing QuTiP onto my computer. I'm running Python 2.7 on Windows 7 and using Anaconda 2.10 64 bit and PyCharm 4.0.4.; I tried installing QuTiP in PyCharm by using file->settings->project interpreter and that successfully installed. However, when I go to the python console and type; from qutip import \* I get the following error message:. Backend Qt4Agg is interactive backend. Turning interactive mode on.; Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-2-674d9281af88>"", line 1, in <module>; from qutip import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""C:\Program Files (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:159,Deployability,install,installing,159,"Hi,. I'm having some trouble installing QuTiP onto my computer. I'm running Python 2.7 on Windows 7 and using Anaconda 2.10 64 bit and PyCharm 4.0.4.; I tried installing QuTiP in PyCharm by using file->settings->project interpreter and that successfully installed. However, when I go to the python console and type; from qutip import \* I get the following error message:. Backend Qt4Agg is interactive backend. Turning interactive mode on.; Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-2-674d9281af88>"", line 1, in <module>; from qutip import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""C:\Program Files (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:254,Deployability,install,installed,254,"Hi,. I'm having some trouble installing QuTiP onto my computer. I'm running Python 2.7 on Windows 7 and using Anaconda 2.10 64 bit and PyCharm 4.0.4.; I tried installing QuTiP in PyCharm by using file->settings->project interpreter and that successfully installed. However, when I go to the python console and type; from qutip import \* I get the following error message:. Backend Qt4Agg is interactive backend. Turning interactive mode on.; Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-2-674d9281af88>"", line 1, in <module>; from qutip import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""C:\Program Files (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:4271,Deployability,install,installed,4271,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:5116,Deployability,install,installing,5116,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:363,Integrability,message,message,363,"Hi,. I'm having some trouble installing QuTiP onto my computer. I'm running Python 2.7 on Windows 7 and using Anaconda 2.10 64 bit and PyCharm 4.0.4.; I tried installing QuTiP in PyCharm by using file->settings->project interpreter and that successfully installed. However, when I go to the python console and type; from qutip import \* I get the following error message:. Backend Qt4Agg is interactive backend. Turning interactive mode on.; Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-2-674d9281af88>"", line 1, in <module>; from qutip import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip\sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""C:\Program Files (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:3703,Integrability,depend,depends,3703,", in load_module; inplace=build_inplace, language_level=language_level); File ""C:\Users\daniel\Anaconda\lib\site-packages\pyximport\pyximport.py"", line 186, in build_module; reload_support=pyxargs.reload_support); File ""C:\Users\daniel\Anaconda\lib\site-packages\pyximport\pyxbuild.py"", line 98, in pyx_to_dll; dist.run_commands(); File ""C:\Users\daniel\Anaconda\lib\distutils\dist.py"", line 953, in run_commands; self.run_command(cmd); File ""C:\Users\daniel\Anaconda\lib\distutils\dist.py"", line 972, in run_command; cmd_obj.run(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:3715,Integrability,depend,depends,3715,"nguage_level); File ""C:\Users\daniel\Anaconda\lib\site-packages\pyximport\pyximport.py"", line 186, in build_module; reload_support=pyxargs.reload_support); File ""C:\Users\daniel\Anaconda\lib\site-packages\pyximport\pyxbuild.py"", line 98, in pyx_to_dll; dist.run_commands(); File ""C:\Users\daniel\Anaconda\lib\distutils\dist.py"", line 953, in run_commands; self.run_command(cmd); File ""C:\Users\daniel\Anaconda\lib\distutils\dist.py"", line 972, in run_command; cmd_obj.run(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_impor",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:5159,Integrability,message,messages,5159,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:4246,Testability,test,testing,4246,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:4314,Testability,test,testing,4314,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/343:4607,Testability,test,testing,4607,":\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 337, in run; self.build_extensions(); File ""C:\Users\daniel\Anaconda\lib\site-packages\Cython\Distutils\build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""C:\Users\daniel\Anaconda\lib\distutils\command\build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 473, in compile; self.initialize(); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 383, in initialize; vc_env = query_vcvarsall(VERSION, plat_spec); File ""C:\Users\daniel\Anaconda\lib\distutils\msvc9compiler.py"", line 271, in query_vcvarsall; raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); ImportError: Building module qutip.cy.spmatfuncs failed: ['DistutilsPlatformError: Unable to find vcvarsall.bat\n']. I tried testing to see if it was installed correctly by typing import qutip.testing as qt and I get. Traceback (most recent call last):; File ""C:\Users\daniel\Anaconda\lib\site-packages\IPython\core\interactiveshell.py"", line 2883, in run_code; exec(code_obj, self.user_global_ns, self.user_ns); File ""<ipython-input-3-ae6395ba7937>"", line 1, in <module>; import qutip.testing as qt; File ""C:\Program Files (x86)\JetBrains\PyCharm Community Edition 4.0.4\helpers\pydev\pydev_import_hook.py"", line 21, in do_import; module = self._system_import(name, _args, *_kwargs); File ""C:\Users\daniel\Anaconda\lib\site-packages\qutip__init__.py"", line 62, in <module>; qutip.settings.ipython = False; AttributeError: 'module' object has no attribute 'settings'. I have also tried downloading the file, putting it in the folder Anaconda\pkgs, opening a command window, setting the path and installing it there. I don't get any error messages but I still cannot seem to import QuTiP. What am I doing wrong?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/343
https://github.com/qutip/qutip/issues/348:177,Availability,error,error,177,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:215,Availability,error,error,215,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:473,Availability,error,error,473,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:555,Availability,error,error,555,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:666,Availability,error,error,666,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:748,Availability,error,error,748,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:859,Availability,error,error,859,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:941,Availability,error,error,941,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:4,Deployability,install,installation,4,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:331,Deployability,install,installed,331,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:3105,Integrability,depend,depends,3105,"import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 186, in build_module; reload_support=pyxargs.reload_support); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyxbuild.py"", line 100, in pyx_to_dll; dist.run_commands(); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py"", line 953, in run_commands; self.run_command(cmd); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py"", line 972, in run_command; cmd_obj.run(); File ""/usr/local/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; self.build_extensions(); File ""/usr/local/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; raise CompileError, msg; ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'clang' failed with exit status 1\n""]; Your system is ready to brew.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:3117,Integrability,depend,depends,3117,"import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 186, in build_module; reload_support=pyxargs.reload_support); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyxbuild.py"", line 100, in pyx_to_dll; dist.run_commands(); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py"", line 953, in run_commands; self.run_command(cmd); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py"", line 972, in run_command; cmd_obj.run(); File ""/usr/local/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; _build_ext.build_ext.run(self); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; self.build_extensions(); File ""/usr/local/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; self.build_extension(ext); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; depends=ext.depends); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); File ""/usr/local/Cellar/python/2.7.10/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; raise CompileError, msg; ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'clang' failed with exit status 1\n""]; Your system is ready to brew.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:127,Performance,load,load,127,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:76,Testability,test,tests,76,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:276,Testability,test,testing,276,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/348:373,Testability,test,tests,373,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/348
https://github.com/qutip/qutip/issues/353:251,Modifiability,variab,variable,251,"There appears to be a bug in OptimizerLBFGSB.run_optimization . At line 901, _build_bounds_list is called and correctly constructs the list of upper and lower bound tuples and sets self.bounds, however there is no return value. At line 939, the empty variable 'bounds' is passed to scipy.fmin_l_bfgs_b and therefore the constraints are not active. . Easy solution is to change ""bounds=bounds"" to ""bounds=self.bounds"" in line 939.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/353
https://github.com/qutip/qutip/issues/353:29,Performance,Optimiz,OptimizerLBFGSB,29,"There appears to be a bug in OptimizerLBFGSB.run_optimization . At line 901, _build_bounds_list is called and correctly constructs the list of upper and lower bound tuples and sets self.bounds, however there is no return value. At line 939, the empty variable 'bounds' is passed to scipy.fmin_l_bfgs_b and therefore the constraints are not active. . Easy solution is to change ""bounds=bounds"" to ""bounds=self.bounds"" in line 939.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/353
https://github.com/qutip/qutip/pull/357:398,Testability,benchmark,benchmarking,398,"This PR introduces a new metric, unitarity, based on [work with Wallman, Harper and Flammia](https://scirate.com/arxiv/1503.07865). In that work, we show that this metric is useful for discriminating between coherent and incoherence noise. As such, I hope that contributing an implementation of our new metric to QuTiP will be of use, especially for comparison to experimental data from randomized benchmarking. While it still needs some more documentation and test cases, I wanted to open the PR now to get some initial feedback.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/357
https://github.com/qutip/qutip/pull/357:461,Testability,test,test,461,"This PR introduces a new metric, unitarity, based on [work with Wallman, Harper and Flammia](https://scirate.com/arxiv/1503.07865). In that work, we show that this metric is useful for discriminating between coherent and incoherence noise. As such, I hope that contributing an implementation of our new metric to QuTiP will be of use, especially for comparison to experimental data from randomized benchmarking. While it still needs some more documentation and test cases, I wanted to open the PR now to get some initial feedback.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/357
https://github.com/qutip/qutip/pull/357:521,Usability,feedback,feedback,521,"This PR introduces a new metric, unitarity, based on [work with Wallman, Harper and Flammia](https://scirate.com/arxiv/1503.07865). In that work, we show that this metric is useful for discriminating between coherent and incoherence noise. As such, I hope that contributing an implementation of our new metric to QuTiP will be of use, especially for comparison to experimental data from randomized benchmarking. While it still needs some more documentation and test cases, I wanted to open the PR now to get some initial feedback.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/357
https://github.com/qutip/qutip/pull/358:201,Availability,error,error,201,"This PR introduces a new generator function, qubit_clifford_group, that yields each member of the single-qubit Clifford group as a Qobj. This functionality should be useful in contexts such as quantum error correction and randomized benchmarking.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/358
https://github.com/qutip/qutip/pull/358:233,Testability,benchmark,benchmarking,233,"This PR introduces a new generator function, qubit_clifford_group, that yields each member of the single-qubit Clifford group as a Qobj. This functionality should be useful in contexts such as quantum error correction and randomized benchmarking.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/358
https://github.com/qutip/qutip/pull/359:440,Testability,test,tests,440,"This PR changes `Qobj.__mul__` and `Qobj.__add__` to leave `isherm` lazily-evaluated (that is, `_isherm = None`) unless the Hermicity of the result is already known from closure under addition. This change was prompted by noticing that `isherm` alone took up over half of the runtime of a computation I was attempting, despite that nothing actually ever looked at the Hermicity of a product of two `Qobj` instances. I also added additional tests to ensure that `__mul__` doesn't result in incorrect values of `isherm`, something that was not previously covered by `qutip.tests.test_qobj.test_QobjHerm`. The new tests pass locally on Python 2.7 and 3.4 (Ubuntu 14.10) as well as on Windows with Python 2.7.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/359
https://github.com/qutip/qutip/pull/359:571,Testability,test,tests,571,"This PR changes `Qobj.__mul__` and `Qobj.__add__` to leave `isherm` lazily-evaluated (that is, `_isherm = None`) unless the Hermicity of the result is already known from closure under addition. This change was prompted by noticing that `isherm` alone took up over half of the runtime of a computation I was attempting, despite that nothing actually ever looked at the Hermicity of a product of two `Qobj` instances. I also added additional tests to ensure that `__mul__` doesn't result in incorrect values of `isherm`, something that was not previously covered by `qutip.tests.test_qobj.test_QobjHerm`. The new tests pass locally on Python 2.7 and 3.4 (Ubuntu 14.10) as well as on Windows with Python 2.7.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/359
https://github.com/qutip/qutip/pull/359:611,Testability,test,tests,611,"This PR changes `Qobj.__mul__` and `Qobj.__add__` to leave `isherm` lazily-evaluated (that is, `_isherm = None`) unless the Hermicity of the result is already known from closure under addition. This change was prompted by noticing that `isherm` alone took up over half of the runtime of a computation I was attempting, despite that nothing actually ever looked at the Hermicity of a product of two `Qobj` instances. I also added additional tests to ensure that `__mul__` doesn't result in incorrect values of `isherm`, something that was not previously covered by `qutip.tests.test_qobj.test_QobjHerm`. The new tests pass locally on Python 2.7 and 3.4 (Ubuntu 14.10) as well as on Windows with Python 2.7.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/359
https://github.com/qutip/qutip/pull/360:39,Availability,failure,failures,39,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:208,Availability,reliab,reliable,208,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:130,Deployability,configurat,configuration,130,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:185,Deployability,configurat,configuration,185,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:394,Deployability,upgrade,upgrade,394,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:452,Deployability,configurat,configuration,452,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:130,Modifiability,config,configuration,130,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:185,Modifiability,config,configuration,185,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/pull/360:452,Modifiability,config,configuration,452,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/360
https://github.com/qutip/qutip/issues/361:248,Integrability,rout,routine,248,"fidelity() returns >1 by a significant amount for certain pure states. States are normalised, and taking the inner product returns 1. Code below provides two examples of states which give fidelity >1 with themselves. ```; #to test qutip's fidelity routine; import qutip as qu. psi0=qu.Qobj(). i=0; while i<=1:; j=0; while j<=1:; psi0+=qu.state_number_qobj([2,2],[i,j]) #even superposition of qubit states; j+=1; i+=1. psi0=psi0.unit() #normalise. print(qu.fidelity(psi0,psi0)); print((psi0.dag()*psi0).norm()**2); print(""\n""). psi0=qu.tensor(psi0,qu.basis(10,1)) #tensor product with Fock state. print(qu.fidelity(psi0,psi0)); print((psi0.dag()*psi0).norm()**2). ```. Output:. ```; 1.00000002107; 1.0. 1.00000003485; 1.0; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/361
https://github.com/qutip/qutip/issues/361:226,Testability,test,test,226,"fidelity() returns >1 by a significant amount for certain pure states. States are normalised, and taking the inner product returns 1. Code below provides two examples of states which give fidelity >1 with themselves. ```; #to test qutip's fidelity routine; import qutip as qu. psi0=qu.Qobj(). i=0; while i<=1:; j=0; while j<=1:; psi0+=qu.state_number_qobj([2,2],[i,j]) #even superposition of qubit states; j+=1; i+=1. psi0=psi0.unit() #normalise. print(qu.fidelity(psi0,psi0)); print((psi0.dag()*psi0).norm()**2); print(""\n""). psi0=qu.tensor(psi0,qu.basis(10,1)) #tensor product with Fock state. print(qu.fidelity(psi0,psi0)); print((psi0.dag()*psi0).norm()**2). ```. Output:. ```; 1.00000002107; 1.0. 1.00000003485; 1.0; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/361
https://github.com/qutip/qutip/pull/362:137,Testability,test,tests,137,This new function doesn't calculate the explicit sqrtm() unless; absolutely necessary to improve numerical stability. Also includes new; tests to check for regressions of #361.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/362
https://github.com/qutip/qutip/issues/363:312,Modifiability,extend,extending,312,"Currently, the`identity` and `qeye` functions each take lists of dims as an alternative to an integer. For instance, `qeye([2, 3])` is equivalent to `tensor(qeye(2), qeye(3))`. While convenient, this is inconsistent with `zero_oper`, `basis`, `maximally_mixed_dm`, `projection` and `zero_ket`. Would it be worth extending the shorthand used by `identity` to these functions?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/363
https://github.com/qutip/qutip/issues/365:261,Availability,Error,Error,261,"I am running a IPython/Jupyter Notebook via [supervisor](http://supervisord.org/) which does not export the `$HOME` environment variable (this is of course easily fixable). When importing qutip, I get the following warning message:. ```; WARNING:qutip.settings:Error loading RC file.; Traceback (most recent call last):; File ""/home/mvd/miniconda3/lib/python3.4/site-packages/qutip/__init__.py"", line 138, in <module>; os.environ['HOME'], "".qutiprc""; File ""/home/mvd/miniconda3/lib/python3.4/os.py"", line 633, in __getitem__; raise KeyError(key) from None; KeyError: 'HOME'; ```. Since this is just a warning, does it mean that there are no problems, or will it have some effects?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/365
https://github.com/qutip/qutip/issues/365:223,Integrability,message,message,223,"I am running a IPython/Jupyter Notebook via [supervisor](http://supervisord.org/) which does not export the `$HOME` environment variable (this is of course easily fixable). When importing qutip, I get the following warning message:. ```; WARNING:qutip.settings:Error loading RC file.; Traceback (most recent call last):; File ""/home/mvd/miniconda3/lib/python3.4/site-packages/qutip/__init__.py"", line 138, in <module>; os.environ['HOME'], "".qutiprc""; File ""/home/mvd/miniconda3/lib/python3.4/os.py"", line 633, in __getitem__; raise KeyError(key) from None; KeyError: 'HOME'; ```. Since this is just a warning, does it mean that there are no problems, or will it have some effects?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/365
https://github.com/qutip/qutip/issues/365:128,Modifiability,variab,variable,128,"I am running a IPython/Jupyter Notebook via [supervisor](http://supervisord.org/) which does not export the `$HOME` environment variable (this is of course easily fixable). When importing qutip, I get the following warning message:. ```; WARNING:qutip.settings:Error loading RC file.; Traceback (most recent call last):; File ""/home/mvd/miniconda3/lib/python3.4/site-packages/qutip/__init__.py"", line 138, in <module>; os.environ['HOME'], "".qutiprc""; File ""/home/mvd/miniconda3/lib/python3.4/os.py"", line 633, in __getitem__; raise KeyError(key) from None; KeyError: 'HOME'; ```. Since this is just a warning, does it mean that there are no problems, or will it have some effects?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/365
https://github.com/qutip/qutip/issues/365:267,Performance,load,loading,267,"I am running a IPython/Jupyter Notebook via [supervisor](http://supervisord.org/) which does not export the `$HOME` environment variable (this is of course easily fixable). When importing qutip, I get the following warning message:. ```; WARNING:qutip.settings:Error loading RC file.; Traceback (most recent call last):; File ""/home/mvd/miniconda3/lib/python3.4/site-packages/qutip/__init__.py"", line 138, in <module>; os.environ['HOME'], "".qutiprc""; File ""/home/mvd/miniconda3/lib/python3.4/os.py"", line 633, in __getitem__; raise KeyError(key) from None; KeyError: 'HOME'; ```. Since this is just a warning, does it mean that there are no problems, or will it have some effects?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/365
https://github.com/qutip/qutip/issues/368:5,Testability,test,tests,5,Unit tests should be added for each of the main methods control.pulse_optim.; These should be based on the examples in qutip_notebooks; Gradient calcs should also be checked,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/368
https://github.com/qutip/qutip/issues/371:69,Energy Efficiency,monitor,monitor,69,"There are various options for 'test_output' files that can be set to monitor progress of an optimisation or to debug. These are currently output to files during the run. By default none of these files are produced. . It would be better to return an object tree, which could then saved to file if necessary. It should remain possible to output to file during the run, as in some cases this can be useful.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/371
https://github.com/qutip/qutip/pull/372:185,Performance,optimiz,optimizer,185,Use of iteritems removed in apply_params to make compatible with Python3; fixes #367 ; Also some changes to the way max_metric_corr and accuracy_factor method_params are applied in the optimizer,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/372
https://github.com/qutip/qutip/issues/374:82,Availability,error,errors,82,"The `Qobj.dag()` method does not preserve `superrep`, which can create surprising errors when attempting to work with adjoint channels (as [Watrous notes](https://cs.uwaterloo.ca/~watrous/TQI/), adjoint channels can be calculated from the Hermitian conjugates of superoperators). In particular, `to_choi(rand_super_bcsz().dag())` raises a `TypeError`:. ``` python; In [1]: from qutip import *. In [2]: to_choi(rand_super_bcsz().dag()); ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-2-63b1d2d94b5e> in <module>(); ----> 1 to_choi(rand_super_bcsz().dag()). C:\Anaconda\lib\site-packages\qutip-3.2.0.dev_adb91b0-py2.7-win-amd64.egg\qutip\superop_reps.pyc in to_choi(q_oper); 392 return chi_to_choi(q_oper); 393 else:; --> 394 raise TypeError(q_oper.superrep); 395 elif q_oper.type == 'oper':; 396 return super_to_choi(spre(q_oper) * spost(q_oper.dag())). TypeError: None; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/374
https://github.com/qutip/qutip/pull/376:50,Deployability,install,installations,50,removed import of setuptools as this breaks fresh installations (i.e; under macports) on some systems by not registering the qutip module; properly. Added it just to try wheels builds so not important,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/376
https://github.com/qutip/qutip/issues/377:85,Deployability,install,installing,85,A number of posts have appeared recently on the Google group reporting problems with installing QuTiP on MS Windows 8 or 10 64 bit editions. I have also experienced problems when trying to install on a colleagues laptop. Mainly these seem to be compilation related issues. Is there anything we can do to the code or the instructions to help avoid these issues?. Is there any value in creating an Anaconda install package?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/377
https://github.com/qutip/qutip/issues/377:189,Deployability,install,install,189,A number of posts have appeared recently on the Google group reporting problems with installing QuTiP on MS Windows 8 or 10 64 bit editions. I have also experienced problems when trying to install on a colleagues laptop. Mainly these seem to be compilation related issues. Is there anything we can do to the code or the instructions to help avoid these issues?. Is there any value in creating an Anaconda install package?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/377
https://github.com/qutip/qutip/issues/377:405,Deployability,install,install,405,A number of posts have appeared recently on the Google group reporting problems with installing QuTiP on MS Windows 8 or 10 64 bit editions. I have also experienced problems when trying to install on a colleagues laptop. Mainly these seem to be compilation related issues. Is there anything we can do to the code or the instructions to help avoid these issues?. Is there any value in creating an Anaconda install package?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/377
https://github.com/qutip/qutip/issues/377:341,Safety,avoid,avoid,341,A number of posts have appeared recently on the Google group reporting problems with installing QuTiP on MS Windows 8 or 10 64 bit editions. I have also experienced problems when trying to install on a colleagues laptop. Mainly these seem to be compilation related issues. Is there anything we can do to the code or the instructions to help avoid these issues?. Is there any value in creating an Anaconda install package?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/377
https://github.com/qutip/qutip/issues/378:138,Availability,avail,available,138,The six library is used for Python 2.x and 3.x compatibility tricks. It failed to import during Travis tests. Should we make this library available in Travis tests?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/378
https://github.com/qutip/qutip/issues/378:103,Testability,test,tests,103,The six library is used for Python 2.x and 3.x compatibility tricks. It failed to import during Travis tests. Should we make this library available in Travis tests?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/378
https://github.com/qutip/qutip/issues/378:158,Testability,test,tests,158,The six library is used for Python 2.x and 3.x compatibility tricks. It failed to import during Travis tests. Should we make this library available in Travis tests?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/378
https://github.com/qutip/qutip/pull/379:288,Safety,avoid,avoid,288,"This should at least partially address #377, as it seems that `from __future__ import absolute_import` isn't causing the built-in `logging` to appear in preference to `qutip.logging` on Windows 8. Given the hassles of calling both `logging`, the idea behind this PR is to just rename and avoid conflicts that way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/379
https://github.com/qutip/qutip/pull/379:131,Testability,log,logging,131,"This should at least partially address #377, as it seems that `from __future__ import absolute_import` isn't causing the built-in `logging` to appear in preference to `qutip.logging` on Windows 8. Given the hassles of calling both `logging`, the idea behind this PR is to just rename and avoid conflicts that way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/379
https://github.com/qutip/qutip/pull/379:174,Testability,log,logging,174,"This should at least partially address #377, as it seems that `from __future__ import absolute_import` isn't causing the built-in `logging` to appear in preference to `qutip.logging` on Windows 8. Given the hassles of calling both `logging`, the idea behind this PR is to just rename and avoid conflicts that way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/379
https://github.com/qutip/qutip/pull/379:232,Testability,log,logging,232,"This should at least partially address #377, as it seems that `from __future__ import absolute_import` isn't causing the built-in `logging` to appear in preference to `qutip.logging` on Windows 8. Given the hassles of calling both `logging`, the idea behind this PR is to just rename and avoid conflicts that way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/379
https://github.com/qutip/qutip/pull/380:143,Availability,error,error,143,corr_mat casting made explicit; A cast from object to complex that was acceptable in numpy 1.9; was failing in numpy 1.10; This was causing an error in #379 Travis tests,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/380
https://github.com/qutip/qutip/pull/380:164,Testability,test,tests,164,corr_mat casting made explicit; A cast from object to complex that was acceptable in numpy 1.9; was failing in numpy 1.10; This was causing an error in #379 Travis tests,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/380
https://github.com/qutip/qutip/issues/381:137,Deployability,release,release,137,"There are many deprecation warnings arising from the Travis tests. It would seem wise to resolve these before generating the next stable release, as it is likely to be long-lived.; Although there are lots of warnings, the sources might be few.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/381
https://github.com/qutip/qutip/issues/381:60,Testability,test,tests,60,"There are many deprecation warnings arising from the Travis tests. It would seem wise to resolve these before generating the next stable release, as it is likely to be long-lived.; Although there are lots of warnings, the sources might be few.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/381
https://github.com/qutip/qutip/issues/382:80,Availability,error,errors,80,"I just built and installed Qutip on the command line using Enthought python. No errors... Then when I run I get:. Enthought Canopy Python 2.7.9 | 64-bit | (default, May 20 2015, 20:01:56) ; [GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.6)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information. > > > from qutip import *; > > > Compiling with an SDK that doesn't seem to exist: /Developer/SDKs/MacOSX10.6.sdk; > > > Please check your Xcode installation; > > > In file included from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/syslimits.h:7:0,; > > > from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:34,; > > > from /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:19,; > > > from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:; > > > /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:168:61: error: no include path in which to search for limits.h; > > > In file included from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:0:; > > > /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:33:19: fatal error: stdio.h: No such file or directory; > > > compilation terminated.; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 213, in <module>; > > > from qutip.qobj import *; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; > > > from qutip.ptrace import _ptrace; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; > > > from qutip.sparse import sp_reshape; > > > File ""/Users/rjmag",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:1008,Availability,error,error,1008,"tip on the command line using Enthought python. No errors... Then when I run I get:. Enthought Canopy Python 2.7.9 | 64-bit | (default, May 20 2015, 20:01:56) ; [GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.6)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information. > > > from qutip import *; > > > Compiling with an SDK that doesn't seem to exist: /Developer/SDKs/MacOSX10.6.sdk; > > > Please check your Xcode installation; > > > In file included from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/syslimits.h:7:0,; > > > from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:34,; > > > from /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:19,; > > > from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:; > > > /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:168:61: error: no include path in which to search for limits.h; > > > In file included from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:0:; > > > /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:33:19: fatal error: stdio.h: No such file or directory; > > > compilation terminated.; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 213, in <module>; > > > from qutip.qobj import *; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; > > > from qutip.ptrace import _ptrace; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; > > > from qutip.sparse import sp_reshape; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:1309,Availability,error,error,1309,"cense"" for more information. > > > from qutip import *; > > > Compiling with an SDK that doesn't seem to exist: /Developer/SDKs/MacOSX10.6.sdk; > > > Please check your Xcode installation; > > > In file included from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/syslimits.h:7:0,; > > > from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:34,; > > > from /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:19,; > > > from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:; > > > /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:168:61: error: no include path in which to search for limits.h; > > > In file included from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:0:; > > > /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:33:19: fatal error: stdio.h: No such file or directory; > > > compilation terminated.; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 213, in <module>; > > > from qutip.qobj import *; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; > > > from qutip.ptrace import _ptrace; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; > > > from qutip.sparse import sp_reshape; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; > > > from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:5201,Availability,error,error,5201,"/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/dist.py"", line 972, in run_command; > > > cmd_obj.run(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; > > > _build_ext.build_ext.run(self); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; > > > self.build_extensions(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; > > > self.build_extension(ext); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; > > > depends=ext.depends); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; > > > self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; > > > raise CompileError, msg; > > > ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'gcc' failed with exit status 1\n""]; > > > import numpy as np; > > > ; > > > from qutip import *; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 62, in <module>; > > > qutip.settings.ipython = False; > > > AttributeError: 'module' object has no attribute 'settings'; ###### . This seems similar to the build error in Installation on OS X with Homebrew script error #348. Is this a bug in qutip ? Is there a way to fix this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:5252,Availability,error,error,5252,"/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/dist.py"", line 972, in run_command; > > > cmd_obj.run(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; > > > _build_ext.build_ext.run(self); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; > > > self.build_extensions(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; > > > self.build_extension(ext); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; > > > depends=ext.depends); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; > > > self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; > > > raise CompileError, msg; > > > ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'gcc' failed with exit status 1\n""]; > > > import numpy as np; > > > ; > > > from qutip import *; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 62, in <module>; > > > qutip.settings.ipython = False; > > > AttributeError: 'module' object has no attribute 'settings'; ###### . This seems similar to the build error in Installation on OS X with Homebrew script error #348. Is this a bug in qutip ? Is there a way to fix this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:17,Deployability,install,installed,17,"I just built and installed Qutip on the command line using Enthought python. No errors... Then when I run I get:. Enthought Canopy Python 2.7.9 | 64-bit | (default, May 20 2015, 20:01:56) ; [GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.6)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information. > > > from qutip import *; > > > Compiling with an SDK that doesn't seem to exist: /Developer/SDKs/MacOSX10.6.sdk; > > > Please check your Xcode installation; > > > In file included from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/syslimits.h:7:0,; > > > from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:34,; > > > from /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:19,; > > > from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:; > > > /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:168:61: error: no include path in which to search for limits.h; > > > In file included from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:0:; > > > /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:33:19: fatal error: stdio.h: No such file or directory; > > > compilation terminated.; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 213, in <module>; > > > from qutip.qobj import *; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; > > > from qutip.ptrace import _ptrace; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; > > > from qutip.sparse import sp_reshape; > > > File ""/Users/rjmag",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:482,Deployability,install,installation,482,"I just built and installed Qutip on the command line using Enthought python. No errors... Then when I run I get:. Enthought Canopy Python 2.7.9 | 64-bit | (default, May 20 2015, 20:01:56) ; [GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.6)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information. > > > from qutip import *; > > > Compiling with an SDK that doesn't seem to exist: /Developer/SDKs/MacOSX10.6.sdk; > > > Please check your Xcode installation; > > > In file included from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/syslimits.h:7:0,; > > > from /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:34,; > > > from /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:19,; > > > from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:; > > > /usr/local/lib/gcc/x86_64-apple-darwin14.4.0/5.1.0/include-fixed/limits.h:168:61: error: no include path in which to search for limits.h; > > > In file included from /Users/rjmagya/.pyxbld/temp.macosx-10.6-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:16:0:; > > > /Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/include/python2.7/Python.h:33:19: fatal error: stdio.h: No such file or directory; > > > compilation terminated.; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 213, in <module>; > > > from qutip.qobj import *; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; > > > from qutip.ptrace import _ptrace; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; > > > from qutip.sparse import sp_reshape; > > > File ""/Users/rjmag",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:5210,Deployability,Install,Installation,5210,"/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/dist.py"", line 972, in run_command; > > > cmd_obj.run(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; > > > _build_ext.build_ext.run(self); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; > > > self.build_extensions(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; > > > self.build_extension(ext); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; > > > depends=ext.depends); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; > > > self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; > > > raise CompileError, msg; > > > ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'gcc' failed with exit status 1\n""]; > > > import numpy as np; > > > ; > > > from qutip import *; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 62, in <module>; > > > qutip.settings.ipython = False; > > > AttributeError: 'module' object has no attribute 'settings'; ###### . This seems similar to the build error in Installation on OS X with Homebrew script error #348. Is this a bug in qutip ? Is there a way to fix this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:4208,Integrability,depend,depends,4208,"ontents/lib/python2.7/distutils/dist.py"", line 953, in run_commands; > > > self.run_command(cmd); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/dist.py"", line 972, in run_command; > > > cmd_obj.run(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; > > > _build_ext.build_ext.run(self); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; > > > self.build_extensions(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; > > > self.build_extension(ext); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; > > > depends=ext.depends); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; > > > self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; > > > raise CompileError, msg; > > > ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'gcc' failed with exit status 1\n""]; > > > import numpy as np; > > > ; > > > from qutip import *; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 62, in <module>; > > > qutip.settings.ipython = False; > > > AttributeError: 'module' object has no attribute 'settings'; ###### . This seems similar to the",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/issues/382:4220,Integrability,depend,depends,4220,"53, in run_commands; > > > self.run_command(cmd); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/dist.py"", line 972, in run_command; > > > cmd_obj.run(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; > > > _build_ext.build_ext.run(self); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; > > > self.build_extensions(); > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; > > > self.build_extension(ext); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; > > > depends=ext.depends); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; > > > self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); > > > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; > > > raise CompileError, msg; > > > ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'gcc' failed with exit status 1\n""]; > > > import numpy as np; > > > ; > > > from qutip import *; > > > Traceback (most recent call last):; > > > File ""<stdin>"", line 1, in <module>; > > > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/**init**.py"", line 62, in <module>; > > > qutip.settings.ipython = False; > > > AttributeError: 'module' object has no attribute 'settings'; ###### . This seems similar to the build error in Installation on OS X with Homebr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/382
https://github.com/qutip/qutip/pull/383:6,Testability,test,tests,6,Units tests added for the qutip.control modules; Tests based on the notebook examples; Some other small fixes applied to issues found during the testing.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/383
https://github.com/qutip/qutip/pull/383:49,Testability,Test,Tests,49,Units tests added for the qutip.control modules; Tests based on the notebook examples; Some other small fixes applied to issues found during the testing.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/383
https://github.com/qutip/qutip/pull/383:145,Testability,test,testing,145,Units tests added for the qutip.control modules; Tests based on the notebook examples; Some other small fixes applied to issues found during the testing.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/383
https://github.com/qutip/qutip/issues/384:3771,Deployability,integrat,integrator,3771,"initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, E0, tlist, e_ops, opt, progress_bar). def _rhs(t,y,data):; ym = y.reshape(data.shape); return (ym*data).ravel(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:3843,Deployability,integrat,integrate,3843,"initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, E0, tlist, e_ops, opt, progress_bar). def _rhs(t,y,data):; ym = y.reshape(data.shape); return (ym*data).ravel(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:3880,Deployability,integrat,integrate,3880,"initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, E0, tlist, e_ops, opt, progress_bar). def _rhs(t,y,data):; ym = y.reshape(data.shape); return (ym*data).ravel(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:2137,Integrability,depend,depending,2137,"uld be to generate these with a (costly) Lindblad equation in a large Hilbert space, and use the TTM to extrapolate to larger times. My code is not quite ready for a pull request yet (due to this issue amongst other things), but when it is I would also like to discuss the structure of such a package. I guess it is best to leave that to when I have a pull request ready though. For now I have a local modified version of the `_mesolve_const` function that allows a superoperator in place of `rho0`. The necessary modification is actually only to the function implementing the ""right hand side"" (RHS) of the differential equation, as this now needs to implement a matrix-matrix multiplication instead of a matrix-vector multiplication. For illustration purposes I will attach a code for a modified `_mesolve_const` below, that does the job, but the RHS is not implemented in cython. I think implementing this feature in qutip should be relatively straight forward, but possibly a bit tedious since it there are so many different dispatch functions from `mesolve` depending on the different types of time-dependence etc. One would also need cython implementations of the RHS functions for superoperator evolutions. Please let me know what you think about implementing this in qutip. Here is the code for a function that propagates the Lindblad equation with a superoperator as initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:2178,Integrability,depend,dependence,2178,"uld be to generate these with a (costly) Lindblad equation in a large Hilbert space, and use the TTM to extrapolate to larger times. My code is not quite ready for a pull request yet (due to this issue amongst other things), but when it is I would also like to discuss the structure of such a package. I guess it is best to leave that to when I have a pull request ready though. For now I have a local modified version of the `_mesolve_const` function that allows a superoperator in place of `rho0`. The necessary modification is actually only to the function implementing the ""right hand side"" (RHS) of the differential equation, as this now needs to implement a matrix-matrix multiplication instead of a matrix-vector multiplication. For illustration purposes I will attach a code for a modified `_mesolve_const` below, that does the job, but the RHS is not implemented in cython. I think implementing this feature in qutip should be relatively straight forward, but possibly a bit tedious since it there are so many different dispatch functions from `mesolve` depending on the different types of time-dependence etc. One would also need cython implementations of the RHS functions for superoperator evolutions. Please let me know what you think about implementing this in qutip. Here is the code for a function that propagates the Lindblad equation with a superoperator as initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:3771,Integrability,integrat,integrator,3771,"initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, E0, tlist, e_ops, opt, progress_bar). def _rhs(t,y,data):; ym = y.reshape(data.shape); return (ym*data).ravel(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:3843,Integrability,integrat,integrate,3843,"initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, E0, tlist, e_ops, opt, progress_bar). def _rhs(t,y,data):; ym = y.reshape(data.shape); return (ym*data).ravel(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:3880,Integrability,integrat,integrate,3880,"initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, E0, tlist, e_ops, opt, progress_bar). def _rhs(t,y,data):; ym = y.reshape(data.shape); return (ym*data).ravel(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/384:3045,Modifiability,Evolve,Evolve,3045,"t possibly a bit tedious since it there are so many different dispatch functions from `mesolve` depending on the different types of time-dependence etc. One would also need cython implementations of the RHS functions for superoperator evolutions. Please let me know what you think about implementing this in qutip. Here is the code for a function that propagates the Lindblad equation with a superoperator as initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/384
https://github.com/qutip/qutip/issues/385:116,Integrability,Contract,Contraction,116,"The usage of the `tensor_contract` function is explained in [QuTiP Example: Superoperators, Pauli Basis and Channel Contraction](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-superop-contract.ipynb). It is explained in terms of the graphical notation in http://arxiv.org/abs/1111.6950. However, there is no figure explaining how the ""tensor wires"" are numbered. In the notebook it says ""Numbering the tensor wires from 0 to 3, this corresponds to a tensor_contract argument of (1, 3)."" But it is not clear what the convention is... does the numbering follow in an anticlockwise fashion, starting with 0 at the top left?. A figure in the notebook showing the numbering convention would be extremely helpful.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/385
https://github.com/qutip/qutip/issues/385:223,Integrability,contract,contract,223,"The usage of the `tensor_contract` function is explained in [QuTiP Example: Superoperators, Pauli Basis and Channel Contraction](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-superop-contract.ipynb). It is explained in terms of the graphical notation in http://arxiv.org/abs/1111.6950. However, there is no figure explaining how the ""tensor wires"" are numbered. In the notebook it says ""Numbering the tensor wires from 0 to 3, this corresponds to a tensor_contract argument of (1, 3)."" But it is not clear what the convention is... does the numbering follow in an anticlockwise fashion, starting with 0 at the top left?. A figure in the notebook showing the numbering convention would be extremely helpful.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/385
https://github.com/qutip/qutip/issues/385:540,Usability,clear,clear,540,"The usage of the `tensor_contract` function is explained in [QuTiP Example: Superoperators, Pauli Basis and Channel Contraction](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-superop-contract.ipynb). It is explained in terms of the graphical notation in http://arxiv.org/abs/1111.6950. However, there is no figure explaining how the ""tensor wires"" are numbered. In the notebook it says ""Numbering the tensor wires from 0 to 3, this corresponds to a tensor_contract argument of (1, 3)."" But it is not clear what the convention is... does the numbering follow in an anticlockwise fashion, starting with 0 at the top left?. A figure in the notebook showing the numbering convention would be extremely helpful.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/385
https://github.com/qutip/qutip/issues/386:94,Integrability,contract,contract,94,"This one seems to be due to a quirk of NumPy's fancy indexing, but `tensor_contract` fails to contract out a pair `(i, j)` if `j == i + 1 and i > 0`. For example::. ``` python; In [1]: import numpy as np. In [2]: import qutip as qt. In [3]: dat = np.arange(2 * 3 * 3 * 4).reshape((2 * 3, 3 * 4)). In [4]: qobj = qt.Qobj(dat, dims=[[2, 3], [3, 4]]). In [5]: qt.tensor_contract(qobj, (1, 2)); ---------------------------------------------------------------------------; ValueError Traceback (most recent call last); <ipython-input-5-cfa6198a0fa3> in <module>(); ----> 1 qt.tensor_contract(qobj, (1, 2)). C:\Anaconda\lib\site-packages\qutip-3.2.0.dev_8af111f-py2.7-win-amd64.egg\qutip\; tensor.pyc in tensor_contract(qobj, *pairs); 421; 422 # Reshape back into a 2D matrix.; --> 423 qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)); 424; 425 # Return back as a qobj. ValueError: total size of new array must be unchanged; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/386
https://github.com/qutip/qutip/pull/387:285,Availability,robust,robust,285,"This PR fixes #386 by changing checking if `j == i + 1`, in which case NumPy doesn't automatically move fancy indices to the left. In particular, for adjacent indices, we should sum over index `i`, not over index `0` as was assumed before. To catch regressions, this PR also adds more robust unit tests that check more unusual tensor contractions. Thanks to @arnelg for pointing this out!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/387
https://github.com/qutip/qutip/pull/387:334,Integrability,contract,contractions,334,"This PR fixes #386 by changing checking if `j == i + 1`, in which case NumPy doesn't automatically move fancy indices to the left. In particular, for adjacent indices, we should sum over index `i`, not over index `0` as was assumed before. To catch regressions, this PR also adds more robust unit tests that check more unusual tensor contractions. Thanks to @arnelg for pointing this out!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/387
https://github.com/qutip/qutip/pull/387:297,Testability,test,tests,297,"This PR fixes #386 by changing checking if `j == i + 1`, in which case NumPy doesn't automatically move fancy indices to the left. In particular, for adjacent indices, we should sum over index `i`, not over index `0` as was assumed before. To catch regressions, this PR also adds more robust unit tests that check more unusual tensor contractions. Thanks to @arnelg for pointing this out!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/387
https://github.com/qutip/qutip/issues/388:521,Integrability,contract,contracts,521,"In writing documentation examples for #385 and fixing #386, I ran across a problem with the current implementation of `tensor_contract`. In particular, it assumes that the order of the tensor indices into `Qobj.data` is the same as the order in `Qobj.dims`, but this is true only for `Qobj` instances that do not act on vectorized operators. This problem occurs in two places: first, in the call to `reshape`, and second, in the arguments passed to `_tensor_contract_dense`. Notably, this issue does not affect code that contracts corresponding input/output pairs of rectangular superoperators, as is the case for the partial trace example, so I don't believe that the current examples are wrong. Rather, this will generate invalid results for less conventional examples of tensor contraction.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/388
https://github.com/qutip/qutip/issues/388:781,Integrability,contract,contraction,781,"In writing documentation examples for #385 and fixing #386, I ran across a problem with the current implementation of `tensor_contract`. In particular, it assumes that the order of the tensor indices into `Qobj.data` is the same as the order in `Qobj.dims`, but this is true only for `Qobj` instances that do not act on vectorized operators. This problem occurs in two places: first, in the call to `reshape`, and second, in the arguments passed to `_tensor_contract_dense`. Notably, this issue does not affect code that contracts corresponding input/output pairs of rectangular superoperators, as is the case for the partial trace example, so I don't believe that the current examples are wrong. Rather, this will generate invalid results for less conventional examples of tensor contraction.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/388
https://github.com/qutip/qutip/pull/389:64,Testability,log,logic,64,"This PR starts work on fixing #388 by splitting out much of the logic handling lists of dims into a new module, `dims_utils`, and providing a new function that converts between indices into `Qobj.dims` and tensor indices (as used by `np.reshape`). While this PR is not yet done, I wanted to make a PR for the fixes early to solicit feedback.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/389
https://github.com/qutip/qutip/pull/389:332,Usability,feedback,feedback,332,"This PR starts work on fixing #388 by splitting out much of the logic handling lists of dims into a new module, `dims_utils`, and providing a new function that converts between indices into `Qobj.dims` and tensor indices (as used by `np.reshape`). While this PR is not yet done, I wanted to make a PR for the fixes early to solicit feedback.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/389
https://github.com/qutip/qutip/pull/390:260,Energy Efficiency,power,powers,260,"The previous implementation of `choi_to_chi` and `chi_to_choi` required that `dims` be specified explicitly as qubits; for example, `[[[2, 2, 2], [2, 2, 2]], [[2, 2, 2], [2, 2, 2]]]` for a three-qubit system. This PR generalizes to allow for `dims` built from powers of 2 instead, as in `[[[8], [8]], [[8], [8]]]`. In addition, this PR adds new test cases to check that `to_choi` and `to_chi` properly roundtrip for multiqubit dimensions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/390
https://github.com/qutip/qutip/pull/390:345,Testability,test,test,345,"The previous implementation of `choi_to_chi` and `chi_to_choi` required that `dims` be specified explicitly as qubits; for example, `[[[2, 2, 2], [2, 2, 2]], [[2, 2, 2], [2, 2, 2]]]` for a three-qubit system. This PR generalizes to allow for `dims` built from powers of 2 instead, as in `[[[8], [8]], [[8], [8]]]`. In addition, this PR adds new test cases to check that `to_choi` and `to_chi` properly roundtrip for multiqubit dimensions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/390
https://github.com/qutip/qutip/issues/391:12,Deployability,install,installed,12,Hello!!!. I installed python using anaconda on my mac and then installed qutip. When I run the installation test I always get. Fortran mcsolver: False. How can I install the Fortran compiler needed. Thanks. Regards!!. Sebastian,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/391
https://github.com/qutip/qutip/issues/391:63,Deployability,install,installed,63,Hello!!!. I installed python using anaconda on my mac and then installed qutip. When I run the installation test I always get. Fortran mcsolver: False. How can I install the Fortran compiler needed. Thanks. Regards!!. Sebastian,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/391
https://github.com/qutip/qutip/issues/391:95,Deployability,install,installation,95,Hello!!!. I installed python using anaconda on my mac and then installed qutip. When I run the installation test I always get. Fortran mcsolver: False. How can I install the Fortran compiler needed. Thanks. Regards!!. Sebastian,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/391
https://github.com/qutip/qutip/issues/391:162,Deployability,install,install,162,Hello!!!. I installed python using anaconda on my mac and then installed qutip. When I run the installation test I always get. Fortran mcsolver: False. How can I install the Fortran compiler needed. Thanks. Regards!!. Sebastian,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/391
https://github.com/qutip/qutip/issues/391:108,Testability,test,test,108,Hello!!!. I installed python using anaconda on my mac and then installed qutip. When I run the installation test I always get. Fortran mcsolver: False. How can I install the Fortran compiler needed. Thanks. Regards!!. Sebastian,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/391
https://github.com/qutip/qutip/issues/392:162,Modifiability,config,config,162,"The latest numpy enables `extra_link_args` in your site.cfg. Hence the `setup.py` files should not set those values. For instance `qutip/fortran/setup.py`:. ```; config.add_extension('qutraj_run',; sources=sources,; extra_compile_args=extra_compile_args,; extra_link_args=extra_link_args,; libraries=libs,; **newblas; ); ```. should be. ```; config.add_extension('qutraj_run',; sources=sources,; libraries=libs,; **newblas; ); ```. as `newblas` can be given options through the `site.cfg`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/392
https://github.com/qutip/qutip/issues/392:342,Modifiability,config,config,342,"The latest numpy enables `extra_link_args` in your site.cfg. Hence the `setup.py` files should not set those values. For instance `qutip/fortran/setup.py`:. ```; config.add_extension('qutraj_run',; sources=sources,; extra_compile_args=extra_compile_args,; extra_link_args=extra_link_args,; libraries=libs,; **newblas; ); ```. should be. ```; config.add_extension('qutraj_run',; sources=sources,; libraries=libs,; **newblas; ); ```. as `newblas` can be given options through the `site.cfg`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/392
https://github.com/qutip/qutip/pull/393:5,Deployability,update,updated,5,Also updated the mac hardware_info func.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/393
https://github.com/qutip/qutip/pull/396:43,Deployability,patch,patches,43,"@ajgpitch,. Could you take a look at these patches, with this set I've tried to keep this backwards compatible. With this set, the helper function `create_pulse_optimizer` has been updated to accept the new drifts.; `optimize_pulse` currently creates an array of constant drift amplitudes, adding yet a another `PulseGen` parameter to an already excessive amount seemed counter productive. There are no examples in this patch, that's something I'll look at if wanted. Thanks; Ian",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/396
https://github.com/qutip/qutip/pull/396:181,Deployability,update,updated,181,"@ajgpitch,. Could you take a look at these patches, with this set I've tried to keep this backwards compatible. With this set, the helper function `create_pulse_optimizer` has been updated to accept the new drifts.; `optimize_pulse` currently creates an array of constant drift amplitudes, adding yet a another `PulseGen` parameter to an already excessive amount seemed counter productive. There are no examples in this patch, that's something I'll look at if wanted. Thanks; Ian",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/396
https://github.com/qutip/qutip/pull/396:420,Deployability,patch,patch,420,"@ajgpitch,. Could you take a look at these patches, with this set I've tried to keep this backwards compatible. With this set, the helper function `create_pulse_optimizer` has been updated to accept the new drifts.; `optimize_pulse` currently creates an array of constant drift amplitudes, adding yet a another `PulseGen` parameter to an already excessive amount seemed counter productive. There are no examples in this patch, that's something I'll look at if wanted. Thanks; Ian",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/396
https://github.com/qutip/qutip/pull/397:904,Energy Efficiency,efficient,efficient,904,"The internal data type for storing dynamics generators (Hamiltonians), propagators, and the time evolution can now be set as Qobj. When using Qobj the propagators are computed using qutip methods for expm. Resolves #370; The default for small systems remains ndarray, as this provides much faster execution (factor of 10 approx). However, it is assumed, but not yet tested, that for larger systems the Qobj propagation will be faster, and certainly less memory consumptive. The internal data type (if not specified) is chosen automatically using the same criteria Qobj.expm() uses to determine whether to use the (cython) sparse method.; The main motivation for implementing this change is for users developing their own custom fidelity and gradient measures which use the partial trace method. Consequently, preserving the dimensions is important. This has been shown (by colleagues testing) to be more efficient than recreating the Qobjs from ndarrays.; The internal operator processing methods and attributes have been renamed with underscores preceding to indicate that these will be of the internal operator data type. Accessors have been added that will always provide Qobj representations of the operators.; Theoretically any operator data type that supports the dot() method could be used, e.g. some other sparse matrix type, however this has not been extensively tested and should be considered an experimental feature.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/397
https://github.com/qutip/qutip/pull/397:1124,Security,Access,Accessors,1124,"The internal data type for storing dynamics generators (Hamiltonians), propagators, and the time evolution can now be set as Qobj. When using Qobj the propagators are computed using qutip methods for expm. Resolves #370; The default for small systems remains ndarray, as this provides much faster execution (factor of 10 approx). However, it is assumed, but not yet tested, that for larger systems the Qobj propagation will be faster, and certainly less memory consumptive. The internal data type (if not specified) is chosen automatically using the same criteria Qobj.expm() uses to determine whether to use the (cython) sparse method.; The main motivation for implementing this change is for users developing their own custom fidelity and gradient measures which use the partial trace method. Consequently, preserving the dimensions is important. This has been shown (by colleagues testing) to be more efficient than recreating the Qobjs from ndarrays.; The internal operator processing methods and attributes have been renamed with underscores preceding to indicate that these will be of the internal operator data type. Accessors have been added that will always provide Qobj representations of the operators.; Theoretically any operator data type that supports the dot() method could be used, e.g. some other sparse matrix type, however this has not been extensively tested and should be considered an experimental feature.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/397
https://github.com/qutip/qutip/pull/397:366,Testability,test,tested,366,"The internal data type for storing dynamics generators (Hamiltonians), propagators, and the time evolution can now be set as Qobj. When using Qobj the propagators are computed using qutip methods for expm. Resolves #370; The default for small systems remains ndarray, as this provides much faster execution (factor of 10 approx). However, it is assumed, but not yet tested, that for larger systems the Qobj propagation will be faster, and certainly less memory consumptive. The internal data type (if not specified) is chosen automatically using the same criteria Qobj.expm() uses to determine whether to use the (cython) sparse method.; The main motivation for implementing this change is for users developing their own custom fidelity and gradient measures which use the partial trace method. Consequently, preserving the dimensions is important. This has been shown (by colleagues testing) to be more efficient than recreating the Qobjs from ndarrays.; The internal operator processing methods and attributes have been renamed with underscores preceding to indicate that these will be of the internal operator data type. Accessors have been added that will always provide Qobj representations of the operators.; Theoretically any operator data type that supports the dot() method could be used, e.g. some other sparse matrix type, however this has not been extensively tested and should be considered an experimental feature.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/397
https://github.com/qutip/qutip/pull/397:884,Testability,test,testing,884,"The internal data type for storing dynamics generators (Hamiltonians), propagators, and the time evolution can now be set as Qobj. When using Qobj the propagators are computed using qutip methods for expm. Resolves #370; The default for small systems remains ndarray, as this provides much faster execution (factor of 10 approx). However, it is assumed, but not yet tested, that for larger systems the Qobj propagation will be faster, and certainly less memory consumptive. The internal data type (if not specified) is chosen automatically using the same criteria Qobj.expm() uses to determine whether to use the (cython) sparse method.; The main motivation for implementing this change is for users developing their own custom fidelity and gradient measures which use the partial trace method. Consequently, preserving the dimensions is important. This has been shown (by colleagues testing) to be more efficient than recreating the Qobjs from ndarrays.; The internal operator processing methods and attributes have been renamed with underscores preceding to indicate that these will be of the internal operator data type. Accessors have been added that will always provide Qobj representations of the operators.; Theoretically any operator data type that supports the dot() method could be used, e.g. some other sparse matrix type, however this has not been extensively tested and should be considered an experimental feature.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/397
https://github.com/qutip/qutip/pull/397:1372,Testability,test,tested,1372,"The internal data type for storing dynamics generators (Hamiltonians), propagators, and the time evolution can now be set as Qobj. When using Qobj the propagators are computed using qutip methods for expm. Resolves #370; The default for small systems remains ndarray, as this provides much faster execution (factor of 10 approx). However, it is assumed, but not yet tested, that for larger systems the Qobj propagation will be faster, and certainly less memory consumptive. The internal data type (if not specified) is chosen automatically using the same criteria Qobj.expm() uses to determine whether to use the (cython) sparse method.; The main motivation for implementing this change is for users developing their own custom fidelity and gradient measures which use the partial trace method. Consequently, preserving the dimensions is important. This has been shown (by colleagues testing) to be more efficient than recreating the Qobjs from ndarrays.; The internal operator processing methods and attributes have been renamed with underscores preceding to indicate that these will be of the internal operator data type. Accessors have been added that will always provide Qobj representations of the operators.; Theoretically any operator data type that supports the dot() method could be used, e.g. some other sparse matrix type, however this has not been extensively tested and should be considered an experimental feature.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/397
https://github.com/qutip/qutip/issues/400:97,Security,access,access,97,"Setting the phase option with fid_params does not seem to work. set_phase_option() does not have access to fid_params and when passed in None, sets the option by the fidcomp.phase_option field. However, that appears to be deprecated and requires hard coding in the FidComputer reset method.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/400
https://github.com/qutip/qutip/pull/403:103,Deployability,configurat,configuration,103,additional arguments added to load_parameters so that a general object attributes can be loaded from a configuration file. For a example a custom fidelity computer,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/403
https://github.com/qutip/qutip/pull/403:103,Modifiability,config,configuration,103,additional arguments added to load_parameters so that a general object attributes can be loaded from a configuration file. For a example a custom fidelity computer,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/403
https://github.com/qutip/qutip/pull/403:89,Performance,load,loaded,89,additional arguments added to load_parameters so that a general object attributes can be loaded from a configuration file. For a example a custom fidelity computer,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/403
https://github.com/qutip/qutip/pull/404:1694,Deployability,integrat,integrated,1694,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1712,Deployability,integrat,integration,1712,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1694,Integrability,integrat,integrated,1694,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1712,Integrability,integrat,integration,1712,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1423,Performance,perform,performance,1423," super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1522,Performance,perform,performance,1522,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:192,Testability,test,tests,192,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:211,Testability,test,tests,211,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:250,Testability,Test,TestMESolveSuperInit,250,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:283,Testability,test,tests,283,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:531,Testability,test,tests,531,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:582,Testability,test,tests,582,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:592,Testability,Test,TestMESolveTDDecay,592,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:706,Testability,test,tests,706,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:879,Testability,test,tests,879,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1598,Testability,test,test,1598,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1608,Testability,benchmark,benchmark,1608,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1779,Testability,benchmark,benchmark,1779,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:2280,Testability,test,test,2280,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:872,Usability,simpl,simple,872,"This branch adds support for `rho0` argument to `mesolve` being a superoperator, to resolve #384. The functionality has been added to all the different mesolvers (but not the sesolvers). Unit tests are added to tests/test_mesolve.py in a new class, `TestMESolveSuperInit`. There are tests for all the different mesolvers, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1329,Usability,simpl,simply,1329,"rs, and the result with `rho0` as a density matrix is compared to the result for `rho0` being the identity super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:1591,Usability,simpl,simple,1591,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:2269,Usability,simpl,simplistic,2269,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/404:2331,Usability,learn,learning,2331,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/404
https://github.com/qutip/qutip/pull/405:974,Deployability,integrat,integrate,974," pull request for a subpackage for non-Markovian solvers, called `nonmarkov`. This idea was mentioned in issue #384. The subpackage now includes two modules, with two quite different non-Markov solvers:. `transfertensormethod`: This module is an implementation of the ""Transfer Tensor Method"" (TTM) introduced by Cerrillo and Cao in [Phys. Rev. Lett 112, 110401 (2014)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.112.110401) ([arXiv link](http://arxiv.org/abs/1307.7743)). TTM is a completely general purpose approach to non-Markovian problems. It takes as input a collection of precomputed dynamical maps for a list of intial ""learning times"", and then tries to extrapolate the non-Markovian dynamics to larger times. `memorycascade`: This module implements the method introduced in [Phys. Rev. Lett 115, 060402 (2015)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.060402) ([arXiv link](http://arxiv.org/abs/1502.06959)) to integrate the dynamics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:974,Integrability,integrat,integrate,974," pull request for a subpackage for non-Markovian solvers, called `nonmarkov`. This idea was mentioned in issue #384. The subpackage now includes two modules, with two quite different non-Markov solvers:. `transfertensormethod`: This module is an implementation of the ""Transfer Tensor Method"" (TTM) introduced by Cerrillo and Cao in [Phys. Rev. Lett 112, 110401 (2014)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.112.110401) ([arXiv link](http://arxiv.org/abs/1307.7743)). TTM is a completely general purpose approach to non-Markovian problems. It takes as input a collection of precomputed dynamical maps for a list of intial ""learning times"", and then tries to extrapolate the non-Markovian dynamics to larger times. `memorycascade`: This module implements the method introduced in [Phys. Rev. Lett 115, 060402 (2015)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.060402) ([arXiv link](http://arxiv.org/abs/1502.06959)) to integrate the dynamics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:1769,Integrability,interface,interface,1769,"cade`: This module implements the method introduced in [Phys. Rev. Lett 115, 060402 (2015)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.060402) ([arXiv link](http://arxiv.org/abs/1502.06959)) to integrate the dynamics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:1814,Integrability,interface,interface,1814,"cade`: This module implements the method introduced in [Phys. Rev. Lett 115, 060402 (2015)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.060402) ([arXiv link](http://arxiv.org/abs/1502.06959)) to integrate the dynamics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:2340,Integrability,interface,interface,2340,"ith two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulations. I personally like this style, and I think it is a general style that could be used across a great variety of solvers. I could however in addition write a function with a more `mesolve`-like interface. It can't, however, be identical, as there are several special arguments that has to be given. There is also a separate class method that computes output field correlation functions, and I kind of like that the various methods are collected together in a class, instead of having multiple different functions that all have to be called with a long list of arguments. I therefore suggest the style used in the `memorycascade` module as a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:2610,Integrability,interface,interface,2610,"ed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulations. I personally like this style, and I think it is a general style that could be used across a great variety of solvers. I could however in addition write a function with a more `mesolve`-like interface. It can't, however, be identical, as there are several special arguments that has to be given. There is also a separate class method that computes output field correlation functions, and I kind of like that the various methods are collected together in a class, instead of having multiple different functions that all have to be called with a long list of arguments. I therefore suggest the style used in the `memorycascade` module as a style that can be used for new solvers going forward. In general there will be a class with a name reflecting the solver, and this class has methods for doing various typ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:2955,Integrability,interface,interface,2955,"tring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulations. I personally like this style, and I think it is a general style that could be used across a great variety of solvers. I could however in addition write a function with a more `mesolve`-like interface. It can't, however, be identical, as there are several special arguments that has to be given. There is also a separate class method that computes output field correlation functions, and I kind of like that the various methods are collected together in a class, instead of having multiple different functions that all have to be called with a long list of arguments. I therefore suggest the style used in the `memorycascade` module as a style that can be used for new solvers going forward. In general there will be a class with a name reflecting the solver, and this class has methods for doing various types of simulations. The two non-Markov solvers I have implemented are of course closely related to my own line of current research. The ""memory cascade"" method is something I have developed, and the main motivation for me to implement the TTM was that it can be used very nicely in conjunction with the ""memory cascade"" method (see the notebooks). Going",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:661,Usability,learn,learning,661,"This is the initial pull request for a subpackage for non-Markovian solvers, called `nonmarkov`. This idea was mentioned in issue #384. The subpackage now includes two modules, with two quite different non-Markov solvers:. `transfertensormethod`: This module is an implementation of the ""Transfer Tensor Method"" (TTM) introduced by Cerrillo and Cao in [Phys. Rev. Lett 112, 110401 (2014)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.112.110401) ([arXiv link](http://arxiv.org/abs/1307.7743)). TTM is a completely general purpose approach to non-Markovian problems. It takes as input a collection of precomputed dynamical maps for a list of intial ""learning times"", and then tries to extrapolate the non-Markovian dynamics to larger times. `memorycascade`: This module implements the method introduced in [Phys. Rev. Lett 115, 060402 (2015)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.060402) ([arXiv link](http://arxiv.org/abs/1502.06959)) to integrate the dynamics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningti",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:1043,Usability,feedback,feedback,1043," pull request for a subpackage for non-Markovian solvers, called `nonmarkov`. This idea was mentioned in issue #384. The subpackage now includes two modules, with two quite different non-Markov solvers:. `transfertensormethod`: This module is an implementation of the ""Transfer Tensor Method"" (TTM) introduced by Cerrillo and Cao in [Phys. Rev. Lett 112, 110401 (2014)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.112.110401) ([arXiv link](http://arxiv.org/abs/1307.7743)). TTM is a completely general purpose approach to non-Markovian problems. It takes as input a collection of precomputed dynamical maps for a list of intial ""learning times"", and then tries to extrapolate the non-Markovian dynamics to larger times. `memorycascade`: This module implements the method introduced in [Phys. Rev. Lett 115, 060402 (2015)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.060402) ([arXiv link](http://arxiv.org/abs/1502.06959)) to integrate the dynamics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:1575,Usability,feedback,feedback,1575,"arkovian problems. It takes as input a collection of precomputed dynamical maps for a list of intial ""learning times"", and then tries to extrapolate the non-Markovian dynamics to larger times. `memorycascade`: This module implements the method introduced in [Phys. Rev. Lett 115, 060402 (2015)](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.060402) ([arXiv link](http://arxiv.org/abs/1502.06959)) to integrate the dynamics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implement",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:1991,Usability,learn,learningtimes,1991,"mics of open quantum systems coupled to a coherent feedback loop with a time-delay. I decided to refer to this method as the ""memory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulations. I personally like this style, and I think it is a general style that could be used across a great variety of solvers. I could however in addition write a function with a more `mesolve`-like interface. It can't, however, be iden",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/405:2101,Usability,learn,learn,2101,"emory cascade"" method in qutip. The method essentially maps the non-Markovian problem onto a cascaded chain of identical system, where each system in the chain represents a ""memory"" of a previous version of the system. There is a companion pull request to the qutip-notebooks repo with two new notebooks documenting the usage of these two modules, qutip/qutip-notebooks#21:. examples/example-transfer-tensor-method.ipynb; examples/example-coherent-delayed-feedback.ipynb. Together with code docstrings, these two notebooks should give a good idea of how the modules are to be used. As you will see in the notebooks, the TTM implementation has a user interface that closely mimicks the `mesolve` interface. The solver is called `ttmsolve` and has the following syntax (explained in more detail in the docstring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulations. I personally like this style, and I think it is a general style that could be used across a great variety of solvers. I could however in addition write a function with a more `mesolve`-like interface. It can't, however, be identical, as there are several special arguments that has to be given. There is also a separate class method that computes output ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/405
https://github.com/qutip/qutip/pull/406:2,Usability,simpl,simple,2,"A simple line plot is produced that illustrates clearly that the pulse is piecewise constant in the timeslots; A standard Matplotlib line plot suggests that the amplitudes vary linearly throughout the timeslot, which is not the case",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/406
https://github.com/qutip/qutip/pull/406:48,Usability,clear,clearly,48,"A simple line plot is produced that illustrates clearly that the pulse is piecewise constant in the timeslots; A standard Matplotlib line plot suggests that the amplitudes vary linearly throughout the timeslot, which is not the case",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/406
https://github.com/qutip/qutip/issues/409:384,Availability,error,errors,384,"[Terminal Saved Output.txt](https://github.com/qutip/qutip/files/67295/Terminal.Saved.Output.txt); Hi, I hope I'm handling this correctly, as I'm new to both qutip and git (recent MATLAB deserter)... I've been trying to set up qutip within my anaconda distribution using . ```; conda install -c https://conda.anaconda.org/jrjohansson qutip; ```. The package linking completes with no errors. But when I . ```; import qutip; ```. I get the following. ```; ImportError: Building module qutip.cy.spmatfuncs failed: ; [""CompileError: command 'gcc' failed with exit status 1\n""]; ```. After running. ```; conda update gcc; conda update cython; ```. I get the same error. I am running OS X 10.11.1. I'm really looking forward to using this software for thesis work, so I hope to get resolved ASAP! Thanks for reading.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/409
https://github.com/qutip/qutip/issues/409:659,Availability,error,error,659,"[Terminal Saved Output.txt](https://github.com/qutip/qutip/files/67295/Terminal.Saved.Output.txt); Hi, I hope I'm handling this correctly, as I'm new to both qutip and git (recent MATLAB deserter)... I've been trying to set up qutip within my anaconda distribution using . ```; conda install -c https://conda.anaconda.org/jrjohansson qutip; ```. The package linking completes with no errors. But when I . ```; import qutip; ```. I get the following. ```; ImportError: Building module qutip.cy.spmatfuncs failed: ; [""CompileError: command 'gcc' failed with exit status 1\n""]; ```. After running. ```; conda update gcc; conda update cython; ```. I get the same error. I am running OS X 10.11.1. I'm really looking forward to using this software for thesis work, so I hope to get resolved ASAP! Thanks for reading.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/409
https://github.com/qutip/qutip/issues/409:284,Deployability,install,install,284,"[Terminal Saved Output.txt](https://github.com/qutip/qutip/files/67295/Terminal.Saved.Output.txt); Hi, I hope I'm handling this correctly, as I'm new to both qutip and git (recent MATLAB deserter)... I've been trying to set up qutip within my anaconda distribution using . ```; conda install -c https://conda.anaconda.org/jrjohansson qutip; ```. The package linking completes with no errors. But when I . ```; import qutip; ```. I get the following. ```; ImportError: Building module qutip.cy.spmatfuncs failed: ; [""CompileError: command 'gcc' failed with exit status 1\n""]; ```. After running. ```; conda update gcc; conda update cython; ```. I get the same error. I am running OS X 10.11.1. I'm really looking forward to using this software for thesis work, so I hope to get resolved ASAP! Thanks for reading.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/409
https://github.com/qutip/qutip/issues/409:606,Deployability,update,update,606,"[Terminal Saved Output.txt](https://github.com/qutip/qutip/files/67295/Terminal.Saved.Output.txt); Hi, I hope I'm handling this correctly, as I'm new to both qutip and git (recent MATLAB deserter)... I've been trying to set up qutip within my anaconda distribution using . ```; conda install -c https://conda.anaconda.org/jrjohansson qutip; ```. The package linking completes with no errors. But when I . ```; import qutip; ```. I get the following. ```; ImportError: Building module qutip.cy.spmatfuncs failed: ; [""CompileError: command 'gcc' failed with exit status 1\n""]; ```. After running. ```; conda update gcc; conda update cython; ```. I get the same error. I am running OS X 10.11.1. I'm really looking forward to using this software for thesis work, so I hope to get resolved ASAP! Thanks for reading.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/409
https://github.com/qutip/qutip/issues/409:624,Deployability,update,update,624,"[Terminal Saved Output.txt](https://github.com/qutip/qutip/files/67295/Terminal.Saved.Output.txt); Hi, I hope I'm handling this correctly, as I'm new to both qutip and git (recent MATLAB deserter)... I've been trying to set up qutip within my anaconda distribution using . ```; conda install -c https://conda.anaconda.org/jrjohansson qutip; ```. The package linking completes with no errors. But when I . ```; import qutip; ```. I get the following. ```; ImportError: Building module qutip.cy.spmatfuncs failed: ; [""CompileError: command 'gcc' failed with exit status 1\n""]; ```. After running. ```; conda update gcc; conda update cython; ```. I get the same error. I am running OS X 10.11.1. I'm really looking forward to using this software for thesis work, so I hope to get resolved ASAP! Thanks for reading.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/409
https://github.com/qutip/qutip/issues/410:31,Testability,test,testing,31,Maybe this:. ```; import qutip.testing as qt; qt.run(); ```. ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/410
https://github.com/qutip/qutip/issues/411:129,Availability,error,error,129,```; mesolve: time-dependence as string list ... /home/yuri/.pyxbld/temp.freebsd-10.2-STABLE-amd64-2.7/pyrex/rhs170529.c:725:24: error: '_Complex type-name' is invalid; typedef npy_double _Complex __pyx_t_npy_double_complex;; ```. Spotted on FreeBSD-10.2,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/411
https://github.com/qutip/qutip/issues/411:19,Integrability,depend,dependence,19,```; mesolve: time-dependence as string list ... /home/yuri/.pyxbld/temp.freebsd-10.2-STABLE-amd64-2.7/pyrex/rhs170529.c:725:24: error: '_Complex type-name' is invalid; typedef npy_double _Complex __pyx_t_npy_double_complex;; ```. Spotted on FreeBSD-10.2,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/411
https://github.com/qutip/qutip/issues/412:582,Integrability,interface,interface,582,"I tried modifying the frequency of a periodic pulse using the `init_pulse_params` argument to `qutip.control.optimize_pulse` (GRAPE algorithm). I tried passing, for example,. ```; init_pulse_params = {'num_waves': 2.0}; ```. but no matter what I choose for 'num_waves', I always get exactly one period (`num_waves`=1.0) for the initial pulse. Similarly if I try to pass a 'freq' key in the dictionary. Looking at the code, it looks like this is hard coded in `create_pulse_optimizer` (line 1942: `pgen.num_waves = 1.0`). Either this is a bug, or I'm misunderstanding how to use the interface.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/412
https://github.com/qutip/qutip/issues/413:34,Deployability,install,installed,34,The nonmarkov folder is not being installed during the setup.; I have done a fix that I will push now,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/413
https://github.com/qutip/qutip/pull/414:42,Deployability,install,installations,42,This is to fix issue #413 that caused new installations to be non-functional.; Anyone got any ideas as to why this was not picked up by the travis tests?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/414
https://github.com/qutip/qutip/pull/414:147,Testability,test,tests,147,This is to fix issue #413 that caused new installations to be non-functional.; Anyone got any ideas as to why this was not picked up by the travis tests?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/414
https://github.com/qutip/qutip/pull/415:163,Testability,test,test,163,Removed hardcoded pulse generator num_waves from create_pulse_optimizer; Changed TRIANGLE pulse type to start from zero (to match the other periodic types); Added test that checks freq and num_waves pulse parameters are applied correctly in create_pulse_optimizer. resolves issue #412,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/415
https://github.com/qutip/qutip/pull/418:16,Deployability,update,updates,16,"A collection of updates at do the following:; - Restore ability to set Q.isherm, Q.type, and Q.superrep explicitly.; - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degenercy.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/418
https://github.com/qutip/qutip/pull/419:292,Testability,test,tests,292,"- Added random stochastic operators.; - rand_herm and rand_dm can be passed an array of eigenvalues that will be the eigenvalues of the resulting random operators. This is done via complex Jacobi rotations, but is really only suitable for operators with dimensionality <~=1000.; - Added unit tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/419
https://github.com/qutip/qutip/pull/420:227,Availability,failure,failures,227,"This PR changes the norm used in `qutip.tests.test_superoper.testLiouvilleImplem` to the max-norm. Previously, this test used the tr-norm, which scaled badly with the dimension of the Liouvillian under test, such that spurious failures were generated (see #419).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/420
https://github.com/qutip/qutip/pull/420:40,Testability,test,tests,40,"This PR changes the norm used in `qutip.tests.test_superoper.testLiouvilleImplem` to the max-norm. Previously, this test used the tr-norm, which scaled badly with the dimension of the Liouvillian under test, such that spurious failures were generated (see #419).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/420
https://github.com/qutip/qutip/pull/420:61,Testability,test,testLiouvilleImplem,61,"This PR changes the norm used in `qutip.tests.test_superoper.testLiouvilleImplem` to the max-norm. Previously, this test used the tr-norm, which scaled badly with the dimension of the Liouvillian under test, such that spurious failures were generated (see #419).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/420
https://github.com/qutip/qutip/pull/420:116,Testability,test,test,116,"This PR changes the norm used in `qutip.tests.test_superoper.testLiouvilleImplem` to the max-norm. Previously, this test used the tr-norm, which scaled badly with the dimension of the Liouvillian under test, such that spurious failures were generated (see #419).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/420
https://github.com/qutip/qutip/pull/420:202,Testability,test,test,202,"This PR changes the norm used in `qutip.tests.test_superoper.testLiouvilleImplem` to the max-norm. Previously, this test used the tr-norm, which scaled badly with the dimension of the Liouvillian under test, such that spurious failures were generated (see #419).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/420
https://github.com/qutip/qutip/pull/421:20,Safety,detect,detects,20,- hardware_info now detects # of physical cpus under Win.; - about() and version_table() now display BLAS type.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/421
https://github.com/qutip/qutip/issues/423:152,Availability,error,error,152,"I was helping someone with an install on windows 7 yesterday.; We were testing using a notebook, and it worked fine except the version_table. The first error was resolved by installing ipython parallel. Still after that it was failing with something like key 'ncpus' missing. Sorry for not supplying exact errors. I could ask the user to post them if necessary. @nonhermitian is #421 likely to resolve this? Even if say they don't have win32com or comtypes installed?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/423
https://github.com/qutip/qutip/issues/423:306,Availability,error,errors,306,"I was helping someone with an install on windows 7 yesterday.; We were testing using a notebook, and it worked fine except the version_table. The first error was resolved by installing ipython parallel. Still after that it was failing with something like key 'ncpus' missing. Sorry for not supplying exact errors. I could ask the user to post them if necessary. @nonhermitian is #421 likely to resolve this? Even if say they don't have win32com or comtypes installed?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/423
https://github.com/qutip/qutip/issues/423:30,Deployability,install,install,30,"I was helping someone with an install on windows 7 yesterday.; We were testing using a notebook, and it worked fine except the version_table. The first error was resolved by installing ipython parallel. Still after that it was failing with something like key 'ncpus' missing. Sorry for not supplying exact errors. I could ask the user to post them if necessary. @nonhermitian is #421 likely to resolve this? Even if say they don't have win32com or comtypes installed?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/423
https://github.com/qutip/qutip/issues/423:174,Deployability,install,installing,174,"I was helping someone with an install on windows 7 yesterday.; We were testing using a notebook, and it worked fine except the version_table. The first error was resolved by installing ipython parallel. Still after that it was failing with something like key 'ncpus' missing. Sorry for not supplying exact errors. I could ask the user to post them if necessary. @nonhermitian is #421 likely to resolve this? Even if say they don't have win32com or comtypes installed?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/423
https://github.com/qutip/qutip/issues/423:457,Deployability,install,installed,457,"I was helping someone with an install on windows 7 yesterday.; We were testing using a notebook, and it worked fine except the version_table. The first error was resolved by installing ipython parallel. Still after that it was failing with something like key 'ncpus' missing. Sorry for not supplying exact errors. I could ask the user to post them if necessary. @nonhermitian is #421 likely to resolve this? Even if say they don't have win32com or comtypes installed?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/423
https://github.com/qutip/qutip/issues/423:71,Testability,test,testing,71,"I was helping someone with an install on windows 7 yesterday.; We were testing using a notebook, and it worked fine except the version_table. The first error was resolved by installing ipython parallel. Still after that it was failing with something like key 'ncpus' missing. Sorry for not supplying exact errors. I could ask the user to post them if necessary. @nonhermitian is #421 likely to resolve this? Even if say they don't have win32com or comtypes installed?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/423
https://github.com/qutip/qutip/issues/425:33,Availability,error,erroring,33,"The tests for this are sometimes erroring in Travis; See test result for #424 ; ERROR: Test Qobj: trunc_neg works for non-diagonal opers. I saw a conversation about this somewhere, but can't find it now",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/425
https://github.com/qutip/qutip/issues/425:80,Availability,ERROR,ERROR,80,"The tests for this are sometimes erroring in Travis; See test result for #424 ; ERROR: Test Qobj: trunc_neg works for non-diagonal opers. I saw a conversation about this somewhere, but can't find it now",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/425
https://github.com/qutip/qutip/issues/425:4,Testability,test,tests,4,"The tests for this are sometimes erroring in Travis; See test result for #424 ; ERROR: Test Qobj: trunc_neg works for non-diagonal opers. I saw a conversation about this somewhere, but can't find it now",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/425
https://github.com/qutip/qutip/issues/425:57,Testability,test,test,57,"The tests for this are sometimes erroring in Travis; See test result for #424 ; ERROR: Test Qobj: trunc_neg works for non-diagonal opers. I saw a conversation about this somewhere, but can't find it now",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/425
https://github.com/qutip/qutip/issues/425:87,Testability,Test,Test,87,"The tests for this are sometimes erroring in Travis; See test result for #424 ; ERROR: Test Qobj: trunc_neg works for non-diagonal opers. I saw a conversation about this somewhere, but can't find it now",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/425
https://github.com/qutip/qutip/issues/426:221,Availability,fault,faulty,221,"Hi,. I think the import order is not correct in `setup.py`, importing `numpy` at the beginning of the file, before giving a chance to `setuptools` to actually install it (because it is in required packages). This line is faulty https://github.com/qutip/qutip/blob/master/setup.py#L34 and results in. ``` zsh; % pip install qutip; Collecting qutip; Downloading qutip-3.1.0.tar.gz (800kB); 100% |████████████████████████████████| 802kB 595kB/s ; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-w53v9c3b/qutip/setup.py"", line 34, in <module>; import numpy as np; ImportError: No module named 'numpy'; ```. Then, instead of `pip install qutip`, one has to `pip install numpy; pip install qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/426
https://github.com/qutip/qutip/issues/426:348,Availability,Down,Downloading,348,"Hi,. I think the import order is not correct in `setup.py`, importing `numpy` at the beginning of the file, before giving a chance to `setuptools` to actually install it (because it is in required packages). This line is faulty https://github.com/qutip/qutip/blob/master/setup.py#L34 and results in. ``` zsh; % pip install qutip; Collecting qutip; Downloading qutip-3.1.0.tar.gz (800kB); 100% |████████████████████████████████| 802kB 595kB/s ; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-w53v9c3b/qutip/setup.py"", line 34, in <module>; import numpy as np; ImportError: No module named 'numpy'; ```. Then, instead of `pip install qutip`, one has to `pip install numpy; pip install qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/426
https://github.com/qutip/qutip/issues/426:159,Deployability,install,install,159,"Hi,. I think the import order is not correct in `setup.py`, importing `numpy` at the beginning of the file, before giving a chance to `setuptools` to actually install it (because it is in required packages). This line is faulty https://github.com/qutip/qutip/blob/master/setup.py#L34 and results in. ``` zsh; % pip install qutip; Collecting qutip; Downloading qutip-3.1.0.tar.gz (800kB); 100% |████████████████████████████████| 802kB 595kB/s ; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-w53v9c3b/qutip/setup.py"", line 34, in <module>; import numpy as np; ImportError: No module named 'numpy'; ```. Then, instead of `pip install qutip`, one has to `pip install numpy; pip install qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/426
https://github.com/qutip/qutip/issues/426:315,Deployability,install,install,315,"Hi,. I think the import order is not correct in `setup.py`, importing `numpy` at the beginning of the file, before giving a chance to `setuptools` to actually install it (because it is in required packages). This line is faulty https://github.com/qutip/qutip/blob/master/setup.py#L34 and results in. ``` zsh; % pip install qutip; Collecting qutip; Downloading qutip-3.1.0.tar.gz (800kB); 100% |████████████████████████████████| 802kB 595kB/s ; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-w53v9c3b/qutip/setup.py"", line 34, in <module>; import numpy as np; ImportError: No module named 'numpy'; ```. Then, instead of `pip install qutip`, one has to `pip install numpy; pip install qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/426
https://github.com/qutip/qutip/issues/426:728,Deployability,install,install,728,"Hi,. I think the import order is not correct in `setup.py`, importing `numpy` at the beginning of the file, before giving a chance to `setuptools` to actually install it (because it is in required packages). This line is faulty https://github.com/qutip/qutip/blob/master/setup.py#L34 and results in. ``` zsh; % pip install qutip; Collecting qutip; Downloading qutip-3.1.0.tar.gz (800kB); 100% |████████████████████████████████| 802kB 595kB/s ; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-w53v9c3b/qutip/setup.py"", line 34, in <module>; import numpy as np; ImportError: No module named 'numpy'; ```. Then, instead of `pip install qutip`, one has to `pip install numpy; pip install qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/426
https://github.com/qutip/qutip/issues/426:760,Deployability,install,install,760,"Hi,. I think the import order is not correct in `setup.py`, importing `numpy` at the beginning of the file, before giving a chance to `setuptools` to actually install it (because it is in required packages). This line is faulty https://github.com/qutip/qutip/blob/master/setup.py#L34 and results in. ``` zsh; % pip install qutip; Collecting qutip; Downloading qutip-3.1.0.tar.gz (800kB); 100% |████████████████████████████████| 802kB 595kB/s ; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-w53v9c3b/qutip/setup.py"", line 34, in <module>; import numpy as np; ImportError: No module named 'numpy'; ```. Then, instead of `pip install qutip`, one has to `pip install numpy; pip install qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/426
https://github.com/qutip/qutip/issues/426:779,Deployability,install,install,779,"Hi,. I think the import order is not correct in `setup.py`, importing `numpy` at the beginning of the file, before giving a chance to `setuptools` to actually install it (because it is in required packages). This line is faulty https://github.com/qutip/qutip/blob/master/setup.py#L34 and results in. ``` zsh; % pip install qutip; Collecting qutip; Downloading qutip-3.1.0.tar.gz (800kB); 100% |████████████████████████████████| 802kB 595kB/s ; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-w53v9c3b/qutip/setup.py"", line 34, in <module>; import numpy as np; ImportError: No module named 'numpy'; ```. Then, instead of `pip install qutip`, one has to `pip install numpy; pip install qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/426
https://github.com/qutip/qutip/pull/429:122,Availability,failure,failure,122,"This PR addresses #410 by attempting to import `setuptools`, which has support for unittesting and nose integration. Upon failure, it should leave the setup process as it was. This PR also fixes a rare exception in `settings.py` that can be caused if you have a `*.pyc` file for `logging.py` and call into QuTiP from something like nose.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/429
https://github.com/qutip/qutip/pull/429:104,Deployability,integrat,integration,104,"This PR addresses #410 by attempting to import `setuptools`, which has support for unittesting and nose integration. Upon failure, it should leave the setup process as it was. This PR also fixes a rare exception in `settings.py` that can be caused if you have a `*.pyc` file for `logging.py` and call into QuTiP from something like nose.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/429
https://github.com/qutip/qutip/pull/429:104,Integrability,integrat,integration,104,"This PR addresses #410 by attempting to import `setuptools`, which has support for unittesting and nose integration. Upon failure, it should leave the setup process as it was. This PR also fixes a rare exception in `settings.py` that can be caused if you have a `*.pyc` file for `logging.py` and call into QuTiP from something like nose.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/429
https://github.com/qutip/qutip/pull/429:280,Testability,log,logging,280,"This PR addresses #410 by attempting to import `setuptools`, which has support for unittesting and nose integration. Upon failure, it should leave the setup process as it was. This PR also fixes a rare exception in `settings.py` that can be caused if you have a `*.pyc` file for `logging.py` and call into QuTiP from something like nose.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/429
https://github.com/qutip/qutip/issues/430:131,Availability,failure,failures,131,"We have a number of pull requests that are all nice fixes and enhancements, however we are delaying merging because of travis test failures. I can't see how any of these pull request can be an underlying cause:; #421; #422; #428; #429. So I will merge all these. We can then investigate what is causing some of the tests to fail under this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/430
https://github.com/qutip/qutip/issues/430:62,Modifiability,enhance,enhancements,62,"We have a number of pull requests that are all nice fixes and enhancements, however we are delaying merging because of travis test failures. I can't see how any of these pull request can be an underlying cause:; #421; #422; #428; #429. So I will merge all these. We can then investigate what is causing some of the tests to fail under this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/430
https://github.com/qutip/qutip/issues/430:126,Testability,test,test,126,"We have a number of pull requests that are all nice fixes and enhancements, however we are delaying merging because of travis test failures. I can't see how any of these pull request can be an underlying cause:; #421; #422; #428; #429. So I will merge all these. We can then investigate what is causing some of the tests to fail under this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/430
https://github.com/qutip/qutip/issues/430:315,Testability,test,tests,315,"We have a number of pull requests that are all nice fixes and enhancements, however we are delaying merging because of travis test failures. I can't see how any of these pull request can be an underlying cause:; #421; #422; #428; #429. So I will merge all these. We can then investigate what is causing some of the tests to fail under this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/430
https://github.com/qutip/qutip/pull/431:45,Testability,log,log,45,The information has been moved to the change log,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/431
https://github.com/qutip/qutip/issues/433:86,Testability,test,tests,86,"UserWarning: Multiplying superoperators with different representations; issued during tests.; @cgranade I think you implemented this part. Is this something to concern; I mainly raised it as I have spent my evening removing all the other warnings from the tests, so would be nice to clear them all",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/433
https://github.com/qutip/qutip/issues/433:256,Testability,test,tests,256,"UserWarning: Multiplying superoperators with different representations; issued during tests.; @cgranade I think you implemented this part. Is this something to concern; I mainly raised it as I have spent my evening removing all the other warnings from the tests, so would be nice to clear them all",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/433
https://github.com/qutip/qutip/issues/433:283,Usability,clear,clear,283,"UserWarning: Multiplying superoperators with different representations; issued during tests.; @cgranade I think you implemented this part. Is this something to concern; I mainly raised it as I have spent my evening removing all the other warnings from the tests, so would be nice to clear them all",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/433
https://github.com/qutip/qutip/pull/434:52,Testability,test,tests,52,"All deprecation warnings issued by numpy during the tests have now been fixed, resolving #381 ; The motivation was to try and make it more clear when and why issue #430 arises",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/434
https://github.com/qutip/qutip/pull/434:139,Usability,clear,clear,139,"All deprecation warnings issued by numpy during the tests have now been fixed, resolving #381 ; The motivation was to try and make it more clear when and why issue #430 arises",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/434
https://github.com/qutip/qutip/pull/435:74,Availability,toler,tolerance,74,Some of the norms calculated in the test_ComplexSuperApply were above the tolerance of 1e-12; In 50 repeated tests 7 errors occurred. norms as large as 5e-11 were reported.; After increasing tol to 1e-10 test were repeated 200 times and no errors occurred,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/435
https://github.com/qutip/qutip/pull/435:117,Availability,error,errors,117,Some of the norms calculated in the test_ComplexSuperApply were above the tolerance of 1e-12; In 50 repeated tests 7 errors occurred. norms as large as 5e-11 were reported.; After increasing tol to 1e-10 test were repeated 200 times and no errors occurred,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/435
https://github.com/qutip/qutip/pull/435:240,Availability,error,errors,240,Some of the norms calculated in the test_ComplexSuperApply were above the tolerance of 1e-12; In 50 repeated tests 7 errors occurred. norms as large as 5e-11 were reported.; After increasing tol to 1e-10 test were repeated 200 times and no errors occurred,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/435
https://github.com/qutip/qutip/pull/435:109,Testability,test,tests,109,Some of the norms calculated in the test_ComplexSuperApply were above the tolerance of 1e-12; In 50 repeated tests 7 errors occurred. norms as large as 5e-11 were reported.; After increasing tol to 1e-10 test were repeated 200 times and no errors occurred,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/435
https://github.com/qutip/qutip/pull/435:204,Testability,test,test,204,Some of the norms calculated in the test_ComplexSuperApply were above the tolerance of 1e-12; In 50 repeated tests 7 errors occurred. norms as large as 5e-11 were reported.; After increasing tol to 1e-10 test were repeated 200 times and no errors occurred,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/435
https://github.com/qutip/qutip/pull/436:275,Performance,perform,performing,275,"This PR addresses #433 by manually setting `Qobj.superrep` to suppress warnings in `chi_to_choi`. The change of basis for chi → choi is currently represented as a `superrep='super'`, as that makes sense in several other contextx, such that spurious warnings were raised when performing this conversion.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/436
https://github.com/qutip/qutip/issues/437:281,Performance,perform,performance,281,"The Qobj data that represents the state or operator is stored as a sparse (csr) array. In most cases this makes sense, as the memory requirements for many solvers would be excessive. There are many cases though for small systems where memory would not be an issue, and significant performance improvements could be gained. This has been demonstrated in the optimal control modules. Many matrix operations are much faster in the dense representation. Originally suggested in #26. This is now more urgent. In answer to #370 I submitted #397. However, it was found that significant performance degradation occurred in the control evolution calculation for small systems, and as such a retrofit of ndarray option for internal operator type was made. This leads to pretty untidy code, and means that subclasses for propagator and gradient calculations, fidelity, and evolution calculations all need to implement conditional methods. Implementation of a dense Qobj would resolve these problems, and as mentioned above, could lead to performance improvements in many of the other solvers. Many of the solvers assume sparsity, and so they too may need changes to support dense states and operators. . In general, great care would need to be undertaken in implementing the dense Qobj. Those methods that did not support it would need to check the Qobj type when called",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/437
https://github.com/qutip/qutip/issues/437:579,Performance,perform,performance,579,"The Qobj data that represents the state or operator is stored as a sparse (csr) array. In most cases this makes sense, as the memory requirements for many solvers would be excessive. There are many cases though for small systems where memory would not be an issue, and significant performance improvements could be gained. This has been demonstrated in the optimal control modules. Many matrix operations are much faster in the dense representation. Originally suggested in #26. This is now more urgent. In answer to #370 I submitted #397. However, it was found that significant performance degradation occurred in the control evolution calculation for small systems, and as such a retrofit of ndarray option for internal operator type was made. This leads to pretty untidy code, and means that subclasses for propagator and gradient calculations, fidelity, and evolution calculations all need to implement conditional methods. Implementation of a dense Qobj would resolve these problems, and as mentioned above, could lead to performance improvements in many of the other solvers. Many of the solvers assume sparsity, and so they too may need changes to support dense states and operators. . In general, great care would need to be undertaken in implementing the dense Qobj. Those methods that did not support it would need to check the Qobj type when called",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/437
https://github.com/qutip/qutip/issues/437:1027,Performance,perform,performance,1027,"The Qobj data that represents the state or operator is stored as a sparse (csr) array. In most cases this makes sense, as the memory requirements for many solvers would be excessive. There are many cases though for small systems where memory would not be an issue, and significant performance improvements could be gained. This has been demonstrated in the optimal control modules. Many matrix operations are much faster in the dense representation. Originally suggested in #26. This is now more urgent. In answer to #370 I submitted #397. However, it was found that significant performance degradation occurred in the control evolution calculation for small systems, and as such a retrofit of ndarray option for internal operator type was made. This leads to pretty untidy code, and means that subclasses for propagator and gradient calculations, fidelity, and evolution calculations all need to implement conditional methods. Implementation of a dense Qobj would resolve these problems, and as mentioned above, could lead to performance improvements in many of the other solvers. Many of the solvers assume sparsity, and so they too may need changes to support dense states and operators. . In general, great care would need to be undertaken in implementing the dense Qobj. Those methods that did not support it would need to check the Qobj type when called",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/437
https://github.com/qutip/qutip/issues/438:440,Security,access,access,440,"As far as I am aware only the Monte Carlo solver supports any kind of parallelization. Many of the other solvers require sequential processing. However, there may be some operations that allow parallel processing. . It is well known for instance that GPUs are widely used for matrix operations. Although Numpy and Sympy do not currently directly support GPU, there are other libraries that could be investigated. Of course not everyone has access to GPU, and potentially the could be CPU parallel possibilities here too. The optimal control modules could certainly be parallelised. In most cases the calculation of the propagators and / or the fidelity gradients are the most costly operations, and can be computed in parallel. So this would be a fairly easy implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/438
https://github.com/qutip/qutip/issues/439:78,Deployability,install,installing,78,"We are planning on moving to use the Anaconda suite as the primary method for installing and using QuTiP. However, this means that one can not install the mcf90 files in a straightforward manner. How are we going to handle these fortran files from here on out?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/439
https://github.com/qutip/qutip/issues/439:143,Deployability,install,install,143,"We are planning on moving to use the Anaconda suite as the primary method for installing and using QuTiP. However, this means that one can not install the mcf90 files in a straightforward manner. How are we going to handle these fortran files from here on out?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/439
https://github.com/qutip/qutip/pull/440:16,Deployability,update,updates,16,A collection of updates that I can find while going through the docs and code.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/440
https://github.com/qutip/qutip/issues/441:102,Availability,down,down,102,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/441
https://github.com/qutip/qutip/issues/441:867,Availability,error,error,867,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/441
https://github.com/qutip/qutip/issues/441:1490,Availability,avail,available,1490,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/441
https://github.com/qutip/qutip/issues/441:1883,Availability,error,error,1883,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/441
https://github.com/qutip/qutip/issues/441:774,Modifiability,enhance,enhancements,774,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/441
https://github.com/qutip/qutip/issues/441:1052,Modifiability,Extend,Extend,1052,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/441
https://github.com/qutip/qutip/issues/441:1369,Performance,optimiz,optimize,1369,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/441
https://github.com/qutip/qutip/issues/442:92,Energy Efficiency,power,powerful,92,"Measuring the statistics of electron transport though nanostructures has been found to be a powerful experimental tool to gather information about such structures. The functions in countstat.py return the first two cumulants of a transport process, which are associated with measuring the current and shot noise, respectively. However at the moment they are a little buggy, and the current noise function fails sometimes, depending on the dimensionality of the system. As well as fixing this issue, there a couple of enhancements that can be done:. 1) Making the current noise function frequency dependant. This just requires adding a list of frequencies to return, and calculating the noise power for each given frequency ( at the moment it returns the zero frequency current noise). 2) Adding higher-order current cumulants. This is a straightforward generalization of the current noise function, though for very high orders the expansion of a given cumulant in terms of pseudo-inverse and current operators can be a little complicated. An iterative method for generating these can be found in C. Flindt et al., Phys. Rev. Lett. 100, 150601 (2008). and C. Flindt, T. Novotny, A. Braggio, and A.-P. Jauho, Phys. Rev. B 82, 155407 (2010). 3) Calculate the large-deviation function of the current. Such functions return the probability of observing deviations from the average transport behaviour, and have been found to give insight on a range of physical phenomena, including bistability and criticality (and, more practically, life insurance!).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/442
https://github.com/qutip/qutip/issues/442:692,Energy Efficiency,power,power,692,"Measuring the statistics of electron transport though nanostructures has been found to be a powerful experimental tool to gather information about such structures. The functions in countstat.py return the first two cumulants of a transport process, which are associated with measuring the current and shot noise, respectively. However at the moment they are a little buggy, and the current noise function fails sometimes, depending on the dimensionality of the system. As well as fixing this issue, there a couple of enhancements that can be done:. 1) Making the current noise function frequency dependant. This just requires adding a list of frequencies to return, and calculating the noise power for each given frequency ( at the moment it returns the zero frequency current noise). 2) Adding higher-order current cumulants. This is a straightforward generalization of the current noise function, though for very high orders the expansion of a given cumulant in terms of pseudo-inverse and current operators can be a little complicated. An iterative method for generating these can be found in C. Flindt et al., Phys. Rev. Lett. 100, 150601 (2008). and C. Flindt, T. Novotny, A. Braggio, and A.-P. Jauho, Phys. Rev. B 82, 155407 (2010). 3) Calculate the large-deviation function of the current. Such functions return the probability of observing deviations from the average transport behaviour, and have been found to give insight on a range of physical phenomena, including bistability and criticality (and, more practically, life insurance!).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/442
https://github.com/qutip/qutip/issues/442:422,Integrability,depend,depending,422,"Measuring the statistics of electron transport though nanostructures has been found to be a powerful experimental tool to gather information about such structures. The functions in countstat.py return the first two cumulants of a transport process, which are associated with measuring the current and shot noise, respectively. However at the moment they are a little buggy, and the current noise function fails sometimes, depending on the dimensionality of the system. As well as fixing this issue, there a couple of enhancements that can be done:. 1) Making the current noise function frequency dependant. This just requires adding a list of frequencies to return, and calculating the noise power for each given frequency ( at the moment it returns the zero frequency current noise). 2) Adding higher-order current cumulants. This is a straightforward generalization of the current noise function, though for very high orders the expansion of a given cumulant in terms of pseudo-inverse and current operators can be a little complicated. An iterative method for generating these can be found in C. Flindt et al., Phys. Rev. Lett. 100, 150601 (2008). and C. Flindt, T. Novotny, A. Braggio, and A.-P. Jauho, Phys. Rev. B 82, 155407 (2010). 3) Calculate the large-deviation function of the current. Such functions return the probability of observing deviations from the average transport behaviour, and have been found to give insight on a range of physical phenomena, including bistability and criticality (and, more practically, life insurance!).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/442
https://github.com/qutip/qutip/issues/442:596,Integrability,depend,dependant,596,"Measuring the statistics of electron transport though nanostructures has been found to be a powerful experimental tool to gather information about such structures. The functions in countstat.py return the first two cumulants of a transport process, which are associated with measuring the current and shot noise, respectively. However at the moment they are a little buggy, and the current noise function fails sometimes, depending on the dimensionality of the system. As well as fixing this issue, there a couple of enhancements that can be done:. 1) Making the current noise function frequency dependant. This just requires adding a list of frequencies to return, and calculating the noise power for each given frequency ( at the moment it returns the zero frequency current noise). 2) Adding higher-order current cumulants. This is a straightforward generalization of the current noise function, though for very high orders the expansion of a given cumulant in terms of pseudo-inverse and current operators can be a little complicated. An iterative method for generating these can be found in C. Flindt et al., Phys. Rev. Lett. 100, 150601 (2008). and C. Flindt, T. Novotny, A. Braggio, and A.-P. Jauho, Phys. Rev. B 82, 155407 (2010). 3) Calculate the large-deviation function of the current. Such functions return the probability of observing deviations from the average transport behaviour, and have been found to give insight on a range of physical phenomena, including bistability and criticality (and, more practically, life insurance!).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/442
https://github.com/qutip/qutip/issues/442:517,Modifiability,enhance,enhancements,517,"Measuring the statistics of electron transport though nanostructures has been found to be a powerful experimental tool to gather information about such structures. The functions in countstat.py return the first two cumulants of a transport process, which are associated with measuring the current and shot noise, respectively. However at the moment they are a little buggy, and the current noise function fails sometimes, depending on the dimensionality of the system. As well as fixing this issue, there a couple of enhancements that can be done:. 1) Making the current noise function frequency dependant. This just requires adding a list of frequencies to return, and calculating the noise power for each given frequency ( at the moment it returns the zero frequency current noise). 2) Adding higher-order current cumulants. This is a straightforward generalization of the current noise function, though for very high orders the expansion of a given cumulant in terms of pseudo-inverse and current operators can be a little complicated. An iterative method for generating these can be found in C. Flindt et al., Phys. Rev. Lett. 100, 150601 (2008). and C. Flindt, T. Novotny, A. Braggio, and A.-P. Jauho, Phys. Rev. B 82, 155407 (2010). 3) Calculate the large-deviation function of the current. Such functions return the probability of observing deviations from the average transport behaviour, and have been found to give insight on a range of physical phenomena, including bistability and criticality (and, more practically, life insurance!).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/442
https://github.com/qutip/qutip/pull/443:158,Testability,test,test,158,- A Qobj times a dense vector would result in a recursive loop and; crash the computer.; - Made the multi array check better about handling dtypes and added; test. The output is a dense array. However if we do create a dense Qobj class (as described in #437) then that should be the returned object.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/443
https://github.com/qutip/qutip/issues/444:88,Availability,avail,available,88,"Hi,. I cannot find any doc (except the source code itself) about which progress bar are available and how to use them. Especially, the only references to the progress bar in [the doc](http://qutip.org/docs/3.1.0/) are the options for `mesolve` etc. I think it could be really useful to document it, or provide an iPython notebook making use of it. EDIT: Plus the docstring of `mesolve` function (for instance) seems to contradict the first lines of the function:. ```; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; ```. versus. ``` python; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/444
https://github.com/qutip/qutip/issues/444:71,Usability,progress bar,progress bar,71,"Hi,. I cannot find any doc (except the source code itself) about which progress bar are available and how to use them. Especially, the only references to the progress bar in [the doc](http://qutip.org/docs/3.1.0/) are the options for `mesolve` etc. I think it could be really useful to document it, or provide an iPython notebook making use of it. EDIT: Plus the docstring of `mesolve` function (for instance) seems to contradict the first lines of the function:. ```; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; ```. versus. ``` python; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/444
https://github.com/qutip/qutip/issues/444:158,Usability,progress bar,progress bar,158,"Hi,. I cannot find any doc (except the source code itself) about which progress bar are available and how to use them. Especially, the only references to the progress bar in [the doc](http://qutip.org/docs/3.1.0/) are the options for `mesolve` etc. I think it could be really useful to document it, or provide an iPython notebook making use of it. EDIT: Plus the docstring of `mesolve` function (for instance) seems to contradict the first lines of the function:. ```; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; ```. versus. ``` python; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/444
https://github.com/qutip/qutip/issues/1517:49,Usability,progress bar,progress bars,49,"Documentation has been requested about using the progress bars in qutip/qutip#444.; @cgranade maybe you could look at this, as you did quite a lot of work on the web progress bar?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1517
https://github.com/qutip/qutip/issues/1517:166,Usability,progress bar,progress bar,166,"Documentation has been requested about using the progress bars in qutip/qutip#444.; @cgranade maybe you could look at this, as you did quite a lot of work on the web progress bar?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1517
https://github.com/qutip/qutip/issues/445:571,Availability,error,error,571,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:618,Availability,ERROR,ERROR,618,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:156,Integrability,message,message,156,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:577,Integrability,message,message,577,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:639,Integrability,depend,dependence,639,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:1508,Modifiability,config,config,1508," version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:29,Testability,test,testing,29,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:112,Testability,test,testing,112,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:187,Testability,test,tests,187,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:220,Testability,test,testing,220,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:247,Testability,test,tests,247,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:275,Testability,test,test,275,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:288,Testability,test,tests,288,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:417,Testability,test,tests,417,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:856,Testability,test,test,856,"1. version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:1010,Testability,test,tests,1010," version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/issues/445:1047,Testability,test,testMETDDecayAsArray,1047," version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/445
https://github.com/qutip/qutip/pull/446:74,Performance,perform,performance,74,"This may seem like a pedantic change, but is does (very slightly) improve performance in hsolve, and also avoids addressing an array index as a non-integer. Seems to make sense for the state numbers to be integers anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/446
https://github.com/qutip/qutip/pull/446:106,Safety,avoid,avoids,106,"This may seem like a pedantic change, but is does (very slightly) improve performance in hsolve, and also avoids addressing an array index as a non-integer. Seems to make sense for the state numbers to be integers anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/446
https://github.com/qutip/qutip/issues/1523:150,Usability,Guid,Guide,150,"The new random Qobj functions `rand_ket_haar`, `rand_dm_hs`, `rand_dm_ginibre`, `rand_unitary_haar` and `rand_super_bcsz` need to be explained in the Guide as well as in the apidocs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1523
https://github.com/qutip/qutip/issues/447:548,Testability,test,tests,548,"Not really expecting anyone to fix this urgently, I am just recording some ideas, as I have spent a lot of time looking into this recently while try to build a conda package. Currently on Windows we compile under mingw. This is sub-optimal, according to various sources, including:; https://wiki.python.org/moin/WindowsCompilers; Python C extensions should be compiled using the same compiler that was used to compile the Python distro that is being used. Failing to do so can result in some strange behaviour. I have experienced issues with qutip tests hanging on Windows. Therefore it would clearly be beneficial if we could build qutip under MSVC. It is of particular interest now that we have a conda recipe that autobuilds for all the version, platform variations.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/447
https://github.com/qutip/qutip/issues/447:593,Usability,clear,clearly,593,"Not really expecting anyone to fix this urgently, I am just recording some ideas, as I have spent a lot of time looking into this recently while try to build a conda package. Currently on Windows we compile under mingw. This is sub-optimal, according to various sources, including:; https://wiki.python.org/moin/WindowsCompilers; Python C extensions should be compiled using the same compiler that was used to compile the Python distro that is being used. Failing to do so can result in some strange behaviour. I have experienced issues with qutip tests hanging on Windows. Therefore it would clearly be beneficial if we could build qutip under MSVC. It is of particular interest now that we have a conda recipe that autobuilds for all the version, platform variations.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/447
https://github.com/qutip/qutip/issues/448:157,Deployability,install,install,157,"There is a section in qutip/**init**.py that checks the cython version, then re cythonizes all the pyx. It prints a warning if cython is not found. So after install, during which all the cython modules get built, during the first import of qutip all the building happens again. This seems unnecessary, and is actually an issue if we are making a pre-built package. I have patched out this section in the conda-forge feedstock. All but 7 of the tests are successful. Cython is not actually needed at run time for most of QuTiP. Why is it sometimes needed at runtime?. Should we look remove this section from the **init**.py, and put some warning in the methods that use cython at runtime?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/448
https://github.com/qutip/qutip/issues/448:372,Deployability,patch,patched,372,"There is a section in qutip/**init**.py that checks the cython version, then re cythonizes all the pyx. It prints a warning if cython is not found. So after install, during which all the cython modules get built, during the first import of qutip all the building happens again. This seems unnecessary, and is actually an issue if we are making a pre-built package. I have patched out this section in the conda-forge feedstock. All but 7 of the tests are successful. Cython is not actually needed at run time for most of QuTiP. Why is it sometimes needed at runtime?. Should we look remove this section from the **init**.py, and put some warning in the methods that use cython at runtime?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/448
https://github.com/qutip/qutip/issues/448:444,Testability,test,tests,444,"There is a section in qutip/**init**.py that checks the cython version, then re cythonizes all the pyx. It prints a warning if cython is not found. So after install, during which all the cython modules get built, during the first import of qutip all the building happens again. This seems unnecessary, and is actually an issue if we are making a pre-built package. I have patched out this section in the conda-forge feedstock. All but 7 of the tests are successful. Cython is not actually needed at run time for most of QuTiP. Why is it sometimes needed at runtime?. Should we look remove this section from the **init**.py, and put some warning in the methods that use cython at runtime?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/448
https://github.com/qutip/qutip/issues/449:415,Availability,error,error,415,"Some of the test have decorators like this:. ```; @unittest.skipIf(_version2int(Cython.__version__) < _version2int('0.14') or; Cython_found == 0, 'Cython not found or version too low.'); ```. with the Cython_found variable being set at the top of the file like this:. ```; # find Cython if it exists; try:; import Cython; except:; Cython_found = 0; else:; Cython_found = 1; ```. The condition in the decorator will error, as the Cython version is checked even though it failed to import.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/449
https://github.com/qutip/qutip/issues/449:214,Modifiability,variab,variable,214,"Some of the test have decorators like this:. ```; @unittest.skipIf(_version2int(Cython.__version__) < _version2int('0.14') or; Cython_found == 0, 'Cython not found or version too low.'); ```. with the Cython_found variable being set at the top of the file like this:. ```; # find Cython if it exists; try:; import Cython; except:; Cython_found = 0; else:; Cython_found = 1; ```. The condition in the decorator will error, as the Cython version is checked even though it failed to import.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/449
https://github.com/qutip/qutip/issues/449:12,Testability,test,test,12,"Some of the test have decorators like this:. ```; @unittest.skipIf(_version2int(Cython.__version__) < _version2int('0.14') or; Cython_found == 0, 'Cython not found or version too low.'); ```. with the Cython_found variable being set at the top of the file like this:. ```; # find Cython if it exists; try:; import Cython; except:; Cython_found = 0; else:; Cython_found = 1; ```. The condition in the decorator will error, as the Cython version is checked even though it failed to import.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/449
https://github.com/qutip/qutip/issues/450:42,Modifiability,config,config,42,"The qutip/setup.py; has these lines. ```; config.add_subpackage('cy'); config.add_subpackage('control'); ```. Should the qip packages and nonmarkov go in there or or is this covered by this in the main setup.py. ```; PACKAGES = ['qutip', 'qutip/ui', 'qutip/cy', 'qutip/qip', 'qutip/qip/models',; 'qutip/qip/algorithms', 'qutip/control', 'qutip/nonmarkov', ; 'qutip/tests']; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/450
https://github.com/qutip/qutip/issues/450:71,Modifiability,config,config,71,"The qutip/setup.py; has these lines. ```; config.add_subpackage('cy'); config.add_subpackage('control'); ```. Should the qip packages and nonmarkov go in there or or is this covered by this in the main setup.py. ```; PACKAGES = ['qutip', 'qutip/ui', 'qutip/cy', 'qutip/qip', 'qutip/qip/models',; 'qutip/qip/algorithms', 'qutip/control', 'qutip/nonmarkov', ; 'qutip/tests']; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/450
https://github.com/qutip/qutip/issues/450:365,Testability,test,tests,365,"The qutip/setup.py; has these lines. ```; config.add_subpackage('cy'); config.add_subpackage('control'); ```. Should the qip packages and nonmarkov go in there or or is this covered by this in the main setup.py. ```; PACKAGES = ['qutip', 'qutip/ui', 'qutip/cy', 'qutip/qip', 'qutip/qip/models',; 'qutip/qip/algorithms', 'qutip/control', 'qutip/nonmarkov', ; 'qutip/tests']; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/450
https://github.com/qutip/qutip/pull/452:197,Security,expose,expose,197,"This PR should fix #451 by adding an additional check to `Qobj.iscp` to check the hermicity-preserving condition. Since this is a useful condition in its own right, the PR also adds `Qobj.ishp` to expose that logic separately. Finally, new unit tests have been added to check for regressions on #451, and for the new `Qobj.ishp` attribute.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/452
https://github.com/qutip/qutip/pull/452:209,Testability,log,logic,209,"This PR should fix #451 by adding an additional check to `Qobj.iscp` to check the hermicity-preserving condition. Since this is a useful condition in its own right, the PR also adds `Qobj.ishp` to expose that logic separately. Finally, new unit tests have been added to check for regressions on #451, and for the new `Qobj.ishp` attribute.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/452
https://github.com/qutip/qutip/pull/452:245,Testability,test,tests,245,"This PR should fix #451 by adding an additional check to `Qobj.iscp` to check the hermicity-preserving condition. Since this is a useful condition in its own right, the PR also adds `Qobj.ishp` to expose that logic separately. Finally, new unit tests have been added to check for regressions on #451, and for the new `Qobj.ishp` attribute.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/452
https://github.com/qutip/qutip/issues/453:185,Performance,cache,cached,185,"Currently, `Qobj` has several attributes which are somewhat expensive to compute:; - `type`; - `isherm`; - `istp`; - `iscp`; - `ishp` (added in #452). Of these, `type` and `isherm` are cached by `Qobj._type` and `Qobj._isherm`, respectively. These should be unified, so that the other three are also cached properly. Moreover, we should add unit tests to make sure that this caching is properly invalidated under at least some reasonably common manipulations. For instance, with the caching of `type`, it can sometimes fail in unexpected ways to build an object up then redefine its `dims`:. ``` python; >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type). >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> print(J.type); >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type); ```. The first of these two snippets correctly prints `super`, while the extra `print(J.type)` in the second snippet causes it to cache `type` and print `oper` twice. An experienced user can of course invalidate the cache with `J._type = None`, but that is somewhat counter-intuitive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/453
https://github.com/qutip/qutip/issues/453:300,Performance,cache,cached,300,"Currently, `Qobj` has several attributes which are somewhat expensive to compute:; - `type`; - `isherm`; - `istp`; - `iscp`; - `ishp` (added in #452). Of these, `type` and `isherm` are cached by `Qobj._type` and `Qobj._isherm`, respectively. These should be unified, so that the other three are also cached properly. Moreover, we should add unit tests to make sure that this caching is properly invalidated under at least some reasonably common manipulations. For instance, with the caching of `type`, it can sometimes fail in unexpected ways to build an object up then redefine its `dims`:. ``` python; >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type). >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> print(J.type); >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type); ```. The first of these two snippets correctly prints `super`, while the extra `print(J.type)` in the second snippet causes it to cache `type` and print `oper` twice. An experienced user can of course invalidate the cache with `J._type = None`, but that is somewhat counter-intuitive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/453
https://github.com/qutip/qutip/issues/453:1117,Performance,cache,cache,1117,"Currently, `Qobj` has several attributes which are somewhat expensive to compute:; - `type`; - `isherm`; - `istp`; - `iscp`; - `ishp` (added in #452). Of these, `type` and `isherm` are cached by `Qobj._type` and `Qobj._isherm`, respectively. These should be unified, so that the other three are also cached properly. Moreover, we should add unit tests to make sure that this caching is properly invalidated under at least some reasonably common manipulations. For instance, with the caching of `type`, it can sometimes fail in unexpected ways to build an object up then redefine its `dims`:. ``` python; >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type). >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> print(J.type); >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type); ```. The first of these two snippets correctly prints `super`, while the extra `print(J.type)` in the second snippet causes it to cache `type` and print `oper` twice. An experienced user can of course invalidate the cache with `J._type = None`, but that is somewhat counter-intuitive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/453
https://github.com/qutip/qutip/issues/453:1203,Performance,cache,cache,1203,"Currently, `Qobj` has several attributes which are somewhat expensive to compute:; - `type`; - `isherm`; - `istp`; - `iscp`; - `ishp` (added in #452). Of these, `type` and `isherm` are cached by `Qobj._type` and `Qobj._isherm`, respectively. These should be unified, so that the other three are also cached properly. Moreover, we should add unit tests to make sure that this caching is properly invalidated under at least some reasonably common manipulations. For instance, with the caching of `type`, it can sometimes fail in unexpected ways to build an object up then redefine its `dims`:. ``` python; >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type). >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> print(J.type); >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type); ```. The first of these two snippets correctly prints `super`, while the extra `print(J.type)` in the second snippet causes it to cache `type` and print `oper` twice. An experienced user can of course invalidate the cache with `J._type = None`, but that is somewhat counter-intuitive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/453
https://github.com/qutip/qutip/issues/453:346,Testability,test,tests,346,"Currently, `Qobj` has several attributes which are somewhat expensive to compute:; - `type`; - `isherm`; - `istp`; - `iscp`; - `ishp` (added in #452). Of these, `type` and `isherm` are cached by `Qobj._type` and `Qobj._isherm`, respectively. These should be unified, so that the other three are also cached properly. Moreover, we should add unit tests to make sure that this caching is properly invalidated under at least some reasonably common manipulations. For instance, with the caching of `type`, it can sometimes fail in unexpected ways to build an object up then redefine its `dims`:. ``` python; >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type). >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> print(J.type); >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type); ```. The first of these two snippets correctly prints `super`, while the extra `print(J.type)` in the second snippet causes it to cache `type` and print `oper` twice. An experienced user can of course invalidate the cache with `J._type = None`, but that is somewhat counter-intuitive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/453
https://github.com/qutip/qutip/issues/453:1261,Usability,intuit,intuitive,1261,"Currently, `Qobj` has several attributes which are somewhat expensive to compute:; - `type`; - `isherm`; - `istp`; - `iscp`; - `ishp` (added in #452). Of these, `type` and `isherm` are cached by `Qobj._type` and `Qobj._isherm`, respectively. These should be unified, so that the other three are also cached properly. Moreover, we should add unit tests to make sure that this caching is properly invalidated under at least some reasonably common manipulations. For instance, with the caching of `type`, it can sometimes fail in unexpected ways to build an object up then redefine its `dims`:. ``` python; >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type). >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> print(J.type); >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type); ```. The first of these two snippets correctly prints `super`, while the extra `print(J.type)` in the second snippet causes it to cache `type` and print `oper` twice. An experienced user can of course invalidate the cache with `J._type = None`, but that is somewhat counter-intuitive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/453
https://github.com/qutip/qutip/pull/454:50,Integrability,message,messages,50,"This class allows counts and timings (and general messages) to be collected about solver performance.; These can then be reported at the end.; I could not see anything similar already in qutip. I hope I have not duplicated effort. I have been outputting some counts and timings in hsolve in order to look for efficiency improvements. They are a bit untidy at the moment, so I wanted a more tidy way to achieve the same. . Hopefully this can be used in other solvers too. I intend to make the control stats subclass from this at some point.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/454
https://github.com/qutip/qutip/pull/454:89,Performance,perform,performance,89,"This class allows counts and timings (and general messages) to be collected about solver performance.; These can then be reported at the end.; I could not see anything similar already in qutip. I hope I have not duplicated effort. I have been outputting some counts and timings in hsolve in order to look for efficiency improvements. They are a bit untidy at the moment, so I wanted a more tidy way to achieve the same. . Hopefully this can be used in other solvers too. I intend to make the control stats subclass from this at some point.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/454
https://github.com/qutip/qutip/pull/455:22,Modifiability,variab,variable,22,"Clarification of some variable naming to attempt to link with literature and also be usable without having to read the papers.; Switch to a class module. In line with recent work from @arnelg ; Moved to nonmarkov folder, as this is a non-Markovian approx method. Old file remains with deprecated function, just in case anyone was using it. This now links to the new instance method.; Many efficiency improvements (now up to 10x faster). Test added. . Will provide a notebook example soon. Then some documentation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/455
https://github.com/qutip/qutip/pull/455:437,Testability,Test,Test,437,"Clarification of some variable naming to attempt to link with literature and also be usable without having to read the papers.; Switch to a class module. In line with recent work from @arnelg ; Moved to nonmarkov folder, as this is a non-Markovian approx method. Old file remains with deprecated function, just in case anyone was using it. This now links to the new instance method.; Many efficiency improvements (now up to 10x faster). Test added. . Will provide a notebook example soon. Then some documentation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/455
https://github.com/qutip/qutip/pull/455:85,Usability,usab,usable,85,"Clarification of some variable naming to attempt to link with literature and also be usable without having to read the papers.; Switch to a class module. In line with recent work from @arnelg ; Moved to nonmarkov folder, as this is a non-Markovian approx method. Old file remains with deprecated function, just in case anyone was using it. This now links to the new instance method.; Many efficiency improvements (now up to 10x faster). Test added. . Will provide a notebook example soon. Then some documentation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/455
https://github.com/qutip/qutip/pull/456:378,Testability,test,tests,378,"This PR is very much still in progress, but adds three very nice new features inspired by the rather widespread interest in diamond norms (see, for example, pyGSTi, SchattenNorms.jl, QETLAB). Having them in QuTiP should help a lot. I've run some informal checks against other libraries, and the results returned by the new dnorm method agree pretty well; I'll write more formal tests soon. Adding tensor swap and dual channel functionality is helpful in writing specialized cases for dnorm based on the observation that the diamond norm for positive maps is the same as the completely-bounded infinity norm (see [Johnston and Kribs](http://arxiv.org/pdf/1102.0948v2.pdf) and Watrous' notes). I hope to have this case added to dnorm soon as well, but I wanted to focus on making sure that the prerequisite features are included and well-tested. Thanks to @ysanders for pointing out that CVXPY has come a long way recently. With that library in place, I think it's a good time to get dnorm() out there.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/456
https://github.com/qutip/qutip/pull/456:836,Testability,test,tested,836,"This PR is very much still in progress, but adds three very nice new features inspired by the rather widespread interest in diamond norms (see, for example, pyGSTi, SchattenNorms.jl, QETLAB). Having them in QuTiP should help a lot. I've run some informal checks against other libraries, and the results returned by the new dnorm method agree pretty well; I'll write more formal tests soon. Adding tensor swap and dual channel functionality is helpful in writing specialized cases for dnorm based on the observation that the diamond norm for positive maps is the same as the completely-bounded infinity norm (see [Johnston and Kribs](http://arxiv.org/pdf/1102.0948v2.pdf) and Watrous' notes). I hope to have this case added to dnorm soon as well, but I wanted to focus on making sure that the prerequisite features are included and well-tested. Thanks to @ysanders for pointing out that CVXPY has come a long way recently. With that library in place, I think it's a good time to get dnorm() out there.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/456
https://github.com/qutip/qutip/pull/457:103,Integrability,depend,dependent,103,The correlation solvers were rewritten using args=None that is incompatible with the mesolver for time-dependent systems. This fixes that by replacing with args={}.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/457
https://github.com/qutip/qutip/pull/458:91,Testability,test,tests,91,- Removed yield commands as they output to the console.; - Removed the lgmres steady state tests since this will be removed.; - Fixed test name going over 80 chars.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/458
https://github.com/qutip/qutip/pull/458:134,Testability,test,test,134,- Removed yield commands as they output to the console.; - Removed the lgmres steady state tests since this will be removed.; - Fixed test name going over 80 chars.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/458
https://github.com/qutip/qutip/pull/459:44,Security,access,access,44,"This will be a collection of functions that access the sparse features in the Intel MKL:. 1) Parallel CSR SpMV. 2) Parallel direct sparse LU factorization. I have yet to work out a nice way of importing the MKL library, so these functions will not work unless the path to the MKL is modified by hand. My thinking is to look at the python version string to check for the Anaconda or Intel Python distros, and if found, find the MKL in the known locations for each distro and platform. Intel said they would expose this functionality in a later version of their distro.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/459
https://github.com/qutip/qutip/pull/459:506,Security,expose,expose,506,"This will be a collection of functions that access the sparse features in the Intel MKL:. 1) Parallel CSR SpMV. 2) Parallel direct sparse LU factorization. I have yet to work out a nice way of importing the MKL library, so these functions will not work unless the path to the MKL is modified by hand. My thinking is to look at the python version string to check for the Anaconda or Intel Python distros, and if found, find the MKL in the known locations for each distro and platform. Intel said they would expose this functionality in a later version of their distro.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/459
https://github.com/qutip/qutip/pull/461:135,Testability,Test,Test,135,"A new iterative method using Clenshaw summation is implemented. It is numerically stable and fast (2-3 times faster than 'iterative'). Test:. ```; import matplotlib.pyplot as plt; from qutip import *; import numpy as np. xvec=np.linspace(-10,10,101);yvec=xvec;X,Y = np.meshgrid(xvec, yvec); psi=coherent(100,7.3*np.exp(1j*0.5)); rho0 = ket2dm(psi); WW = wigner(rho0,xvec,yvec,method='iterative'); WWc = wigner(rho0,xvec,yvec,method='clenshaw'). plt.contourf(X,Y,WW,100,cmap=plt.cm.viridis); plt.show(); plt.contourf(X,Y,WWc,100,cmap=plt.cm.viridis); plt.show(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/461
https://github.com/qutip/qutip/issues/462:866,Availability,error,error,866,"Alex has asked about having a faster expm method for Qobj objects. Having looked into it a bit, here are my thoughts:; - We should check to see if the Qobj is diag, and if so just do the exp on the elements. Otherwise do a dense expm. This is really what matlab does. This will be done in parallel if connected to a good BLAS.; - I have yet to find a real-world usage case where the resulting expm is not a dense matrix. Therefore, the above suggestion seems to be optimal.; - There is a bug in our expm code for a particular kind of matrix, this happens to be a particular diagonal matrix.; - There is a bug in the scipy.sparse.linalg.expm function that is even more serious, and was reported.; - Someone discussed using approximation methods for the expm in the control module. This is an interesting idea in general, but we would need some way of quantifying the error in the approximation. This has probably already been done in the literature somewhere.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/462
https://github.com/qutip/qutip/pull/464:0,Deployability,Update,Updated,0,"Updated expm function. Fixes bug in previous version. Defaults to sparse=False as resulting matrix is almost always dense, and the algorithm runs about 10x faster.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/464
https://github.com/qutip/qutip/pull/465:69,Safety,avoid,avoided,69,Having a warning that appears every time qutip is imported should be avoided. That is unless we want a ton of questions on the google help group.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/465
https://github.com/qutip/qutip/pull/466:146,Performance,perform,performs,146,"The new version of expm that I grabbed from Expokit does not behave quite as well as the SciPy version. After a bit of testing, the SciPy version performs the best overall. For our purposes, I think that either method would be sufficient. However, the SciPy version is the current best algorithm, and replacing as much code as possible with SciPy code is probably a good thing. This code still defaults to the dense method.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/466
https://github.com/qutip/qutip/pull/466:119,Testability,test,testing,119,"The new version of expm that I grabbed from Expokit does not behave quite as well as the SciPy version. After a bit of testing, the SciPy version performs the best overall. For our purposes, I think that either method would be sufficient. However, the SciPy version is the current best algorithm, and replacing as much code as possible with SciPy code is probably a good thing. This code still defaults to the dense method.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/466
https://github.com/qutip/qutip/issues/469:139,Availability,error,error,139,"Hi,; I just recently installed qutip on Canopy using a Windows Binary. When I try to run one of the tests, e.g. test_wigner.py, I get this error:. ---. AttributeError Traceback (most recent call last); C:\Users\David Feng\Desktop\qutip-3.1.0\qutip\tests\test_wigner.py in <module>(); 37 from numpy.testing import assert_, run_module_suite, assert_equal; 38 ; ---> 39 from qutip.states import coherent, fock; 40 from qutip.wigner import wigner; 41 from qutip.random_objects import rand_dm, rand_ket. C:\Users\David Feng\Desktop\qutip-3.1.0\qutip__init__.pyc in <module>(); 60 qutip.settings.ipython = True; 61 except:; ---> 62 qutip.settings.ipython = False; 63 ; 64 # -----------------------------------------------------------------------------. AttributeError: 'module' object has no attribute 'settings' . The AttributeError also appears when I simply try to import qutip from the command line. I'm not too familiar with Python scripting so any assistance on the matter would be greatly appreciated. Thank you!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/469
https://github.com/qutip/qutip/issues/469:21,Deployability,install,installed,21,"Hi,; I just recently installed qutip on Canopy using a Windows Binary. When I try to run one of the tests, e.g. test_wigner.py, I get this error:. ---. AttributeError Traceback (most recent call last); C:\Users\David Feng\Desktop\qutip-3.1.0\qutip\tests\test_wigner.py in <module>(); 37 from numpy.testing import assert_, run_module_suite, assert_equal; 38 ; ---> 39 from qutip.states import coherent, fock; 40 from qutip.wigner import wigner; 41 from qutip.random_objects import rand_dm, rand_ket. C:\Users\David Feng\Desktop\qutip-3.1.0\qutip__init__.pyc in <module>(); 60 qutip.settings.ipython = True; 61 except:; ---> 62 qutip.settings.ipython = False; 63 ; 64 # -----------------------------------------------------------------------------. AttributeError: 'module' object has no attribute 'settings' . The AttributeError also appears when I simply try to import qutip from the command line. I'm not too familiar with Python scripting so any assistance on the matter would be greatly appreciated. Thank you!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/469
https://github.com/qutip/qutip/issues/469:100,Testability,test,tests,100,"Hi,; I just recently installed qutip on Canopy using a Windows Binary. When I try to run one of the tests, e.g. test_wigner.py, I get this error:. ---. AttributeError Traceback (most recent call last); C:\Users\David Feng\Desktop\qutip-3.1.0\qutip\tests\test_wigner.py in <module>(); 37 from numpy.testing import assert_, run_module_suite, assert_equal; 38 ; ---> 39 from qutip.states import coherent, fock; 40 from qutip.wigner import wigner; 41 from qutip.random_objects import rand_dm, rand_ket. C:\Users\David Feng\Desktop\qutip-3.1.0\qutip__init__.pyc in <module>(); 60 qutip.settings.ipython = True; 61 except:; ---> 62 qutip.settings.ipython = False; 63 ; 64 # -----------------------------------------------------------------------------. AttributeError: 'module' object has no attribute 'settings' . The AttributeError also appears when I simply try to import qutip from the command line. I'm not too familiar with Python scripting so any assistance on the matter would be greatly appreciated. Thank you!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/469
https://github.com/qutip/qutip/issues/469:248,Testability,test,tests,248,"Hi,; I just recently installed qutip on Canopy using a Windows Binary. When I try to run one of the tests, e.g. test_wigner.py, I get this error:. ---. AttributeError Traceback (most recent call last); C:\Users\David Feng\Desktop\qutip-3.1.0\qutip\tests\test_wigner.py in <module>(); 37 from numpy.testing import assert_, run_module_suite, assert_equal; 38 ; ---> 39 from qutip.states import coherent, fock; 40 from qutip.wigner import wigner; 41 from qutip.random_objects import rand_dm, rand_ket. C:\Users\David Feng\Desktop\qutip-3.1.0\qutip__init__.pyc in <module>(); 60 qutip.settings.ipython = True; 61 except:; ---> 62 qutip.settings.ipython = False; 63 ; 64 # -----------------------------------------------------------------------------. AttributeError: 'module' object has no attribute 'settings' . The AttributeError also appears when I simply try to import qutip from the command line. I'm not too familiar with Python scripting so any assistance on the matter would be greatly appreciated. Thank you!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/469
https://github.com/qutip/qutip/issues/469:298,Testability,test,testing,298,"Hi,; I just recently installed qutip on Canopy using a Windows Binary. When I try to run one of the tests, e.g. test_wigner.py, I get this error:. ---. AttributeError Traceback (most recent call last); C:\Users\David Feng\Desktop\qutip-3.1.0\qutip\tests\test_wigner.py in <module>(); 37 from numpy.testing import assert_, run_module_suite, assert_equal; 38 ; ---> 39 from qutip.states import coherent, fock; 40 from qutip.wigner import wigner; 41 from qutip.random_objects import rand_dm, rand_ket. C:\Users\David Feng\Desktop\qutip-3.1.0\qutip__init__.pyc in <module>(); 60 qutip.settings.ipython = True; 61 except:; ---> 62 qutip.settings.ipython = False; 63 ; 64 # -----------------------------------------------------------------------------. AttributeError: 'module' object has no attribute 'settings' . The AttributeError also appears when I simply try to import qutip from the command line. I'm not too familiar with Python scripting so any assistance on the matter would be greatly appreciated. Thank you!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/469
https://github.com/qutip/qutip/issues/469:848,Usability,simpl,simply,848,"Hi,; I just recently installed qutip on Canopy using a Windows Binary. When I try to run one of the tests, e.g. test_wigner.py, I get this error:. ---. AttributeError Traceback (most recent call last); C:\Users\David Feng\Desktop\qutip-3.1.0\qutip\tests\test_wigner.py in <module>(); 37 from numpy.testing import assert_, run_module_suite, assert_equal; 38 ; ---> 39 from qutip.states import coherent, fock; 40 from qutip.wigner import wigner; 41 from qutip.random_objects import rand_dm, rand_ket. C:\Users\David Feng\Desktop\qutip-3.1.0\qutip__init__.pyc in <module>(); 60 qutip.settings.ipython = True; 61 except:; ---> 62 qutip.settings.ipython = False; 63 ; 64 # -----------------------------------------------------------------------------. AttributeError: 'module' object has no attribute 'settings' . The AttributeError also appears when I simply try to import qutip from the command line. I'm not too familiar with Python scripting so any assistance on the matter would be greatly appreciated. Thank you!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/469
https://github.com/qutip/qutip/pull/470:632,Deployability,Integrat,Integrating,632,"Here is a parallel version of the spmv_csr function that we use almost everywhere. I get quite a bit of speedup as the dimensionality of the system goes above ~500 or so states (depends on the problem though). Here is a plot of the speedup from serial for a spin-chain. ![parallel_spmv](https://cloud.githubusercontent.com/assets/1249193/14974780/82bc2754-10b6-11e6-94cb-35c046be5f97.png). It uses the openmp from cython so the GCC is required. On linux this is fine, but on OSX the GCC needs to come from homebrew or macports as the builtin clang does not support openmp. On Win, my guess is that the intel compiler could be used. Integrating this into the various solvers will be done in the next couple of days.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/470
https://github.com/qutip/qutip/pull/470:178,Integrability,depend,depends,178,"Here is a parallel version of the spmv_csr function that we use almost everywhere. I get quite a bit of speedup as the dimensionality of the system goes above ~500 or so states (depends on the problem though). Here is a plot of the speedup from serial for a spin-chain. ![parallel_spmv](https://cloud.githubusercontent.com/assets/1249193/14974780/82bc2754-10b6-11e6-94cb-35c046be5f97.png). It uses the openmp from cython so the GCC is required. On linux this is fine, but on OSX the GCC needs to come from homebrew or macports as the builtin clang does not support openmp. On Win, my guess is that the intel compiler could be used. Integrating this into the various solvers will be done in the next couple of days.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/470
https://github.com/qutip/qutip/pull/470:632,Integrability,Integrat,Integrating,632,"Here is a parallel version of the spmv_csr function that we use almost everywhere. I get quite a bit of speedup as the dimensionality of the system goes above ~500 or so states (depends on the problem though). Here is a plot of the speedup from serial for a spin-chain. ![parallel_spmv](https://cloud.githubusercontent.com/assets/1249193/14974780/82bc2754-10b6-11e6-94cb-35c046be5f97.png). It uses the openmp from cython so the GCC is required. On linux this is fine, but on OSX the GCC needs to come from homebrew or macports as the builtin clang does not support openmp. On Win, my guess is that the intel compiler could be used. Integrating this into the various solvers will be done in the next couple of days.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/470
https://github.com/qutip/qutip/pull/471:57,Integrability,depend,dependent,57,This prevents intermediate calls to Python from the time-dependent string format.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/471
https://github.com/qutip/qutip/issues/472:134,Availability,error,error,134,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:37,Deployability,release,released,37,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:185,Deployability,update,update,185,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:260,Deployability,release,releases,260,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:283,Deployability,Release,Release,283,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:308,Deployability,Release,Release,308,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:487,Deployability,configurat,configuration,487,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:573,Deployability,release,releases,573,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:706,Deployability,release,releases,706,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:487,Modifiability,config,configuration,487,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:363,Security,authenticat,authenticated,363,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/472:436,Security,secur,secure,436,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/472
https://github.com/qutip/qutip/issues/475:322,Security,access,accessible,322,"As per discussion in #474, [this notebook](http://nbviewer.jupyter.org/gist/cgranade/d20fcf3e9907eb26c7fc2f6a8d855918) describes the semantics for a proposed `Qobj.__call__` method that would generalize action on density operators and state vectors by superoperators and unitary operators. This would help make QuTiP more accessible and provide a consistent API for several closely-related group actions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/475
https://github.com/qutip/qutip/issues/479:545,Availability,error,error,545,"I'm still fairly new to QuTiP but I've found that `mesolve` allows `H` and `rho0` to have different dimensions. Of course getting it right is the users responsibility, an informative warning may be useful. A minimal example is as follows:. ```; from qutip import *; import numpy as np. N = 3; a = tensor(destroy(N),identity(2)); sz = tensor(identity(N),sigmaz()). H = sz*a.dag() + sz.dag()*a; collapse = [a]; tlist = np.linspace(0,1,100); solution = mesolve(H, basis(2,0), tlist, collapse, [a.dag()*a]); ```. which gives a numerical integration error:; `UserWarning: zvode: Repeated convergence failures. (Perhaps bad Jacobian supplied or wrong choice of MF or tolerances.)`; Rather than a more direct warning about the (more likely) problem of mis-matched Hilbert spaces. I'm happy to add a check to the `mesolve` function and submit a PR, but I wanted to be sure that I'm not missing some use case where `H` and `rho0` should be allowed to differ.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/479
https://github.com/qutip/qutip/issues/479:595,Availability,failure,failures,595,"I'm still fairly new to QuTiP but I've found that `mesolve` allows `H` and `rho0` to have different dimensions. Of course getting it right is the users responsibility, an informative warning may be useful. A minimal example is as follows:. ```; from qutip import *; import numpy as np. N = 3; a = tensor(destroy(N),identity(2)); sz = tensor(identity(N),sigmaz()). H = sz*a.dag() + sz.dag()*a; collapse = [a]; tlist = np.linspace(0,1,100); solution = mesolve(H, basis(2,0), tlist, collapse, [a.dag()*a]); ```. which gives a numerical integration error:; `UserWarning: zvode: Repeated convergence failures. (Perhaps bad Jacobian supplied or wrong choice of MF or tolerances.)`; Rather than a more direct warning about the (more likely) problem of mis-matched Hilbert spaces. I'm happy to add a check to the `mesolve` function and submit a PR, but I wanted to be sure that I'm not missing some use case where `H` and `rho0` should be allowed to differ.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/479
https://github.com/qutip/qutip/issues/479:661,Availability,toler,tolerances,661,"I'm still fairly new to QuTiP but I've found that `mesolve` allows `H` and `rho0` to have different dimensions. Of course getting it right is the users responsibility, an informative warning may be useful. A minimal example is as follows:. ```; from qutip import *; import numpy as np. N = 3; a = tensor(destroy(N),identity(2)); sz = tensor(identity(N),sigmaz()). H = sz*a.dag() + sz.dag()*a; collapse = [a]; tlist = np.linspace(0,1,100); solution = mesolve(H, basis(2,0), tlist, collapse, [a.dag()*a]); ```. which gives a numerical integration error:; `UserWarning: zvode: Repeated convergence failures. (Perhaps bad Jacobian supplied or wrong choice of MF or tolerances.)`; Rather than a more direct warning about the (more likely) problem of mis-matched Hilbert spaces. I'm happy to add a check to the `mesolve` function and submit a PR, but I wanted to be sure that I'm not missing some use case where `H` and `rho0` should be allowed to differ.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/479
https://github.com/qutip/qutip/issues/479:533,Deployability,integrat,integration,533,"I'm still fairly new to QuTiP but I've found that `mesolve` allows `H` and `rho0` to have different dimensions. Of course getting it right is the users responsibility, an informative warning may be useful. A minimal example is as follows:. ```; from qutip import *; import numpy as np. N = 3; a = tensor(destroy(N),identity(2)); sz = tensor(identity(N),sigmaz()). H = sz*a.dag() + sz.dag()*a; collapse = [a]; tlist = np.linspace(0,1,100); solution = mesolve(H, basis(2,0), tlist, collapse, [a.dag()*a]); ```. which gives a numerical integration error:; `UserWarning: zvode: Repeated convergence failures. (Perhaps bad Jacobian supplied or wrong choice of MF or tolerances.)`; Rather than a more direct warning about the (more likely) problem of mis-matched Hilbert spaces. I'm happy to add a check to the `mesolve` function and submit a PR, but I wanted to be sure that I'm not missing some use case where `H` and `rho0` should be allowed to differ.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/479
https://github.com/qutip/qutip/issues/479:533,Integrability,integrat,integration,533,"I'm still fairly new to QuTiP but I've found that `mesolve` allows `H` and `rho0` to have different dimensions. Of course getting it right is the users responsibility, an informative warning may be useful. A minimal example is as follows:. ```; from qutip import *; import numpy as np. N = 3; a = tensor(destroy(N),identity(2)); sz = tensor(identity(N),sigmaz()). H = sz*a.dag() + sz.dag()*a; collapse = [a]; tlist = np.linspace(0,1,100); solution = mesolve(H, basis(2,0), tlist, collapse, [a.dag()*a]); ```. which gives a numerical integration error:; `UserWarning: zvode: Repeated convergence failures. (Perhaps bad Jacobian supplied or wrong choice of MF or tolerances.)`; Rather than a more direct warning about the (more likely) problem of mis-matched Hilbert spaces. I'm happy to add a check to the `mesolve` function and submit a PR, but I wanted to be sure that I'm not missing some use case where `H` and `rho0` should be allowed to differ.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/479
https://github.com/qutip/qutip/issues/480:1026,Availability,reliab,reliable,1026,"Hello. As qutip is new to me, I'am not shure if there is a real problem or if it is just poor understanding. Well, here is my issue:; I'd like to get the the final state after solving some unitary time evolution with `mesolve`. The input state is a tensor product of three Fock states.; `psi0 = tensor(basis(N+1,0), basis(N+1,0), basis(N+1,N))`. Then I do the evolution like this:; `H = tensor(a, b, c.dag() * c.dag()) - tensor(a.dag(), b.dag(), c * c)`; Operators a,b and c are defined as `destroy(N+1)`.; `times = np.linspace(0.0, 2.0, 100.0)`; `opts = Options(store_states=False, store_final_state=True)`; `result = mesolve(H, psi0, times, [], [numAop,numBop,numCop], options=opts)`. Now I observe different dimension of input and output state:; `print(psi0.dims, psi0.shape)`; `print(result.final_state.dims, result.final_state.shape)`; gives:; [[41, 41, 41], [1, 1, 1]] [68921, 1]; [[68921], [1]] [68921, 1]; So somehow the dimension structure is lost. The results for the expectation values of the number operators look reliable. So I guess that the time evolution itself worked fine.; Kind regards; Fabian",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/480
https://github.com/qutip/qutip/issues/482:189,Deployability,release,release,189,"Hey,. It seems the sigmam() operator incorrectly returns True when tested with isherm. I think this is only an issue in the developer version 3.2.0.dev- (it does not happen with the stable release). The following code reproduces the issue:. ``` python; import qutip as qu. print(""My version:""); print(qu.version.version). mysigmam = qu.basis(2,1) * qu.basis(2,0).dag(); print(""My sigmam:""); print(mysigmam); print(""is hermitian?:""); print(mysigmam.isherm). print(""Qutip sigmam:""); print(qu.operators.sigmam()); print(""is hermitian?:""); print(qu.operators.sigmam().isherm); ```. Which returns, on my machine:. ```; My version:; 3.2.0.dev-; My sigmam:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = False; Qobj data =; [[ 0. 0.]; [ 1. 0.]]; is hermitian?:; False; Qutip sigmam:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.]; [ 1. 0.]]; is hermitian?:; True; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/482
https://github.com/qutip/qutip/issues/482:67,Testability,test,tested,67,"Hey,. It seems the sigmam() operator incorrectly returns True when tested with isherm. I think this is only an issue in the developer version 3.2.0.dev- (it does not happen with the stable release). The following code reproduces the issue:. ``` python; import qutip as qu. print(""My version:""); print(qu.version.version). mysigmam = qu.basis(2,1) * qu.basis(2,0).dag(); print(""My sigmam:""); print(mysigmam); print(""is hermitian?:""); print(mysigmam.isherm). print(""Qutip sigmam:""); print(qu.operators.sigmam()); print(""is hermitian?:""); print(qu.operators.sigmam().isherm); ```. Which returns, on my machine:. ```; My version:; 3.2.0.dev-; My sigmam:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = False; Qobj data =; [[ 0. 0.]; [ 1. 0.]]; is hermitian?:; False; Qutip sigmam:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.]; [ 1. 0.]]; is hermitian?:; True; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/482
https://github.com/qutip/qutip/issues/484:80,Availability,error,errors,80,"As noted by @ajgpitch in #476, Travis CI is currently raising a large number of errors, as every call to `dnorm()` results in a `SolverError`. I am in the process of investigating this problem, but have not yet been able to reproduce the test failures locally. It appears as though the failures only occur when MKL and CVXPY are used together, but I am able to use MKL and CVXPY together fine locally.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/484
https://github.com/qutip/qutip/issues/484:243,Availability,failure,failures,243,"As noted by @ajgpitch in #476, Travis CI is currently raising a large number of errors, as every call to `dnorm()` results in a `SolverError`. I am in the process of investigating this problem, but have not yet been able to reproduce the test failures locally. It appears as though the failures only occur when MKL and CVXPY are used together, but I am able to use MKL and CVXPY together fine locally.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/484
https://github.com/qutip/qutip/issues/484:286,Availability,failure,failures,286,"As noted by @ajgpitch in #476, Travis CI is currently raising a large number of errors, as every call to `dnorm()` results in a `SolverError`. I am in the process of investigating this problem, but have not yet been able to reproduce the test failures locally. It appears as though the failures only occur when MKL and CVXPY are used together, but I am able to use MKL and CVXPY together fine locally.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/484
https://github.com/qutip/qutip/issues/484:238,Testability,test,test,238,"As noted by @ajgpitch in #476, Travis CI is currently raising a large number of errors, as every call to `dnorm()` results in a `SolverError`. I am in the process of investigating this problem, but have not yet been able to reproduce the test failures locally. It appears as though the failures only occur when MKL and CVXPY are used together, but I am able to use MKL and CVXPY together fine locally.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/484
https://github.com/qutip/qutip/pull/486:208,Availability,error,errors,208,"- Fixed the dims on the final_state output in mesolve and sesolve.; - Also explicitly set the isherm on ouput from mesolve to be True, since the output should be viewed as aa DM regardless if small numerical errors may the isherm check fail.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/486
https://github.com/qutip/qutip/pull/487:62,Availability,failure,failure,62,This PR addresses #484 by skipping dnorm() tests in the known failure case that MKL is present (see #484 and cvxopt/cvxopt#57).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/487
https://github.com/qutip/qutip/pull/487:43,Testability,test,tests,43,This PR addresses #484 by skipping dnorm() tests in the known failure case that MKL is present (see #484 and cvxopt/cvxopt#57).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/487
https://github.com/qutip/qutip/pull/488:287,Usability,simpl,simple,287,"This PR makes `Qobj` a callable, in keeping with the proposed semantics discussed in #475. Hopefully, this should make it easier for newcomers and experienced users alike to use the superoperator functionality by removing the need to use `operator_to_vector` and `vector_to_operator` in simple cases.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/488
https://github.com/qutip/qutip/pull/489:44,Deployability,install,install,44,"As raised in #426, QuTiP currently does not install correctly if listed in the requirements.txt for an external project unless the target environment already has numpy installed. This is due to the use of `numpy.distutils` in the current `setup.py`, such that this PR attempts to solve the issue by falling back to setuptools and then distutils when numpy is missing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/489
https://github.com/qutip/qutip/pull/489:168,Deployability,install,installed,168,"As raised in #426, QuTiP currently does not install correctly if listed in the requirements.txt for an external project unless the target environment already has numpy installed. This is due to the use of `numpy.distutils` in the current `setup.py`, such that this PR attempts to solve the issue by falling back to setuptools and then distutils when numpy is missing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/489
https://github.com/qutip/qutip/issues/490:920,Energy Efficiency,green,green,920,"Using Time dependent Hamiltonian in mcsolve and mesolve product different result for expectation value for `sigmay()`. It seems to work well for expectation value for `sigmax()` or `sigmaz()`. I wonder if dealing with complex number leads to this or there is another issue. This is a simple code illustrating the problem. ```; from qutip import *; from scipy import *; from pylab import*; #sigmay problem. psi0 = (basis(2,0) + basis(2,1)).unit() ; rho0 = psi0*psi0.dag(). H0 = 0*sigmax(); H1 = sigmax(); print(psi0); print(H0*psi0); H2 = sigmaz(); def H1_coeff(t,args):; return t-1. def H2_coeff(t,args):; return -t. h_t = [H0,[H1, H1_coeff],; [H2, H2_coeff]]. ntraj = 500. tlist = linspace(0, 3, 100); medata = mesolve(h_t, rho0, tlist, [], [sigmay()], args = {}); mcdata = mcsolve(h_t, psi0, tlist, [], [sigmay()], ntraj = ntraj, args = {}). fig,axes = subplots(1,1,figsize=(12,6)); axes.plot(mcdata.expect[0], color=""green"", alpha =0.6, label = ""mcsolve""); axes.plot(medata.expect[0], color=""blue"", alpha =0.6, label = ""mesolve""); axes.set_xlabel(r'$\frac{t}{t_f}$'); axes.set_ylabel('Expectation value'); axes.legend((""mcsolve"", ""mesolve"")). show(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/490
https://github.com/qutip/qutip/issues/490:11,Integrability,depend,dependent,11,"Using Time dependent Hamiltonian in mcsolve and mesolve product different result for expectation value for `sigmay()`. It seems to work well for expectation value for `sigmax()` or `sigmaz()`. I wonder if dealing with complex number leads to this or there is another issue. This is a simple code illustrating the problem. ```; from qutip import *; from scipy import *; from pylab import*; #sigmay problem. psi0 = (basis(2,0) + basis(2,1)).unit() ; rho0 = psi0*psi0.dag(). H0 = 0*sigmax(); H1 = sigmax(); print(psi0); print(H0*psi0); H2 = sigmaz(); def H1_coeff(t,args):; return t-1. def H2_coeff(t,args):; return -t. h_t = [H0,[H1, H1_coeff],; [H2, H2_coeff]]. ntraj = 500. tlist = linspace(0, 3, 100); medata = mesolve(h_t, rho0, tlist, [], [sigmay()], args = {}); mcdata = mcsolve(h_t, psi0, tlist, [], [sigmay()], ntraj = ntraj, args = {}). fig,axes = subplots(1,1,figsize=(12,6)); axes.plot(mcdata.expect[0], color=""green"", alpha =0.6, label = ""mcsolve""); axes.plot(medata.expect[0], color=""blue"", alpha =0.6, label = ""mesolve""); axes.set_xlabel(r'$\frac{t}{t_f}$'); axes.set_ylabel('Expectation value'); axes.legend((""mcsolve"", ""mesolve"")). show(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/490
https://github.com/qutip/qutip/issues/490:284,Usability,simpl,simple,284,"Using Time dependent Hamiltonian in mcsolve and mesolve product different result for expectation value for `sigmay()`. It seems to work well for expectation value for `sigmax()` or `sigmaz()`. I wonder if dealing with complex number leads to this or there is another issue. This is a simple code illustrating the problem. ```; from qutip import *; from scipy import *; from pylab import*; #sigmay problem. psi0 = (basis(2,0) + basis(2,1)).unit() ; rho0 = psi0*psi0.dag(). H0 = 0*sigmax(); H1 = sigmax(); print(psi0); print(H0*psi0); H2 = sigmaz(); def H1_coeff(t,args):; return t-1. def H2_coeff(t,args):; return -t. h_t = [H0,[H1, H1_coeff],; [H2, H2_coeff]]. ntraj = 500. tlist = linspace(0, 3, 100); medata = mesolve(h_t, rho0, tlist, [], [sigmay()], args = {}); mcdata = mcsolve(h_t, psi0, tlist, [], [sigmay()], ntraj = ntraj, args = {}). fig,axes = subplots(1,1,figsize=(12,6)); axes.plot(mcdata.expect[0], color=""green"", alpha =0.6, label = ""mcsolve""); axes.plot(medata.expect[0], color=""blue"", alpha =0.6, label = ""mesolve""); axes.set_xlabel(r'$\frac{t}{t_f}$'); axes.set_ylabel('Expectation value'); axes.legend((""mcsolve"", ""mesolve"")). show(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/490
https://github.com/qutip/qutip/issues/491:1699,Availability,error,error,1699,"I am trying to install qutip with the fortran monte-carlo solver. I'm installing over a version of qutip which did not have this option, so my installation command is:. pip install --upgrade --no-deps --force-reinstall qutip --install-option=--with-f90mc. The build fails as below. It is looking for libraries which do not exist in the MKL distribution I am using. Perhaps they existed in an earlier version ? Can anyone advise how to achieve a succesful build - I think I need to modify the link line. . Any suggestions gratefully received.; Colin. /cm/shared/apps/gcc/4.8.1/bin/gfortran -Wall -g -Wall -g -shared build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_runmodule.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/fortranobject.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_precision.o build/temp.linux-x86_64-2.7/qutip/fortran/mt19937.o build/temp.linux-x86_64-2.7/qutip/fortran/linked_list.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_general.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_hilbert.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_evolve.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_linalg.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_run.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_run-f2pywrappers2.o -L/cm/shared/apps/intel/composer_xe/2013_sp1.3.174/mkl/lib/intel64 -L/cm/shared/apps/python/2.7.9/lib -Lbuild/temp.linux-x86_64-2.7 -lzvode -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lpython2.7 -lgfortran -o build/lib.linux-x86_64-2.7/qutip/fortran/qutraj_run.so; /usr/bin/ld: cannot find -lmkl_lapack32; collect2: error: ld returned 1 exit status",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/491
https://github.com/qutip/qutip/issues/491:15,Deployability,install,install,15,"I am trying to install qutip with the fortran monte-carlo solver. I'm installing over a version of qutip which did not have this option, so my installation command is:. pip install --upgrade --no-deps --force-reinstall qutip --install-option=--with-f90mc. The build fails as below. It is looking for libraries which do not exist in the MKL distribution I am using. Perhaps they existed in an earlier version ? Can anyone advise how to achieve a succesful build - I think I need to modify the link line. . Any suggestions gratefully received.; Colin. /cm/shared/apps/gcc/4.8.1/bin/gfortran -Wall -g -Wall -g -shared build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_runmodule.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/fortranobject.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_precision.o build/temp.linux-x86_64-2.7/qutip/fortran/mt19937.o build/temp.linux-x86_64-2.7/qutip/fortran/linked_list.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_general.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_hilbert.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_evolve.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_linalg.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_run.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_run-f2pywrappers2.o -L/cm/shared/apps/intel/composer_xe/2013_sp1.3.174/mkl/lib/intel64 -L/cm/shared/apps/python/2.7.9/lib -Lbuild/temp.linux-x86_64-2.7 -lzvode -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lpython2.7 -lgfortran -o build/lib.linux-x86_64-2.7/qutip/fortran/qutraj_run.so; /usr/bin/ld: cannot find -lmkl_lapack32; collect2: error: ld returned 1 exit status",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/491
https://github.com/qutip/qutip/issues/491:70,Deployability,install,installing,70,"I am trying to install qutip with the fortran monte-carlo solver. I'm installing over a version of qutip which did not have this option, so my installation command is:. pip install --upgrade --no-deps --force-reinstall qutip --install-option=--with-f90mc. The build fails as below. It is looking for libraries which do not exist in the MKL distribution I am using. Perhaps they existed in an earlier version ? Can anyone advise how to achieve a succesful build - I think I need to modify the link line. . Any suggestions gratefully received.; Colin. /cm/shared/apps/gcc/4.8.1/bin/gfortran -Wall -g -Wall -g -shared build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_runmodule.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/fortranobject.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_precision.o build/temp.linux-x86_64-2.7/qutip/fortran/mt19937.o build/temp.linux-x86_64-2.7/qutip/fortran/linked_list.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_general.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_hilbert.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_evolve.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_linalg.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_run.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_run-f2pywrappers2.o -L/cm/shared/apps/intel/composer_xe/2013_sp1.3.174/mkl/lib/intel64 -L/cm/shared/apps/python/2.7.9/lib -Lbuild/temp.linux-x86_64-2.7 -lzvode -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lpython2.7 -lgfortran -o build/lib.linux-x86_64-2.7/qutip/fortran/qutraj_run.so; /usr/bin/ld: cannot find -lmkl_lapack32; collect2: error: ld returned 1 exit status",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/491
https://github.com/qutip/qutip/issues/491:143,Deployability,install,installation,143,"I am trying to install qutip with the fortran monte-carlo solver. I'm installing over a version of qutip which did not have this option, so my installation command is:. pip install --upgrade --no-deps --force-reinstall qutip --install-option=--with-f90mc. The build fails as below. It is looking for libraries which do not exist in the MKL distribution I am using. Perhaps they existed in an earlier version ? Can anyone advise how to achieve a succesful build - I think I need to modify the link line. . Any suggestions gratefully received.; Colin. /cm/shared/apps/gcc/4.8.1/bin/gfortran -Wall -g -Wall -g -shared build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_runmodule.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/fortranobject.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_precision.o build/temp.linux-x86_64-2.7/qutip/fortran/mt19937.o build/temp.linux-x86_64-2.7/qutip/fortran/linked_list.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_general.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_hilbert.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_evolve.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_linalg.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_run.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_run-f2pywrappers2.o -L/cm/shared/apps/intel/composer_xe/2013_sp1.3.174/mkl/lib/intel64 -L/cm/shared/apps/python/2.7.9/lib -Lbuild/temp.linux-x86_64-2.7 -lzvode -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lpython2.7 -lgfortran -o build/lib.linux-x86_64-2.7/qutip/fortran/qutraj_run.so; /usr/bin/ld: cannot find -lmkl_lapack32; collect2: error: ld returned 1 exit status",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/491
https://github.com/qutip/qutip/issues/491:173,Deployability,install,install,173,"I am trying to install qutip with the fortran monte-carlo solver. I'm installing over a version of qutip which did not have this option, so my installation command is:. pip install --upgrade --no-deps --force-reinstall qutip --install-option=--with-f90mc. The build fails as below. It is looking for libraries which do not exist in the MKL distribution I am using. Perhaps they existed in an earlier version ? Can anyone advise how to achieve a succesful build - I think I need to modify the link line. . Any suggestions gratefully received.; Colin. /cm/shared/apps/gcc/4.8.1/bin/gfortran -Wall -g -Wall -g -shared build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_runmodule.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/fortranobject.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_precision.o build/temp.linux-x86_64-2.7/qutip/fortran/mt19937.o build/temp.linux-x86_64-2.7/qutip/fortran/linked_list.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_general.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_hilbert.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_evolve.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_linalg.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_run.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_run-f2pywrappers2.o -L/cm/shared/apps/intel/composer_xe/2013_sp1.3.174/mkl/lib/intel64 -L/cm/shared/apps/python/2.7.9/lib -Lbuild/temp.linux-x86_64-2.7 -lzvode -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lpython2.7 -lgfortran -o build/lib.linux-x86_64-2.7/qutip/fortran/qutraj_run.so; /usr/bin/ld: cannot find -lmkl_lapack32; collect2: error: ld returned 1 exit status",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/491
https://github.com/qutip/qutip/issues/491:183,Deployability,upgrade,upgrade,183,"I am trying to install qutip with the fortran monte-carlo solver. I'm installing over a version of qutip which did not have this option, so my installation command is:. pip install --upgrade --no-deps --force-reinstall qutip --install-option=--with-f90mc. The build fails as below. It is looking for libraries which do not exist in the MKL distribution I am using. Perhaps they existed in an earlier version ? Can anyone advise how to achieve a succesful build - I think I need to modify the link line. . Any suggestions gratefully received.; Colin. /cm/shared/apps/gcc/4.8.1/bin/gfortran -Wall -g -Wall -g -shared build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_runmodule.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/fortranobject.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_precision.o build/temp.linux-x86_64-2.7/qutip/fortran/mt19937.o build/temp.linux-x86_64-2.7/qutip/fortran/linked_list.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_general.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_hilbert.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_evolve.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_linalg.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_run.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_run-f2pywrappers2.o -L/cm/shared/apps/intel/composer_xe/2013_sp1.3.174/mkl/lib/intel64 -L/cm/shared/apps/python/2.7.9/lib -Lbuild/temp.linux-x86_64-2.7 -lzvode -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lpython2.7 -lgfortran -o build/lib.linux-x86_64-2.7/qutip/fortran/qutraj_run.so; /usr/bin/ld: cannot find -lmkl_lapack32; collect2: error: ld returned 1 exit status",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/491
https://github.com/qutip/qutip/issues/491:227,Deployability,install,install-option,227,"I am trying to install qutip with the fortran monte-carlo solver. I'm installing over a version of qutip which did not have this option, so my installation command is:. pip install --upgrade --no-deps --force-reinstall qutip --install-option=--with-f90mc. The build fails as below. It is looking for libraries which do not exist in the MKL distribution I am using. Perhaps they existed in an earlier version ? Can anyone advise how to achieve a succesful build - I think I need to modify the link line. . Any suggestions gratefully received.; Colin. /cm/shared/apps/gcc/4.8.1/bin/gfortran -Wall -g -Wall -g -shared build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_runmodule.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/fortranobject.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_precision.o build/temp.linux-x86_64-2.7/qutip/fortran/mt19937.o build/temp.linux-x86_64-2.7/qutip/fortran/linked_list.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_general.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_hilbert.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_evolve.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_linalg.o build/temp.linux-x86_64-2.7/qutip/fortran/qutraj_run.o build/temp.linux-x86_64-2.7/build/src.linux-x86_64-2.7/qutip/fortran/qutraj_run-f2pywrappers2.o -L/cm/shared/apps/intel/composer_xe/2013_sp1.3.174/mkl/lib/intel64 -L/cm/shared/apps/python/2.7.9/lib -Lbuild/temp.linux-x86_64-2.7 -lzvode -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lmkl_lapack32 -lmkl_lapack64 -lmkl_rt -lpthread -lpython2.7 -lgfortran -o build/lib.linux-x86_64-2.7/qutip/fortran/qutraj_run.so; /usr/bin/ld: cannot find -lmkl_lapack32; collect2: error: ld returned 1 exit status",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/491
https://github.com/qutip/qutip/issues/493:1172,Performance,optimiz,optimizing,1172,"Qobj.expm() is currently not working properly for diagonal states which have a zero in the diagonal (these zeros don't become ones). An example:. ``` python; >>> foo = qutip.Qobj([[1.,0.],[0.,0.]]); >>> foo.expm(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 0. ]]; ```. While the correct result should have been (notice the element in second row, second column):. ``` python; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 1. ]]; ```. On analysing the source code I found the the function `sp_expm` in `sparse.py` is responsible for this computation. The particular code is reproduced below:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A.data = np.exp(A.data); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. Since `A.data` is stored in sparse matrix format, only non-zero elements are exponentiated. A way to avoid this problem would be to either completely remove the case of optimizing for diagonal states or modifying the appropriate code as:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A = sp.diags(np.exp(A.diagonal()),format='csr'); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. I am running qutip 3.2.0.dev-cb698ef; Python 3.5.1, numpy 1.10.4, scipy 0.17.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/493
https://github.com/qutip/qutip/issues/493:1104,Safety,avoid,avoid,1104,"Qobj.expm() is currently not working properly for diagonal states which have a zero in the diagonal (these zeros don't become ones). An example:. ``` python; >>> foo = qutip.Qobj([[1.,0.],[0.,0.]]); >>> foo.expm(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 0. ]]; ```. While the correct result should have been (notice the element in second row, second column):. ``` python; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 1. ]]; ```. On analysing the source code I found the the function `sp_expm` in `sparse.py` is responsible for this computation. The particular code is reproduced below:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A.data = np.exp(A.data); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. Since `A.data` is stored in sparse matrix format, only non-zero elements are exponentiated. A way to avoid this problem would be to either completely remove the case of optimizing for diagonal states or modifying the appropriate code as:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A = sp.diags(np.exp(A.diagonal()),format='csr'); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. I am running qutip 3.2.0.dev-cb698ef; Python 3.5.1, numpy 1.10.4, scipy 0.17.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/493
https://github.com/qutip/qutip/pull/495:5,Testability,test,test,5,Unit test for #490.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/495
https://github.com/qutip/qutip/pull/496:155,Testability,test,tests,155,- Propagator can now be run in parallel.; - Simplified dissipative calling by unifying 'sparse' and dense calls when dissipative.; - Added propagator unit tests.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/496
https://github.com/qutip/qutip/pull/496:44,Usability,Simpl,Simplified,44,- Propagator can now be run in parallel.; - Simplified dissipative calling by unifying 'sparse' and dense calls when dissipative.; - Added propagator unit tests.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/496
https://github.com/qutip/qutip/pull/497:191,Availability,error,errors,191,"Some of the super operator and QPT tests may have name space issues as reported in the google group: . https://groups.google.com/d/msg/qutip/Z-5o4HHYRv4/yRX7dvjiEgAJ. I can not reproduce the errors, but here is a clean up that will likely fix this possible issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/497
https://github.com/qutip/qutip/pull/497:35,Testability,test,tests,35,"Some of the super operator and QPT tests may have name space issues as reported in the google group: . https://groups.google.com/d/msg/qutip/Z-5o4HHYRv4/yRX7dvjiEgAJ. I can not reproduce the errors, but here is a clean up that will likely fix this possible issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/497
https://github.com/qutip/qutip/issues/498:20,Availability,failure,failure,20,"There seems to be a failure in how `Qobj.istp` checks trace-preservingness for superoperators acting on composite systems. I think there's an exception raised inside the property accessor which is being downgraded to `istp == False`; I'll investigate and fix it soon. In the meantime, I've written a [brief test case](https://gist.github.com/cgranade/31bce360282097d4abd545b68eb65b7d) that shows the problem.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/498
https://github.com/qutip/qutip/issues/498:203,Availability,down,downgraded,203,"There seems to be a failure in how `Qobj.istp` checks trace-preservingness for superoperators acting on composite systems. I think there's an exception raised inside the property accessor which is being downgraded to `istp == False`; I'll investigate and fix it soon. In the meantime, I've written a [brief test case](https://gist.github.com/cgranade/31bce360282097d4abd545b68eb65b7d) that shows the problem.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/498
https://github.com/qutip/qutip/issues/498:179,Security,access,accessor,179,"There seems to be a failure in how `Qobj.istp` checks trace-preservingness for superoperators acting on composite systems. I think there's an exception raised inside the property accessor which is being downgraded to `istp == False`; I'll investigate and fix it soon. In the meantime, I've written a [brief test case](https://gist.github.com/cgranade/31bce360282097d4abd545b68eb65b7d) that shows the problem.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/498
https://github.com/qutip/qutip/issues/498:307,Testability,test,test,307,"There seems to be a failure in how `Qobj.istp` checks trace-preservingness for superoperators acting on composite systems. I think there's an exception raised inside the property accessor which is being downgraded to `istp == False`; I'll investigate and fix it soon. In the meantime, I've written a [brief test case](https://gist.github.com/cgranade/31bce360282097d4abd545b68eb65b7d) that shows the problem.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/498
https://github.com/qutip/qutip/pull/499:306,Testability,test,test,306,"This PR addresses #498 by collapsing composite (multipartite) dimensions before taking the partial trace. This is backed by new functions to collapse dimensions specifications of multipartite systems, and both these new functions and the originally erroneous behavior of `Qobj.istp` are now covered by new test cases.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/499
https://github.com/qutip/qutip/issues/503:637,Availability,toler,tolerance,637,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:901,Availability,toler,tolerance,901,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:223,Deployability,integrat,integrate,223,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:351,Deployability,integrat,integrate,351,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:459,Deployability,integrat,integrate,459,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:717,Deployability,integrat,integrate,717,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:223,Integrability,integrat,integrate,223,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:351,Integrability,integrat,integrate,351,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:459,Integrability,integrat,integrate,459,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/503:717,Integrability,integrat,integrate,717,"Looking into the function `_mc_alg_evolve` in the source code of mcsolve, I have two questions in mind:; 1. Why do you divide the interval into each `tlist[k]` (`while ODE.t < tlist[k]:`) and run the ode internal step `ODE.integrate(tlist[k], step=1)` one at a time and evaluate `if norm2_psi <= rand_vals[0]:`?; Alternatively, can I run the ode `ODE.integrate(tlist, step=n)` without collapse until `norm2_psi <= rand_vals[0]`? It seems to be faster if `ODE.integrate(tlist, step=n)` can store the state. In this way I ignore `tlist[k]` totally.; 2. After `if norm2_psi <= rand_vals[0]:`, you find the collapse time to within specified tolerance. Can I just take the collapse time as the time immediately after `ODE.integrate(tlist[k], step=1)`? Since the step in the `ODE` should be small enough, would it make a lot difference by ignoring the steps of finding the collapse time to within specified tolerance?. Thank you very much.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/503
https://github.com/qutip/qutip/issues/504:146,Availability,error,error,146,"Hello, I read the '; Lecture 7 - Symbolic quantum mechanics using SymPsi - Semiclassical equations of motion' and re-run it's codes but I receive error in following line:. ---. ops, op_eqm, sc_eqm, sc_ode, ofm, oim = semi_classical_eqm(H, c_ops). ---. ValueError Traceback (most recent call last); <ipython-input-13-e7aaa32c59a9> in <module>(); ----> 1 ops, op_eqm, sc_eqm, sc_ode, ofm, oim = semi_classical_eqm(H, c_ops). ValueError: too many values to unpack. ---. what is this error?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/504
https://github.com/qutip/qutip/issues/504:480,Availability,error,error,480,"Hello, I read the '; Lecture 7 - Symbolic quantum mechanics using SymPsi - Semiclassical equations of motion' and re-run it's codes but I receive error in following line:. ---. ops, op_eqm, sc_eqm, sc_ode, ofm, oim = semi_classical_eqm(H, c_ops). ---. ValueError Traceback (most recent call last); <ipython-input-13-e7aaa32c59a9> in <module>(); ----> 1 ops, op_eqm, sc_eqm, sc_ode, ofm, oim = semi_classical_eqm(H, c_ops). ValueError: too many values to unpack. ---. what is this error?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/504
https://github.com/qutip/qutip/issues/505:2904,Availability,down,down,2904,", rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4289)(). TypeError: Cannot convert csr_matrix to numpy.ndarray; ```. Is it expected? (in this case the doc may be misleading). I tried to trace it down, but could not get any luck for the moment. EDIT: Actually, it seems that in such a case, one has to pass a density matrix and not a state as initial state, and that the liouvillian callback should return a `.data` item.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:1658,Deployability,integrat,integrate,1658,"ypeError Traceback (most recent call last); <ipython-input-116-e35e17a7e3ab> in <module>(); 6 [],; 7 [],; ----> 8 progress_bar=True). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:1801,Deployability,integrat,integrate,1801," /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4289)(). TypeError: Cannot convert csr_ma",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:1822,Deployability,integrat,integrate,1822,"que/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4289)(). TypeError: Cannot convert csr_matrix to numpy.ndarray; ```. Is it expected",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:2143,Deployability,integrat,integrate,2143,", rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4289)(). TypeError: Cannot convert csr_matrix to numpy.ndarray; ```. Is it expected? (in this case the doc may be misleading). I tried to trace it down, but could not get any luck for the moment. EDIT: Actually, it seems that in such a case, one has to pass a density matrix and not a state as initial state, and that the liouvillian callback should return a `.data` item.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:64,Integrability,depend,dependent,64,"Hi,. According to the `mesolve` doc, . > For problems with time-dependent problems H and c_ops can be callback functions that takes two arguments, time and args, and returns the Hamiltonian or Liouvillian for the system at that point in time (callback format). Then, I would have expected something very basic such as. ``` python; import numpy as np; import qutip. a = qutip.destroy(40); tlist = np.arange(0, 100, 10); results = qutip.mesolve(lambda t, args: a,; qutip.coherent(40, 2),; tlist,; [],; [],; progress_bar=True); ```. to be working. Instead, it gives (full traceback). ```; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-116-e35e17a7e3ab> in <module>(); 6 [],; 7 [],; ----> 8 progress_bar=True). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except System",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:1658,Integrability,integrat,integrate,1658,"ypeError Traceback (most recent call last); <ipython-input-116-e35e17a7e3ab> in <module>(); 6 [],; 7 [],; ----> 8 progress_bar=True). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:1801,Integrability,integrat,integrate,1801," /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4289)(). TypeError: Cannot convert csr_ma",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:1822,Integrability,integrat,integrate,1822,"que/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4289)(). TypeError: Cannot convert csr_matrix to numpy.ndarray; ```. Is it expected",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/issues/505:2143,Integrability,integrat,integrate,2143,", rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4289)(). TypeError: Cannot convert csr_matrix to numpy.ndarray; ```. Is it expected? (in this case the doc may be misleading). I tried to trace it down, but could not get any luck for the moment. EDIT: Actually, it seems that in such a case, one has to pass a density matrix and not a state as initial state, and that the liouvillian callback should return a `.data` item.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/505
https://github.com/qutip/qutip/pull/506:140,Modifiability,flexible,flexible,140,"A few people have been asking for this again recently. ; I have produced this new PR, rather than apply #396, as its a bit simpler and more flexible. It is a bit more memory consumptive, but probably a small percentage of the whole. It's also based an recent pull. . No notebook as yet, as I will wait for feedback from those who requested it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/506
https://github.com/qutip/qutip/pull/506:123,Usability,simpl,simpler,123,"A few people have been asking for this again recently. ; I have produced this new PR, rather than apply #396, as its a bit simpler and more flexible. It is a bit more memory consumptive, but probably a small percentage of the whole. It's also based an recent pull. . No notebook as yet, as I will wait for feedback from those who requested it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/506
https://github.com/qutip/qutip/pull/506:306,Usability,feedback,feedback,306,"A few people have been asking for this again recently. ; I have produced this new PR, rather than apply #396, as its a bit simpler and more flexible. It is a bit more memory consumptive, but probably a small percentage of the whole. It's also based an recent pull. . No notebook as yet, as I will wait for feedback from those who requested it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/506
https://github.com/qutip/qutip/issues/507:290,Modifiability,variab,variables,290,"Hello, I want to solve problems in optomechanics with QuTip but I don't know which packages(mathmp, sympy,sympsi,..) must be used. please guide me about writing QuTip programs for optomechanical systems. also, I want to know in steady state, how I can plot a quantity(like variance) versus variables other than time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/507
https://github.com/qutip/qutip/issues/507:138,Usability,guid,guide,138,"Hello, I want to solve problems in optomechanics with QuTip but I don't know which packages(mathmp, sympy,sympsi,..) must be used. please guide me about writing QuTip programs for optomechanical systems. also, I want to know in steady state, how I can plot a quantity(like variance) versus variables other than time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/507
https://github.com/qutip/qutip/pull/509:80,Integrability,depend,dependent,80,"This branch adds the ability to calculate two-time correlations with fully time-dependent Hamiltonians and collapse operators. The time-dependence may now either be in the Hamiltonian or the collapse operators, or both. Additionally, support for the numpy list format was added. New tests were made to test all of these functionalities. Bugs were fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/509
https://github.com/qutip/qutip/pull/509:136,Integrability,depend,dependence,136,"This branch adds the ability to calculate two-time correlations with fully time-dependent Hamiltonians and collapse operators. The time-dependence may now either be in the Hamiltonian or the collapse operators, or both. Additionally, support for the numpy list format was added. New tests were made to test all of these functionalities. Bugs were fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/509
https://github.com/qutip/qutip/pull/509:283,Testability,test,tests,283,"This branch adds the ability to calculate two-time correlations with fully time-dependent Hamiltonians and collapse operators. The time-dependence may now either be in the Hamiltonian or the collapse operators, or both. Additionally, support for the numpy list format was added. New tests were made to test all of these functionalities. Bugs were fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/509
https://github.com/qutip/qutip/pull/509:302,Testability,test,test,302,"This branch adds the ability to calculate two-time correlations with fully time-dependent Hamiltonians and collapse operators. The time-dependence may now either be in the Hamiltonian or the collapse operators, or both. Additionally, support for the numpy list format was added. New tests were made to test all of these functionalities. Bugs were fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/509
https://github.com/qutip/qutip/pull/516:30,Availability,error,errors,30,Updates to remove some of the errors from the Sphinx docs. Many errors in the control module have yet to be fixed.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/516
https://github.com/qutip/qutip/pull/516:64,Availability,error,errors,64,Updates to remove some of the errors from the Sphinx docs. Many errors in the control module have yet to be fixed.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/516
https://github.com/qutip/qutip/pull/516:0,Deployability,Update,Updates,0,Updates to remove some of the errors from the Sphinx docs. Many errors in the control module have yet to be fixed.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/516
https://github.com/qutip/qutip/pull/517:108,Integrability,depend,dependent,108,This is a cubic spline interpolation object that is compatible with being called from the string-based time-dependent format in the solvers.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/517
https://github.com/qutip/qutip/pull/520:33,Energy Efficiency,efficient,efficient,33,"I'm not sure if this is the most efficient way to do this, but here's what I came up with. The previous version only worked for linear tlists, this one now works for arbitrary tlists",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/520
https://github.com/qutip/qutip/issues/521:1113,Safety,detect,detector,1113,"ith a float<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current be",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1188,Safety,detect,detector,1188,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1217,Safety,detect,detector,1217,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1241,Safety,detect,detector,1241,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1315,Safety,detect,detectors,1315,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1354,Safety,detect,detector,1354,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1364,Safety,detect,detector,1364,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1413,Safety,detect,detector,1413,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1488,Safety,detect,detector,1488,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1517,Safety,detect,detector,1517,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1541,Safety,detect,detector,1541,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1615,Safety,detect,detectors,1615,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1654,Safety,detect,detector,1654,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1664,Safety,detect,detector,1664,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1790,Safety,detect,detector,1790,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1840,Safety,detect,detectors,1840,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1890,Safety,detect,detector,1890,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/issues/521:1940,Safety,detect,detectors,1940,"oat<1e-12 makes all entries 0.0. This can be worked-around as follows:. ``` python; import qutip as qt. print ""Multiplying states by small numbers""; state3 = qt.ket([0])*1e-12; state2 = qt.ket([0])*9.999e-13; state1 = qt.ket([0]); state1 = qt.Qobj(state1.data*9.999e-13); print 'Desired:', state3; print 'Undesired:', state2; print 'Desired, via workaround:', state1; ```. ```; Multiplying states by small numbers; Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.00000000e-12]; [ 0.00000000e+00]]; Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]; Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 9.99900000e-13]; [ 0.00000000e+00]]; ```. But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators' values are all >1e-12:. ``` python; print ""Expectation values with small operators""; detector = qt.Qobj([[1e-12, 0], [0, 0]]); print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-6, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); detector = qt.Qobj([[1e-14, 0], [0, 0]]); print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); detector = qt.Qobj([[1e-7, 0], [0, 0]]); print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); ```. ```; Expectation values with small operators; Expectation value for one detector, 1e-12: 1e-12; Expectation value for two detectors, 1e-6: 1e-12; Expectation value for one detector, 1e-14: 1e-14; Expectation value for two detectors, 1e-7: 0.0; ```. It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/521
https://github.com/qutip/qutip/pull/522:70,Availability,down,downloaded,70,Reverts qutip/qutip#518. This has been causing some issues when being downloaded directly from git. Will rework it.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/522
https://github.com/qutip/qutip/pull/523:7,Usability,simpl,simpler,7,A much simpler way to get PEP compliance.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/523
https://github.com/qutip/qutip/pull/525:19,Integrability,depend,dependent,19,Implemented a time-dependent version of the Bloch-Redfield master equation solver for time-dependent Hamiltonians and c_ops. It makes use of the list array format. Also fixed some formatting inconsistencies in the correlation docstrings (yet again... I think I got it this time),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/525
https://github.com/qutip/qutip/pull/525:91,Integrability,depend,dependent,91,Implemented a time-dependent version of the Bloch-Redfield master equation solver for time-dependent Hamiltonians and c_ops. It makes use of the list array format. Also fixed some formatting inconsistencies in the correlation docstrings (yet again... I think I got it this time),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/525
https://github.com/qutip/qutip/issues/526:9,Testability,test,test,9,"A simple test shows that the Clenshaw method from @Vutshi does not give results consistant with the other solvers. This slipped through because the test suite was not testing this new method against random operators. ``` python; N = 20; xvec = np.linspace(-10, 10, 128); for i in range(3):; rho = rand_dm(N). Wfft = wigner(rho, xvec, xvec, method='iterative'); W = wigner(rho, xvec, xvec, method='clenshaw'). Wdiff = abs(W - Wfft); print(np.sum(abs(Wdiff))); ```. With the above code, I am getting differences on the order of one, where as the other methods all are close on the order of 1e-12 or so. I will revert back to the old iterative method until this is resolved.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/526
https://github.com/qutip/qutip/issues/526:148,Testability,test,test,148,"A simple test shows that the Clenshaw method from @Vutshi does not give results consistant with the other solvers. This slipped through because the test suite was not testing this new method against random operators. ``` python; N = 20; xvec = np.linspace(-10, 10, 128); for i in range(3):; rho = rand_dm(N). Wfft = wigner(rho, xvec, xvec, method='iterative'); W = wigner(rho, xvec, xvec, method='clenshaw'). Wdiff = abs(W - Wfft); print(np.sum(abs(Wdiff))); ```. With the above code, I am getting differences on the order of one, where as the other methods all are close on the order of 1e-12 or so. I will revert back to the old iterative method until this is resolved.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/526
https://github.com/qutip/qutip/issues/526:167,Testability,test,testing,167,"A simple test shows that the Clenshaw method from @Vutshi does not give results consistant with the other solvers. This slipped through because the test suite was not testing this new method against random operators. ``` python; N = 20; xvec = np.linspace(-10, 10, 128); for i in range(3):; rho = rand_dm(N). Wfft = wigner(rho, xvec, xvec, method='iterative'); W = wigner(rho, xvec, xvec, method='clenshaw'). Wdiff = abs(W - Wfft); print(np.sum(abs(Wdiff))); ```. With the above code, I am getting differences on the order of one, where as the other methods all are close on the order of 1e-12 or so. I will revert back to the old iterative method until this is resolved.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/526
https://github.com/qutip/qutip/issues/526:2,Usability,simpl,simple,2,"A simple test shows that the Clenshaw method from @Vutshi does not give results consistant with the other solvers. This slipped through because the test suite was not testing this new method against random operators. ``` python; N = 20; xvec = np.linspace(-10, 10, 128); for i in range(3):; rho = rand_dm(N). Wfft = wigner(rho, xvec, xvec, method='iterative'); W = wigner(rho, xvec, xvec, method='clenshaw'). Wdiff = abs(W - Wfft); print(np.sum(abs(Wdiff))); ```. With the above code, I am getting differences on the order of one, where as the other methods all are close on the order of 1e-12 or so. I will revert back to the old iterative method until this is resolved.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/526
https://github.com/qutip/qutip/pull/527:13,Deployability,update,update,13,"Just a minor update where the diags of the sparse matrix are grabbed directly rather than converting the matrix to dense form. For larger density matrices, this method outperforms the dense method due to the time it takes to convert the format and do the multiplication.; - Also added more Wigner unit tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/527
https://github.com/qutip/qutip/pull/527:302,Testability,test,tests,302,"Just a minor update where the diags of the sparse matrix are grabbed directly rather than converting the matrix to dense form. For larger density matrices, this method outperforms the dense method due to the time it takes to convert the format and do the multiplication.; - Also added more Wigner unit tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/527
https://github.com/qutip/qutip/pull/528:448,Availability,error,error,448,"This is my first attempt at fixing and slightly extending the functionality of the countstat_current_noise(); function in countstat.py. There were several issues with this function, which I have attempted to rectify as described below. Also its my first pull request (instead of asking anubhav or alex to help), so if I messed it up let me know. 1) The default method, a direct solution using sparse matrices, would fail with an ""exactly singular"" error on small examples (like the well studied single-resonant level or double quantum dot examples). The other sparse methods also suffered from the same issue, as did the 'direct' method for dense solutions. The latter, the dense matrices solver, I have fixed by capturing the error using lstsq() if np.linalg.solve() fails. For the sparse cases there seems to no equivalent fix. One can solve the issue by adding a small finite frequency to the definition of the shot noise. However, this seems like a bit of a bodge, and could cause issues if this small frequency is of the order of some system frequencies. So I have changed the default behavior to use the dense solvers, and added a description of the sparse matrix issues in the function description and in an example notebook I will upload to the example notebooks github. . Maybe someone can suggest a better fix?. 2) There was, in addition, an error in the definition of the shot noise formula in the default sparse matrix direct solution. In addition, the dense methods which used pinv() were also incorrectly defined (they were missing pre and post- multiplication by the 'Q' operator), and would thus give different results from the direct solutions. These issues have been fixed, and everything now fits expected analytical results (see example notebook). 3) I have added a frequency dependence via a list of possible frequencies at which to evaluate the shot noise. 4) I removed the option of passing a pseudo-inverse to the function directly, and changed various other interface things. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/528
https://github.com/qutip/qutip/pull/528:727,Availability,error,error,727,"This is my first attempt at fixing and slightly extending the functionality of the countstat_current_noise(); function in countstat.py. There were several issues with this function, which I have attempted to rectify as described below. Also its my first pull request (instead of asking anubhav or alex to help), so if I messed it up let me know. 1) The default method, a direct solution using sparse matrices, would fail with an ""exactly singular"" error on small examples (like the well studied single-resonant level or double quantum dot examples). The other sparse methods also suffered from the same issue, as did the 'direct' method for dense solutions. The latter, the dense matrices solver, I have fixed by capturing the error using lstsq() if np.linalg.solve() fails. For the sparse cases there seems to no equivalent fix. One can solve the issue by adding a small finite frequency to the definition of the shot noise. However, this seems like a bit of a bodge, and could cause issues if this small frequency is of the order of some system frequencies. So I have changed the default behavior to use the dense solvers, and added a description of the sparse matrix issues in the function description and in an example notebook I will upload to the example notebooks github. . Maybe someone can suggest a better fix?. 2) There was, in addition, an error in the definition of the shot noise formula in the default sparse matrix direct solution. In addition, the dense methods which used pinv() were also incorrectly defined (they were missing pre and post- multiplication by the 'Q' operator), and would thus give different results from the direct solutions. These issues have been fixed, and everything now fits expected analytical results (see example notebook). 3) I have added a frequency dependence via a list of possible frequencies at which to evaluate the shot noise. 4) I removed the option of passing a pseudo-inverse to the function directly, and changed various other interface things. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/528
https://github.com/qutip/qutip/pull/528:1352,Availability,error,error,1352,". There were several issues with this function, which I have attempted to rectify as described below. Also its my first pull request (instead of asking anubhav or alex to help), so if I messed it up let me know. 1) The default method, a direct solution using sparse matrices, would fail with an ""exactly singular"" error on small examples (like the well studied single-resonant level or double quantum dot examples). The other sparse methods also suffered from the same issue, as did the 'direct' method for dense solutions. The latter, the dense matrices solver, I have fixed by capturing the error using lstsq() if np.linalg.solve() fails. For the sparse cases there seems to no equivalent fix. One can solve the issue by adding a small finite frequency to the definition of the shot noise. However, this seems like a bit of a bodge, and could cause issues if this small frequency is of the order of some system frequencies. So I have changed the default behavior to use the dense solvers, and added a description of the sparse matrix issues in the function description and in an example notebook I will upload to the example notebooks github. . Maybe someone can suggest a better fix?. 2) There was, in addition, an error in the definition of the shot noise formula in the default sparse matrix direct solution. In addition, the dense methods which used pinv() were also incorrectly defined (they were missing pre and post- multiplication by the 'Q' operator), and would thus give different results from the direct solutions. These issues have been fixed, and everything now fits expected analytical results (see example notebook). 3) I have added a frequency dependence via a list of possible frequencies at which to evaluate the shot noise. 4) I removed the option of passing a pseudo-inverse to the function directly, and changed various other interface things. I am not sure if everything conforms to PEP8 etc. Edit: the example notebook is here https://github.com/qutip/qutip-notebooks/pull/35",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/528
https://github.com/qutip/qutip/pull/528:1796,Integrability,depend,dependence,1796,". There were several issues with this function, which I have attempted to rectify as described below. Also its my first pull request (instead of asking anubhav or alex to help), so if I messed it up let me know. 1) The default method, a direct solution using sparse matrices, would fail with an ""exactly singular"" error on small examples (like the well studied single-resonant level or double quantum dot examples). The other sparse methods also suffered from the same issue, as did the 'direct' method for dense solutions. The latter, the dense matrices solver, I have fixed by capturing the error using lstsq() if np.linalg.solve() fails. For the sparse cases there seems to no equivalent fix. One can solve the issue by adding a small finite frequency to the definition of the shot noise. However, this seems like a bit of a bodge, and could cause issues if this small frequency is of the order of some system frequencies. So I have changed the default behavior to use the dense solvers, and added a description of the sparse matrix issues in the function description and in an example notebook I will upload to the example notebooks github. . Maybe someone can suggest a better fix?. 2) There was, in addition, an error in the definition of the shot noise formula in the default sparse matrix direct solution. In addition, the dense methods which used pinv() were also incorrectly defined (they were missing pre and post- multiplication by the 'Q' operator), and would thus give different results from the direct solutions. These issues have been fixed, and everything now fits expected analytical results (see example notebook). 3) I have added a frequency dependence via a list of possible frequencies at which to evaluate the shot noise. 4) I removed the option of passing a pseudo-inverse to the function directly, and changed various other interface things. I am not sure if everything conforms to PEP8 etc. Edit: the example notebook is here https://github.com/qutip/qutip-notebooks/pull/35",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/528
https://github.com/qutip/qutip/pull/528:1983,Integrability,interface,interface,1983,". There were several issues with this function, which I have attempted to rectify as described below. Also its my first pull request (instead of asking anubhav or alex to help), so if I messed it up let me know. 1) The default method, a direct solution using sparse matrices, would fail with an ""exactly singular"" error on small examples (like the well studied single-resonant level or double quantum dot examples). The other sparse methods also suffered from the same issue, as did the 'direct' method for dense solutions. The latter, the dense matrices solver, I have fixed by capturing the error using lstsq() if np.linalg.solve() fails. For the sparse cases there seems to no equivalent fix. One can solve the issue by adding a small finite frequency to the definition of the shot noise. However, this seems like a bit of a bodge, and could cause issues if this small frequency is of the order of some system frequencies. So I have changed the default behavior to use the dense solvers, and added a description of the sparse matrix issues in the function description and in an example notebook I will upload to the example notebooks github. . Maybe someone can suggest a better fix?. 2) There was, in addition, an error in the definition of the shot noise formula in the default sparse matrix direct solution. In addition, the dense methods which used pinv() were also incorrectly defined (they were missing pre and post- multiplication by the 'Q' operator), and would thus give different results from the direct solutions. These issues have been fixed, and everything now fits expected analytical results (see example notebook). 3) I have added a frequency dependence via a list of possible frequencies at which to evaluate the shot noise. 4) I removed the option of passing a pseudo-inverse to the function directly, and changed various other interface things. I am not sure if everything conforms to PEP8 etc. Edit: the example notebook is here https://github.com/qutip/qutip-notebooks/pull/35",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/528
https://github.com/qutip/qutip/pull/528:48,Modifiability,extend,extending,48,"This is my first attempt at fixing and slightly extending the functionality of the countstat_current_noise(); function in countstat.py. There were several issues with this function, which I have attempted to rectify as described below. Also its my first pull request (instead of asking anubhav or alex to help), so if I messed it up let me know. 1) The default method, a direct solution using sparse matrices, would fail with an ""exactly singular"" error on small examples (like the well studied single-resonant level or double quantum dot examples). The other sparse methods also suffered from the same issue, as did the 'direct' method for dense solutions. The latter, the dense matrices solver, I have fixed by capturing the error using lstsq() if np.linalg.solve() fails. For the sparse cases there seems to no equivalent fix. One can solve the issue by adding a small finite frequency to the definition of the shot noise. However, this seems like a bit of a bodge, and could cause issues if this small frequency is of the order of some system frequencies. So I have changed the default behavior to use the dense solvers, and added a description of the sparse matrix issues in the function description and in an example notebook I will upload to the example notebooks github. . Maybe someone can suggest a better fix?. 2) There was, in addition, an error in the definition of the shot noise formula in the default sparse matrix direct solution. In addition, the dense methods which used pinv() were also incorrectly defined (they were missing pre and post- multiplication by the 'Q' operator), and would thus give different results from the direct solutions. These issues have been fixed, and everything now fits expected analytical results (see example notebook). 3) I have added a frequency dependence via a list of possible frequencies at which to evaluate the shot noise. 4) I removed the option of passing a pseudo-inverse to the function directly, and changed various other interface things. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/528
https://github.com/qutip/qutip/pull/529:442,Availability,error,error,442,New methods for single stochastic jump operator are implemented:; - 1/2 order predictor-corrector euler-maruyama; - 1 order semi-implicit Milstein; - 3/2 order explicit and semi-implicit Taylor 1.5. Tests for all the new (and old) methods are added. There is a corresponding notebook which shows that the solvers achieve (or exceed) their order of convergence.; https://github.com/qutip/qutip-notebooks/pull/37; Here is the scaling of solver error as a function of stepsize:; ![error_scaling_y_an](https://cloud.githubusercontent.com/assets/4971779/18120795/128dcbe6-6f6a-11e6-8b36-8b16fb73f35a.png). Bug: fast-milstein modifies input noise - fixed. The explicit Taylor 1.5 method and most of the coding is done by **Manuel Grimm** under supervision of **Niels Lörch** at University of Basel.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/529
https://github.com/qutip/qutip/pull/529:78,Safety,predict,predictor-corrector,78,New methods for single stochastic jump operator are implemented:; - 1/2 order predictor-corrector euler-maruyama; - 1 order semi-implicit Milstein; - 3/2 order explicit and semi-implicit Taylor 1.5. Tests for all the new (and old) methods are added. There is a corresponding notebook which shows that the solvers achieve (or exceed) their order of convergence.; https://github.com/qutip/qutip-notebooks/pull/37; Here is the scaling of solver error as a function of stepsize:; ![error_scaling_y_an](https://cloud.githubusercontent.com/assets/4971779/18120795/128dcbe6-6f6a-11e6-8b36-8b16fb73f35a.png). Bug: fast-milstein modifies input noise - fixed. The explicit Taylor 1.5 method and most of the coding is done by **Manuel Grimm** under supervision of **Niels Lörch** at University of Basel.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/529
https://github.com/qutip/qutip/pull/529:199,Testability,Test,Tests,199,New methods for single stochastic jump operator are implemented:; - 1/2 order predictor-corrector euler-maruyama; - 1 order semi-implicit Milstein; - 3/2 order explicit and semi-implicit Taylor 1.5. Tests for all the new (and old) methods are added. There is a corresponding notebook which shows that the solvers achieve (or exceed) their order of convergence.; https://github.com/qutip/qutip-notebooks/pull/37; Here is the scaling of solver error as a function of stepsize:; ![error_scaling_y_an](https://cloud.githubusercontent.com/assets/4971779/18120795/128dcbe6-6f6a-11e6-8b36-8b16fb73f35a.png). Bug: fast-milstein modifies input noise - fixed. The explicit Taylor 1.5 method and most of the coding is done by **Manuel Grimm** under supervision of **Niels Lörch** at University of Basel.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/529
https://github.com/qutip/qutip/pull/530:140,Performance,perform,performance,140,"- This pull contains a sparse kron function that does not need to convert to COO format to do the product. It is possible to get up to ~20x performance over the SciPy implementation.; - This function can likely be recast to use OPENMP on the outer-loop.; - Added random tests comparing this method vs the SciPy sparse kron. Here are speed ups for various random objects (dims in range [2,100]) with random densities:; ![oper-oper](https://cloud.githubusercontent.com/assets/1249193/18156290/76e1f8d4-6fd2-11e6-91b4-e898429ecf1c.png); ![oper-ket](https://cloud.githubusercontent.com/assets/1249193/18156291/784e4204-6fd2-11e6-95e1-221a90c3d20b.png); ![ket-ket](https://cloud.githubusercontent.com/assets/1249193/18156292/796a22fc-6fd2-11e6-9646-04214cdf3af4.png). The graphs show a relatively constant speedup. However, the results are a bit better than displayed here when using the `timeit` module directly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/530
https://github.com/qutip/qutip/pull/530:270,Testability,test,tests,270,"- This pull contains a sparse kron function that does not need to convert to COO format to do the product. It is possible to get up to ~20x performance over the SciPy implementation.; - This function can likely be recast to use OPENMP on the outer-loop.; - Added random tests comparing this method vs the SciPy sparse kron. Here are speed ups for various random objects (dims in range [2,100]) with random densities:; ![oper-oper](https://cloud.githubusercontent.com/assets/1249193/18156290/76e1f8d4-6fd2-11e6-91b4-e898429ecf1c.png); ![oper-ket](https://cloud.githubusercontent.com/assets/1249193/18156291/784e4204-6fd2-11e6-95e1-221a90c3d20b.png); ![ket-ket](https://cloud.githubusercontent.com/assets/1249193/18156292/796a22fc-6fd2-11e6-9646-04214cdf3af4.png). The graphs show a relatively constant speedup. However, the results are a bit better than displayed here when using the `timeit` module directly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/530
https://github.com/qutip/qutip/issues/531:404,Safety,avoid,avoid,404,"Hi,; In the source code of `mesolve`, the derivative are defined via `L * rho` where L is Liouvillian. But when the size is too large, `L` is of huge dimension. I have two questions:; 1. What tricks have you made so that the derivative is still defined via `L` instead of collapse operators, which is relatively smaller in dimension? Sparse in scipy was used. But if `L` is not sparse at all, how can we avoid memory problem?; 2. What is the general advantage of using Liouvillian `L` to define derivative instead of `C` the collapse operators? It seems that using `L` requires only 1 multiplication, but when I tested and try to define in `C`, it seems that it is still faster for relatively small hilbert space dimension. Is speed the main reason?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/531
https://github.com/qutip/qutip/issues/531:612,Testability,test,tested,612,"Hi,; In the source code of `mesolve`, the derivative are defined via `L * rho` where L is Liouvillian. But when the size is too large, `L` is of huge dimension. I have two questions:; 1. What tricks have you made so that the derivative is still defined via `L` instead of collapse operators, which is relatively smaller in dimension? Sparse in scipy was used. But if `L` is not sparse at all, how can we avoid memory problem?; 2. What is the general advantage of using Liouvillian `L` to define derivative instead of `C` the collapse operators? It seems that using `L` requires only 1 multiplication, but when I tested and try to define in `C`, it seems that it is still faster for relatively small hilbert space dimension. Is speed the main reason?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/531
https://github.com/qutip/qutip/pull/532:79,Deployability,release,release,79,"We have done quite a bit of work, and added a lot of functionality for a point release. I am suggesting that we bump the dev version to 4.0, and have this be the version that corresponds to the PRX paper. A list of additional things I want in a 4.0 release is in the roadmap:. https://github.com/qutip/qutip/wiki/Roadmap",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/532
https://github.com/qutip/qutip/pull/532:249,Deployability,release,release,249,"We have done quite a bit of work, and added a lot of functionality for a point release. I am suggesting that we bump the dev version to 4.0, and have this be the version that corresponds to the PRX paper. A list of additional things I want in a 4.0 release is in the roadmap:. https://github.com/qutip/qutip/wiki/Roadmap",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/532
https://github.com/qutip/qutip/pull/536:84,Deployability,release,release,84,The physicalcpu item from the commandline has shifted locations in the latest MacOS release. This fi should fix this and all later versions.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/536
https://github.com/qutip/qutip/issues/539:256,Usability,feedback,feedback,256,"Hi,. Is there a reason for not using aspect ratio ""equal"" for the resulting plot of the `plot_wigner` function? Wigner plots are much more readable when using such settings, in my opinion. Thanks. EDIT: I can make a PR for this, but would rather have some feedback before doing it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/539
https://github.com/qutip/qutip/issues/544:1152,Performance,perform,perform,1152,"Hi,. I recently had to animate a Wigner plot, to show the evolution of the Wigner function in time. It looks like QuTip does not any specific methods to ease this, at least when doing it in a Jupyter notebook. Typically, the `qutip.plot_wigner` method is really handy to plot Wigner functions, as it deals with everything, from the Wigner generation to the correct plotting. However, using it in an animation function callback from `matplotlib.animation.FuncAnimation` is not doable if you want it to be plotted live in the notebook. And to use `qutip.wigner.wigner` you have to manually reproduce lots of code from `qutip.plot_wigner`. I can think about two solutions to this issue:; 1. Enhancing `qutip.plot_wigner` so that it supports the first parameter to be a list of ket / density matrices, and in such a case it would render an animation rather than a single plot.; 2. Splitting `qutip.plot_wigner` in different methods that could be called independently. Typically, a first method to initialize the Wigner plot (that is set the correct colormap, labels for axis and so on), another one to compute a wigner function to render and a last one to perform the plot itself which would call all the other methods and have the same behavior as the current `qutip.plot_wigner` method. This way, if one wishes to render an animation of a Wigner function time evolution, he can call the first method to setup the matplotlib figure accordingly, then precomputes all the wigner arrays to plot on the animation and handle the animation part on his own, typically with a `FuncAnimation` animation. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/544
https://github.com/qutip/qutip/pull/545:46,Testability,test,tests,46,A bug is fixed in Qobj permute and bra vector tests are added.; The bug is found by a student of mine Slava Kuzmin (IQOQI).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/545
https://github.com/qutip/qutip/pull/550:89,Integrability,depend,dependent,89,"- Cubic_Spline objects can now be used in the me, se, and mc dynamics; solvers as a time-dependent term.; - If possible, the Cubic_Spline object will be evaluated in the; str-based format.; - I have yet to add this functionality to the collapse terms .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/550
https://github.com/qutip/qutip/pull/551:30,Modifiability,enhance,enhancement,30,"- One can get a 10-40%+ speed enhancement on the core spmv and spmvpy functions by moving to c-code and intrinsics on SSE3 compatible processors. The biggest gains come on platforms that use clang (e.g. OSX) where the speedups are in the 40% or higher range compared to the current Cython based method. GCC seems to be better suited to compile Cython code, so the gains are only 10-20% there.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/551
https://github.com/qutip/qutip/issues/552:132,Availability,error,error,132,"Hi devs,. I've been running into an issue installing the most recent dev version. The _blas_info() method is throwing the following error:. ```; Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) ; [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/__init__.py"", line 174, in <module>; import qutip._mkl; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/__init__.py"", line 3, in <module>; _set_mkl(); File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/utilities.py"", line 47, in _set_mkl; if _blas_info() == 'INTEL MKL':; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/utilities.py"", line 405, in _blas_info; if hasattr(config,'mkl_info') or any('mkl' in lib for lib in blas_info['libraries']):; KeyError: 'libraries'; ```. It seems this method was changed most recently in commit d7bb119 to include a line containing `blas_info['libraries']`. For reference I am doing a basic installation with just numpy (1.11.2), scipy (0.18.1), and cython (0.24.1), and not with any of the fortran MC stuff. I'm using Mac OSX 10.11, and Python 3.5.2. [I've also been able to successfully install using a commit from before this, a31f7fc.] . Please let me know if there is just something I've missed here. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/552
https://github.com/qutip/qutip/issues/552:42,Deployability,install,installing,42,"Hi devs,. I've been running into an issue installing the most recent dev version. The _blas_info() method is throwing the following error:. ```; Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) ; [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/__init__.py"", line 174, in <module>; import qutip._mkl; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/__init__.py"", line 3, in <module>; _set_mkl(); File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/utilities.py"", line 47, in _set_mkl; if _blas_info() == 'INTEL MKL':; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/utilities.py"", line 405, in _blas_info; if hasattr(config,'mkl_info') or any('mkl' in lib for lib in blas_info['libraries']):; KeyError: 'libraries'; ```. It seems this method was changed most recently in commit d7bb119 to include a line containing `blas_info['libraries']`. For reference I am doing a basic installation with just numpy (1.11.2), scipy (0.18.1), and cython (0.24.1), and not with any of the fortran MC stuff. I'm using Mac OSX 10.11, and Python 3.5.2. [I've also been able to successfully install using a commit from before this, a31f7fc.] . Please let me know if there is just something I've missed here. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/552
https://github.com/qutip/qutip/issues/552:1114,Deployability,install,installation,1114,"Hi devs,. I've been running into an issue installing the most recent dev version. The _blas_info() method is throwing the following error:. ```; Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) ; [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/__init__.py"", line 174, in <module>; import qutip._mkl; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/__init__.py"", line 3, in <module>; _set_mkl(); File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/utilities.py"", line 47, in _set_mkl; if _blas_info() == 'INTEL MKL':; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/utilities.py"", line 405, in _blas_info; if hasattr(config,'mkl_info') or any('mkl' in lib for lib in blas_info['libraries']):; KeyError: 'libraries'; ```. It seems this method was changed most recently in commit d7bb119 to include a line containing `blas_info['libraries']`. For reference I am doing a basic installation with just numpy (1.11.2), scipy (0.18.1), and cython (0.24.1), and not with any of the fortran MC stuff. I'm using Mac OSX 10.11, and Python 3.5.2. [I've also been able to successfully install using a commit from before this, a31f7fc.] . Please let me know if there is just something I've missed here. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/552
https://github.com/qutip/qutip/issues/552:1312,Deployability,install,install,1312,"Hi devs,. I've been running into an issue installing the most recent dev version. The _blas_info() method is throwing the following error:. ```; Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) ; [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/__init__.py"", line 174, in <module>; import qutip._mkl; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/__init__.py"", line 3, in <module>; _set_mkl(); File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/utilities.py"", line 47, in _set_mkl; if _blas_info() == 'INTEL MKL':; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/utilities.py"", line 405, in _blas_info; if hasattr(config,'mkl_info') or any('mkl' in lib for lib in blas_info['libraries']):; KeyError: 'libraries'; ```. It seems this method was changed most recently in commit d7bb119 to include a line containing `blas_info['libraries']`. For reference I am doing a basic installation with just numpy (1.11.2), scipy (0.18.1), and cython (0.24.1), and not with any of the fortran MC stuff. I'm using Mac OSX 10.11, and Python 3.5.2. [I've also been able to successfully install using a commit from before this, a31f7fc.] . Please let me know if there is just something I've missed here. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/552
https://github.com/qutip/qutip/issues/552:857,Modifiability,config,config,857,"Hi devs,. I've been running into an issue installing the most recent dev version. The _blas_info() method is throwing the following error:. ```; Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) ; [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/__init__.py"", line 174, in <module>; import qutip._mkl; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/__init__.py"", line 3, in <module>; _set_mkl(); File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/utilities.py"", line 47, in _set_mkl; if _blas_info() == 'INTEL MKL':; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/utilities.py"", line 405, in _blas_info; if hasattr(config,'mkl_info') or any('mkl' in lib for lib in blas_info['libraries']):; KeyError: 'libraries'; ```. It seems this method was changed most recently in commit d7bb119 to include a line containing `blas_info['libraries']`. For reference I am doing a basic installation with just numpy (1.11.2), scipy (0.18.1), and cython (0.24.1), and not with any of the fortran MC stuff. I'm using Mac OSX 10.11, and Python 3.5.2. [I've also been able to successfully install using a commit from before this, a31f7fc.] . Please let me know if there is just something I've missed here. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/552
https://github.com/qutip/qutip/pull/553:336,Testability,test,test,336,There were brackets missing in a list comprehension in the function `qip.qubit_states`. ; Additionally puting states = [0] put the qubit in the |1> state and states=[1] put the qubit in the |0> state. I have changed this so that [0] correpsonds to |0> and [1] corresponds to |1>. This pull request addresses these issues and provides a test to test the added functionality.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/553
https://github.com/qutip/qutip/pull/553:344,Testability,test,test,344,There were brackets missing in a list comprehension in the function `qip.qubit_states`. ; Additionally puting states = [0] put the qubit in the |1> state and states=[1] put the qubit in the |0> state. I have changed this so that [0] correpsonds to |0> and [1] corresponds to |1>. This pull request addresses these issues and provides a test to test the added functionality.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/553
https://github.com/qutip/qutip/issues/555:396,Modifiability,config,config,396,"In file [propagator.py](https://github.com/qutip/qutip/blob/master/qutip/propagator.py), near line 119:; ```python; td_type = _td_format_check(H, c_op_list, solver='me')[2]; if td_type > 0:; rhs_generate(H, c_op_list, args=args, options=options); ```; The performance would be improved if this code checked for the presence of an already compiled tdfunc like this:; ```python; if td_type > 0 and config.tdfunc is None:; ...; ```; which only requires an additional import of the config object from qutip.solver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/555
https://github.com/qutip/qutip/issues/555:478,Modifiability,config,config,478,"In file [propagator.py](https://github.com/qutip/qutip/blob/master/qutip/propagator.py), near line 119:; ```python; td_type = _td_format_check(H, c_op_list, solver='me')[2]; if td_type > 0:; rhs_generate(H, c_op_list, args=args, options=options); ```; The performance would be improved if this code checked for the presence of an already compiled tdfunc like this:; ```python; if td_type > 0 and config.tdfunc is None:; ...; ```; which only requires an additional import of the config object from qutip.solver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/555
https://github.com/qutip/qutip/issues/555:256,Performance,perform,performance,256,"In file [propagator.py](https://github.com/qutip/qutip/blob/master/qutip/propagator.py), near line 119:; ```python; td_type = _td_format_check(H, c_op_list, solver='me')[2]; if td_type > 0:; rhs_generate(H, c_op_list, args=args, options=options); ```; The performance would be improved if this code checked for the presence of an already compiled tdfunc like this:; ```python; if td_type > 0 and config.tdfunc is None:; ...; ```; which only requires an additional import of the config object from qutip.solver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/555
https://github.com/qutip/qutip/pull/559:145,Performance,optimiz,optimize,145,- The current choice of CFLAGS made generating the str-based c-code slower than necessary for little to no speed gain. Here we choose flags that optimize less since there is no benefit.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/559
https://github.com/qutip/qutip/issues/561:13,Integrability,depend,dependent,13,"Solving time-dependent Hamiltonian problems, where the time array provided to mesolve doesn't have t[0]=0, gives unexpected results. This happens both for the list callback format and for the list array ; format. Example [here](https://gist.github.com/asafpm/a86cd9f33f9ec7e5e360c348c1b0506e). Using qutip 3.1.0 and python 2.7",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/561
https://github.com/qutip/qutip/issues/562:57,Energy Efficiency,charge,charge,57,"Hi,. Sometimes it is useful to write an hamiltonian in a charge state basis. This requires the basis to be able to run through integers from minus infinity to plus infinity. This is typically the case in [this Qutip example notebook](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-11-Charge-Qubits.ipynb). In this notebook, the author manually creates a numpy object and cast it to a `Qobj`. What about offering an analog to `qutip.basis` for such states?. Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/562
https://github.com/qutip/qutip/issues/562:320,Energy Efficiency,Charge,Charge-Qubits,320,"Hi,. Sometimes it is useful to write an hamiltonian in a charge state basis. This requires the basis to be able to run through integers from minus infinity to plus infinity. This is typically the case in [this Qutip example notebook](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-11-Charge-Qubits.ipynb). In this notebook, the author manually creates a numpy object and cast it to a `Qobj`. What about offering an analog to `qutip.basis` for such states?. Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/562
https://github.com/qutip/qutip/issues/564:64,Deployability,integrat,integration,64,"[Gitter](https://gitter.im) is a networking platform with tight integration to Github. Its shows the latest activity (commits, PR, comments on issues) and can be a place for people to quickly connect with other QuTiP users and find solutions. For example, the gitter channel for Dipy is pretty active and helpful. (https://gitter.im/nipy/dipy). Has QuTiP considered [integrating](https://github.com/integrations/gitter) gitter with the repository ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/564
https://github.com/qutip/qutip/issues/564:367,Deployability,integrat,integrating,367,"[Gitter](https://gitter.im) is a networking platform with tight integration to Github. Its shows the latest activity (commits, PR, comments on issues) and can be a place for people to quickly connect with other QuTiP users and find solutions. For example, the gitter channel for Dipy is pretty active and helpful. (https://gitter.im/nipy/dipy). Has QuTiP considered [integrating](https://github.com/integrations/gitter) gitter with the repository ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/564
https://github.com/qutip/qutip/issues/564:399,Deployability,integrat,integrations,399,"[Gitter](https://gitter.im) is a networking platform with tight integration to Github. Its shows the latest activity (commits, PR, comments on issues) and can be a place for people to quickly connect with other QuTiP users and find solutions. For example, the gitter channel for Dipy is pretty active and helpful. (https://gitter.im/nipy/dipy). Has QuTiP considered [integrating](https://github.com/integrations/gitter) gitter with the repository ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/564
https://github.com/qutip/qutip/issues/564:64,Integrability,integrat,integration,64,"[Gitter](https://gitter.im) is a networking platform with tight integration to Github. Its shows the latest activity (commits, PR, comments on issues) and can be a place for people to quickly connect with other QuTiP users and find solutions. For example, the gitter channel for Dipy is pretty active and helpful. (https://gitter.im/nipy/dipy). Has QuTiP considered [integrating](https://github.com/integrations/gitter) gitter with the repository ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/564
https://github.com/qutip/qutip/issues/564:367,Integrability,integrat,integrating,367,"[Gitter](https://gitter.im) is a networking platform with tight integration to Github. Its shows the latest activity (commits, PR, comments on issues) and can be a place for people to quickly connect with other QuTiP users and find solutions. For example, the gitter channel for Dipy is pretty active and helpful. (https://gitter.im/nipy/dipy). Has QuTiP considered [integrating](https://github.com/integrations/gitter) gitter with the repository ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/564
https://github.com/qutip/qutip/issues/564:399,Integrability,integrat,integrations,399,"[Gitter](https://gitter.im) is a networking platform with tight integration to Github. Its shows the latest activity (commits, PR, comments on issues) and can be a place for people to quickly connect with other QuTiP users and find solutions. For example, the gitter channel for Dipy is pretty active and helpful. (https://gitter.im/nipy/dipy). Has QuTiP considered [integrating](https://github.com/integrations/gitter) gitter with the repository ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/564
https://github.com/qutip/qutip/pull/569:72,Testability,test,tests,72,Corrected sign in jmat when called without arguments and the respective tests in test_operators.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/569
https://github.com/qutip/qutip/issues/571:164,Deployability,install,installation,164,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/571
https://github.com/qutip/qutip/issues/571:252,Deployability,install,install,252,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/571
https://github.com/qutip/qutip/issues/571:366,Deployability,install,install,366,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/571
https://github.com/qutip/qutip/issues/571:473,Deployability,install,install,473,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/571
https://github.com/qutip/qutip/issues/571:1033,Modifiability,extend,extend,1033,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/571
https://github.com/qutip/qutip/issues/571:304,Security,access,access,304,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/571
https://github.com/qutip/qutip/issues/571:726,Usability,Clear,Clearly,726,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/571
https://github.com/qutip/qutip/issues/572:1719,Security,hash,hashtag,1719,"The problem appears in qutip version 4.0.0 when considering the tensor product of a few systems, and including more than one dissipation channel. I noticed a similar issue on a much more complex system, but in the code attached I consider the simplest system on which I have found the bug to appear. Consider three uncoupled qubits, each with a distinct frequency. The Hamiltonian is (ignoring tensor products with identity matrices) :. H = (w1 / 2) * sigmaz_1 + (w2 / 2) * sigmaz_2 + (w3 / 2) * sigmaz_3. Let us couple qubits 2 and 3 to independent white-noise environments through operators sigmax_2 and sigmax_3. Qubit 1 is decoupled from the other qubits, and does not couple to any relaxation channel. We consider the initial state |1:e, 2:g, 3:g>, where g(e) labels the ground (excited) state of a qubit, and evaluate the population of the excited state of qubit 1 as a function of time using bloch_redfield_tensor() and bloch_redfield_solve(). Since qubit 1 is decoupled from the other qubits, its excited-state population should remain 1 at all times. Yet, qutip yields exponential decay of the population of qubit 1. I noticed that when I remove dissipation for qubit 2 (keeping only dissipation through sigmax_3), the problem disappears and qubit 1 forever stays in its excited state. So the problem seems to arise when combining two relaxation sources. I am using qutip version 4.0.0. A colleague of mine tried the attached test code on qutip version 3.1.0 and did not catch any bug (i.e. qubit 1 did not relax with qutip 3.1.0). So the problem seems to be related to versions of qutip later than 3.1.0. Can anyone replicate the bug with the attached code ? . (I tried putting the code directly here but the hashtag signs for the comments made a mess, and github does not accept attached .py files, so I have put the code in a .txt file instead.). [redfield.txt](https://github.com/qutip/qutip/files/635122/redfield.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/572
https://github.com/qutip/qutip/issues/572:1435,Testability,test,test,1435,"The problem appears in qutip version 4.0.0 when considering the tensor product of a few systems, and including more than one dissipation channel. I noticed a similar issue on a much more complex system, but in the code attached I consider the simplest system on which I have found the bug to appear. Consider three uncoupled qubits, each with a distinct frequency. The Hamiltonian is (ignoring tensor products with identity matrices) :. H = (w1 / 2) * sigmaz_1 + (w2 / 2) * sigmaz_2 + (w3 / 2) * sigmaz_3. Let us couple qubits 2 and 3 to independent white-noise environments through operators sigmax_2 and sigmax_3. Qubit 1 is decoupled from the other qubits, and does not couple to any relaxation channel. We consider the initial state |1:e, 2:g, 3:g>, where g(e) labels the ground (excited) state of a qubit, and evaluate the population of the excited state of qubit 1 as a function of time using bloch_redfield_tensor() and bloch_redfield_solve(). Since qubit 1 is decoupled from the other qubits, its excited-state population should remain 1 at all times. Yet, qutip yields exponential decay of the population of qubit 1. I noticed that when I remove dissipation for qubit 2 (keeping only dissipation through sigmax_3), the problem disappears and qubit 1 forever stays in its excited state. So the problem seems to arise when combining two relaxation sources. I am using qutip version 4.0.0. A colleague of mine tried the attached test code on qutip version 3.1.0 and did not catch any bug (i.e. qubit 1 did not relax with qutip 3.1.0). So the problem seems to be related to versions of qutip later than 3.1.0. Can anyone replicate the bug with the attached code ? . (I tried putting the code directly here but the hashtag signs for the comments made a mess, and github does not accept attached .py files, so I have put the code in a .txt file instead.). [redfield.txt](https://github.com/qutip/qutip/files/635122/redfield.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/572
https://github.com/qutip/qutip/issues/572:243,Usability,simpl,simplest,243,"The problem appears in qutip version 4.0.0 when considering the tensor product of a few systems, and including more than one dissipation channel. I noticed a similar issue on a much more complex system, but in the code attached I consider the simplest system on which I have found the bug to appear. Consider three uncoupled qubits, each with a distinct frequency. The Hamiltonian is (ignoring tensor products with identity matrices) :. H = (w1 / 2) * sigmaz_1 + (w2 / 2) * sigmaz_2 + (w3 / 2) * sigmaz_3. Let us couple qubits 2 and 3 to independent white-noise environments through operators sigmax_2 and sigmax_3. Qubit 1 is decoupled from the other qubits, and does not couple to any relaxation channel. We consider the initial state |1:e, 2:g, 3:g>, where g(e) labels the ground (excited) state of a qubit, and evaluate the population of the excited state of qubit 1 as a function of time using bloch_redfield_tensor() and bloch_redfield_solve(). Since qubit 1 is decoupled from the other qubits, its excited-state population should remain 1 at all times. Yet, qutip yields exponential decay of the population of qubit 1. I noticed that when I remove dissipation for qubit 2 (keeping only dissipation through sigmax_3), the problem disappears and qubit 1 forever stays in its excited state. So the problem seems to arise when combining two relaxation sources. I am using qutip version 4.0.0. A colleague of mine tried the attached test code on qutip version 3.1.0 and did not catch any bug (i.e. qubit 1 did not relax with qutip 3.1.0). So the problem seems to be related to versions of qutip later than 3.1.0. Can anyone replicate the bug with the attached code ? . (I tried putting the code directly here but the hashtag signs for the comments made a mess, and github does not accept attached .py files, so I have put the code in a .txt file instead.). [redfield.txt](https://github.com/qutip/qutip/files/635122/redfield.txt)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/572
https://github.com/qutip/qutip/pull/576:62,Deployability,update,updated,62,A faster way to get the cdef'ed version of numpy arrays. Only updated the spmatfuncs module since the others have some compatibility issues that should be addressed first.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/576
https://github.com/qutip/qutip/issues/580:20,Safety,avoid,avoided,20,* imports should be avoided internally to try and make single qutip module imports more lightweight,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/580
https://github.com/qutip/qutip/pull/586:5,Testability,test,tests,5,Unit tests for fast_csr class,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/586
https://github.com/qutip/qutip/pull/587:32,Integrability,depend,dependent,32,Use double erf function in time-dependent strings,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/587
https://github.com/qutip/qutip/issues/597:652,Availability,down,down,652,"We get warnings when compiling using the mingw32 compiler under windows.; ```; ""unknown conversion type 'z' in format""; ```; The warnings only seem to occur during the tests and not the build_ext, so there may be something we can do with CFLAGS. ; I have done quite a lot of reading around and it seems many projects suffer from this. There did not seem to be a clear resolution, other than to change the C code. We don't seem to use the 'z' in any of our source, but it is found in all the so files, so I guess it is used in one of the dependencies, and hence I don't think we can take that approach.; The tests still seem to pass, so I am putting it down as a won't fix.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/597
https://github.com/qutip/qutip/issues/597:537,Integrability,depend,dependencies,537,"We get warnings when compiling using the mingw32 compiler under windows.; ```; ""unknown conversion type 'z' in format""; ```; The warnings only seem to occur during the tests and not the build_ext, so there may be something we can do with CFLAGS. ; I have done quite a lot of reading around and it seems many projects suffer from this. There did not seem to be a clear resolution, other than to change the C code. We don't seem to use the 'z' in any of our source, but it is found in all the so files, so I guess it is used in one of the dependencies, and hence I don't think we can take that approach.; The tests still seem to pass, so I am putting it down as a won't fix.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/597
https://github.com/qutip/qutip/issues/597:168,Testability,test,tests,168,"We get warnings when compiling using the mingw32 compiler under windows.; ```; ""unknown conversion type 'z' in format""; ```; The warnings only seem to occur during the tests and not the build_ext, so there may be something we can do with CFLAGS. ; I have done quite a lot of reading around and it seems many projects suffer from this. There did not seem to be a clear resolution, other than to change the C code. We don't seem to use the 'z' in any of our source, but it is found in all the so files, so I guess it is used in one of the dependencies, and hence I don't think we can take that approach.; The tests still seem to pass, so I am putting it down as a won't fix.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/597
https://github.com/qutip/qutip/issues/597:607,Testability,test,tests,607,"We get warnings when compiling using the mingw32 compiler under windows.; ```; ""unknown conversion type 'z' in format""; ```; The warnings only seem to occur during the tests and not the build_ext, so there may be something we can do with CFLAGS. ; I have done quite a lot of reading around and it seems many projects suffer from this. There did not seem to be a clear resolution, other than to change the C code. We don't seem to use the 'z' in any of our source, but it is found in all the so files, so I guess it is used in one of the dependencies, and hence I don't think we can take that approach.; The tests still seem to pass, so I am putting it down as a won't fix.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/597
https://github.com/qutip/qutip/issues/597:362,Usability,clear,clear,362,"We get warnings when compiling using the mingw32 compiler under windows.; ```; ""unknown conversion type 'z' in format""; ```; The warnings only seem to occur during the tests and not the build_ext, so there may be something we can do with CFLAGS. ; I have done quite a lot of reading around and it seems many projects suffer from this. There did not seem to be a clear resolution, other than to change the C code. We don't seem to use the 'z' in any of our source, but it is found in all the so files, so I guess it is used in one of the dependencies, and hence I don't think we can take that approach.; The tests still seem to pass, so I am putting it down as a won't fix.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/597
https://github.com/qutip/qutip/issues/598:446,Deployability,install,install,446,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/598
https://github.com/qutip/qutip/issues/598:55,Modifiability,config,config,55,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/598
https://github.com/qutip/qutip/issues/598:161,Modifiability,config,config,161,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/598
https://github.com/qutip/qutip/issues/598:47,Performance,load,loading,47,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/598
https://github.com/qutip/qutip/issues/598:153,Performance,load,loading,153,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/598
https://github.com/qutip/qutip/issues/598:241,Performance,load,loadparams,241,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/598
https://github.com/qutip/qutip/issues/598:7,Testability,test,test,7,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/598
https://github.com/qutip/qutip/issues/599:67,Availability,failure,failure,67,"infidelity threshold not reached on Windows tests. It is a strange failure, as the assert_almost_equal would seem to be within tolerance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/599
https://github.com/qutip/qutip/issues/599:127,Availability,toler,tolerance,127,"infidelity threshold not reached on Windows tests. It is a strange failure, as the assert_almost_equal would seem to be within tolerance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/599
https://github.com/qutip/qutip/issues/599:44,Testability,test,tests,44,"infidelity threshold not reached on Windows tests. It is a strange failure, as the assert_almost_equal would seem to be within tolerance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/599
https://github.com/qutip/qutip/pull/600:20,Testability,test,tests,20,"Control pulse optim tests split into more distinct functions.; This is generally a good idea, and will also help investigate #599",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/600
https://github.com/qutip/qutip/issues/601:14,Testability,test,tests,14,Running qutip tests is leaving behind rhs*.pyx files.; @nonhermitian I think you said you know which one(s); I guess it's quite easy to fix if I can pin-point the offender,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/601
https://github.com/qutip/qutip/pull/603:276,Availability,fault,fault-tolerant,276,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:292,Availability,error,error,292,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:596,Availability,fault,fault-tolerant,596,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:1677,Availability,error,errors,1677,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:658,Deployability,pipeline,pipeline,658,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:1706,Deployability,Update,Update,1706,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:327,Performance,optimiz,optimization,327,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:671,Performance,optimiz,optimization,671,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:865,Performance,optimiz,optimizations,865,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:1695,Testability,test,tests,1695,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/603:931,Usability,learn,learning,931,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/603
https://github.com/qutip/qutip/pull/604:15,Testability,test,tests,15,All pulseoptim tests now passing on Windows,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/604
https://github.com/qutip/qutip/issues/607:17,Testability,test,tests,17,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:455,Testability,test,test-environment,455,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:542,Testability,test,test,542,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:593,Testability,test,test-environment,593,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:692,Testability,test,tests,692,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:850,Testability,test,test-environment,850,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:901,Testability,test,testing,901,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:947,Testability,Assert,AssertionError,947,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:969,Testability,Assert,AssertionError,969,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/issues/607:58,Usability,clear,clear,58,"Some correlation tests fail on some attempts.; Not really clear why.; This issue can be used to keep a record, and then they can be fixed. This is an example:; ```; ======================================================================; FAIL: correlation: comparing me and mc for driven oscillator in fock state; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/qutip-4.1.0.dev0+0e91439-py2.7-linux-x86_64.egg/qutip/tests/test_correlation.py"", line 125, in test_compare_solvers_coherent_state_memc; assert_(abs(corr1 - corr2).max() < 0.2); File ""/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/numpy/testing/utils.py"", line 77, in assert_; raise AssertionError(smsg); AssertionError; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/607
https://github.com/qutip/qutip/pull/608:105,Testability,test,tests,105,The .T and .H methods for fast_csr were not returning another fast_csr. This fixes that an verifies with tests.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/608
https://github.com/qutip/qutip/pull/609:23,Safety,safe,safety,23,"This pull implements a safety check where the Qobj data class is validated as fast_csr_matrix type everytime the Q.data attribute is set. This guarantees that the Qobj's have the correct data type. This was not always true previously. In addition, many items are fixed so that the above rule passes. Finally, we no longer need the tests that check for Qobj csr_matrix type. This is now strictly enforced.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/609
https://github.com/qutip/qutip/pull/609:65,Security,validat,validated,65,"This pull implements a safety check where the Qobj data class is validated as fast_csr_matrix type everytime the Q.data attribute is set. This guarantees that the Qobj's have the correct data type. This was not always true previously. In addition, many items are fixed so that the above rule passes. Finally, we no longer need the tests that check for Qobj csr_matrix type. This is now strictly enforced.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/609
https://github.com/qutip/qutip/pull/609:331,Testability,test,tests,331,"This pull implements a safety check where the Qobj data class is validated as fast_csr_matrix type everytime the Q.data attribute is set. This guarantees that the Qobj's have the correct data type. This was not always true previously. In addition, many items are fixed so that the above rule passes. Finally, we no longer need the tests that check for Qobj csr_matrix type. This is now strictly enforced.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/609
https://github.com/qutip/qutip/issues/610:918,Safety,sanity check,sanity check,918,"Currently, the method to add a new gate to a quantum circuit is the following:; ```; import numpy as np; from qutip import QubitCircuit; from qutip.qip.circuit import Gate. qcircuit = QubitCircuit(4); qcircuit.add_gate(""CNOT"", targets=[2], controls=[0]). # This is a valid gate addition.; qcircuit.add_gate(""test_gate"", targets=[0], controls=[1], arg_label=r""\pi/12"",; 	 arg_value=""np.pi/12""); for gate in qcircuit.gates:; 	print(gate). ```. There is no way to add a gate directly. For instance:. ```; test_gate = Gate(""test_gate"", targets=[0], controls=[1], arg_label=r""\pi/12"",; 	 arg_value=""np.pi/12""); # This leads to an invalid gate addition.; qcircuit.add_gate(test_gate); ```; which leads to . ```; Gate(Gate(test_gate, targets=[0], controls=[1]), targets=None, controls=None); ```. Can we add a check to see if the input to `add_gate` is a Gate object and unpack it to add a new gate ? Or, have some kind of a sanity check if the given input is in a correct gate input format. (name, targets, controls).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/610
https://github.com/qutip/qutip/pull/611:69,Testability,test,test,69,This is in ref to #610. I have also cleaned up some pep8 and added a test for `add_gate`. This is now ready for review. @ajgpitch,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/611
https://github.com/qutip/qutip/issues/616:216,Availability,avail,available,216,"The latest version of QuTIP uploaded to PyPI (4.0.1 uploaded on 2016-12-29) has scipy (>=0.15) listed as a dependency. However, the file fastsparse.py imports `get_sum_dtype` from scipy.sparse.sputils, which is only available in scipy 0.18 and newer. I believe that the function was not actually used, and the import was removed in commit #596. . I am not certain that the current version still requires scipy(>=0.18), but the version currently available on PyPI (and thus auto-installed with pip) does require it. If the user has an earlier version of scipy, qutip will fail on import (ImportError).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/616
https://github.com/qutip/qutip/issues/616:445,Availability,avail,available,445,"The latest version of QuTIP uploaded to PyPI (4.0.1 uploaded on 2016-12-29) has scipy (>=0.15) listed as a dependency. However, the file fastsparse.py imports `get_sum_dtype` from scipy.sparse.sputils, which is only available in scipy 0.18 and newer. I believe that the function was not actually used, and the import was removed in commit #596. . I am not certain that the current version still requires scipy(>=0.18), but the version currently available on PyPI (and thus auto-installed with pip) does require it. If the user has an earlier version of scipy, qutip will fail on import (ImportError).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/616
https://github.com/qutip/qutip/issues/616:478,Deployability,install,installed,478,"The latest version of QuTIP uploaded to PyPI (4.0.1 uploaded on 2016-12-29) has scipy (>=0.15) listed as a dependency. However, the file fastsparse.py imports `get_sum_dtype` from scipy.sparse.sputils, which is only available in scipy 0.18 and newer. I believe that the function was not actually used, and the import was removed in commit #596. . I am not certain that the current version still requires scipy(>=0.18), but the version currently available on PyPI (and thus auto-installed with pip) does require it. If the user has an earlier version of scipy, qutip will fail on import (ImportError).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/616
https://github.com/qutip/qutip/issues/616:107,Integrability,depend,dependency,107,"The latest version of QuTIP uploaded to PyPI (4.0.1 uploaded on 2016-12-29) has scipy (>=0.15) listed as a dependency. However, the file fastsparse.py imports `get_sum_dtype` from scipy.sparse.sputils, which is only available in scipy 0.18 and newer. I believe that the function was not actually used, and the import was removed in commit #596. . I am not certain that the current version still requires scipy(>=0.18), but the version currently available on PyPI (and thus auto-installed with pip) does require it. If the user has an earlier version of scipy, qutip will fail on import (ImportError).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/616
https://github.com/qutip/qutip/issues/617:288,Performance,perform,performed,288,"To generate a random ket and have it be in the tensor product space of 3 qubits I would use. ket = qutip.rand_ket(8, dims=[[2, 2, 2], [1, 1, 1]]); so to have the `dims` form I would get by actually taking the tensor product of three 1-qubit kets.; However this will fail due to the check performed of [L652](https://github.com/qutip/qutip/blob/master/qutip/random_objects.py#L652) of `random_objects.py`:. if not isinstance(dims, list) or isinstance(dims[0], list):; Did I understood wrong how the `dims` parameter of `rand_ket` is supposed to work? or is there a simple typo in the above line and it was instead supposed to be something like:. if not (isinstance(dims, list) or isinstance(dims[0], list)):; ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/617
https://github.com/qutip/qutip/issues/617:564,Usability,simpl,simple,564,"To generate a random ket and have it be in the tensor product space of 3 qubits I would use. ket = qutip.rand_ket(8, dims=[[2, 2, 2], [1, 1, 1]]); so to have the `dims` form I would get by actually taking the tensor product of three 1-qubit kets.; However this will fail due to the check performed of [L652](https://github.com/qutip/qutip/blob/master/qutip/random_objects.py#L652) of `random_objects.py`:. if not isinstance(dims, list) or isinstance(dims[0], list):; Did I understood wrong how the `dims` parameter of `rand_ket` is supposed to work? or is there a simple typo in the above line and it was instead supposed to be something like:. if not (isinstance(dims, list) or isinstance(dims[0], list)):; ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/617
https://github.com/qutip/qutip/pull/618:174,Testability,test,tests,174,"Some bug fixes in fast csr.; `get_sum_dtype` import removed as it was not used and incompatible with scipy < 0.18, as mentioned in #616 ; Various improvements / bug fixes in tests (fast_csr, control and correlation); Need for manifest.ini removed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/618
https://github.com/qutip/qutip/issues/621:71,Availability,toler,tolerances,71,Some tests fail from time to time. Most likely they need to have their tolerances increased; This issue replaces #607 as it is more general,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/621
https://github.com/qutip/qutip/issues/621:5,Testability,test,tests,5,Some tests fail from time to time. Most likely they need to have their tolerances increased; This issue replaces #607 as it is more general,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/621
https://github.com/qutip/qutip/issues/623:773,Modifiability,enhance,enhancement,773,"This is just for future reference for topological quantum circuits. A lab mate of mine (https://github.com/rxnew/) has developed a nice code for visualisation of topological quantum circuits which can be seen here - http://sahmed.in/tqc_viewer/. Click on one of the samples to see the circuit visualisation. It is in 3D and you can zoom in, zoom out and pan the figure. In future, if we implement topological quantum computing, surface codes etc we may wish to use this in some way. . I also had some difficulties with the LaTeX visualisation of quantum circuits and I was wondering if that could be improved somehow. Particularly, the .png file is not created during latex compilation. I will try to reproduce the issue and post here. This should probably be marked as an enhancement.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/623
https://github.com/qutip/qutip/issues/624:193,Testability,test,test,193,qutip-doc/guide/scripts/floquet_ex3.py raises an exception in `floquet_master_equation_tensor`; ```; TypeError: Qobj data must be in fast_csr format.; ```; This should have been picked up by a test.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/624
https://github.com/qutip/qutip/issues/624:10,Usability,guid,guide,10,qutip-doc/guide/scripts/floquet_ex3.py raises an exception in `floquet_master_equation_tensor`; ```; TypeError: Qobj data must be in fast_csr format.; ```; This should have been picked up by a test.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/624
https://github.com/qutip/qutip/issues/625:433,Testability,test,tests,433,"```; File ""/home/alex/GitHub/qutip/qutip/floquet.py"", line 989, in fmmesolve; R = floquet_master_equation_tensor(Amat, f_energies); File ""/home/alex/GitHub/qutip/qutip/floquet.py"", line 724, in floquet_master_equation_tensor; R.data = R.data.tolil(); File ""/home/alex/GitHub/qutip/qutip/qobj.py"", line 328, in set_data; raise TypeError('Qobj data must be in fast_csr format.'); TypeError: Qobj data must be in fast_csr format.; ```. tests should have caught this #624",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/625
https://github.com/qutip/qutip/pull/628:8,Availability,error,error,8,Fix for error that popped up when running:; ```; qutip-doc/guide/scripts/floquet_ex3.py; ```; Had to fix the last fix #626 as well.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/628
https://github.com/qutip/qutip/pull/628:59,Usability,guid,guide,59,Fix for error that popped up when running:; ```; qutip-doc/guide/scripts/floquet_ex3.py; ```; Had to fix the last fix #626 as well.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/628
https://github.com/qutip/qutip/pull/629:287,Integrability,depend,dependent,287,"A faster isherm function. 3-5x faster if operator is Hermitian, 100x+ faster if not. Essentially does a modified adjoint calculation. This requires having a csr matrix in canonical format, which is not guaranteed under sparse multiplication. Since canonical format is important for time-dependent dynamics as well, fast_csr_matrix now does the indices and data sorting for canonical format after multiplication. This gives a slight performance hit, but having all Qobj in canonical format outweighs this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/629
https://github.com/qutip/qutip/pull/629:432,Performance,perform,performance,432,"A faster isherm function. 3-5x faster if operator is Hermitian, 100x+ faster if not. Essentially does a modified adjoint calculation. This requires having a csr matrix in canonical format, which is not guaranteed under sparse multiplication. Since canonical format is important for time-dependent dynamics as well, fast_csr_matrix now does the indices and data sorting for canonical format after multiplication. This gives a slight performance hit, but having all Qobj in canonical format outweighs this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/629
https://github.com/qutip/qutip/issues/630:282,Availability,error,error,282,"The checks are too restrictive. For the collapse and expectation operator lists, previous versions allowed the input of single operators. The documentation also explicitly states this is OK. Ex. ; mesolve(qzero(2), fock(2, 1), [0, 2], destroy(2), sigmaz()). But now this yields the error:. Traceback (most recent call last):; File ""/home/kevinf/PycharmProjects/QutipProjects/test/test.py"", line 3, in <module>; mesolve(qzero(2), fock(2, 1), [0, 2], destroy(2), sigmaz()); File ""/usr/local/lib/python3.4/dist-packages/qutip/mesolve.py"", line 208, in mesolve; _solver_safety_check(H, rho0, c_ops, e_ops, args); File ""/usr/local/lib/python3.4/dist-packages/qutip/solver.py"", line 813, in _solver_safety_check; for ii in range(len(c_ops)):; TypeError: object of type 'Qobj' has no len()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/630
https://github.com/qutip/qutip/issues/630:375,Testability,test,test,375,"The checks are too restrictive. For the collapse and expectation operator lists, previous versions allowed the input of single operators. The documentation also explicitly states this is OK. Ex. ; mesolve(qzero(2), fock(2, 1), [0, 2], destroy(2), sigmaz()). But now this yields the error:. Traceback (most recent call last):; File ""/home/kevinf/PycharmProjects/QutipProjects/test/test.py"", line 3, in <module>; mesolve(qzero(2), fock(2, 1), [0, 2], destroy(2), sigmaz()); File ""/usr/local/lib/python3.4/dist-packages/qutip/mesolve.py"", line 208, in mesolve; _solver_safety_check(H, rho0, c_ops, e_ops, args); File ""/usr/local/lib/python3.4/dist-packages/qutip/solver.py"", line 813, in _solver_safety_check; for ii in range(len(c_ops)):; TypeError: object of type 'Qobj' has no len()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/630
https://github.com/qutip/qutip/issues/630:380,Testability,test,test,380,"The checks are too restrictive. For the collapse and expectation operator lists, previous versions allowed the input of single operators. The documentation also explicitly states this is OK. Ex. ; mesolve(qzero(2), fock(2, 1), [0, 2], destroy(2), sigmaz()). But now this yields the error:. Traceback (most recent call last):; File ""/home/kevinf/PycharmProjects/QutipProjects/test/test.py"", line 3, in <module>; mesolve(qzero(2), fock(2, 1), [0, 2], destroy(2), sigmaz()); File ""/usr/local/lib/python3.4/dist-packages/qutip/mesolve.py"", line 208, in mesolve; _solver_safety_check(H, rho0, c_ops, e_ops, args); File ""/usr/local/lib/python3.4/dist-packages/qutip/solver.py"", line 813, in _solver_safety_check; for ii in range(len(c_ops)):; TypeError: object of type 'Qobj' has no len()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/630
https://github.com/qutip/qutip/pull/631:53,Safety,safe,safety,53,- Just a simple reorder of the e_ops to list and the safety checks.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/631
https://github.com/qutip/qutip/pull/631:9,Usability,simpl,simple,9,- Just a simple reorder of the e_ops to list and the safety checks.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/631
https://github.com/qutip/qutip/issues/633:113,Availability,down,download,113,I am running ubuntu 16.4. The following code:; rho = rand_dm(5); hinton(rho);; produces the following figure:; ![download](https://cloud.githubusercontent.com/assets/9404272/21955048/107afc22-da6b-11e6-894c-f7e03d0b7eb8.png); I am unsure as to where the issue lies since I have latex installed and the bras and kets are displayed correctly inline with jupyter.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/633
https://github.com/qutip/qutip/issues/633:284,Deployability,install,installed,284,I am running ubuntu 16.4. The following code:; rho = rand_dm(5); hinton(rho);; produces the following figure:; ![download](https://cloud.githubusercontent.com/assets/9404272/21955048/107afc22-da6b-11e6-894c-f7e03d0b7eb8.png); I am unsure as to where the issue lies since I have latex installed and the bras and kets are displayed correctly inline with jupyter.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/633
https://github.com/qutip/qutip/pull/634:86,Integrability,depend,depending,86,"Moved the loops to cython, and reworked the indices selection. Now 2x - 100x+ faster, depending on size. This pull also switches the fast_csr_matrix multiplication to our own version. This eliminates the need to call A.prune() after the SciPy matmat call. We also handle the nnz=0 case better. Still need to do:; - ptrace unit tests; - move old ptrace to a 'legacy' folder for testing against.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/634
https://github.com/qutip/qutip/pull/634:327,Testability,test,tests,327,"Moved the loops to cython, and reworked the indices selection. Now 2x - 100x+ faster, depending on size. This pull also switches the fast_csr_matrix multiplication to our own version. This eliminates the need to call A.prune() after the SciPy matmat call. We also handle the nnz=0 case better. Still need to do:; - ptrace unit tests; - move old ptrace to a 'legacy' folder for testing against.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/634
https://github.com/qutip/qutip/pull/634:377,Testability,test,testing,377,"Moved the loops to cython, and reworked the indices selection. Now 2x - 100x+ faster, depending on size. This pull also switches the fast_csr_matrix multiplication to our own version. This eliminates the need to call A.prune() after the SciPy matmat call. We also handle the nnz=0 case better. Still need to do:; - ptrace unit tests; - move old ptrace to a 'legacy' folder for testing against.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/634
https://github.com/qutip/qutip/issues/635:49,Deployability,continuous,continuous,49,Is it possible to create a Hamiltonian which has continuous operators such as spatial differential operator? Perhaps this would be done using Sympy in some way?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/635
https://github.com/qutip/qutip/issues/637:42,Availability,error,error,42,"Does anyone know how to fix the following error, or even how to interpret it?. ---------------------------------------------------------------------------; ImportError Traceback (most recent call last); <ipython-input-2-d4205f385795> in <module>(); ----> 1 from qutip import*. /home/jan/.local/lib/python2.7/site-packages/qutip/__init__.pyc in <module>(); 203 ; 204 # core; --> 205 from qutip.qobj import *; 206 from qutip.states import *; 207 from qutip.operators import *. /home/jan/.local/lib/python2.7/site-packages/qutip/qobj.py in <module>(); 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.ptrace import _ptrace; 62 from qutip.permute import _permute. /home/jan/.local/lib/python2.7/site-packages/qutip/fastsparse.py in <module>(); 403 #Need to do some trailing imports here; 404 #-------------------------------------; --> 405 from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint). /home/jan/.local/lib/python2.7/site-packages/qutip/cy/__init__.py in <module>(); ----> 1 from qutip.cy.spmatfuncs import *. ImportError: /home/jan/.local/lib/python2.7/site-packages/qutip/cy/spmatfuncs.so: undefined symbol: PyUnicodeUCS2_FromStringAndSize",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/637
https://github.com/qutip/qutip/issues/639:176,Availability,error,error,176,"I'm using [solus](https://solus-project.com) 64-bit, and anaconda for my python. anaconda cannot find any qutip package, so I tried to install with pip. It gives the following error:. `Command ""/home/jakeargent/anaconda3/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:566,Availability,error,error,566,"I'm using [solus](https://solus-project.com) 64-bit, and anaconda for my python. anaconda cannot find any qutip package, so I tried to install with pip. It gives the following error:. `Command ""/home/jakeargent/anaconda3/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:1191,Availability,error,error,1191,"nd ""/home/jakeargent/anaconda3/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakearg",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:1271,Availability,down,down,1271,"ld-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:1665,Availability,error,error,1665,"cessing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:1745,Availability,down,down,1745,"home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the follow",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:1798,Availability,error,error,1798,"its.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcomp",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:1830,Availability,error,error,1830,"its.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcomp",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:2146,Availability,error,error,2146,"its.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcomp",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:4318,Availability,error,error,4318,".cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; copying build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wfor",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:4773,Availability,error,error,4773," build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:4901,Availability,error,error,4901," customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:4996,Availability,error,error,4996,"e-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it should",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:5312,Availability,error,error,5312,"e-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it should",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:5972,Availability,error,error-c,5972,"ong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it shouldn't)). How can I install qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:6027,Availability,error,error,6027,"ong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it shouldn't)). How can I install qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:135,Deployability,install,install,135,"I'm using [solus](https://solus-project.com) 64-bit, and anaconda for my python. anaconda cannot find any qutip package, so I tried to install with pip. It gives the following error:. `Command ""/home/jakeargent/anaconda3/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:446,Deployability,install,install,446,"I'm using [solus](https://solus-project.com) 64-bit, and anaconda for my python. anaconda cannot find any qutip package, so I tried to install with pip. It gives the following error:. `Command ""/home/jakeargent/anaconda3/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:488,Deployability,install,install-record,488,"I'm using [solus](https://solus-project.com) 64-bit, and anaconda for my python. anaconda cannot find any qutip package, so I tried to install with pip. It gives the following error:. `Command ""/home/jakeargent/anaconda3/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:808,Deployability,Install,Installing,808,"I'm using [solus](https://solus-project.com) 64-bit, and anaconda for my python. anaconda cannot find any qutip package, so I tried to install with pip. It gives the following error:. `Command ""/home/jakeargent/anaconda3/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-n7ekqm4y/qutip/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-lnsaamvm-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-n7ekqm4y/qutip/; `. Then I tried easy_install, which gave me:. `Processing qutip; Writing /home/jakeargent/qutip/setup.cfg; Running setup.py -q bdist_egg --dist-dir /home/jakeargent/qutip/egg-dist-tmp-9_egnp34; Installing without the fortran mcsolver.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:5913,Deployability,install,install-gives-command-python-setup-py-egg-info-failed-with-error-c,5913,"ong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it shouldn't)). How can I install qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:6100,Deployability,install,installed,6100,"ong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it shouldn't)). How can I install qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:6113,Deployability,upgrade,upgraded,6113,"ong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it shouldn't)). How can I install qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:6205,Deployability,install,install,6205,"ong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it shouldn't)). How can I install qutip?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:2849,Modifiability,config,config,2849,"ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; copying build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:2953,Modifiability,config,config,2953,"ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; copying build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:3672,Modifiability,config,config,3672,"to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; copying build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:1993,Security,secur,security,1993,"its.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; In file included from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/syslimits.h:7:0,; from /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:34,; from /home/jakeargent/anaconda3/include/python3.5m/Python.h:11,; from qutip/cy/spmatfuncs.c:27:; /usr/lib64/gcc/x86_64-solus-linux/6.3.0/include-fixed/limits.h:168:61: fatal error: limits.h: No such file or directory; #include_next <limits.h> /* recurse down to the real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcomp",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:4165,Security,secur,security,4165,".cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; copying build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wfor",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:5159,Security,secur,security,5159,"e-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; gcc: qutip/cy/src/zspmv.c; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; qutip/cy/src/zspmv.c:2:21: fatal error: complex.h: No such file or directory; #include <complex.h>; ^; compilation terminated.; error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/src/zspmv.c -o build/temp.linux-x86_64-3.5/qutip/cy/src/zspmv.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1`. Well, all of them seem to fail with a similar issue. Whatever is exit status 1. ([This](http://stackoverflow.com/questions/35991403/python-pip-install-gives-command-python-setup-py-egg-info-failed-with-error-c) is the SO solution I followed, it claims that error code is related to operation not permitted or setuptools not being installed. I upgraded the setuptools, pip doesn't work with sudo (I'm guessing it should",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/issues/639:2768,Testability,log,log,2768," real one */; ^; compilation terminated.; error: Setup script exited with error: Command ""gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/639
https://github.com/qutip/qutip/pull/641:289,Testability,test,tests,289,- Can now convert from COO to CSR structs inplace with inplace indices sort; - zcsr_mult now has the option to sort indices or not.; - sp_reshape now calls zcsr_reshape that does an in-place reshape.; - Handy functions for quickly builting structs from COO and CSR SciPy matrices.; - Unit tests for cython structs.; - Random objects with a given eigenspectra are now sorted.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/641
https://github.com/qutip/qutip/issues/645:100,Availability,Error,Error,100,"To reproduce the problem:. - run Lecture 8 - Adiabatic sweep from qutip lectures with qutip 4.02. - Error message:. Traceback (most recent call last):; File ""as.py"", line 92, in <module>; mesolve(h_t, psi0, taulist, [], process_rho, args); File ""/usr/local/lib/python2.7/site-packages/qutip/mesolve.py"", line 208, in mesolve; _solver_safety_check(H, rho0, c_ops, e_ops, args); File ""/usr/local/lib/python2.7/site-packages/qutip/solver.py"", line 822, in _solver_safety_check; for ii in range(len(e_ops)):; TypeError: object of type 'function' has no len()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/645
https://github.com/qutip/qutip/issues/645:106,Integrability,message,message,106,"To reproduce the problem:. - run Lecture 8 - Adiabatic sweep from qutip lectures with qutip 4.02. - Error message:. Traceback (most recent call last):; File ""as.py"", line 92, in <module>; mesolve(h_t, psi0, taulist, [], process_rho, args); File ""/usr/local/lib/python2.7/site-packages/qutip/mesolve.py"", line 208, in mesolve; _solver_safety_check(H, rho0, c_ops, e_ops, args); File ""/usr/local/lib/python2.7/site-packages/qutip/solver.py"", line 822, in _solver_safety_check; for ii in range(len(e_ops)):; TypeError: object of type 'function' has no len()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/645
https://github.com/qutip/qutip/issues/647:328,Deployability,install,installing,328,"Is there any performance reason why we should not compile the extensions using C++ ?. We are having issues with the conda forge packages:; conda-forge/qutip-feedstock#16; I am sure than this problem would not occur if we were compiling using MS compilers.; We are receiving lots of support requests on the Google group for help installing on Windows; We do not have a solution for python>=3.5 on Windows. I posted a question on the Cython help group asking about accessing complex functions on Windows. One suggestion was to try C++, importing functions from `complex` rather than `complex.h`. I made a small test project that imported `conj` and it compiled using MS compilers and worked on Windows 10 with both Python 2.7 and 3.5. We only have one small C source file. I guess it could be rewritten in C++ quite easily.; I can do further tests to check performance if we consider C++ compilation is an option for qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/647
https://github.com/qutip/qutip/issues/647:13,Performance,perform,performance,13,"Is there any performance reason why we should not compile the extensions using C++ ?. We are having issues with the conda forge packages:; conda-forge/qutip-feedstock#16; I am sure than this problem would not occur if we were compiling using MS compilers.; We are receiving lots of support requests on the Google group for help installing on Windows; We do not have a solution for python>=3.5 on Windows. I posted a question on the Cython help group asking about accessing complex functions on Windows. One suggestion was to try C++, importing functions from `complex` rather than `complex.h`. I made a small test project that imported `conj` and it compiled using MS compilers and worked on Windows 10 with both Python 2.7 and 3.5. We only have one small C source file. I guess it could be rewritten in C++ quite easily.; I can do further tests to check performance if we consider C++ compilation is an option for qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/647
https://github.com/qutip/qutip/issues/647:855,Performance,perform,performance,855,"Is there any performance reason why we should not compile the extensions using C++ ?. We are having issues with the conda forge packages:; conda-forge/qutip-feedstock#16; I am sure than this problem would not occur if we were compiling using MS compilers.; We are receiving lots of support requests on the Google group for help installing on Windows; We do not have a solution for python>=3.5 on Windows. I posted a question on the Cython help group asking about accessing complex functions on Windows. One suggestion was to try C++, importing functions from `complex` rather than `complex.h`. I made a small test project that imported `conj` and it compiled using MS compilers and worked on Windows 10 with both Python 2.7 and 3.5. We only have one small C source file. I guess it could be rewritten in C++ quite easily.; I can do further tests to check performance if we consider C++ compilation is an option for qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/647
https://github.com/qutip/qutip/issues/647:463,Security,access,accessing,463,"Is there any performance reason why we should not compile the extensions using C++ ?. We are having issues with the conda forge packages:; conda-forge/qutip-feedstock#16; I am sure than this problem would not occur if we were compiling using MS compilers.; We are receiving lots of support requests on the Google group for help installing on Windows; We do not have a solution for python>=3.5 on Windows. I posted a question on the Cython help group asking about accessing complex functions on Windows. One suggestion was to try C++, importing functions from `complex` rather than `complex.h`. I made a small test project that imported `conj` and it compiled using MS compilers and worked on Windows 10 with both Python 2.7 and 3.5. We only have one small C source file. I guess it could be rewritten in C++ quite easily.; I can do further tests to check performance if we consider C++ compilation is an option for qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/647
https://github.com/qutip/qutip/issues/647:609,Testability,test,test,609,"Is there any performance reason why we should not compile the extensions using C++ ?. We are having issues with the conda forge packages:; conda-forge/qutip-feedstock#16; I am sure than this problem would not occur if we were compiling using MS compilers.; We are receiving lots of support requests on the Google group for help installing on Windows; We do not have a solution for python>=3.5 on Windows. I posted a question on the Cython help group asking about accessing complex functions on Windows. One suggestion was to try C++, importing functions from `complex` rather than `complex.h`. I made a small test project that imported `conj` and it compiled using MS compilers and worked on Windows 10 with both Python 2.7 and 3.5. We only have one small C source file. I guess it could be rewritten in C++ quite easily.; I can do further tests to check performance if we consider C++ compilation is an option for qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/647
https://github.com/qutip/qutip/issues/647:840,Testability,test,tests,840,"Is there any performance reason why we should not compile the extensions using C++ ?. We are having issues with the conda forge packages:; conda-forge/qutip-feedstock#16; I am sure than this problem would not occur if we were compiling using MS compilers.; We are receiving lots of support requests on the Google group for help installing on Windows; We do not have a solution for python>=3.5 on Windows. I posted a question on the Cython help group asking about accessing complex functions on Windows. One suggestion was to try C++, importing functions from `complex` rather than `complex.h`. I made a small test project that imported `conj` and it compiled using MS compilers and worked on Windows 10 with both Python 2.7 and 3.5. We only have one small C source file. I guess it could be rewritten in C++ quite easily.; I can do further tests to check performance if we consider C++ compilation is an option for qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/647
https://github.com/qutip/qutip/pull/648:245,Integrability,depend,dependent,245,"I have managed to get everything moved over to c++. Should address #647. There are still a few issues to address, but the tests pass on unix based systems. - CFLAGS need to be set for visual studio builds.; - zspmv src files need to be platform dependent (i.e. win/unix versions). This is mainly due to a few minor variations in how compiler hinting is done. No big deal. Also, when moving to openmp, visual studio uses v2.0, which is a bit dated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/648
https://github.com/qutip/qutip/pull/648:122,Testability,test,tests,122,"I have managed to get everything moved over to c++. Should address #647. There are still a few issues to address, but the tests pass on unix based systems. - CFLAGS need to be set for visual studio builds.; - zspmv src files need to be platform dependent (i.e. win/unix versions). This is mainly due to a few minor variations in how compiler hinting is done. No big deal. Also, when moving to openmp, visual studio uses v2.0, which is a bit dated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/648
https://github.com/qutip/qutip/issues/649:49,Deployability,release,released,49,"Once pull #648 is merged I am keen to get a v4.1 released.; The conda-forge packages for Windows currently do work. I am very keen to resolve this. ; Also very keen to get a solution for qutip on MS Windows with Python >= 3.5 out there.; I am happy to do the admin work for the release. The installation documentation will need updating, I am happy to this.; Is there anything else we would like to finish off, that can be done quickly, that we would like to get into a release of 4.1?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/649
https://github.com/qutip/qutip/issues/649:278,Deployability,release,release,278,"Once pull #648 is merged I am keen to get a v4.1 released.; The conda-forge packages for Windows currently do work. I am very keen to resolve this. ; Also very keen to get a solution for qutip on MS Windows with Python >= 3.5 out there.; I am happy to do the admin work for the release. The installation documentation will need updating, I am happy to this.; Is there anything else we would like to finish off, that can be done quickly, that we would like to get into a release of 4.1?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/649
https://github.com/qutip/qutip/issues/649:291,Deployability,install,installation,291,"Once pull #648 is merged I am keen to get a v4.1 released.; The conda-forge packages for Windows currently do work. I am very keen to resolve this. ; Also very keen to get a solution for qutip on MS Windows with Python >= 3.5 out there.; I am happy to do the admin work for the release. The installation documentation will need updating, I am happy to this.; Is there anything else we would like to finish off, that can be done quickly, that we would like to get into a release of 4.1?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/649
https://github.com/qutip/qutip/issues/649:470,Deployability,release,release,470,"Once pull #648 is merged I am keen to get a v4.1 released.; The conda-forge packages for Windows currently do work. I am very keen to resolve this. ; Also very keen to get a solution for qutip on MS Windows with Python >= 3.5 out there.; I am happy to do the admin work for the release. The installation documentation will need updating, I am happy to this.; Is there anything else we would like to finish off, that can be done quickly, that we would like to get into a release of 4.1?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/649
https://github.com/qutip/qutip/pull/650:5,Deployability,update,updates,5,Some updates to the Cython code. Also removed the test scripts for the mcf90 routine as Pull #648 removed the ability to install the module.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/650
https://github.com/qutip/qutip/pull/650:121,Deployability,install,install,121,Some updates to the Cython code. Also removed the test scripts for the mcf90 routine as Pull #648 removed the ability to install the module.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/650
https://github.com/qutip/qutip/pull/650:77,Integrability,rout,routine,77,Some updates to the Cython code. Also removed the test scripts for the mcf90 routine as Pull #648 removed the ability to install the module.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/650
https://github.com/qutip/qutip/pull/650:50,Testability,test,test,50,Some updates to the Cython code. Also removed the test scripts for the mcf90 routine as Pull #648 removed the ability to install the module.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/650
https://github.com/qutip/qutip/pull/654:0,Deployability,Update,Updated,0,Updated RCM and one/inf-norms.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/654
https://github.com/qutip/qutip/pull/655:29,Deployability,update,update,29,"In moving to c++, we did not update the Cython cleanup routine. Also, using Visual Studio leads to a different set of temp files than GCC. Here, I take advantage of the fact that all the temp files start with 'tdname' and then just walk the dir to clean them, regardless of extension and what not.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/655
https://github.com/qutip/qutip/pull/655:55,Integrability,rout,routine,55,"In moving to c++, we did not update the Cython cleanup routine. Also, using Visual Studio leads to a different set of temp files than GCC. Here, I take advantage of the fact that all the temp files start with 'tdname' and then just walk the dir to clean them, regardless of extension and what not.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/655
https://github.com/qutip/qutip/pull/660:345,Availability,error,error,345,"Not sure what is causing conda-forge/qutip-feedstock#18, but switching to a vector in sort may help as there was no issues with the previous 4.0.2 build that has a similar routine in the COO -> CSR inplace conversion function. Note also that building with VS 2015, mingpy, clang-3.9 from homebrew, and clang from Apple itself does not raise the error mentioned in conda-forge/qutip-feedstock#18.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/660
https://github.com/qutip/qutip/pull/660:172,Integrability,rout,routine,172,"Not sure what is causing conda-forge/qutip-feedstock#18, but switching to a vector in sort may help as there was no issues with the previous 4.0.2 build that has a similar routine in the COO -> CSR inplace conversion function. Note also that building with VS 2015, mingpy, clang-3.9 from homebrew, and clang from Apple itself does not raise the error mentioned in conda-forge/qutip-feedstock#18.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/660
https://github.com/qutip/qutip/issues/661:994,Integrability,depend,depend,994,"When I tried to use the `qutip.squeeze` function for my simulations I noticed that something was off. Upon further investigation I found out that the output is not a truncated version of the single-mode squeezing unitary, but rather the matrix exponential of the truncated generator. These are _very_ different things!. Am I right in assuming that the most useful matrix would be the truncated unitary? If that's the case, the current method to compute it is wrong. To compute the right matrix one can use the disentangling formula for SU(1,1) (formula (31) [here](http://aip.scitation.org/doi/pdf/10.1063/1.3413923)):. ```python; def squeeze(n,z):; s0 = np.exp(1j*np.angle(z))*np.tanh(abs(z)); s1 = -2*np.log(np.cosh(abs(z))); s2 = -np.exp(-1j*np.angle(z))*np.tanh(abs(z)); ; L = s0*0.5*(qt.create(n)*qt.create(n)); K = s1*(0.5*qt.num(n)+0.25*qt.identity(n)); R = s2*0.5*(qt.destroy(n)*qt.destroy(n)); ; return (L.expm())*(K.expm())*(R.expm()); ```. As you can see, this definition does *not* depend on the truncation parameter. Specifically, the upper-left portion of the matrix that `qutip.squeeze` outputs converges to my `squeeze` function for large `n`. I suspect that one can apply similar arguments to other functions in `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/661
https://github.com/qutip/qutip/issues/661:706,Testability,log,log,706,"When I tried to use the `qutip.squeeze` function for my simulations I noticed that something was off. Upon further investigation I found out that the output is not a truncated version of the single-mode squeezing unitary, but rather the matrix exponential of the truncated generator. These are _very_ different things!. Am I right in assuming that the most useful matrix would be the truncated unitary? If that's the case, the current method to compute it is wrong. To compute the right matrix one can use the disentangling formula for SU(1,1) (formula (31) [here](http://aip.scitation.org/doi/pdf/10.1063/1.3413923)):. ```python; def squeeze(n,z):; s0 = np.exp(1j*np.angle(z))*np.tanh(abs(z)); s1 = -2*np.log(np.cosh(abs(z))); s2 = -np.exp(-1j*np.angle(z))*np.tanh(abs(z)); ; L = s0*0.5*(qt.create(n)*qt.create(n)); K = s1*(0.5*qt.num(n)+0.25*qt.identity(n)); R = s2*0.5*(qt.destroy(n)*qt.destroy(n)); ; return (L.expm())*(K.expm())*(R.expm()); ```. As you can see, this definition does *not* depend on the truncation parameter. Specifically, the upper-left portion of the matrix that `qutip.squeeze` outputs converges to my `squeeze` function for large `n`. I suspect that one can apply similar arguments to other functions in `qutip`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/661
https://github.com/qutip/qutip/pull/662:30,Deployability,release,release,30,Applying fix from #660 to the release branch,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/662
https://github.com/qutip/qutip/pull/668:54,Availability,error,error,54,"The `from scipy.misc import factorial` generated some error when building win py27 builds in conda-forge/qutip-feedstock#18. So I moved it to the only function in `utilities` that used it. Not strictly good practice. Would perhaps be better to move `_version2int` and `_blas_info` to another module, but quite a bit more work and I was not sure what to call the module: `sysutils`?. The error came from inside scipy due to a call to `multiprocessing.cpu_count()`. As we had one of those inside `__init__()` I wrapped that up as well.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/668
https://github.com/qutip/qutip/pull/668:387,Availability,error,error,387,"The `from scipy.misc import factorial` generated some error when building win py27 builds in conda-forge/qutip-feedstock#18. So I moved it to the only function in `utilities` that used it. Not strictly good practice. Would perhaps be better to move `_version2int` and `_blas_info` to another module, but quite a bit more work and I was not sure what to call the module: `sysutils`?. The error came from inside scipy due to a call to `multiprocessing.cpu_count()`. As we had one of those inside `__init__()` I wrapped that up as well.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/668
https://github.com/qutip/qutip/pull/668:509,Integrability,wrap,wrapped,509,"The `from scipy.misc import factorial` generated some error when building win py27 builds in conda-forge/qutip-feedstock#18. So I moved it to the only function in `utilities` that used it. Not strictly good practice. Would perhaps be better to move `_version2int` and `_blas_info` to another module, but quite a bit more work and I was not sure what to call the module: `sysutils`?. The error came from inside scipy due to a call to `multiprocessing.cpu_count()`. As we had one of those inside `__init__()` I wrapped that up as well.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/668
https://github.com/qutip/qutip/pull/669:33,Deployability,release,release,33,applying qutip/qutip#668 to this release branch,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/669
https://github.com/qutip/qutip/issues/671:0,Availability,Error,Error,0,"Error message:; ```; ../anaconda/lib/python3.4/site-packages/qutip/bloch3d.py"", line 115, in __init__; raise Exception(""This function requires the mayavi module.""); ```; It seems that we cannot use python3 and mayavi at the same time. Anyone has similar issues?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/671
https://github.com/qutip/qutip/issues/671:6,Integrability,message,message,6,"Error message:; ```; ../anaconda/lib/python3.4/site-packages/qutip/bloch3d.py"", line 115, in __init__; raise Exception(""This function requires the mayavi module.""); ```; It seems that we cannot use python3 and mayavi at the same time. Anyone has similar issues?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/671
https://github.com/qutip/qutip/issues/672:272,Usability,simpl,simple,272,"In all my recent PR branches many commits are shown. I think these date back to when we started Squash & Merge as our policy. The same policy is in use on our conda-forge/qutip-feedstock but I don't find this issue there. I did a lot of reading, but could not find a nice simple way to stop this happening. Do we know why this is happening? I see @nonhermitian has a similar string of old commits on his PR branches too. I see we have a new 'Rebase and Merge' option for merging PRs now. Do we think we should be using this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/672
https://github.com/qutip/qutip/issues/674:0,Deployability,Install,Installing,0,"Installing qutip via the conda package and then importing it produces a crash for me:. goerz@mlhpc2:~> conda create -y -c conda-forge -m -n qutiptest python=3.5 qutip; Using Anaconda Cloud api site https://api.anaconda.org; Fetching package metadata: ........; Solving package specifications: ......... Package plan for installation in environment /home/goerz/.conda/envs/qutiptest:. The following NEW packages will be INSTALLED:. certifi: 2017.1.23-py35_0; cython: 0.25.2-py35_1; libgfortran: 3.0.0-1; mkl: 2017.0.1-0; ncurses: 5.9-10 numpy: 1.12.1-py35_0; openssl: 1.0.2k-1; pip: 9.0.1-py35_1; python: 3.5.3-1; qutip: 4.1.0-np112py35_1; readline: 6.2-2 (soft-link); scipy: 0.19.0-np112py35_0; setuptools: 33.1.1-py35_0; sqlite: 3.13.0-1; tk: 8.5.19-1; wheel: 0.29.0-py35_0; xz: 5.2.2-1; zlib: 1.2.11-0. Linking packages ...; [ COMPLETE ]|##########################| 100%; #; # To activate this environment, use:; # $ source activate qutiptest; #; # To deactivate this environment, use:; # $ source deactivate; #; goerz@mlhpc2:~> source activate qutiptest; discarding /home/goerz/.conda/envs/default/bin from PATH; prepending /home/goerz/.conda/envs/qutiptest/bin to PATH; (qutiptest)goerz@mlhpc2:~> python; Python 3.5.3 | packaged by conda-forge | (default, Feb 9 2017, 14:37:12); [GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] on linux; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; /home/goerz/.conda/envs/qutiptest/lib/python3.5/site-packages/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Illegal instruction (core dumped); (qutiptest)goerz@mlhpc2:~>. Let me know if you need further information on my setup in order to reproduce this",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/674
https://github.com/qutip/qutip/issues/674:320,Deployability,install,installation,320,"Installing qutip via the conda package and then importing it produces a crash for me:. goerz@mlhpc2:~> conda create -y -c conda-forge -m -n qutiptest python=3.5 qutip; Using Anaconda Cloud api site https://api.anaconda.org; Fetching package metadata: ........; Solving package specifications: ......... Package plan for installation in environment /home/goerz/.conda/envs/qutiptest:. The following NEW packages will be INSTALLED:. certifi: 2017.1.23-py35_0; cython: 0.25.2-py35_1; libgfortran: 3.0.0-1; mkl: 2017.0.1-0; ncurses: 5.9-10 numpy: 1.12.1-py35_0; openssl: 1.0.2k-1; pip: 9.0.1-py35_1; python: 3.5.3-1; qutip: 4.1.0-np112py35_1; readline: 6.2-2 (soft-link); scipy: 0.19.0-np112py35_0; setuptools: 33.1.1-py35_0; sqlite: 3.13.0-1; tk: 8.5.19-1; wheel: 0.29.0-py35_0; xz: 5.2.2-1; zlib: 1.2.11-0. Linking packages ...; [ COMPLETE ]|##########################| 100%; #; # To activate this environment, use:; # $ source activate qutiptest; #; # To deactivate this environment, use:; # $ source deactivate; #; goerz@mlhpc2:~> source activate qutiptest; discarding /home/goerz/.conda/envs/default/bin from PATH; prepending /home/goerz/.conda/envs/qutiptest/bin to PATH; (qutiptest)goerz@mlhpc2:~> python; Python 3.5.3 | packaged by conda-forge | (default, Feb 9 2017, 14:37:12); [GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] on linux; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; /home/goerz/.conda/envs/qutiptest/lib/python3.5/site-packages/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Illegal instruction (core dumped); (qutiptest)goerz@mlhpc2:~>. Let me know if you need further information on my setup in order to reproduce this",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/674
https://github.com/qutip/qutip/issues/674:419,Deployability,INSTALL,INSTALLED,419,"Installing qutip via the conda package and then importing it produces a crash for me:. goerz@mlhpc2:~> conda create -y -c conda-forge -m -n qutiptest python=3.5 qutip; Using Anaconda Cloud api site https://api.anaconda.org; Fetching package metadata: ........; Solving package specifications: ......... Package plan for installation in environment /home/goerz/.conda/envs/qutiptest:. The following NEW packages will be INSTALLED:. certifi: 2017.1.23-py35_0; cython: 0.25.2-py35_1; libgfortran: 3.0.0-1; mkl: 2017.0.1-0; ncurses: 5.9-10 numpy: 1.12.1-py35_0; openssl: 1.0.2k-1; pip: 9.0.1-py35_1; python: 3.5.3-1; qutip: 4.1.0-np112py35_1; readline: 6.2-2 (soft-link); scipy: 0.19.0-np112py35_0; setuptools: 33.1.1-py35_0; sqlite: 3.13.0-1; tk: 8.5.19-1; wheel: 0.29.0-py35_0; xz: 5.2.2-1; zlib: 1.2.11-0. Linking packages ...; [ COMPLETE ]|##########################| 100%; #; # To activate this environment, use:; # $ source activate qutiptest; #; # To deactivate this environment, use:; # $ source deactivate; #; goerz@mlhpc2:~> source activate qutiptest; discarding /home/goerz/.conda/envs/default/bin from PATH; prepending /home/goerz/.conda/envs/qutiptest/bin to PATH; (qutiptest)goerz@mlhpc2:~> python; Python 3.5.3 | packaged by conda-forge | (default, Feb 9 2017, 14:37:12); [GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] on linux; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; /home/goerz/.conda/envs/qutiptest/lib/python3.5/site-packages/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Illegal instruction (core dumped); (qutiptest)goerz@mlhpc2:~>. Let me know if you need further information on my setup in order to reproduce this",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/674
https://github.com/qutip/qutip/pull/676:44,Integrability,depend,dependent,44,This is the Pull that will contain the time-dependent Bloch-Redfield solver.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/676
https://github.com/qutip/qutip/issues/678:165,Modifiability,variab,variables,165,"We should modify the `QubitCircuit` class to have input and output states specified for a quantum circuit. Currently the `QubitCircuit` class has only the following variables - N, reverse_gates, gates, U_list. We could add two more variables - input_states, output_states which could contain the input and output states as a list or a dictionary with the qubit number as key and the state as the value. This can be added to QubitCircuit [here](https://github.com/qutip/qutip/blob/master/qutip/qip/circuit.py#L168). . Then we can modify the function [`latex_code`](https://github.com/qutip/qutip/blob/master/qutip/qip/circuit.py#L939) to add in the input and output states similar to how the gates are added so the qcircuit latex package compiles it. The original [discussion](https://groups.google.com/forum/#!topic/qutip/QRu54GlED9A) can be found in the QuTiP Google help group where Morten Kjaergaard suggested this. . To do; -----. - [x] Add input and output states to `QubitCircuit` class.; - [x] Implement latex visualisation of input and output states.; - [ ] Create a dictionary to label known states and get their representation using the `qubit_states` function for computation. {""+"": (|0> + |1>)/sqrt(2), ""0"": 0}. This can be used with the `qubit_state` function to get a `Qobj` so that it can be used for computing.; - [ ] Add a method to get output states from input states by acting the propagators of the circuit on the given input states.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/678
https://github.com/qutip/qutip/issues/678:232,Modifiability,variab,variables,232,"We should modify the `QubitCircuit` class to have input and output states specified for a quantum circuit. Currently the `QubitCircuit` class has only the following variables - N, reverse_gates, gates, U_list. We could add two more variables - input_states, output_states which could contain the input and output states as a list or a dictionary with the qubit number as key and the state as the value. This can be added to QubitCircuit [here](https://github.com/qutip/qutip/blob/master/qutip/qip/circuit.py#L168). . Then we can modify the function [`latex_code`](https://github.com/qutip/qutip/blob/master/qutip/qip/circuit.py#L939) to add in the input and output states similar to how the gates are added so the qcircuit latex package compiles it. The original [discussion](https://groups.google.com/forum/#!topic/qutip/QRu54GlED9A) can be found in the QuTiP Google help group where Morten Kjaergaard suggested this. . To do; -----. - [x] Add input and output states to `QubitCircuit` class.; - [x] Implement latex visualisation of input and output states.; - [ ] Create a dictionary to label known states and get their representation using the `qubit_states` function for computation. {""+"": (|0> + |1>)/sqrt(2), ""0"": 0}. This can be used with the `qubit_state` function to get a `Qobj` so that it can be used for computing.; - [ ] Add a method to get output states from input states by acting the propagators of the circuit on the given input states.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/678
https://github.com/qutip/qutip/issues/681:133,Availability,down,down,133,"I just updated to qutip 4.1.0 on archlinux and now code that ran fine before simply fails. The smallest example I managed to boil it down to is multiplying a daggered state with an operator:; ```; import qutip as qt; import numpy as np. N = 10; x = qt.Qobj(np.ones(N, complex)/(N**(1/2))); op = qt.destroy(N) + qt.create(N). for i in range(10):; print(x.dag()*op); ```; which randomly yields different results, e.g.; ```; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+241j; 5.37624943e+241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; 0.94868330+0.j ]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; 0.94868330+0.j ]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +0.00000000e+000j 0.00000000e+000 +5.29328215e+180j; 5.29328215e+180 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+24",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:7,Deployability,update,updated,7,"I just updated to qutip 4.1.0 on archlinux and now code that ran fine before simply fails. The smallest example I managed to boil it down to is multiplying a daggered state with an operator:; ```; import qutip as qt; import numpy as np. N = 10; x = qt.Qobj(np.ones(N, complex)/(N**(1/2))); op = qt.destroy(N) + qt.create(N). for i in range(10):; print(x.dag()*op); ```; which randomly yields different results, e.g.; ```; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+241j; 5.37624943e+241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; 0.94868330+0.j ]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; 0.94868330+0.j ]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +0.00000000e+000j 0.00000000e+000 +5.29328215e+180j; 5.29328215e+180 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+24",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:3378,Energy Efficiency,monitor,monitor,3378,"241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb intel_ppin tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts; ```; I'll gladly provide any additional information that might be needed. It's definitely a possibility that I did something wrong in the build process of either qutip itself (this is the archlinux build script: https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=python-qutip) or one of its libraries. Any ideas?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:2567,Integrability,depend,dependent,2567,"0000000e+000 +0.00000000e+000j 0.00000000e+000 +5.29328215e+180j; 5.29328215e+180 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+241j; 5.37624943e+241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:3033,Performance,cache,cache,3033,"241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb intel_ppin tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts; ```; I'll gladly provide any additional information that might be needed. It's definitely a possibility that I did something wrong in the build process of either qutip itself (this is the archlinux build script: https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=python-qutip) or one of its libraries. Any ideas?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:3049,Performance,cache,cache,3049,"241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb intel_ppin tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts; ```; I'll gladly provide any additional information that might be needed. It's definitely a possibility that I did something wrong in the build process of either qutip itself (this is the archlinux build script: https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=python-qutip) or one of its libraries. Any ideas?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:3064,Performance,cache,cache,3064,"241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb intel_ppin tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts; ```; I'll gladly provide any additional information that might be needed. It's definitely a possibility that I did something wrong in the build process of either qutip itself (this is the archlinux build script: https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=python-qutip) or one of its libraries. Any ideas?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:3080,Performance,cache,cache,3080,"241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb intel_ppin tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts; ```; I'll gladly provide any additional information that might be needed. It's definitely a possibility that I did something wrong in the build process of either qutip itself (this is the archlinux build script: https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=python-qutip) or one of its libraries. Any ideas?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:2469,Testability,test,test,2469,"0000000e+000 +0.00000000e+000j 0.00000000e+000 +5.29328215e+180j; 5.29328215e+180 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+241j; 5.37624943e+241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/issues/681:77,Usability,simpl,simply,77,"I just updated to qutip 4.1.0 on archlinux and now code that ran fine before simply fails. The smallest example I managed to boil it down to is multiplying a daggered state with an operator:; ```; import qutip as qt; import numpy as np. N = 10; x = qt.Qobj(np.ones(N, complex)/(N**(1/2))); op = qt.destroy(N) + qt.create(N). for i in range(10):; print(x.dag()*op); ```; which randomly yields different results, e.g.; ```; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+241j; 5.37624943e+241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; 0.94868330+0.j ]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; 0.94868330+0.j ]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +0.00000000e+000j 0.00000000e+000 +5.29328215e+180j; 5.29328215e+180 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 3.16227766e-001 +0.00000000e+000j 7.63441362e-001 +0.00000000e+000j; 0.00000000e+000 +4.00979001e+087j 0.00000000e+000 +5.37624943e+24",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/681
https://github.com/qutip/qutip/pull/683:130,Safety,avoid,avoiding,130,"Instead of calculating the alpha**n/sqrt(n!) for every entry, calculate; it recursively by x_{n+1} = x_{n}*alpha/sqrt(n), thereby avoiding the; explicit calculation of the factorial. This way it works also for; dimensions>400 where it would fail before. This comes with a speed improvement:; ![benchmark_coherentstate](https://cloud.githubusercontent.com/assets/102507/24836249/399a4fba-1d17-11e7-9387-dd6ab9da1172.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/683
https://github.com/qutip/qutip/pull/684:95,Modifiability,variab,variable,95,The `reverse_circuit` function was broken as the gates should have been added to the temporary variable's `QubitCircuit.gates`. A better way is to use the `add_gate` method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/684
https://github.com/qutip/qutip/pull/686:73,Integrability,depend,dependent,73,This Pull implements a faster way to create the output array in the time-dependent codegen function.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/686
https://github.com/qutip/qutip/pull/687:11,Safety,safe,safety,11,"The solver safety check did not work for a list of Python funcs as the td input. This fixes that, and allows for e_ops to be a Python callback function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/687
https://github.com/qutip/qutip/issues/688:23,Availability,error,error,23,"Hello, i discovered an error in the implementation of the QFT. Namely when i want to obtain the gate sequence. The is when tha code runs this . if swapping is True:; for i in range(N // 2):; qc.add_gate(r""SWAP"", targets=[i], controls=[N - 1 - i, i]). it gives an error because the swap gate needs two targets and it is only passing one. Here is a test code. qft.qft_gate_sequence(N=2)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/688
https://github.com/qutip/qutip/issues/688:263,Availability,error,error,263,"Hello, i discovered an error in the implementation of the QFT. Namely when i want to obtain the gate sequence. The is when tha code runs this . if swapping is True:; for i in range(N // 2):; qc.add_gate(r""SWAP"", targets=[i], controls=[N - 1 - i, i]). it gives an error because the swap gate needs two targets and it is only passing one. Here is a test code. qft.qft_gate_sequence(N=2)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/688
https://github.com/qutip/qutip/issues/688:347,Testability,test,test,347,"Hello, i discovered an error in the implementation of the QFT. Namely when i want to obtain the gate sequence. The is when tha code runs this . if swapping is True:; for i in range(N // 2):; qc.add_gate(r""SWAP"", targets=[i], controls=[N - 1 - i, i]). it gives an error because the swap gate needs two targets and it is only passing one. Here is a test code. qft.qft_gate_sequence(N=2)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/688
https://github.com/qutip/qutip/issues/689:652,Usability,clear,clearly,652,"The function `spectrum_correlation_fft(taulist, y)` accepts all kinds of (non-linspace) taulists with corresponding correlation values `y`.; However, `y` is passed to `scipy.fftpack.fft(y)`, which assumes the values to be linearly spaced in time. If 'taulist' is not a linspace, the result of `spectrum_correlation_fft(taulist, y)` will seem realistic, but in fact be totally off.; This behaviour is especially critical, because it is often advantageous to use non-linear taulists for the calculation of correlation values. I guess this limitation is indicated by the fact that it uses a fast fourier transform, but I think it should be indicated more clearly, at least in the docstring. P.S: Thanks for the great module! I quite enjoy working with qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/689
https://github.com/qutip/qutip/issues/690:379,Integrability,depend,dependent,379,"I can reproduce the problem by the following codes: . from qutip import *; ; N = 10; v = rand_ket(N); p1 = v * v.dag(); p2 = Qobj([[ v[n,0]*v[m,0].conj() for m in range(0,v.shape[0])] ; for n in range(0,v.shape[0])]); print(p1-p2). where p1 is not giving correct result. Everything is correct using smaller N. The code also works fine on my server, so it seems to be environment dependent. . I am working on Arch Linux, Python3.6.1 with latest version of qutip from AUR (4.1.0-1). . Any suggestion of what I can try? ; Thank you!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/690
https://github.com/qutip/qutip/issues/694:72,Availability,down,down,72,"I see that qutip announced a new version, but after my update,It breaks down:; `from qutip import *`; the error occurs: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E; After google the error,I find a possible solution :` pip install qutip`; Then the error changes to : ; `---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-3-0a5c3f9bc976> in <module>(); 3 import matplotlib.pyplot as plt; 4 from tqdm import tnrange,tqdm_notebook; ----> 5 from qutip import *. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'`. PS:I'm using Google Computing platform. The system is Ubuntu .However,it works fine on my mac...........",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/694
https://github.com/qutip/qutip/issues/694:106,Availability,error,error,106,"I see that qutip announced a new version, but after my update,It breaks down:; `from qutip import *`; the error occurs: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E; After google the error,I find a possible solution :` pip install qutip`; Then the error changes to : ; `---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-3-0a5c3f9bc976> in <module>(); 3 import matplotlib.pyplot as plt; 4 from tqdm import tnrange,tqdm_notebook; ----> 5 from qutip import *. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'`. PS:I'm using Google Computing platform. The system is Ubuntu .However,it works fine on my mac...........",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/694
https://github.com/qutip/qutip/issues/694:189,Availability,error,error,189,"I see that qutip announced a new version, but after my update,It breaks down:; `from qutip import *`; the error occurs: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E; After google the error,I find a possible solution :` pip install qutip`; Then the error changes to : ; `---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-3-0a5c3f9bc976> in <module>(); 3 import matplotlib.pyplot as plt; 4 from tqdm import tnrange,tqdm_notebook; ----> 5 from qutip import *. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'`. PS:I'm using Google Computing platform. The system is Ubuntu .However,it works fine on my mac...........",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/694
https://github.com/qutip/qutip/issues/694:254,Availability,error,error,254,"I see that qutip announced a new version, but after my update,It breaks down:; `from qutip import *`; the error occurs: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E; After google the error,I find a possible solution :` pip install qutip`; Then the error changes to : ; `---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-3-0a5c3f9bc976> in <module>(); 3 import matplotlib.pyplot as plt; 4 from tqdm import tnrange,tqdm_notebook; ----> 5 from qutip import *. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'`. PS:I'm using Google Computing platform. The system is Ubuntu .However,it works fine on my mac...........",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/694
https://github.com/qutip/qutip/issues/694:55,Deployability,update,update,55,"I see that qutip announced a new version, but after my update,It breaks down:; `from qutip import *`; the error occurs: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E; After google the error,I find a possible solution :` pip install qutip`; Then the error changes to : ; `---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-3-0a5c3f9bc976> in <module>(); 3 import matplotlib.pyplot as plt; 4 from tqdm import tnrange,tqdm_notebook; ----> 5 from qutip import *. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'`. PS:I'm using Google Computing platform. The system is Ubuntu .However,it works fine on my mac...........",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/694
https://github.com/qutip/qutip/issues/694:229,Deployability,install,install,229,"I see that qutip announced a new version, but after my update,It breaks down:; `from qutip import *`; the error occurs: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E; After google the error,I find a possible solution :` pip install qutip`; Then the error changes to : ; `---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 46 __IPYTHON__; ---> 47 qutip.settings.ipython = True; 48 except:. AttributeError: module 'qutip' has no attribute 'settings'. During handling of the above exception, another exception occurred:. AttributeError Traceback (most recent call last); <ipython-input-3-0a5c3f9bc976> in <module>(); 3 import matplotlib.pyplot as plt; 4 from tqdm import tnrange,tqdm_notebook; ----> 5 from qutip import *. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 47 qutip.settings.ipython = True; 48 except:; ---> 49 qutip.settings.ipython = False; 50 ; 51 # -----------------------------------------------------------------------------. AttributeError: module 'qutip' has no attribute 'settings'`. PS:I'm using Google Computing platform. The system is Ubuntu .However,it works fine on my mac...........",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/694
https://github.com/qutip/qutip/issues/697:5517,Availability,error,errors,5517,".run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an error:; `gcc: error trying to exec '/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1plus': execv: Argument list too long`. After killing the kernel, open the notebook again...Everything is ok...I'm puzzled now...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:5764,Availability,error,error,5764,".run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an error:; `gcc: error trying to exec '/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1plus': execv: Argument list too long`. After killing the kernel, open the notebook again...Everything is ok...I'm puzzled now...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:5778,Availability,error,error,5778,".run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an error:; `gcc: error trying to exec '/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1plus': execv: Argument list too long`. After killing the kernel, open the notebook again...Everything is ok...I'm puzzled now...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:4713,Integrability,depend,depends,4713,"3 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototype",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:4725,Integrability,depend,depends,4725,"n[command] = 1; 976 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:4968,Integrability,depend,depends,4968,"uild_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an error:; `gcc: error trying to exec '/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1plus': execv: Argument list too long`. After killing the kernel, open the notebook again...Everything is ok...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:1363,Modifiability,config,config,1363,"aculate(phi, step_dot, v); 4 a_0 = []; 5 for j in tnrange(step_dot):; ----> 6 temp = connection(alpha2_list[j],1,0,phi,step_dot,v); 7 a_0.append(temp); 8 sum_0 = 0. <ipython-input-27-8ed9b415bc26> in connection(alpha2, n_state, w, phi, step, v); 33 H = [H_static,[H_dynamic_0,str0],[H_dynamic_1,str1],[H_dynamic_2,str2],[H_dynamic_3,str3]]; 34 t_list = np.linspace(0,(alpha1_end - alpha1_0)/v,step); ---> 35 result = mesolve(H,psi0,t_list,[],args = {'alpha2':alpha2,'phi':phi,'v':v}); 36 psi = result.states; 37 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 335 elif n_str > 0:; 336 res = _sesolve_list_str_td(H, rho0, tlist,; --> 337 e_ops, args, options, progress_bar); 338 elif isinstance(H, (types.FunctionType,; 339 types.BuiltinFunctionType, partial)):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 420 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 421 '<string>', 'exec'); --> 422 exec(code, globals()); 423 config.tdfunc = cy_td_ode_rhs; 424 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in <module>(). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:1465,Modifiability,config,config,1465,",1,0,phi,step_dot,v); 7 a_0.append(temp); 8 sum_0 = 0. <ipython-input-27-8ed9b415bc26> in connection(alpha2, n_state, w, phi, step, v); 33 H = [H_static,[H_dynamic_0,str0],[H_dynamic_1,str1],[H_dynamic_2,str2],[H_dynamic_3,str3]]; 34 t_list = np.linspace(0,(alpha1_end - alpha1_0)/v,step); ---> 35 result = mesolve(H,psi0,t_list,[],args = {'alpha2':alpha2,'phi':phi,'v':v}); 36 psi = result.states; 37 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 335 elif n_str > 0:; 336 res = _sesolve_list_str_td(H, rho0, tlist,; --> 337 e_ops, args, options, progress_bar); 338 elif isinstance(H, (types.FunctionType,; 339 types.BuiltinFunctionType, partial)):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 420 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 421 '<string>', 'exec'); --> 422 exec(code, globals()); 423 config.tdfunc = cy_td_ode_rhs; 424 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in <module>(). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = name; 215",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:4760,Modifiability,variab,variable,4760,"n[command] = 1; 976 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:3894,Performance,optimiz,optimization,3894,"; 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path; 194 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 100 try:; 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]; 104 if obj_build_ext.inplace:. /home/caidish1234/anaconda3/lib/python3.6/distutils/dist.py in run_commands(self); 953 """"""; 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 ; 957 # -- Methods that operate on its Commands --------------------------. /home/caidish1234/anaconda3/lib/python3.6/distutils/dist.py in run_command(self, command); 972 cmd_obj = self.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sou",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:2896,Testability,assert,assert,2896,"ort/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = name; 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, language_level=language_level); 217 mod = imp.load_dynamic(name, so_path); 218 if is_package and not hasattr(mod, '__path__'):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 190 setup_args=sargs,; 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path; 194 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 100 try:; 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]; 104 if obj_build_ext.inplace:. /home/caidish1234/anaconda3/lib/python3.6/distutils/dist.py in run_commands(self); 953 """"""; 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 ; 957 # -- Methods that operate on its Commands --------------------------. /home/caidish1234/anaconda3/lib/python3.6/distutils/dist.py in run_command(self, command); 972 cmd_obj = self.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in run(self); 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/issues/697:5613,Testability,log,log,5613,".run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an error:; `gcc: error trying to exec '/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1plus': execv: Argument list too long`. After killing the kernel, open the notebook again...Everything is ok...I'm puzzled now...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/697
https://github.com/qutip/qutip/pull/701:89,Deployability,UPDATE,UPDATE,89,"Better way to permute Qobj. Captured a bug where old permute didn't permute dimensions.; UPDATE: Now works for super objects (including operator-bra); Benchmark (permute 1st and last qubits):; <img width=""520"" alt=""unknown-1"" src=""https://cloud.githubusercontent.com/assets/4971779/26755844/811dbbce-4896-11e7-89b8-c11251b5a550.png"">; <img width=""520"" alt=""unknown-2"" src=""https://cloud.githubusercontent.com/assets/4971779/26755847/87cbe928-4896-11e7-8143-73ddcc77cd36.png"">",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/701
https://github.com/qutip/qutip/pull/701:151,Testability,Benchmark,Benchmark,151,"Better way to permute Qobj. Captured a bug where old permute didn't permute dimensions.; UPDATE: Now works for super objects (including operator-bra); Benchmark (permute 1st and last qubits):; <img width=""520"" alt=""unknown-1"" src=""https://cloud.githubusercontent.com/assets/4971779/26755844/811dbbce-4896-11e7-89b8-c11251b5a550.png"">; <img width=""520"" alt=""unknown-2"" src=""https://cloud.githubusercontent.com/assets/4971779/26755847/87cbe928-4896-11e7-8143-73ddcc77cd36.png"">",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/701
https://github.com/qutip/qutip/issues/702:206,Deployability,install,installed,206,"Hello, I posted this issue on the QuTiP Tutorials GitHub repo, but it doesn't look like anyone is monitoring it. I've tried googling, but I only find stuff about making sure Imagemagick and Ghostscript are installed and they both are. I also made sure texlive was installed. When I try to generate a circuit diagram as follows:. > %matplotlib inline; > from qutip import *; > from qutip.qip.models.circuitprocessor import *; > from qutip.qip.models.spinchain import *; > ; > N = 3; > qc = QubitCircuit(N); > ; > qc.add_gate(""CNOT"", targets=[0], controls=[2]); > ; > qc.png; > . I get a stack trace. > FileNotFoundError Traceback (most recent call last); > <ipython-input-2-4489e338191c> in <module>(); > 4 qc.add_gate(""CNOT"", targets=[0], controls=[2]); > 5 ; > ----> 6 qc.png; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in png(self); > 1012 def png(self):; > 1013 from IPython.display import Image; > -> 1014 return Image(self._repr_png_(), embed=True); > 1015 ; > 1016 @property; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in _repr_png_(self); > 1004 ; > 1005 def _repr_png_(self):; > -> 1006 return _latex_compile(self.latex_code(), format=""png""); > 1007 ; > 1008 def _repr_svg_(self):; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); > 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; > 61 filename)); > ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; > 63 result = f.read(); > 64 else:; > ; > FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'; > . I'm using. My configuration information is as follows:. > Software	Version; > QuTiP	4.1.0; > Numpy	1.11.3; > SciPy	0.18.1; > matplotlib	2.0.0; > Cython	0.25.2; > Number of CPUs	4; > BLAS Info	INTEL MKL; > IPython	5.1.0; > Python	3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]; > OS	posix [lin",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/702
https://github.com/qutip/qutip/issues/702:264,Deployability,install,installed,264,"Hello, I posted this issue on the QuTiP Tutorials GitHub repo, but it doesn't look like anyone is monitoring it. I've tried googling, but I only find stuff about making sure Imagemagick and Ghostscript are installed and they both are. I also made sure texlive was installed. When I try to generate a circuit diagram as follows:. > %matplotlib inline; > from qutip import *; > from qutip.qip.models.circuitprocessor import *; > from qutip.qip.models.spinchain import *; > ; > N = 3; > qc = QubitCircuit(N); > ; > qc.add_gate(""CNOT"", targets=[0], controls=[2]); > ; > qc.png; > . I get a stack trace. > FileNotFoundError Traceback (most recent call last); > <ipython-input-2-4489e338191c> in <module>(); > 4 qc.add_gate(""CNOT"", targets=[0], controls=[2]); > 5 ; > ----> 6 qc.png; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in png(self); > 1012 def png(self):; > 1013 from IPython.display import Image; > -> 1014 return Image(self._repr_png_(), embed=True); > 1015 ; > 1016 @property; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in _repr_png_(self); > 1004 ; > 1005 def _repr_png_(self):; > -> 1006 return _latex_compile(self.latex_code(), format=""png""); > 1007 ; > 1008 def _repr_svg_(self):; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); > 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; > 61 filename)); > ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; > 63 result = f.read(); > 64 else:; > ; > FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'; > . I'm using. My configuration information is as follows:. > Software	Version; > QuTiP	4.1.0; > Numpy	1.11.3; > SciPy	0.18.1; > matplotlib	2.0.0; > Cython	0.25.2; > Number of CPUs	4; > BLAS Info	INTEL MKL; > IPython	5.1.0; > Python	3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]; > OS	posix [lin",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/702
https://github.com/qutip/qutip/issues/702:1666,Deployability,configurat,configuration,1666,"I posted this issue on the QuTiP Tutorials GitHub repo, but it doesn't look like anyone is monitoring it. I've tried googling, but I only find stuff about making sure Imagemagick and Ghostscript are installed and they both are. I also made sure texlive was installed. When I try to generate a circuit diagram as follows:. > %matplotlib inline; > from qutip import *; > from qutip.qip.models.circuitprocessor import *; > from qutip.qip.models.spinchain import *; > ; > N = 3; > qc = QubitCircuit(N); > ; > qc.add_gate(""CNOT"", targets=[0], controls=[2]); > ; > qc.png; > . I get a stack trace. > FileNotFoundError Traceback (most recent call last); > <ipython-input-2-4489e338191c> in <module>(); > 4 qc.add_gate(""CNOT"", targets=[0], controls=[2]); > 5 ; > ----> 6 qc.png; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in png(self); > 1012 def png(self):; > 1013 from IPython.display import Image; > -> 1014 return Image(self._repr_png_(), embed=True); > 1015 ; > 1016 @property; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in _repr_png_(self); > 1004 ; > 1005 def _repr_png_(self):; > -> 1006 return _latex_compile(self.latex_code(), format=""png""); > 1007 ; > 1008 def _repr_svg_(self):; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); > 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; > 61 filename)); > ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; > 63 result = f.read(); > 64 else:; > ; > FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'; > . I'm using. My configuration information is as follows:. > Software	Version; > QuTiP	4.1.0; > Numpy	1.11.3; > SciPy	0.18.1; > matplotlib	2.0.0; > Cython	0.25.2; > Number of CPUs	4; > BLAS Info	INTEL MKL; > IPython	5.1.0; > Python	3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]; > OS	posix [linux]; >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/702
https://github.com/qutip/qutip/issues/702:98,Energy Efficiency,monitor,monitoring,98,"Hello, I posted this issue on the QuTiP Tutorials GitHub repo, but it doesn't look like anyone is monitoring it. I've tried googling, but I only find stuff about making sure Imagemagick and Ghostscript are installed and they both are. I also made sure texlive was installed. When I try to generate a circuit diagram as follows:. > %matplotlib inline; > from qutip import *; > from qutip.qip.models.circuitprocessor import *; > from qutip.qip.models.spinchain import *; > ; > N = 3; > qc = QubitCircuit(N); > ; > qc.add_gate(""CNOT"", targets=[0], controls=[2]); > ; > qc.png; > . I get a stack trace. > FileNotFoundError Traceback (most recent call last); > <ipython-input-2-4489e338191c> in <module>(); > 4 qc.add_gate(""CNOT"", targets=[0], controls=[2]); > 5 ; > ----> 6 qc.png; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in png(self); > 1012 def png(self):; > 1013 from IPython.display import Image; > -> 1014 return Image(self._repr_png_(), embed=True); > 1015 ; > 1016 @property; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in _repr_png_(self); > 1004 ; > 1005 def _repr_png_(self):; > -> 1006 return _latex_compile(self.latex_code(), format=""png""); > 1007 ; > 1008 def _repr_svg_(self):; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); > 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; > 61 filename)); > ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; > 63 result = f.read(); > 64 else:; > ; > FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'; > . I'm using. My configuration information is as follows:. > Software	Version; > QuTiP	4.1.0; > Numpy	1.11.3; > SciPy	0.18.1; > matplotlib	2.0.0; > Cython	0.25.2; > Number of CPUs	4; > BLAS Info	INTEL MKL; > IPython	5.1.0; > Python	3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]; > OS	posix [lin",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/702
https://github.com/qutip/qutip/issues/702:1666,Modifiability,config,configuration,1666,"I posted this issue on the QuTiP Tutorials GitHub repo, but it doesn't look like anyone is monitoring it. I've tried googling, but I only find stuff about making sure Imagemagick and Ghostscript are installed and they both are. I also made sure texlive was installed. When I try to generate a circuit diagram as follows:. > %matplotlib inline; > from qutip import *; > from qutip.qip.models.circuitprocessor import *; > from qutip.qip.models.spinchain import *; > ; > N = 3; > qc = QubitCircuit(N); > ; > qc.add_gate(""CNOT"", targets=[0], controls=[2]); > ; > qc.png; > . I get a stack trace. > FileNotFoundError Traceback (most recent call last); > <ipython-input-2-4489e338191c> in <module>(); > 4 qc.add_gate(""CNOT"", targets=[0], controls=[2]); > 5 ; > ----> 6 qc.png; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in png(self); > 1012 def png(self):; > 1013 from IPython.display import Image; > -> 1014 return Image(self._repr_png_(), embed=True); > 1015 ; > 1016 @property; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in _repr_png_(self); > 1004 ; > 1005 def _repr_png_(self):; > -> 1006 return _latex_compile(self.latex_code(), format=""png""); > 1007 ; > 1008 def _repr_svg_(self):; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); > 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; > 61 filename)); > ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; > 63 result = f.read(); > 64 else:; > ; > FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'; > . I'm using. My configuration information is as follows:. > Software	Version; > QuTiP	4.1.0; > Numpy	1.11.3; > SciPy	0.18.1; > matplotlib	2.0.0; > Cython	0.25.2; > Number of CPUs	4; > BLAS Info	INTEL MKL; > IPython	5.1.0; > Python	3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]; > OS	posix [linux]; >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/702
https://github.com/qutip/qutip/pull/707:51,Energy Efficiency,power,power,51,"Uses a tuple (f(w), g(t)) to give product of noise power spectrum f(w) and time-dependence g(t). Both can be strings or Cubic_Spline objects.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/707
https://github.com/qutip/qutip/pull/707:80,Integrability,depend,dependence,80,"Uses a tuple (f(w), g(t)) to give product of noise power spectrum f(w) and time-dependence g(t). Both can be strings or Cubic_Spline objects.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/707
https://github.com/qutip/qutip/pull/708:431,Deployability,release,releases,431,"Since NumPy 1.12, `np.linspace` raises a DeprecationWarning when its third `num` parameter cannot be safely interpreted as an integer. This method is used in the `mesolve` tests. Fixed by feeding the calls to `linspace` 100 instead of 100.0. The warning (in Travis CI):; ; ![image](https://user-images.githubusercontent.com/220701/27771317-c325fe9c-5f4c-11e7-8d4b-66980255dcfd.png). The deprecation: https://github.com/numpy/numpy/releases/tag/v1.12.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/708
https://github.com/qutip/qutip/pull/708:101,Safety,safe,safely,101,"Since NumPy 1.12, `np.linspace` raises a DeprecationWarning when its third `num` parameter cannot be safely interpreted as an integer. This method is used in the `mesolve` tests. Fixed by feeding the calls to `linspace` 100 instead of 100.0. The warning (in Travis CI):; ; ![image](https://user-images.githubusercontent.com/220701/27771317-c325fe9c-5f4c-11e7-8d4b-66980255dcfd.png). The deprecation: https://github.com/numpy/numpy/releases/tag/v1.12.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/708
https://github.com/qutip/qutip/pull/708:172,Testability,test,tests,172,"Since NumPy 1.12, `np.linspace` raises a DeprecationWarning when its third `num` parameter cannot be safely interpreted as an integer. This method is used in the `mesolve` tests. Fixed by feeding the calls to `linspace` 100 instead of 100.0. The warning (in Travis CI):; ; ![image](https://user-images.githubusercontent.com/220701/27771317-c325fe9c-5f4c-11e7-8d4b-66980255dcfd.png). The deprecation: https://github.com/numpy/numpy/releases/tag/v1.12.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/708
https://github.com/qutip/qutip/pull/709:241,Testability,test,test,241,"This fixes #688, following the suggestion by @mrcalixe. The fix sets the swap targets to `[N - i - 1, i]`, instead of setting a target and a control separately. The method `qft_gate_sequence` was untested: This pull request provides various test cases of varying length (1-6) and with and without swapping enabled.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/709
https://github.com/qutip/qutip/pull/712:115,Availability,error,error,115,Fixes the wrong vector ordering in the conversion between fock and eigen bases. Essentially gave rise to transpose error. Added tests to verify fix. Also added @cython.cdivision(True) to both BR and ME codegens so that any string with division do not call back to Python.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/712
https://github.com/qutip/qutip/pull/712:128,Testability,test,tests,128,Fixes the wrong vector ordering in the conversion between fock and eigen bases. Essentially gave rise to transpose error. Added tests to verify fix. Also added @cython.cdivision(True) to both BR and ME codegens so that any string with division do not call back to Python.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/712
https://github.com/qutip/qutip/pull/714:394,Integrability,depend,dependent,394,"This Pull allows for passing operators of the form H = f(t)*a+g(t)*a.dag() as a_ops to the td-BR solver. Since the a_ops are Hermitian, this implies that f(t) = conj[g(t)]. You can also pass more than two terms if needed. The signature for the a_ops in this form is:. a_ops = [ [(a,a.dag()), (w, t1, t2)],...],. where `w` is a placeholder for the spectra string, and `t1` and `t2' are the time-dependent string for the operators `a` and `a.dag()`, respectively.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/714
https://github.com/qutip/qutip/pull/722:26,Availability,toler,tolerance,26,It looks like my original tolerance was stricter than the default tolerance on the ODE solver. Oops.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/722
https://github.com/qutip/qutip/pull/722:66,Availability,toler,tolerance,66,It looks like my original tolerance was stricter than the default tolerance on the ODE solver. Oops.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/722
https://github.com/qutip/qutip/issues/723:153,Availability,error,error,153,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:231,Availability,error,error,231,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:505,Availability,Error,Error,505,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:943,Availability,Error,Error,943,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:3871,Availability,Error,Errors,3871,"python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1138, in cythonize_one; raise CompileError(None, pyx_file); Cython.Compiler.Errors.CompileError: qutip/cy/sparse_utils.pyx; ```. Tested with:; * Cython 0.26; * numpy 1.13.1; * gcc 4.9.1. Any recommendation on how to fix this? . Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:27,Deployability,install,installation,27,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:348,Deployability,install,installation,348,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:381,Deployability,install,install,381,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:1432,Integrability,depend,depends,1432,"; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/si",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:1572,Integrability,depend,depends,1572,"----------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-pac",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:1714,Integrability,depend,depends,1714,"):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:1855,Integrability,depend,depends,1855,"------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cyth",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:1996,Integrability,depend,depends,1996,"------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cy",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2132,Integrability,depend,depends,2132,"ouble max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2266,Integrability,depend,depends,2266,-----------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizi,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2400,Integrability,depend,depends,2400,"ncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2534,Integrability,depend,depends,2534,"tochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2670,Integrability,depend,depends,2670,"cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2807,Integrability,depend,depends,2807,"utip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1138, in cythonize_one; ra",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2950,Integrability,depend,depends,2950,"ip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1138, in cythonize_one; raise CompileError(None, pyx_file); Cython.Compiler.Errors.CompileError: qutip/cy/sparse_utils.pyx; ```. Tested with:; * Cython 0.26; * numpy 1.1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:3641,Integrability,Depend,Dependencies,3641,"python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1138, in cythonize_one; raise CompileError(None, pyx_file); Cython.Compiler.Errors.CompileError: qutip/cy/sparse_utils.pyx; ```. Tested with:; * Cython 0.26; * numpy 1.13.1; * gcc 4.9.1. Any recommendation on how to fix this? . Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:3772,Integrability,Depend,Dependencies,3772,"python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1138, in cythonize_one; raise CompileError(None, pyx_file); Cython.Compiler.Errors.CompileError: qutip/cy/sparse_utils.pyx; ```. Tested with:; * Cython 0.26; * numpy 1.13.1; * gcc 4.9.1. Any recommendation on how to fix this? . Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:420,Performance,cache,cached,420,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:77,Testability,test,tested,77,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:2784,Testability,test,testing,2784,"n/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Depend",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/723:3924,Testability,Test,Tested,3924,"python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1138, in cythonize_one; raise CompileError(None, pyx_file); Cython.Compiler.Errors.CompileError: qutip/cy/sparse_utils.pyx; ```. Tested with:; * Cython 0.26; * numpy 1.13.1; * gcc 4.9.1. Any recommendation on how to fix this? . Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/723
https://github.com/qutip/qutip/issues/728:141,Availability,error,error,141,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/728
https://github.com/qutip/qutip/issues/728:613,Performance,queue,queues,613,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/728
https://github.com/qutip/qutip/issues/728:665,Performance,load,loads,665,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/728
https://github.com/qutip/qutip/issues/728:18,Testability,test,test,18,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/728
https://github.com/qutip/qutip/issues/728:769,Testability,test,test,769,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/728
https://github.com/qutip/qutip/issues/728:779,Testability,test,test,779,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/728
https://github.com/qutip/qutip/issues/728:920,Testability,test,test,920,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/728
https://github.com/qutip/qutip/pull/729:91,Integrability,depend,dependent,91,This Pull attempts to fix the issues with Win not finding RHS functions when repeated time-dependent solvers are used in the tests. I have also added some unit tests to verify that rhs_reuse still works.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/729
https://github.com/qutip/qutip/pull/729:125,Testability,test,tests,125,This Pull attempts to fix the issues with Win not finding RHS functions when repeated time-dependent solvers are used in the tests. I have also added some unit tests to verify that rhs_reuse still works.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/729
https://github.com/qutip/qutip/pull/729:160,Testability,test,tests,160,This Pull attempts to fix the issues with Win not finding RHS functions when repeated time-dependent solvers are used in the tests. I have also added some unit tests to verify that rhs_reuse still works.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/729
https://github.com/qutip/qutip/pull/732:34,Deployability,release,release,34,Added changes from master for new release,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/732
https://github.com/qutip/qutip/pull/735:100,Availability,error,errors,100,"This trace out only occurred when adding system, and not things like mult. Caused several confusing errors.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/735
https://github.com/qutip/qutip/pull/737:110,Energy Efficiency,efficient,efficient,110,"It is possible to pass a list of Qobj to mesolve, where it is compiled into c. This is of course not the most efficient thing to do, but it is allowed. This pull makes the brmesolve function work in this case.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/737
https://github.com/qutip/qutip/issues/738:44,Integrability,depend,depended,44,"Hi all,; currently we are working on a time depended version of the SME solver. There is a strategic decision to be made. At the moment, the stochastic.py file is the second largest file in qutip due to variety of methods involved. So it is a kind of mess. We think it makes sense to create stochastic_td.py to contain all the related time depended cases for solvers etc. Should we do it or is it better to keep enlarging the stochastic.py file?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/738
https://github.com/qutip/qutip/issues/738:340,Integrability,depend,depended,340,"Hi all,; currently we are working on a time depended version of the SME solver. There is a strategic decision to be made. At the moment, the stochastic.py file is the second largest file in qutip due to variety of methods involved. So it is a kind of mess. We think it makes sense to create stochastic_td.py to contain all the related time depended cases for solvers etc. Should we do it or is it better to keep enlarging the stochastic.py file?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/738
https://github.com/qutip/qutip/issues/739:142,Availability,error,error,142,"Hello Dear community, ; i'm trying to install qutip using the "" pip install qutip "" command on ubuntu 16.04 , however at each time i get this error ""Command python setup.py egg_info failed with error code 1 in /tmp/pip_build"" ; i have tried many versions of ubuntu ( 14, 15 ...) and many tricks in the net ( upgrading pip; upgrading python... ) trying to bypass this problem however all my tries failed..; i'll appreciate any help dear community...; sincerly yours; Amine Ch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/739
https://github.com/qutip/qutip/issues/739:194,Availability,error,error,194,"Hello Dear community, ; i'm trying to install qutip using the "" pip install qutip "" command on ubuntu 16.04 , however at each time i get this error ""Command python setup.py egg_info failed with error code 1 in /tmp/pip_build"" ; i have tried many versions of ubuntu ( 14, 15 ...) and many tricks in the net ( upgrading pip; upgrading python... ) trying to bypass this problem however all my tries failed..; i'll appreciate any help dear community...; sincerly yours; Amine Ch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/739
https://github.com/qutip/qutip/issues/739:38,Deployability,install,install,38,"Hello Dear community, ; i'm trying to install qutip using the "" pip install qutip "" command on ubuntu 16.04 , however at each time i get this error ""Command python setup.py egg_info failed with error code 1 in /tmp/pip_build"" ; i have tried many versions of ubuntu ( 14, 15 ...) and many tricks in the net ( upgrading pip; upgrading python... ) trying to bypass this problem however all my tries failed..; i'll appreciate any help dear community...; sincerly yours; Amine Ch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/739
https://github.com/qutip/qutip/issues/739:68,Deployability,install,install,68,"Hello Dear community, ; i'm trying to install qutip using the "" pip install qutip "" command on ubuntu 16.04 , however at each time i get this error ""Command python setup.py egg_info failed with error code 1 in /tmp/pip_build"" ; i have tried many versions of ubuntu ( 14, 15 ...) and many tricks in the net ( upgrading pip; upgrading python... ) trying to bypass this problem however all my tries failed..; i'll appreciate any help dear community...; sincerly yours; Amine Ch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/739
https://github.com/qutip/qutip/pull/744:5,Deployability,release,release,5,PyPi release done. Bump 4.2.0 to 4.2.1. @ajgpitch,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/744
https://github.com/qutip/qutip/pull/749:118,Energy Efficiency,efficient,efficient,118,This is the most naive way perhaps to do this. But since it uses Qobj functions to do it I am guessing it is the most efficient and takes into consideration sparse matrices etc. @ajgpitch,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/749
https://github.com/qutip/qutip/pull/750:221,Modifiability,variab,variables,221,"The td-BR solver has about a 3-5 second compile time, regardless of system size. Not 100% sure why it takes this long verses the other solvers, but that is what we got. This Pull allows for passing the usual args dict of variables to the solver for use in td Hamiltonian or c-op terms. In combination with Options(rhs_reuse=True), this should allow the user to bypass additional compilation steps when changing Hamiltonian parameters. This trick does not work for the a_op spectrum strings, since they need to be hardcoded due to limitations in c++.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/750
https://github.com/qutip/qutip/pull/752:547,Integrability,message,message,547,As discussed in #664 this PR is regarding citation reminders for QuTiP as it seems that many times users are unaware of the papers to cite when they use QuTiP. I have added a bibtex file in the source now and into the MANIFEST file. We should discuss how to get this to the users attention. Creation of a cite() function which generates a bibtex entry in the working directory whenever qutip is imported could be one option. The other option is to put it in /home/qutip or print it out whenever a result class is called. We can also add a welcome message at setup which reminds users regarding the papers and points them to the bibtex file. I am in favour of having a bibtex generator in __init__.py such that qutip.bib appears in the code folder whenever QuTiP is used.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/752
https://github.com/qutip/qutip/pull/753:149,Availability,avail,available,149,#This pull request will deal with a new module for solving quantum systems exploiting permutational symmetries. A somewhat complete code for this is available at https://github.com/nathanshammah/piqs which is built on several papers @nathanshammah can link to. The code is almost complete and tested but here we will upload it in parts to make the review process easy. @ajgpitch @nonhermitian @nwlambert,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/753
https://github.com/qutip/qutip/pull/753:293,Testability,test,tested,293,#This pull request will deal with a new module for solving quantum systems exploiting permutational symmetries. A somewhat complete code for this is available at https://github.com/nathanshammah/piqs which is built on several papers @nathanshammah can link to. The code is almost complete and tested but here we will upload it in parts to make the review process easy. @ajgpitch @nonhermitian @nwlambert,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/753
https://github.com/qutip/qutip/issues/754:66,Usability,simpl,simple,66,"`QubitCircuit` doesn't find `png` (or `svg`) as expected. Using a simple example right out of [one of the demo notebooks](http://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/quantum-gates.ipynb). ```python; qc3 = QubitCircuit(3); qc3.add_gate(""CNOT"", 1, 0); qc3.add_gate(""RX"", 0, None, np.pi/2, r""\pi/2""); qc3.add_gate(""RY"", 1, None, np.pi/2, r""\pi/2""); qc3.add_gate(""RZ"", 2, None, np.pi/2, r""\pi/2""); qc3.add_gate(""ISWAP"", [1, 2]); qc3.svg; ```; I get. ```; ---------------------------------------------------------------------------; IOError Traceback (most recent call last); <ipython-input-17-90c37b42f323> in <module>(); 5 qc3.add_gate(""RZ"", 2, None, np.pi/2, r""\pi/2""); 6 qc3.add_gate(""ISWAP"", [1, 2]); ----> 7 qc3.svg; 8 dir(qc3). /usr/local/lib/python2.7/site-packages/qutip/qip/circuit.pyc in svg(self); 1049 def svg(self):; 1050 from IPython.display import SVG; -> 1051 return SVG(self._repr_svg_()); 1052 ; 1053 def qasm(self):. /usr/local/lib/python2.7/site-packages/qutip/qip/circuit.pyc in _repr_svg_(self); 1039 ; 1040 def _repr_svg_(self):; -> 1041 return _latex_compile(self.latex_code(), format=""svg""); 1042 ; 1043 @property. /usr/local/lib/python2.7/site-packages/qutip/qip/circuit_latex.pyc in _latex_compile(code, filename, format); 64 else:; 65 os.system(""pdf2svg %s.pdf %s.svg"" % (filename, filename)); ---> 66 with open(""%s.svg"" % filename) as f:; 67 result = f.read(); 68 . IOError: [Errno 2] No such file or directory: 'qcirc.svg'; ```; with. > uTiP | 4.2.0; > Numpy | 1.13.1; > SciPy | 0.19.1; > matplotlib | 2.0.2; > Cython | 0.27; > Number of CPUs | 2; > BLAS Info | OPENBLAS; > IPython | 5.5.0; > Python | 2.7.13 (default, Jul 18 2017, 09:17:00) [GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)]; > OS | posix [darwin]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/754
https://github.com/qutip/qutip/issues/756:867,Integrability,depend,depends,867,"I have two matrices `A` and `B`. I run. eigvals, eigvecs = simdiag([A, B]); and get. AttributeError Traceback (most recent call last); <ipython-input-8-966464195054> in <module>(); ----> 1 eigvals, eigvecs = simdiag([A, B]); /usr/lib/python3.6/site-packages/qutip/simdiag.py in simdiag(ops, evals); 82 eigvals, eigvecs = la.eig(A.full()); 83 zipped = zip(-eigvals, range(len(eigvals))); ---> 84 zipped.sort(); 85 ds, perm = zip(*zipped); 86 ds = -np.real(np.array(ds)); AttributeError: 'zip' object has no attribute 'sort'. The solution is to change the lines. zipped.sort(); in `simdiag` and the private function `degen` to. zipped = sorted(zipped); I did this and it works. However, I'm also wondering if there are plans to rewrite `simdiag` to be more numerically stable (if possible). I've found that the eigenvalues returned and the accuracy of the eigenvectors depends significantly on the order that they are passed. For instance, I know that `A` has integer eigenvalues, and when I run. eigvals, eigvecs = simuldiag([A, B]); eigvals[0]. I get. array([ 8., 7., 7., 7., 7., 7., 7., 7., 7., 6., 6., 6., 6.,; 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6.,; 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 2., 2.,; 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/756
https://github.com/qutip/qutip/issues/756:726,Modifiability,rewrite,rewrite,726,"I have two matrices `A` and `B`. I run. eigvals, eigvecs = simdiag([A, B]); and get. AttributeError Traceback (most recent call last); <ipython-input-8-966464195054> in <module>(); ----> 1 eigvals, eigvecs = simdiag([A, B]); /usr/lib/python3.6/site-packages/qutip/simdiag.py in simdiag(ops, evals); 82 eigvals, eigvecs = la.eig(A.full()); 83 zipped = zip(-eigvals, range(len(eigvals))); ---> 84 zipped.sort(); 85 ds, perm = zip(*zipped); 86 ds = -np.real(np.array(ds)); AttributeError: 'zip' object has no attribute 'sort'. The solution is to change the lines. zipped.sort(); in `simdiag` and the private function `degen` to. zipped = sorted(zipped); I did this and it works. However, I'm also wondering if there are plans to rewrite `simdiag` to be more numerically stable (if possible). I've found that the eigenvalues returned and the accuracy of the eigenvectors depends significantly on the order that they are passed. For instance, I know that `A` has integer eigenvalues, and when I run. eigvals, eigvecs = simuldiag([A, B]); eigvals[0]. I get. array([ 8., 7., 7., 7., 7., 7., 7., 7., 7., 6., 6., 6., 6.,; 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6.,; 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 2., 2.,; 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/756
https://github.com/qutip/qutip/pull/757:0,Integrability,Rout,Routine,0,"Routine computes matrix elements about 10x faster than previous method. It is slightly better not to actually use a bra-vector, but use a ket-vector instead, and let the computation handle the difference internally.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/757
https://github.com/qutip/qutip/pull/760:62,Integrability,rout,routine,62,"Compute the projector of a ket or bra Qobj via Q.proj(). This routine is ~3x faster than doing the outer product explicitly, and does not need a temp matrix.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/760
https://github.com/qutip/qutip/issues/761:240,Availability,error,error,240,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:337,Availability,fault,fault,337,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:503,Availability,down,down,503,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:646,Availability,error,error,646,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:652,Availability,down,down,652,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:877,Availability,error,error,877,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:1301,Deployability,Install,Installed,1301,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:1373,Deployability,Install,Installation,1373,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:246,Integrability,message,message,246,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/issues/761:102,Usability,guid,guide,102,"Hi,. I was trying to run some simulations with [Floquet formalism in Qutip](http://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html) in a Jupyter notebook, when I ran into a ""The kernel appears to died unexpectedly, it will restart"" error message. I tried to understand what is happening, and it seems it is due to a segmentation fault. It happens also when run in CPython 3.5.2. `gdb` was not super useful, and I could not get it to output any interesting backtrace. Manually tracking the issue down, it seems that `qutip.floquet.floquet_modes` call `qutip.propagator.propagator` which itself calls `sesolve`. As far as I could track the error down for the moment, it seems to happen in [this call](https://github.com/qutip/qutip/blob/master/qutip/propagator.py#L159-L160). My code is quite lengthy, and I did not yet manage to isolate a small snippet to reproduce the error :/ Not sure what is the best way to debug this either :/. ```python; >>> qutip.about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 0.19.1; Cython Version: 0.27.1; Matplotlib Version: 2.0.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip; ```. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/761
https://github.com/qutip/qutip/pull/762:295,Energy Efficiency,reduce,reduced,295,"The scalar product `(f_modes_t[a].dag() * c_op * f_modes_t[b])[0, 0]` is computed at each loop in the `for` loop on `k`. But it only depends on `a` and `b` and can then be computed outside of the loop. In my case, I was dealing with Hilbert spaces of size 100, which resulted in a significantly reduced run time. Please, let me know about any feedback about this PR :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/762
https://github.com/qutip/qutip/pull/762:133,Integrability,depend,depends,133,"The scalar product `(f_modes_t[a].dag() * c_op * f_modes_t[b])[0, 0]` is computed at each loop in the `for` loop on `k`. But it only depends on `a` and `b` and can then be computed outside of the loop. In my case, I was dealing with Hilbert spaces of size 100, which resulted in a significantly reduced run time. Please, let me know about any feedback about this PR :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/762
https://github.com/qutip/qutip/pull/762:343,Usability,feedback,feedback,343,"The scalar product `(f_modes_t[a].dag() * c_op * f_modes_t[b])[0, 0]` is computed at each loop in the `for` loop on `k`. But it only depends on `a` and `b` and can then be computed outside of the loop. In my case, I was dealing with Hilbert spaces of size 100, which resulted in a significantly reduced run time. Please, let me know about any feedback about this PR :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/762
https://github.com/qutip/qutip/pull/763:7,Integrability,rout,routine,7,Faster routine to compute inner products. About 30x faster than previous versions.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/763
https://github.com/qutip/qutip/pull/766:285,Energy Efficiency,reduce,reduced,285,"The scalar product (f_modes_t[a].dag() * c_op * f_modes_t[b])[0, 0] is computed at each loop in the for loop on k. But it only depends on a and b and can then be computed outside of the loop. In my case, I was dealing with Hilbert spaces of size 100, which resulted in a significantly reduced run time. Please, let me know about any feedback about this PR :). Follow up of !762.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/766
https://github.com/qutip/qutip/pull/766:127,Integrability,depend,depends,127,"The scalar product (f_modes_t[a].dag() * c_op * f_modes_t[b])[0, 0] is computed at each loop in the for loop on k. But it only depends on a and b and can then be computed outside of the loop. In my case, I was dealing with Hilbert spaces of size 100, which resulted in a significantly reduced run time. Please, let me know about any feedback about this PR :). Follow up of !762.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/766
https://github.com/qutip/qutip/pull/766:333,Usability,feedback,feedback,333,"The scalar product (f_modes_t[a].dag() * c_op * f_modes_t[b])[0, 0] is computed at each loop in the for loop on k. But it only depends on a and b and can then be computed outside of the loop. In my case, I was dealing with Hilbert spaces of size 100, which resulted in a significantly reduced run time. Please, let me know about any feedback about this PR :). Follow up of !762.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/766
https://github.com/qutip/qutip/issues/767:1077,Availability,avail,available,1077,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:24,Deployability,integrat,integration,24,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:605,Deployability,integrat,integrate,605,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:675,Deployability,integrat,integrate,675,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:853,Deployability,integrat,integrate,853,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:929,Deployability,integrat,integrate,929,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:955,Deployability,integrat,integrate,955,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:520,Energy Efficiency,efficient,efficient,520,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:717,Energy Efficiency,efficient,efficient,717,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:986,Energy Efficiency,adapt,adaptive,986,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:24,Integrability,integrat,integration,24,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:605,Integrability,integrat,integrate,605,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:675,Integrability,integrat,integrate,675,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:853,Integrability,integrat,integrate,853,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:929,Integrability,integrat,integrate,929,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:955,Integrability,integrat,integrate,955,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:986,Modifiability,adapt,adaptive,986,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:246,Security,access,accessible,246,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/767:1056,Usability,feedback,feedback,1056,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/767
https://github.com/qutip/qutip/issues/768:636,Availability,error,error,636,"Hi,. I have been trying to use `qutip.floquet.floquet_master_equation_steadystate` method to get the steadystate of my system, but the docstring is not super useful. From the docstring, I guess I should call it as `qutip.floquet.floquet_master_equation_steadystate(H, A)` where. * `H` is my (time-dependent) hamiltonian, similar as the one used in http://qutip.org/docs/latest/guide/dynamics/dynamics-floquet.html#floquet-formalism-in-qutip.; * `A` is the [`A` matrix output](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L587-L588) from `floquet_master_equation_rates` call. I think I missed something as I am getting an error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; from https://github.com/qutip/qutip/blob/master/qutip/steadystate.py#L224. Additionnally, I think there is a much easier way to find the steadystate of such a system, using something like (not really well written nor optimised):. ```python; def floquet_master_equation_steadystate2(A):; """"""; TODO. Parameters; ----------. A : TODO; A matrix used to build the master equation.; """"""; B = np.zeros_like(A); N = A.shape[0]; for a in range(N):; for b in range(N):; # Convergence of off-diagonal terms in density matrix to 0; assert(-0.5 * np.sum(A[:, a] + A[:, b]) < 0); # Diagonal terms of density matrix; if a != b:; B[a, b] = A[a, b]; else:; B[a, b] = -1.0 * np.sum([; A[nu, a] for nu in range(N) if nu != a]; ); eigval, eigvec = Qobj(B).eigenstates(); assert(np.isclose(eigval[-1], 0, atol=1e-15)); return eigvec[-1] * eigvec[-1].dag(); ```. which basically looks for the eigenvector associated with 0 eigenvalue of a matrix derived from `A`, which is basically coming directly from equation 251 of [Gri98](http://qutip.org/docs/latest/biblio.html#gri98).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/768
https://github.com/qutip/qutip/issues/768:297,Integrability,depend,dependent,297,"Hi,. I have been trying to use `qutip.floquet.floquet_master_equation_steadystate` method to get the steadystate of my system, but the docstring is not super useful. From the docstring, I guess I should call it as `qutip.floquet.floquet_master_equation_steadystate(H, A)` where. * `H` is my (time-dependent) hamiltonian, similar as the one used in http://qutip.org/docs/latest/guide/dynamics/dynamics-floquet.html#floquet-formalism-in-qutip.; * `A` is the [`A` matrix output](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L587-L588) from `floquet_master_equation_rates` call. I think I missed something as I am getting an error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; from https://github.com/qutip/qutip/blob/master/qutip/steadystate.py#L224. Additionnally, I think there is a much easier way to find the steadystate of such a system, using something like (not really well written nor optimised):. ```python; def floquet_master_equation_steadystate2(A):; """"""; TODO. Parameters; ----------. A : TODO; A matrix used to build the master equation.; """"""; B = np.zeros_like(A); N = A.shape[0]; for a in range(N):; for b in range(N):; # Convergence of off-diagonal terms in density matrix to 0; assert(-0.5 * np.sum(A[:, a] + A[:, b]) < 0); # Diagonal terms of density matrix; if a != b:; B[a, b] = A[a, b]; else:; B[a, b] = -1.0 * np.sum([; A[nu, a] for nu in range(N) if nu != a]; ); eigval, eigvec = Qobj(B).eigenstates(); assert(np.isclose(eigval[-1], 0, atol=1e-15)); return eigvec[-1] * eigvec[-1].dag(); ```. which basically looks for the eigenvector associated with 0 eigenvalue of a matrix derived from `A`, which is basically coming directly from equation 251 of [Gri98](http://qutip.org/docs/latest/biblio.html#gri98).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/768
https://github.com/qutip/qutip/issues/768:1250,Testability,assert,assert,1250,"Hi,. I have been trying to use `qutip.floquet.floquet_master_equation_steadystate` method to get the steadystate of my system, but the docstring is not super useful. From the docstring, I guess I should call it as `qutip.floquet.floquet_master_equation_steadystate(H, A)` where. * `H` is my (time-dependent) hamiltonian, similar as the one used in http://qutip.org/docs/latest/guide/dynamics/dynamics-floquet.html#floquet-formalism-in-qutip.; * `A` is the [`A` matrix output](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L587-L588) from `floquet_master_equation_rates` call. I think I missed something as I am getting an error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; from https://github.com/qutip/qutip/blob/master/qutip/steadystate.py#L224. Additionnally, I think there is a much easier way to find the steadystate of such a system, using something like (not really well written nor optimised):. ```python; def floquet_master_equation_steadystate2(A):; """"""; TODO. Parameters; ----------. A : TODO; A matrix used to build the master equation.; """"""; B = np.zeros_like(A); N = A.shape[0]; for a in range(N):; for b in range(N):; # Convergence of off-diagonal terms in density matrix to 0; assert(-0.5 * np.sum(A[:, a] + A[:, b]) < 0); # Diagonal terms of density matrix; if a != b:; B[a, b] = A[a, b]; else:; B[a, b] = -1.0 * np.sum([; A[nu, a] for nu in range(N) if nu != a]; ); eigval, eigvec = Qobj(B).eigenstates(); assert(np.isclose(eigval[-1], 0, atol=1e-15)); return eigvec[-1] * eigvec[-1].dag(); ```. which basically looks for the eigenvector associated with 0 eigenvalue of a matrix derived from `A`, which is basically coming directly from equation 251 of [Gri98](http://qutip.org/docs/latest/biblio.html#gri98).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/768
https://github.com/qutip/qutip/issues/768:1481,Testability,assert,assert,1481,"Hi,. I have been trying to use `qutip.floquet.floquet_master_equation_steadystate` method to get the steadystate of my system, but the docstring is not super useful. From the docstring, I guess I should call it as `qutip.floquet.floquet_master_equation_steadystate(H, A)` where. * `H` is my (time-dependent) hamiltonian, similar as the one used in http://qutip.org/docs/latest/guide/dynamics/dynamics-floquet.html#floquet-formalism-in-qutip.; * `A` is the [`A` matrix output](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L587-L588) from `floquet_master_equation_rates` call. I think I missed something as I am getting an error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; from https://github.com/qutip/qutip/blob/master/qutip/steadystate.py#L224. Additionnally, I think there is a much easier way to find the steadystate of such a system, using something like (not really well written nor optimised):. ```python; def floquet_master_equation_steadystate2(A):; """"""; TODO. Parameters; ----------. A : TODO; A matrix used to build the master equation.; """"""; B = np.zeros_like(A); N = A.shape[0]; for a in range(N):; for b in range(N):; # Convergence of off-diagonal terms in density matrix to 0; assert(-0.5 * np.sum(A[:, a] + A[:, b]) < 0); # Diagonal terms of density matrix; if a != b:; B[a, b] = A[a, b]; else:; B[a, b] = -1.0 * np.sum([; A[nu, a] for nu in range(N) if nu != a]; ); eigval, eigvec = Qobj(B).eigenstates(); assert(np.isclose(eigval[-1], 0, atol=1e-15)); return eigvec[-1] * eigvec[-1].dag(); ```. which basically looks for the eigenvector associated with 0 eigenvalue of a matrix derived from `A`, which is basically coming directly from equation 251 of [Gri98](http://qutip.org/docs/latest/biblio.html#gri98).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/768
https://github.com/qutip/qutip/issues/768:377,Usability,guid,guide,377,"Hi,. I have been trying to use `qutip.floquet.floquet_master_equation_steadystate` method to get the steadystate of my system, but the docstring is not super useful. From the docstring, I guess I should call it as `qutip.floquet.floquet_master_equation_steadystate(H, A)` where. * `H` is my (time-dependent) hamiltonian, similar as the one used in http://qutip.org/docs/latest/guide/dynamics/dynamics-floquet.html#floquet-formalism-in-qutip.; * `A` is the [`A` matrix output](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L587-L588) from `floquet_master_equation_rates` call. I think I missed something as I am getting an error; ```; TypeError: Solving for steady states requires Liouvillian (super) operators; ```; from https://github.com/qutip/qutip/blob/master/qutip/steadystate.py#L224. Additionnally, I think there is a much easier way to find the steadystate of such a system, using something like (not really well written nor optimised):. ```python; def floquet_master_equation_steadystate2(A):; """"""; TODO. Parameters; ----------. A : TODO; A matrix used to build the master equation.; """"""; B = np.zeros_like(A); N = A.shape[0]; for a in range(N):; for b in range(N):; # Convergence of off-diagonal terms in density matrix to 0; assert(-0.5 * np.sum(A[:, a] + A[:, b]) < 0); # Diagonal terms of density matrix; if a != b:; B[a, b] = A[a, b]; else:; B[a, b] = -1.0 * np.sum([; A[nu, a] for nu in range(N) if nu != a]; ); eigval, eigvec = Qobj(B).eigenstates(); assert(np.isclose(eigval[-1], 0, atol=1e-15)); return eigvec[-1] * eigvec[-1].dag(); ```. which basically looks for the eigenvector associated with 0 eigenvalue of a matrix derived from `A`, which is basically coming directly from equation 251 of [Gri98](http://qutip.org/docs/latest/biblio.html#gri98).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/768
https://github.com/qutip/qutip/issues/771:2039,Deployability,Install,Installed,2039," 0 to t = 3.5 in the units of 1/(Rabi frequency) and the driving is only present between t = pi/2 and t = pi, I get expected results if I do not include any collapse operators (using []), however as soon as I use the usual collapse operator corresponding to the excited state decay it gives me for all the time the initial values of the quantities. It happens even if I set the decay rate to zero! Also, mcsolve works fine in both cases.; Here is the code that I use:; ```; import numpy as np; import pylab as plt; import scipy as scipy; from qutip import *. #System parameters; Omega = 1; Gamma = 0.1. g = basis(2,0); e = basis(2,1); sgg = g * g.dag() #ground state population; see = e * e.dag() #excited state population; sge = g * e.dag() #atomic coherence sigma_ge. #Driving Hamiltonian; H1 = Omega * (sge + sge.dag()). #Time dependence of the drive; def H1_coeff(t,args):; if t > np.pi:; c =0; elif t >= np.pi/2:; c = 1; else:; c = 0; return c. #Complete Hamiltonian; H = [[H1, H1_coeff]]. #Time; tspan = np.linspace(0,3.5,500). #initial state; psi0 = g. #collapse operators; c_ops = [np.sqrt(Gamma) * sge]. #calculated expectation values; e_ops = [sgg, see]; results = mesolve(H, psi0, tspan, c_ops, e_ops). #plotting the results; fig, ax = plt.subplots(1,1); ax.plot(tspan, results.expect[0]); ax.plot(tspan, results.expect[1]); plt.show(); ```; And here is the information about the packages that I'm using; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.1; Scipy Version: 0.19.1; Cython Version: 0.26; Matplotlib Version: 2.0.2; Python Version: 3.6.2; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```; Another funny fact that I noticed is that changing the `elif` condition to t >= 1.4 gives nice results but changing it to t >= 1.5 will again deliver only the initial values.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/771
https://github.com/qutip/qutip/issues/771:44,Integrability,depend,dependent,44,"Hi,. I was writing a simple code for a time dependent driving of a two level atom with the excited state decay and encountered the following problem: If I evolve the system using mesolve for particular time dependence of my driving field, namely if the evolution time is set to be from t = 0 to t = 3.5 in the units of 1/(Rabi frequency) and the driving is only present between t = pi/2 and t = pi, I get expected results if I do not include any collapse operators (using []), however as soon as I use the usual collapse operator corresponding to the excited state decay it gives me for all the time the initial values of the quantities. It happens even if I set the decay rate to zero! Also, mcsolve works fine in both cases.; Here is the code that I use:; ```; import numpy as np; import pylab as plt; import scipy as scipy; from qutip import *. #System parameters; Omega = 1; Gamma = 0.1. g = basis(2,0); e = basis(2,1); sgg = g * g.dag() #ground state population; see = e * e.dag() #excited state population; sge = g * e.dag() #atomic coherence sigma_ge. #Driving Hamiltonian; H1 = Omega * (sge + sge.dag()). #Time dependence of the drive; def H1_coeff(t,args):; if t > np.pi:; c =0; elif t >= np.pi/2:; c = 1; else:; c = 0; return c. #Complete Hamiltonian; H = [[H1, H1_coeff]]. #Time; tspan = np.linspace(0,3.5,500). #initial state; psi0 = g. #collapse operators; c_ops = [np.sqrt(Gamma) * sge]. #calculated expectation values; e_ops = [sgg, see]; results = mesolve(H, psi0, tspan, c_ops, e_ops). #plotting the results; fig, ax = plt.subplots(1,1); ax.plot(tspan, results.expect[0]); ax.plot(tspan, results.expect[1]); plt.show(); ```; And here is the information about the packages that I'm using; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.1; Scipy Version: 0.19.1; Cython Version: 0.26; Matplotlib Version: 2.0.2; Python Version: 3.6.2; Number of ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/771
https://github.com/qutip/qutip/issues/771:207,Integrability,depend,dependence,207,"Hi,. I was writing a simple code for a time dependent driving of a two level atom with the excited state decay and encountered the following problem: If I evolve the system using mesolve for particular time dependence of my driving field, namely if the evolution time is set to be from t = 0 to t = 3.5 in the units of 1/(Rabi frequency) and the driving is only present between t = pi/2 and t = pi, I get expected results if I do not include any collapse operators (using []), however as soon as I use the usual collapse operator corresponding to the excited state decay it gives me for all the time the initial values of the quantities. It happens even if I set the decay rate to zero! Also, mcsolve works fine in both cases.; Here is the code that I use:; ```; import numpy as np; import pylab as plt; import scipy as scipy; from qutip import *. #System parameters; Omega = 1; Gamma = 0.1. g = basis(2,0); e = basis(2,1); sgg = g * g.dag() #ground state population; see = e * e.dag() #excited state population; sge = g * e.dag() #atomic coherence sigma_ge. #Driving Hamiltonian; H1 = Omega * (sge + sge.dag()). #Time dependence of the drive; def H1_coeff(t,args):; if t > np.pi:; c =0; elif t >= np.pi/2:; c = 1; else:; c = 0; return c. #Complete Hamiltonian; H = [[H1, H1_coeff]]. #Time; tspan = np.linspace(0,3.5,500). #initial state; psi0 = g. #collapse operators; c_ops = [np.sqrt(Gamma) * sge]. #calculated expectation values; e_ops = [sgg, see]; results = mesolve(H, psi0, tspan, c_ops, e_ops). #plotting the results; fig, ax = plt.subplots(1,1); ax.plot(tspan, results.expect[0]); ax.plot(tspan, results.expect[1]); plt.show(); ```; And here is the information about the packages that I'm using; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.1; Scipy Version: 0.19.1; Cython Version: 0.26; Matplotlib Version: 2.0.2; Python Version: 3.6.2; Number of ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/771
https://github.com/qutip/qutip/issues/771:1119,Integrability,depend,dependence,1119,"blem: If I evolve the system using mesolve for particular time dependence of my driving field, namely if the evolution time is set to be from t = 0 to t = 3.5 in the units of 1/(Rabi frequency) and the driving is only present between t = pi/2 and t = pi, I get expected results if I do not include any collapse operators (using []), however as soon as I use the usual collapse operator corresponding to the excited state decay it gives me for all the time the initial values of the quantities. It happens even if I set the decay rate to zero! Also, mcsolve works fine in both cases.; Here is the code that I use:; ```; import numpy as np; import pylab as plt; import scipy as scipy; from qutip import *. #System parameters; Omega = 1; Gamma = 0.1. g = basis(2,0); e = basis(2,1); sgg = g * g.dag() #ground state population; see = e * e.dag() #excited state population; sge = g * e.dag() #atomic coherence sigma_ge. #Driving Hamiltonian; H1 = Omega * (sge + sge.dag()). #Time dependence of the drive; def H1_coeff(t,args):; if t > np.pi:; c =0; elif t >= np.pi/2:; c = 1; else:; c = 0; return c. #Complete Hamiltonian; H = [[H1, H1_coeff]]. #Time; tspan = np.linspace(0,3.5,500). #initial state; psi0 = g. #collapse operators; c_ops = [np.sqrt(Gamma) * sge]. #calculated expectation values; e_ops = [sgg, see]; results = mesolve(H, psi0, tspan, c_ops, e_ops). #plotting the results; fig, ax = plt.subplots(1,1); ax.plot(tspan, results.expect[0]); ax.plot(tspan, results.expect[1]); plt.show(); ```; And here is the information about the packages that I'm using; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.1; Scipy Version: 0.19.1; Cython Version: 0.26; Matplotlib Version: 2.0.2; Python Version: 3.6.2; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```; Another funny fact that I noti",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/771
https://github.com/qutip/qutip/issues/771:155,Modifiability,evolve,evolve,155,"Hi,. I was writing a simple code for a time dependent driving of a two level atom with the excited state decay and encountered the following problem: If I evolve the system using mesolve for particular time dependence of my driving field, namely if the evolution time is set to be from t = 0 to t = 3.5 in the units of 1/(Rabi frequency) and the driving is only present between t = pi/2 and t = pi, I get expected results if I do not include any collapse operators (using []), however as soon as I use the usual collapse operator corresponding to the excited state decay it gives me for all the time the initial values of the quantities. It happens even if I set the decay rate to zero! Also, mcsolve works fine in both cases.; Here is the code that I use:; ```; import numpy as np; import pylab as plt; import scipy as scipy; from qutip import *. #System parameters; Omega = 1; Gamma = 0.1. g = basis(2,0); e = basis(2,1); sgg = g * g.dag() #ground state population; see = e * e.dag() #excited state population; sge = g * e.dag() #atomic coherence sigma_ge. #Driving Hamiltonian; H1 = Omega * (sge + sge.dag()). #Time dependence of the drive; def H1_coeff(t,args):; if t > np.pi:; c =0; elif t >= np.pi/2:; c = 1; else:; c = 0; return c. #Complete Hamiltonian; H = [[H1, H1_coeff]]. #Time; tspan = np.linspace(0,3.5,500). #initial state; psi0 = g. #collapse operators; c_ops = [np.sqrt(Gamma) * sge]. #calculated expectation values; e_ops = [sgg, see]; results = mesolve(H, psi0, tspan, c_ops, e_ops). #plotting the results; fig, ax = plt.subplots(1,1); ax.plot(tspan, results.expect[0]); ax.plot(tspan, results.expect[1]); plt.show(); ```; And here is the information about the packages that I'm using; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.1; Scipy Version: 0.19.1; Cython Version: 0.26; Matplotlib Version: 2.0.2; Python Version: 3.6.2; Number of ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/771
https://github.com/qutip/qutip/issues/771:21,Usability,simpl,simple,21,"Hi,. I was writing a simple code for a time dependent driving of a two level atom with the excited state decay and encountered the following problem: If I evolve the system using mesolve for particular time dependence of my driving field, namely if the evolution time is set to be from t = 0 to t = 3.5 in the units of 1/(Rabi frequency) and the driving is only present between t = pi/2 and t = pi, I get expected results if I do not include any collapse operators (using []), however as soon as I use the usual collapse operator corresponding to the excited state decay it gives me for all the time the initial values of the quantities. It happens even if I set the decay rate to zero! Also, mcsolve works fine in both cases.; Here is the code that I use:; ```; import numpy as np; import pylab as plt; import scipy as scipy; from qutip import *. #System parameters; Omega = 1; Gamma = 0.1. g = basis(2,0); e = basis(2,1); sgg = g * g.dag() #ground state population; see = e * e.dag() #excited state population; sge = g * e.dag() #atomic coherence sigma_ge. #Driving Hamiltonian; H1 = Omega * (sge + sge.dag()). #Time dependence of the drive; def H1_coeff(t,args):; if t > np.pi:; c =0; elif t >= np.pi/2:; c = 1; else:; c = 0; return c. #Complete Hamiltonian; H = [[H1, H1_coeff]]. #Time; tspan = np.linspace(0,3.5,500). #initial state; psi0 = g. #collapse operators; c_ops = [np.sqrt(Gamma) * sge]. #calculated expectation values; e_ops = [sgg, see]; results = mesolve(H, psi0, tspan, c_ops, e_ops). #plotting the results; fig, ax = plt.subplots(1,1); ax.plot(tspan, results.expect[0]); ax.plot(tspan, results.expect[1]); plt.show(); ```; And here is the information about the packages that I'm using; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.1; Scipy Version: 0.19.1; Cython Version: 0.26; Matplotlib Version: 2.0.2; Python Version: 3.6.2; Number of ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/771
https://github.com/qutip/qutip/issues/772:29,Availability,error,errors,29,"Hi,. It seems there are some errors in the Floquet `mesolve`-equivalent function, which are not seen when considering a simple qubit. Consider for instance an harmonic oscillator with a drive, which should converge towards a coherent state:. ```python; %matplotlib notebook. import numpy as np; from qutip import (basis, destroy, expect, fsesolve, sigmax, sigmaz, rand_ket, num,; mesolve); from qutip.floquet import (floquet_modes, floquet_modes_table,; floquet_modes_t_lookup, fmmesolve). # Parameters; wc = 1.0 * 2 * np.pi; wp = 1.5 * 2 * np.pi; T = 2 * np.pi / wp; N = 20; epsilon_p = np.sqrt(2) * np.sqrt(8) * (wp - wc). psi0 = basis(N,0); a = destroy(N); H = [; wc * a.dag() * a,; [1.0j * epsilon_p * (a.dag() - a), 'cos(wp * t)']; ]. args = {; 'wp': wp; }. # noise power spectrum; gamma1 = 0.05; def noise_spectrum(omega):; return 0.5 * gamma1 * omega / (2 * np.pi). tlist = np.linspace(0, 5 / gamma1, 100). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist,; [a], [], [noise_spectrum], T, args). # For reference: calculate the same thing with mesolve; output_ref = mesolve(H, psi0, tlist, [np.sqrt(gamma1) * a],; [], args); ```. `output_ref.states[-1]` is a coherent state as expected. ![image png 1200 x 1200 pixels - redimensionnee 79](https://user-images.githubusercontent.com/3856586/31828448-433fd44a-b588-11e7-9305-e44f88ed8c1b.png). But `output.states[-1]` is far from being a coherent state. ![image png 1200 x 1200 pixels](https://user-images.githubusercontent.com/3856586/31828469-56631e42-b588-11e7-8950-0ca04ce3c70c.png). I tried to debug it, without real success for now :/. EDIT: Might be partially related to #624.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/772
https://github.com/qutip/qutip/issues/772:771,Energy Efficiency,power,power,771,"Hi,. It seems there are some errors in the Floquet `mesolve`-equivalent function, which are not seen when considering a simple qubit. Consider for instance an harmonic oscillator with a drive, which should converge towards a coherent state:. ```python; %matplotlib notebook. import numpy as np; from qutip import (basis, destroy, expect, fsesolve, sigmax, sigmaz, rand_ket, num,; mesolve); from qutip.floquet import (floquet_modes, floquet_modes_table,; floquet_modes_t_lookup, fmmesolve). # Parameters; wc = 1.0 * 2 * np.pi; wp = 1.5 * 2 * np.pi; T = 2 * np.pi / wp; N = 20; epsilon_p = np.sqrt(2) * np.sqrt(8) * (wp - wc). psi0 = basis(N,0); a = destroy(N); H = [; wc * a.dag() * a,; [1.0j * epsilon_p * (a.dag() - a), 'cos(wp * t)']; ]. args = {; 'wp': wp; }. # noise power spectrum; gamma1 = 0.05; def noise_spectrum(omega):; return 0.5 * gamma1 * omega / (2 * np.pi). tlist = np.linspace(0, 5 / gamma1, 100). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist,; [a], [], [noise_spectrum], T, args). # For reference: calculate the same thing with mesolve; output_ref = mesolve(H, psi0, tlist, [np.sqrt(gamma1) * a],; [], args); ```. `output_ref.states[-1]` is a coherent state as expected. ![image png 1200 x 1200 pixels - redimensionnee 79](https://user-images.githubusercontent.com/3856586/31828448-433fd44a-b588-11e7-9305-e44f88ed8c1b.png). But `output.states[-1]` is far from being a coherent state. ![image png 1200 x 1200 pixels](https://user-images.githubusercontent.com/3856586/31828469-56631e42-b588-11e7-8950-0ca04ce3c70c.png). I tried to debug it, without real success for now :/. EDIT: Might be partially related to #624.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/772
https://github.com/qutip/qutip/issues/772:952,Integrability,depend,dependent,952,"Hi,. It seems there are some errors in the Floquet `mesolve`-equivalent function, which are not seen when considering a simple qubit. Consider for instance an harmonic oscillator with a drive, which should converge towards a coherent state:. ```python; %matplotlib notebook. import numpy as np; from qutip import (basis, destroy, expect, fsesolve, sigmax, sigmaz, rand_ket, num,; mesolve); from qutip.floquet import (floquet_modes, floquet_modes_table,; floquet_modes_t_lookup, fmmesolve). # Parameters; wc = 1.0 * 2 * np.pi; wp = 1.5 * 2 * np.pi; T = 2 * np.pi / wp; N = 20; epsilon_p = np.sqrt(2) * np.sqrt(8) * (wp - wc). psi0 = basis(N,0); a = destroy(N); H = [; wc * a.dag() * a,; [1.0j * epsilon_p * (a.dag() - a), 'cos(wp * t)']; ]. args = {; 'wp': wp; }. # noise power spectrum; gamma1 = 0.05; def noise_spectrum(omega):; return 0.5 * gamma1 * omega / (2 * np.pi). tlist = np.linspace(0, 5 / gamma1, 100). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist,; [a], [], [noise_spectrum], T, args). # For reference: calculate the same thing with mesolve; output_ref = mesolve(H, psi0, tlist, [np.sqrt(gamma1) * a],; [], args); ```. `output_ref.states[-1]` is a coherent state as expected. ![image png 1200 x 1200 pixels - redimensionnee 79](https://user-images.githubusercontent.com/3856586/31828448-433fd44a-b588-11e7-9305-e44f88ed8c1b.png). But `output.states[-1]` is far from being a coherent state. ![image png 1200 x 1200 pixels](https://user-images.githubusercontent.com/3856586/31828469-56631e42-b588-11e7-8950-0ca04ce3c70c.png). I tried to debug it, without real success for now :/. EDIT: Might be partially related to #624.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/772
https://github.com/qutip/qutip/issues/772:120,Usability,simpl,simple,120,"Hi,. It seems there are some errors in the Floquet `mesolve`-equivalent function, which are not seen when considering a simple qubit. Consider for instance an harmonic oscillator with a drive, which should converge towards a coherent state:. ```python; %matplotlib notebook. import numpy as np; from qutip import (basis, destroy, expect, fsesolve, sigmax, sigmaz, rand_ket, num,; mesolve); from qutip.floquet import (floquet_modes, floquet_modes_table,; floquet_modes_t_lookup, fmmesolve). # Parameters; wc = 1.0 * 2 * np.pi; wp = 1.5 * 2 * np.pi; T = 2 * np.pi / wp; N = 20; epsilon_p = np.sqrt(2) * np.sqrt(8) * (wp - wc). psi0 = basis(N,0); a = destroy(N); H = [; wc * a.dag() * a,; [1.0j * epsilon_p * (a.dag() - a), 'cos(wp * t)']; ]. args = {; 'wp': wp; }. # noise power spectrum; gamma1 = 0.05; def noise_spectrum(omega):; return 0.5 * gamma1 * omega / (2 * np.pi). tlist = np.linspace(0, 5 / gamma1, 100). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist,; [a], [], [noise_spectrum], T, args). # For reference: calculate the same thing with mesolve; output_ref = mesolve(H, psi0, tlist, [np.sqrt(gamma1) * a],; [], args); ```. `output_ref.states[-1]` is a coherent state as expected. ![image png 1200 x 1200 pixels - redimensionnee 79](https://user-images.githubusercontent.com/3856586/31828448-433fd44a-b588-11e7-9305-e44f88ed8c1b.png). But `output.states[-1]` is far from being a coherent state. ![image png 1200 x 1200 pixels](https://user-images.githubusercontent.com/3856586/31828469-56631e42-b588-11e7-8950-0ca04ce3c70c.png). I tried to debug it, without real success for now :/. EDIT: Might be partially related to #624.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/772
https://github.com/qutip/qutip/pull/773:23,Testability,test,testing,23,Also added more isherm testing.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/773
https://github.com/qutip/qutip/pull/774:148,Integrability,depend,dependent,148,"This contain a new solver for `mcsolve`, `dopri5` which don't go through scipy and is faster for small system. It also contain a new class for time-dependent Qobj. It allow to create an object from the usual list of Qobj and string/function. The object can then be called to obtain the Qobj at a time. It is used in `mcsolve`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/774
https://github.com/qutip/qutip/pull/776:43,Availability,mask,mask,43,partial_transpose doesn't work properly if mask is boolean array instead of integer array.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/776
https://github.com/qutip/qutip/issues/777:67,Testability,log,log,67,"Hi,; In `continuous_variables.logarithmic_negativity`, the natural log base is used, whereas every paper I've seen has `log2`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/777
https://github.com/qutip/qutip/pull/779:5,Deployability,install,installing,5,"When installing Qutip from source in an MSYS2 environment, the build flags should be set to GCC-style like in *nix installations - I updated the relevant files to do this. I just check for the existence of the MSYSTEM environment variable to check for this case.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/779
https://github.com/qutip/qutip/pull/779:115,Deployability,install,installations,115,"When installing Qutip from source in an MSYS2 environment, the build flags should be set to GCC-style like in *nix installations - I updated the relevant files to do this. I just check for the existence of the MSYSTEM environment variable to check for this case.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/779
https://github.com/qutip/qutip/pull/779:133,Deployability,update,updated,133,"When installing Qutip from source in an MSYS2 environment, the build flags should be set to GCC-style like in *nix installations - I updated the relevant files to do this. I just check for the existence of the MSYSTEM environment variable to check for this case.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/779
https://github.com/qutip/qutip/pull/779:230,Modifiability,variab,variable,230,"When installing Qutip from source in an MSYS2 environment, the build flags should be set to GCC-style like in *nix installations - I updated the relevant files to do this. I just check for the existence of the MSYSTEM environment variable to check for this case.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/779
https://github.com/qutip/qutip/pull/780:22,Integrability,depend,dependant,22,"lscpu is localisation dependant and breaks if the OS uses e.g. German. ""Core(s) per socket"" turns into ""Kern(e) pro Socket"" and results in a crash. /proc/cpuinfo on the other hand remains the same same, therefore it is suited more as information source.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/780
https://github.com/qutip/qutip/pull/781:41,Testability,log,log,41,There's a bunch of warnings in the build log that indicate that scipy.special.factorial should be used in favor of scipy.misc.factorial.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/781
https://github.com/qutip/qutip/issues/782:141,Integrability,Depend,Depending,141,"This is minor, but I would recommend to get rid of the division of terms in H by 2\pi in the function `visualization.plot_energy_levels()`.; Depending on the units that one uses, such a division may not be desired, and is currently a little confusing (as right now it's not explicitly mentioned in the function's doc, so one has to check the code to see what's going on).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/782
https://github.com/qutip/qutip/pull/783:318,Deployability,update,updated,318,"Hi,. As raised by someone on the mailing-list, there is a missing return in `qutip.ipynbtools.plot_animation` helper, leading to a `RuntimeError` when trying to execute the `JC-model-wigner-function.ipynb` example notebook. This commit should address this issue. Moreover, the previously mentionned notebook should be updated as well, but I am not sure where the source is. The `plot_result` function should read. ```python; cb = None. def plot_result(result, n, fig=None, axes=None):; ; global cb; ; if fig is None or axes is None:; fig, ax = plot_setup(result); ; axes.cla(). # trace out the atom; rho_cavity = ptrace(result.states[n], 0). W = wigner(rho_cavity, xvec, xvec); ; surf = axes.plot_surface(X, Y, W, rstride=1, cstride=1, cmap=cm.jet,; alpha=1.0, linewidth=0.05, vmax=0.25, vmin=-0.25). ax.set_xlim3d(-5, 5); ax.set_ylim3d(-5, 5); ax.set_zlim3d(-0.25, 0.25). if not cb:; cb = plt.colorbar(surf, shrink=0.65, aspect=20). return surf,; ```. It might be worth noting also that with proper documentation this notebook could potentially fix https://github.com/qutip/qutip/issues/544 as well. Thanks,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/783
https://github.com/qutip/qutip/pull/784:34,Integrability,contract,contraction,34,In this branch I will make tensor contraction work on sparse matrices.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/784
https://github.com/qutip/qutip/issues/788:897,Availability,error,errors,897,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:985,Availability,error,errors,985,"ows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:1003,Availability,repair,repair,1003,"ows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:1016,Availability,error,errors,1016,"ows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:1028,Availability,error,errors,1028,"ows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:1133,Availability,ERROR,ERROR,1133,"ows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:2736,Availability,ERROR,ERROR,2736,"-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.46s. Est. time left: 00:00:00:25; 20.0%. Run time: 4.37s. Est. time left: 00:00:00:17; 32.0%. Run time: 5.00s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.01s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.65s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.69s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.31s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.89s. Est. time left: 00:00:00:01; Total run time: 7.03s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 90, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:4331,Availability,ERROR,ERROR,4331,"-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.40s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.32s. Est. time left: 00:00:00:17; 32.0%. Run time: 4.88s. Est. time left: 00:00:00:10; 40.0%. Run time: 4.89s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.45s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.49s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.02s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.57s. Est. time left: 00:00:00:01; Total run time: 6.62s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 120, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin cap",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:5931,Availability,ERROR,ERROR,5931,"-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 4.13s. Est. time left: 00:00:00:30; 20.0%. Run time: 5.12s. Est. time left: 00:00:00:20; 32.0%. Run time: 6.16s. Est. time left: 00:00:00:13; 40.0%. Run time: 6.21s. Est. time left: 00:00:00:09; 52.0%. Run time: 7.26s. Est. time left: 00:00:00:06; 60.0%. Run time: 7.37s. Est. time left: 00:00:00:04; 72.0%. Run time: 8.34s. Est. time left: 00:00:00:03; 80.0%. Run time: 9.25s. Est. time left: 00:00:00:02; Total run time: 9.33s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 59, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:7534,Availability,ERROR,ERROR,7534,"-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.30s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.23s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.61s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.61s. Est. time left: 00:00:00:06; 52.0%. Run time: 4.99s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.01s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.37s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.74s. Est. time left: 00:00:00:01; Total run time: 5.89s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 89, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:9129,Availability,ERROR,ERROR,9129,"-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.31s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.25s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.65s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.65s. Est. time left: 00:00:00:06; 52.0%. Run time: 5.06s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.07s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.50s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.88s. Est. time left: 00:00:00:01; Total run time: 5.99s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 119, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin cap",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:10773,Availability,error,errors,10773,"e left: 00:00:00:04; 60.0%. Run time: 5.07s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.50s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.88s. Est. time left: 00:00:00:01; Total run time: 5.99s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 119, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.81s. Est. time left: 00:00:00:27; 20.0%. Run time: 4.76s. Est. time left: 00:00:00:19; 32.0%. Run time: 5.66s. Est. time left: 00:00:00:12; 40.0%. Run time: 5.67s. Est. time left: 00:00:00:08; 52.0%. Run time: 6.59s. Est. time left: 00:00:00:06; 60.0%. Run time: 6.65s. Est. time left: 00:00:00:04; 72.0%. Run time: 7.53s. Est. time left: 00:00:00:02; 80.0%. Run time: 8.38s. Est. time left: 00:00:00:02; Total run time: 8.43s. --------------------- >> end captured stdout << ----------------------. ----------------------------------------------------------------------; Ran 320 tests in 1336.173s. FAILED (SKIP=7, errors=6)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:15,Deployability,install,install,15,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:86,Deployability,Install,Install,86,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:277,Deployability,install,installing,277,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:356,Deployability,install,installation,356,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:699,Deployability,install,installed,699,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:820,Deployability,install,installed,820,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:920,Deployability,install,installation,920,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:124,Testability,test,tested,124,"I am trying to install qutip 3.1.0 on my MS Windows following the official steps:; 1. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:1146,Testability,test,tests,1146,".1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work.; 2. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:1385,Testability,test,test,1385,"selected by default.; 3. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.46s. Est. time left: 00:00:00:25; 20.0%. Run time: 4.37s. Est. time left: 00:00:00:17; 32.0%. Run time: 5.00s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.01s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.65s. Est. time ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:1444,Testability,test,tests,1444," content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32; [build_ext]; compiler = mingw32; The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above.; 4. Obtain the QuTiP source code and installed it following the instructions given above. However, there are some errors after i run the installation verifying process. Is there anyone came across such errors? How can I repair these errors? The errors are presented as follow:; ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 60, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.46s. Est. time left: 00:00:00:25; 20.0%. Run time: 4.37s. Est. time left: 00:00:00:17; 32.0%. Run time: 5.00s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.01s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.65s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.69s.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:2749,Testability,test,tests,2749,"smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.46s. Est. time left: 00:00:00:25; 20.0%. Run time: 4.37s. Est. time left: 00:00:00:17; 32.0%. Run time: 5.00s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.01s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.65s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.69s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.31s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.89s. Est. time left: 00:00:00:01; Total run time: 7.03s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 90, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:2984,Testability,test,test,2984,"in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.46s. Est. time left: 00:00:00:25; 20.0%. Run time: 4.37s. Est. time left: 00:00:00:17; 32.0%. Run time: 5.00s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.01s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.65s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.69s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.31s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.89s. Est. time left: 00:00:00:01; Total run time: 7.03s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 90, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.40s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.32s. Est. time left: 00:00:00:17; 32.0%. Run time: 4.88s. Est. time left: 00:00:00:10; 40.0%. Run time: 4.89s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.45s. Est. time left",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:3043,Testability,test,tests,3043,"ect of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.46s. Est. time left: 00:00:00:25; 20.0%. Run time: 4.37s. Est. time left: 00:00:00:17; 32.0%. Run time: 5.00s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.01s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.65s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.69s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.31s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.89s. Est. time left: 00:00:00:01; Total run time: 7.03s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 90, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.40s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.32s. Est. time left: 00:00:00:17; 32.0%. Run time: 4.88s. Est. time left: 00:00:00:10; 40.0%. Run time: 4.89s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.45s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.49s. Est",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:4344,Testability,test,tests,4344,"smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.40s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.32s. Est. time left: 00:00:00:17; 32.0%. Run time: 4.88s. Est. time left: 00:00:00:10; 40.0%. Run time: 4.89s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.45s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.49s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.02s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.57s. Est. time left: 00:00:00:01; Total run time: 6.62s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 120, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:4581,Testability,test,test,4581," get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.40s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.32s. Est. time left: 00:00:00:17; 32.0%. Run time: 4.88s. Est. time left: 00:00:00:10; 40.0%. Run time: 4.89s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.45s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.49s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.02s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.57s. Est. time left: 00:00:00:01; Total run time: 6.62s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 120, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 4.13s. Est. time left: 00:00:00:30; 20.0%. Run time: 5.12s. Est. time left: 00:00:00:20; 32.0%. Run time: 6.16s. Est. time left: 00:00:00:13; 40.0%. Run time: 6.21s. Est. time left: 00:00:00:09; 52.0%. Run time: 7.26s. Est. time l",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:4640,Testability,test,tests,4640,"t of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.40s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.32s. Est. time left: 00:00:00:17; 32.0%. Run time: 4.88s. Est. time left: 00:00:00:10; 40.0%. Run time: 4.89s. Est. time left: 00:00:00:07; 52.0%. Run time: 5.45s. Est. time left: 00:00:00:05; 60.0%. Run time: 5.49s. Est. time left: 00:00:00:03; 72.0%. Run time: 6.02s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.57s. Est. time left: 00:00:00:01; Total run time: 6.62s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_me.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_me.py"", line 120, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 527, in smesolve; res = _smesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 870, in _smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 4.13s. Est. time left: 00:00:00:30; 20.0%. Run time: 5.12s. Est. time left: 00:00:00:20; 32.0%. Run time: 6.16s. Est. time left: 00:00:00:13; 40.0%. Run time: 6.21s. Est. time left: 00:00:00:09; 52.0%. Run time: 7.26s. Est. time left: 00:00:00:06; 60.0%. Run time: 7.37s. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:5944,Testability,test,tests,5944,"smesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 4.13s. Est. time left: 00:00:00:30; 20.0%. Run time: 5.12s. Est. time left: 00:00:00:20; 32.0%. Run time: 6.16s. Est. time left: 00:00:00:13; 40.0%. Run time: 6.21s. Est. time left: 00:00:00:09; 52.0%. Run time: 7.26s. Est. time left: 00:00:00:06; 60.0%. Run time: 7.37s. Est. time left: 00:00:00:04; 72.0%. Run time: 8.34s. Est. time left: 00:00:00:03; 80.0%. Run time: 9.25s. Est. time left: 00:00:00:02; Total run time: 9.33s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 59, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:6183,Testability,test,test,6183,"et; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 4.13s. Est. time left: 00:00:00:30; 20.0%. Run time: 5.12s. Est. time left: 00:00:00:20; 32.0%. Run time: 6.16s. Est. time left: 00:00:00:13; 40.0%. Run time: 6.21s. Est. time left: 00:00:00:09; 52.0%. Run time: 7.26s. Est. time left: 00:00:00:06; 60.0%. Run time: 7.37s. Est. time left: 00:00:00:04; 72.0%. Run time: 8.34s. Est. time left: 00:00:00:03; 80.0%. Run time: 9.25s. Est. time left: 00:00:00:02; Total run time: 9.33s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 59, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.30s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.23s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.61s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.61s. Est. time left: 00:00:00:06; 52.0%. Run time: 4.99s. Est. time ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:6242,Testability,test,tests,6242,"of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 4.13s. Est. time left: 00:00:00:30; 20.0%. Run time: 5.12s. Est. time left: 00:00:00:20; 32.0%. Run time: 6.16s. Est. time left: 00:00:00:13; 40.0%. Run time: 6.21s. Est. time left: 00:00:00:09; 52.0%. Run time: 7.26s. Est. time left: 00:00:00:06; 60.0%. Run time: 7.37s. Est. time left: 00:00:00:04; 72.0%. Run time: 8.34s. Est. time left: 00:00:00:03; 80.0%. Run time: 9.25s. Est. time left: 00:00:00:02; Total run time: 9.33s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_photocurrent; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 59, in test_ssesolve_photocurrent; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.30s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.23s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.61s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.61s. Est. time left: 00:00:00:06; 52.0%. Run time: 4.99s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.01s.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:7547,Testability,test,tests,7547,"ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.30s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.23s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.61s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.61s. Est. time left: 00:00:00:06; 52.0%. Run time: 4.99s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.01s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.37s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.74s. Est. time left: 00:00:00:01; Total run time: 5.89s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 89, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:7782,Testability,test,test,7782,"in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.30s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.23s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.61s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.61s. Est. time left: 00:00:00:06; 52.0%. Run time: 4.99s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.01s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.37s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.74s. Est. time left: 00:00:00:01; Total run time: 5.89s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 89, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.31s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.25s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.65s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.65s. Est. time left: 00:00:00:06; 52.0%. Run time: 5.06s. Est. time left",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:7841,Testability,test,tests,7841,"ect of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.30s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.23s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.61s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.61s. Est. time left: 00:00:00:06; 52.0%. Run time: 4.99s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.01s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.37s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.74s. Est. time left: 00:00:00:01; Total run time: 5.89s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_homodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 89, in test_ssesolve_homodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.31s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.25s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.65s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.65s. Est. time left: 00:00:00:06; 52.0%. Run time: 5.06s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.07s. Est",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:9142,Testability,test,tests,9142,"ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.31s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.25s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.65s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.65s. Est. time left: 00:00:00:06; 52.0%. Run time: 5.06s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.07s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.50s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.88s. Est. time left: 00:00:00:01; Total run time: 5.99s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 119, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:9379,Testability,test,test,9379," get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.31s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.25s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.65s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.65s. Est. time left: 00:00:00:06; 52.0%. Run time: 5.06s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.07s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.50s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.88s. Est. time left: 00:00:00:01; Total run time: 5.99s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 119, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.81s. Est. time left: 00:00:00:27; 20.0%. Run time: 4.76s. Est. time left: 00:00:00:19; 32.0%. Run time: 5.66s. Est. time left: 00:00:00:12; 40.0%. Run time: 5.67s. Est. time left: 00:00:00:08; 52.0%. Run time: 6.59s. Est. time l",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:9438,Testability,test,tests,9438,"t of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.31s. Est. time left: 00:00:00:24; 20.0%. Run time: 4.25s. Est. time left: 00:00:00:16; 32.0%. Run time: 4.65s. Est. time left: 00:00:00:09; 40.0%. Run time: 4.65s. Est. time left: 00:00:00:06; 52.0%. Run time: 5.06s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.07s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.50s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.88s. Est. time left: 00:00:00:01; Total run time: 5.99s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 119, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.81s. Est. time left: 00:00:00:27; 20.0%. Run time: 4.76s. Est. time left: 00:00:00:19; 32.0%. Run time: 5.66s. Est. time left: 00:00:00:12; 40.0%. Run time: 5.67s. Est. time left: 00:00:00:08; 52.0%. Run time: 6.59s. Est. time left: 00:00:00:06; 60.0%. Run time: 6.65s. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/issues/788:10737,Testability,test,tests,10737,"e left: 00:00:00:04; 60.0%. Run time: 5.07s. Est. time left: 00:00:00:03; 72.0%. Run time: 5.50s. Est. time left: 00:00:00:02; 80.0%. Run time: 5.88s. Est. time left: 00:00:00:01; Total run time: 5.99s. --------------------- >> end captured stdout << ----------------------. ======================================================================; ERROR: qutip.tests.test_stochastic_se.test_ssesolve_heterodyne; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Python27\lib\site-packages\nose\case.py"", line 197, in runTest; self.test(*self.arg); File ""C:\Python27\lib\site-packages\qutip\tests\test_stochastic_se.py"", line 119, in test_ssesolve_heterodyne; map_func=parallel_map); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 365, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""C:\Python27\lib\site-packages\qutip\stochastic.py"", line 692, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""C:\Python27\lib\site-packages\qutip\parallel.py"", line 266, in parallel_map; return [ar.get() for ar in async_res]; File ""C:\Python27\lib\multiprocessing\pool.py"", line 554, in get; raise self._value; ValueError: object of too small depth for desired array; -------------------- >> begin captured stdout << ---------------------; 12.0%. Run time: 3.81s. Est. time left: 00:00:00:27; 20.0%. Run time: 4.76s. Est. time left: 00:00:00:19; 32.0%. Run time: 5.66s. Est. time left: 00:00:00:12; 40.0%. Run time: 5.67s. Est. time left: 00:00:00:08; 52.0%. Run time: 6.59s. Est. time left: 00:00:00:06; 60.0%. Run time: 6.65s. Est. time left: 00:00:00:04; 72.0%. Run time: 7.53s. Est. time left: 00:00:00:02; 80.0%. Run time: 8.38s. Est. time left: 00:00:00:02; Total run time: 8.43s. --------------------- >> end captured stdout << ----------------------. ----------------------------------------------------------------------; Ran 320 tests in 1336.173s. FAILED (SKIP=7, errors=6)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/788
https://github.com/qutip/qutip/pull/789:111,Safety,avoid,avoid,111,- Favor sparse matrix BR tensor for non-secular evolution. - Build diagonal Hamiltonian directly from evals to avoid small; off-diagonal nonzeros that popup when doing a basis transformation.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/789
https://github.com/qutip/qutip/pull/790:76,Integrability,depend,dependent,76,"A faster version of `bloch_redfield_tensor`, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. This routine is now likely limited by the time it takes to do the Python callback for the bath spectra functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/790
https://github.com/qutip/qutip/pull/790:179,Integrability,rout,routine,179,"A faster version of `bloch_redfield_tensor`, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. This routine is now likely limited by the time it takes to do the Python callback for the bath spectra functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/790
https://github.com/qutip/qutip/issues/791:142,Availability,error,error,142,"Hello! I'm trying to use the steadystate solver. When not using MKL, my program runs (albeit a bit slow). When using MKL, I get the following error message. I have tried to figure it out myself, to no avail. Traceback (most recent call last):; File ""cubicH_quantumPump_loop.py"", line 54, in <module>; rho = steadystate(H, c_ops); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 234, in steadystate; return _steadystate_direct_sparse(A, ss_args); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 400, in _steadystate_direct_sparse; v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 384, in mkl_spsolve; x = lu.solve(b, verbose=verbose); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 167, in solve; raise Exception(pardiso_error_msgs[str(error)]); KeyError: '[-4]'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/791
https://github.com/qutip/qutip/issues/791:201,Availability,avail,avail,201,"Hello! I'm trying to use the steadystate solver. When not using MKL, my program runs (albeit a bit slow). When using MKL, I get the following error message. I have tried to figure it out myself, to no avail. Traceback (most recent call last):; File ""cubicH_quantumPump_loop.py"", line 54, in <module>; rho = steadystate(H, c_ops); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 234, in steadystate; return _steadystate_direct_sparse(A, ss_args); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 400, in _steadystate_direct_sparse; v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 384, in mkl_spsolve; x = lu.solve(b, verbose=verbose); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 167, in solve; raise Exception(pardiso_error_msgs[str(error)]); KeyError: '[-4]'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/791
https://github.com/qutip/qutip/issues/791:954,Availability,error,error,954,"Hello! I'm trying to use the steadystate solver. When not using MKL, my program runs (albeit a bit slow). When using MKL, I get the following error message. I have tried to figure it out myself, to no avail. Traceback (most recent call last):; File ""cubicH_quantumPump_loop.py"", line 54, in <module>; rho = steadystate(H, c_ops); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 234, in steadystate; return _steadystate_direct_sparse(A, ss_args); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 400, in _steadystate_direct_sparse; v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 384, in mkl_spsolve; x = lu.solve(b, verbose=verbose); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 167, in solve; raise Exception(pardiso_error_msgs[str(error)]); KeyError: '[-4]'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/791
https://github.com/qutip/qutip/issues/791:148,Integrability,message,message,148,"Hello! I'm trying to use the steadystate solver. When not using MKL, my program runs (albeit a bit slow). When using MKL, I get the following error message. I have tried to figure it out myself, to no avail. Traceback (most recent call last):; File ""cubicH_quantumPump_loop.py"", line 54, in <module>; rho = steadystate(H, c_ops); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 234, in steadystate; return _steadystate_direct_sparse(A, ss_args); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/steadystate.py"", line 400, in _steadystate_direct_sparse; v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 384, in mkl_spsolve; x = lu.solve(b, verbose=verbose); File ""/home/ingrid/anaconda3/lib/python3.6/site-packages/qutip/_mkl/spsolve.py"", line 167, in solve; raise Exception(pardiso_error_msgs[str(error)]); KeyError: '[-4]'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/791
https://github.com/qutip/qutip/issues/792:274,Deployability,integrat,integrate,274,"![ce 0](https://user-images.githubusercontent.com/33592789/46414779-505ced80-c73d-11e8-9b03-41cfa1a75bb1.png). I m obtaining this using code:; from numpy import *; from scipy.special import mathieu_cem; import matplotlib.pyplot as plt; from matplotlib import cm; from scipy.integrate import quad. ## Parameters ##; i = 1.0j; x = linspace(-pi,pi,200); p = linspace(-5,5,200); x, p = meshgrid(x, p); y = linspace(-pi, pi, 200). psi = (mathieu_cem(0,-1,(x-y/2)*180/pi)[0]) ; psic = transpose(conj(mathieu_cem(0,-1,(x+y/2)*180/pi)[0])). ## Defining the integral ##; def integrand(y, x, p):; return psic * psi * exp(2 * i * p * y). ## Generate Wigner function ##; def W(x, p):; return quad(integrand, -pi, pi, args=(x, p))[0]. W = vectorize(W); ## Plotting the Distribution ##; fig, axes = plt.subplots(); cont = axes.contourf(x, p, W, 1000, cmap=cm.jet); axes.set_xlabel(r'x'); axes.set_ylabel(r'p', labelpad=-10); cb = fig.colorbar(cont, ax=axes) 			# add colour bar; plt.show(). Any better arrangement?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/792
https://github.com/qutip/qutip/issues/792:274,Integrability,integrat,integrate,274,"![ce 0](https://user-images.githubusercontent.com/33592789/46414779-505ced80-c73d-11e8-9b03-41cfa1a75bb1.png). I m obtaining this using code:; from numpy import *; from scipy.special import mathieu_cem; import matplotlib.pyplot as plt; from matplotlib import cm; from scipy.integrate import quad. ## Parameters ##; i = 1.0j; x = linspace(-pi,pi,200); p = linspace(-5,5,200); x, p = meshgrid(x, p); y = linspace(-pi, pi, 200). psi = (mathieu_cem(0,-1,(x-y/2)*180/pi)[0]) ; psic = transpose(conj(mathieu_cem(0,-1,(x+y/2)*180/pi)[0])). ## Defining the integral ##; def integrand(y, x, p):; return psic * psi * exp(2 * i * p * y). ## Generate Wigner function ##; def W(x, p):; return quad(integrand, -pi, pi, args=(x, p))[0]. W = vectorize(W); ## Plotting the Distribution ##; fig, axes = plt.subplots(); cont = axes.contourf(x, p, W, 1000, cmap=cm.jet); axes.set_xlabel(r'x'); axes.set_ylabel(r'p', labelpad=-10); cb = fig.colorbar(cont, ax=axes) 			# add colour bar; plt.show(). Any better arrangement?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/792
https://github.com/qutip/qutip/pull/793:723,Availability,down,down,723,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/793
https://github.com/qutip/qutip/pull/793:851,Availability,down,down,851,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/793
https://github.com/qutip/qutip/pull/793:19,Modifiability,refactor,refactoring,19,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/793
https://github.com/qutip/qutip/pull/793:1461,Modifiability,Refactor,Refactoring,1461,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/793
https://github.com/qutip/qutip/pull/793:1265,Performance,optimiz,optimized,1265,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/793
https://github.com/qutip/qutip/pull/793:1366,Performance,Optimiz,Optimize,1366,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/793
https://github.com/qutip/qutip/pull/793:1311,Testability,Test,Tests,1311,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/793
https://github.com/qutip/qutip/issues/794:430,Energy Efficiency,reduce,reduce,430,"In the construction of the RHS of the equation for the Hierarchy Equations of Motion (`non_markov/heom`) there is a bug found by @nwlambert . If the 'system' is actually a tensor product of systems it fails as the dimensions are incorrect. This can be fixed by changing the construction of the RHS in `non_markov/heom.py` (line 310) from. ```; sup_dim = H_sys.dims[0][0]**2; unit_sys = qeye(H_sys.dims[0]); ```; to. ```; N_temp = reduce(mul, H_sys.dims[0], 1); sup_dim = N_temp**2; unit_sys = qeye(N_temp); ```. I will open a PR to do the same. Just raising the issue so that it is documented and helps others find the problem in the previous versions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/794
https://github.com/qutip/qutip/issues/796:258,Availability,error,error,258,"Hi QuTip team and community! I just installed QuTiP on my Mac and I am very excited to try it out. I started playing with this section of QuTiP User Guide [Plotting on the Bloch Sphere; ](http://qutip.org/docs/4.1/guide/guide-bloch.html), but encountered an error. This code works well if I run it in Python console:; ```; from qutip import *; bloch = Bloch(); bloch.show(); ```; But the following code in Python console shows an error; ```; bloch.save(); ```. ```; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/qutip/bloch.py"", line 663, in save; '.' + format); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 1834, in savefig; self.canvas.print_figure(fname, **kwargs); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltoni",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:430,Availability,error,error,430,"Hi QuTip team and community! I just installed QuTiP on my Mac and I am very excited to try it out. I started playing with this section of QuTiP User Guide [Plotting on the Bloch Sphere; ](http://qutip.org/docs/4.1/guide/guide-bloch.html), but encountered an error. This code works well if I run it in Python console:; ```; from qutip import *; bloch = Bloch(); bloch.show(); ```; But the following code in Python console shows an error; ```; bloch.save(); ```. ```; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/qutip/bloch.py"", line 663, in save; '.' + format); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 1834, in savefig; self.canvas.print_figure(fname, **kwargs); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltoni",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:1836,Availability,error,error,1836,"lek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:36,Deployability,install,installed,36,"Hi QuTip team and community! I just installed QuTiP on my Mac and I am very excited to try it out. I started playing with this section of QuTiP User Guide [Plotting on the Bloch Sphere; ](http://qutip.org/docs/4.1/guide/guide-bloch.html), but encountered an error. This code works well if I run it in Python console:; ```; from qutip import *; bloch = Bloch(); bloch.show(); ```; But the following code in Python console shows an error; ```; bloch.save(); ```. ```; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/qutip/bloch.py"", line 663, in save; '.' + format); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 1834, in savefig; self.canvas.print_figure(fname, **kwargs); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltoni",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:2397,Modifiability,evolve,evolve,2397,"plotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; print 'len(sx) is ', len(sx); for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:149,Usability,Guid,Guide,149,"Hi QuTip team and community! I just installed QuTiP on my Mac and I am very excited to try it out. I started playing with this section of QuTiP User Guide [Plotting on the Bloch Sphere; ](http://qutip.org/docs/4.1/guide/guide-bloch.html), but encountered an error. This code works well if I run it in Python console:; ```; from qutip import *; bloch = Bloch(); bloch.show(); ```; But the following code in Python console shows an error; ```; bloch.save(); ```. ```; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/qutip/bloch.py"", line 663, in save; '.' + format); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 1834, in savefig; self.canvas.print_figure(fname, **kwargs); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltoni",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:214,Usability,guid,guide,214,"Hi QuTip team and community! I just installed QuTiP on my Mac and I am very excited to try it out. I started playing with this section of QuTiP User Guide [Plotting on the Bloch Sphere; ](http://qutip.org/docs/4.1/guide/guide-bloch.html), but encountered an error. This code works well if I run it in Python console:; ```; from qutip import *; bloch = Bloch(); bloch.show(); ```; But the following code in Python console shows an error; ```; bloch.save(); ```. ```; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/qutip/bloch.py"", line 663, in save; '.' + format); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 1834, in savefig; self.canvas.print_figure(fname, **kwargs); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltoni",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:220,Usability,guid,guide-bloch,220,"Hi QuTip team and community! I just installed QuTiP on my Mac and I am very excited to try it out. I started playing with this section of QuTiP User Guide [Plotting on the Bloch Sphere; ](http://qutip.org/docs/4.1/guide/guide-bloch.html), but encountered an error. This code works well if I run it in Python console:; ```; from qutip import *; bloch = Bloch(); bloch.show(); ```; But the following code in Python console shows an error; ```; bloch.save(); ```. ```; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/qutip/bloch.py"", line 663, in save; '.' + format); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 1834, in savefig; self.canvas.print_figure(fname, **kwargs); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltoni",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:1702,Usability,Guid,Guide,1702,".7/site-packages/matplotlib/figure.py"", line 1834, in savefig; self.canvas.print_figure(fname, **kwargs); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backend_bases.py"", line 2188, in print_figure; self.figure.dpi = dpi; File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 436, in _set_dpi; self.set_size_inches(w, h, forward=forward); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/figure.py"", line 745, in set_size_inches; manager.resize(int(canvasw), int(canvash)); File ""/Users/tilek/miniconda2/lib/python2.7/site-packages/matplotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigm",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/796:3112,Usability,clear,clear,3112,"plotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; print 'len(sx) is ', len(sx); for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/796
https://github.com/qutip/qutip/issues/797:273,Availability,error,error,273,Qubit Decay code example on [this page; ](http://qutip.org/docs/4.1/guide/guide-bloch.html) lists these imports. ```; from qutip import *; from scipy import *; ```; I think it misses; `import numpy as np`; for np.sin and np.cos functions. If I don't add that line I get an error.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/797
https://github.com/qutip/qutip/issues/797:68,Usability,guid,guide,68,Qubit Decay code example on [this page; ](http://qutip.org/docs/4.1/guide/guide-bloch.html) lists these imports. ```; from qutip import *; from scipy import *; ```; I think it misses; `import numpy as np`; for np.sin and np.cos functions. If I don't add that line I get an error.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/797
https://github.com/qutip/qutip/issues/797:74,Usability,guid,guide-bloch,74,Qubit Decay code example on [this page; ](http://qutip.org/docs/4.1/guide/guide-bloch.html) lists these imports. ```; from qutip import *; from scipy import *; ```; I think it misses; `import numpy as np`; for np.sin and np.cos functions. If I don't add that line I get an error.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/797
https://github.com/qutip/qutip/issues/798:279,Availability,error,error,279,"I am trying to use code from User Guide's [Directly Generating an Animation section](http://qutip.org/docs/4.1/guide/guide-bloch.html?highlight=funcanimation#directly-generating-an-animation):. ```; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); ```. I get the following error:; ```; Traceback (most recent call last):; File ""bloch_test.py"", line 59, in <module>; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); TypeError: save() got an unexpected keyword argument 'clear_temp'; ```. It looks like OpenDrift may have had the same or similar issue:; https://github.com/OpenDrift/opendrift/issues/9. My hypothesis is that QuTip needs to be adapted to the newer version of Matplotlib.; According to ; ```; from qutip import *; about(); ```; I use Matplotlib version: 2.1.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/798
https://github.com/qutip/qutip/issues/798:653,Energy Efficiency,adapt,adapted,653,"I am trying to use code from User Guide's [Directly Generating an Animation section](http://qutip.org/docs/4.1/guide/guide-bloch.html?highlight=funcanimation#directly-generating-an-animation):. ```; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); ```. I get the following error:; ```; Traceback (most recent call last):; File ""bloch_test.py"", line 59, in <module>; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); TypeError: save() got an unexpected keyword argument 'clear_temp'; ```. It looks like OpenDrift may have had the same or similar issue:; https://github.com/OpenDrift/opendrift/issues/9. My hypothesis is that QuTip needs to be adapted to the newer version of Matplotlib.; According to ; ```; from qutip import *; about(); ```; I use Matplotlib version: 2.1.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/798
https://github.com/qutip/qutip/issues/798:653,Modifiability,adapt,adapted,653,"I am trying to use code from User Guide's [Directly Generating an Animation section](http://qutip.org/docs/4.1/guide/guide-bloch.html?highlight=funcanimation#directly-generating-an-animation):. ```; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); ```. I get the following error:; ```; Traceback (most recent call last):; File ""bloch_test.py"", line 59, in <module>; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); TypeError: save() got an unexpected keyword argument 'clear_temp'; ```. It looks like OpenDrift may have had the same or similar issue:; https://github.com/OpenDrift/opendrift/issues/9. My hypothesis is that QuTip needs to be adapted to the newer version of Matplotlib.; According to ; ```; from qutip import *; about(); ```; I use Matplotlib version: 2.1.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/798
https://github.com/qutip/qutip/issues/798:34,Usability,Guid,Guide,34,"I am trying to use code from User Guide's [Directly Generating an Animation section](http://qutip.org/docs/4.1/guide/guide-bloch.html?highlight=funcanimation#directly-generating-an-animation):. ```; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); ```. I get the following error:; ```; Traceback (most recent call last):; File ""bloch_test.py"", line 59, in <module>; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); TypeError: save() got an unexpected keyword argument 'clear_temp'; ```. It looks like OpenDrift may have had the same or similar issue:; https://github.com/OpenDrift/opendrift/issues/9. My hypothesis is that QuTip needs to be adapted to the newer version of Matplotlib.; According to ; ```; from qutip import *; about(); ```; I use Matplotlib version: 2.1.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/798
https://github.com/qutip/qutip/issues/798:111,Usability,guid,guide,111,"I am trying to use code from User Guide's [Directly Generating an Animation section](http://qutip.org/docs/4.1/guide/guide-bloch.html?highlight=funcanimation#directly-generating-an-animation):. ```; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); ```. I get the following error:; ```; Traceback (most recent call last):; File ""bloch_test.py"", line 59, in <module>; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); TypeError: save() got an unexpected keyword argument 'clear_temp'; ```. It looks like OpenDrift may have had the same or similar issue:; https://github.com/OpenDrift/opendrift/issues/9. My hypothesis is that QuTip needs to be adapted to the newer version of Matplotlib.; According to ; ```; from qutip import *; about(); ```; I use Matplotlib version: 2.1.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/798
https://github.com/qutip/qutip/issues/798:117,Usability,guid,guide-bloch,117,"I am trying to use code from User Guide's [Directly Generating an Animation section](http://qutip.org/docs/4.1/guide/guide-bloch.html?highlight=funcanimation#directly-generating-an-animation):. ```; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); ```. I get the following error:; ```; Traceback (most recent call last):; File ""bloch_test.py"", line 59, in <module>; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); TypeError: save() got an unexpected keyword argument 'clear_temp'; ```. It looks like OpenDrift may have had the same or similar issue:; https://github.com/OpenDrift/opendrift/issues/9. My hypothesis is that QuTip needs to be adapted to the newer version of Matplotlib.; According to ; ```; from qutip import *; about(); ```; I use Matplotlib version: 2.1.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/798
https://github.com/qutip/qutip/issues/799:231,Availability,error,error,231,"When I run `ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4`; from the User Guide's [Generating Images for Animation; ](http://qutip.org/docs/4.1/guide/guide-bloch.html#generating-images-for-animation) section I get the following error:. ```; Option b (video bitrate (please use -b:v)) cannot be applied to input url %04d.png -- you are trying to apply an input option to an output file or vice versa. Move this option before the file it belongs to.; Error parsing options for input file bloch_%01d.png.; Error opening input files: Invalid argument; ```. What works for me instead is this:; `ffmpeg -r 20 -i bloch_%01d.png -pix_fmt yuv420p bloch.mp4`. Note: personally I print files as zeropadded 4-digit number, so I have %04d.png instead of bloch_%01d.png.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/799
https://github.com/qutip/qutip/issues/799:452,Availability,Error,Error,452,"When I run `ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4`; from the User Guide's [Generating Images for Animation; ](http://qutip.org/docs/4.1/guide/guide-bloch.html#generating-images-for-animation) section I get the following error:. ```; Option b (video bitrate (please use -b:v)) cannot be applied to input url %04d.png -- you are trying to apply an input option to an output file or vice versa. Move this option before the file it belongs to.; Error parsing options for input file bloch_%01d.png.; Error opening input files: Invalid argument; ```. What works for me instead is this:; `ffmpeg -r 20 -i bloch_%01d.png -pix_fmt yuv420p bloch.mp4`. Note: personally I print files as zeropadded 4-digit number, so I have %04d.png instead of bloch_%01d.png.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/799
https://github.com/qutip/qutip/issues/799:506,Availability,Error,Error,506,"When I run `ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4`; from the User Guide's [Generating Images for Animation; ](http://qutip.org/docs/4.1/guide/guide-bloch.html#generating-images-for-animation) section I get the following error:. ```; Option b (video bitrate (please use -b:v)) cannot be applied to input url %04d.png -- you are trying to apply an input option to an output file or vice versa. Move this option before the file it belongs to.; Error parsing options for input file bloch_%01d.png.; Error opening input files: Invalid argument; ```. What works for me instead is this:; `ffmpeg -r 20 -i bloch_%01d.png -pix_fmt yuv420p bloch.mp4`. Note: personally I print files as zeropadded 4-digit number, so I have %04d.png instead of bloch_%01d.png.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/799
https://github.com/qutip/qutip/issues/799:77,Usability,Guid,Guide,77,"When I run `ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4`; from the User Guide's [Generating Images for Animation; ](http://qutip.org/docs/4.1/guide/guide-bloch.html#generating-images-for-animation) section I get the following error:. ```; Option b (video bitrate (please use -b:v)) cannot be applied to input url %04d.png -- you are trying to apply an input option to an output file or vice versa. Move this option before the file it belongs to.; Error parsing options for input file bloch_%01d.png.; Error opening input files: Invalid argument; ```. What works for me instead is this:; `ffmpeg -r 20 -i bloch_%01d.png -pix_fmt yuv420p bloch.mp4`. Note: personally I print files as zeropadded 4-digit number, so I have %04d.png instead of bloch_%01d.png.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/799
https://github.com/qutip/qutip/issues/799:147,Usability,guid,guide,147,"When I run `ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4`; from the User Guide's [Generating Images for Animation; ](http://qutip.org/docs/4.1/guide/guide-bloch.html#generating-images-for-animation) section I get the following error:. ```; Option b (video bitrate (please use -b:v)) cannot be applied to input url %04d.png -- you are trying to apply an input option to an output file or vice versa. Move this option before the file it belongs to.; Error parsing options for input file bloch_%01d.png.; Error opening input files: Invalid argument; ```. What works for me instead is this:; `ffmpeg -r 20 -i bloch_%01d.png -pix_fmt yuv420p bloch.mp4`. Note: personally I print files as zeropadded 4-digit number, so I have %04d.png instead of bloch_%01d.png.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/799
https://github.com/qutip/qutip/issues/799:153,Usability,guid,guide-bloch,153,"When I run `ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4`; from the User Guide's [Generating Images for Animation; ](http://qutip.org/docs/4.1/guide/guide-bloch.html#generating-images-for-animation) section I get the following error:. ```; Option b (video bitrate (please use -b:v)) cannot be applied to input url %04d.png -- you are trying to apply an input option to an output file or vice versa. Move this option before the file it belongs to.; Error parsing options for input file bloch_%01d.png.; Error opening input files: Invalid argument; ```. What works for me instead is this:; `ffmpeg -r 20 -i bloch_%01d.png -pix_fmt yuv420p bloch.mp4`. Note: personally I print files as zeropadded 4-digit number, so I have %04d.png instead of bloch_%01d.png.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/799
https://github.com/qutip/qutip/issues/800:203,Availability,error,error,203,There is a Bloch_Decay.mp4 link at the bottom of the [Plotting on the Bloch Sphere](http://qutip.org/docs/4.1/guide/guide-bloch.html#plotting-on-the-bloch-sphere) webpage. When I click on it I get a 404 error from linked Google Code page:; http://qutip.googlecode.com/svn/doc/figures/bloch_decay.mp4,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/800
https://github.com/qutip/qutip/issues/800:110,Usability,guid,guide,110,There is a Bloch_Decay.mp4 link at the bottom of the [Plotting on the Bloch Sphere](http://qutip.org/docs/4.1/guide/guide-bloch.html#plotting-on-the-bloch-sphere) webpage. When I click on it I get a 404 error from linked Google Code page:; http://qutip.googlecode.com/svn/doc/figures/bloch_decay.mp4,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/800
https://github.com/qutip/qutip/issues/800:116,Usability,guid,guide-bloch,116,There is a Bloch_Decay.mp4 link at the bottom of the [Plotting on the Bloch Sphere](http://qutip.org/docs/4.1/guide/guide-bloch.html#plotting-on-the-bloch-sphere) webpage. When I click on it I get a 404 error from linked Google Code page:; http://qutip.googlecode.com/svn/doc/figures/bloch_decay.mp4,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/800
https://github.com/qutip/qutip/issues/802:140,Availability,error,error,140,"from qutip import *; import numpy as np; import matplotlib.pyplot as plt; import qutip.testing as qt. Here is the part of the code that has error:. H = tensor(sigmaz(),sigmaz(),identity(2)) + tensor(identity(2),sigmaz(),sigmaz()) + 0.05 * tensor(sigmax(), sigmax(),sigmax()); psi0 = basis(8, 0); times = np.linspace(0.0, 10.0, 20.0); result = mesolve(H, psi0, times, [], [sigmaz()]). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-752e3e5ccdb6> in <module>(); 4 psi0 = basis(8, 0); 5 times = np.linspace(0.0, 10.0, 20.0); ----> 6 result = mesolve(H, psi0, times, [], [sigmaz()]). /Users/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 223 ; 224 if _safe_mode:; --> 225 _solver_safety_check(H, rho0, c_ops, e_ops, args); 226 ; 227 if progress_bar is None:. /Users/lib/python2.7/site-packages/qutip/solver.pyc in _solver_safety_check(H, state, c_ops, e_ops, args); 795 Hdims = H.dims; 796 Htype = H.type; --> 797 _structure_check(Hdims, Htype, state); 798 # Input H is function; 799 elif isinstance(H, (FunctionType, BuiltinFunctionType)):. /Users/lib/python2.7/site-packages/qutip/solver.pyc in _structure_check(Hdims, Htype, state); 870 if Htype == 'oper':; 871 if Hdims[1] != state.dims[0]:; --> 872 raise Exception('Input operator and ket do not share same structure.'); 873 # Input is super and state is ket; 874 elif Htype == 'super':. Exception: Input operator and ket do not share same structure.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/802
https://github.com/qutip/qutip/issues/802:87,Testability,test,testing,87,"from qutip import *; import numpy as np; import matplotlib.pyplot as plt; import qutip.testing as qt. Here is the part of the code that has error:. H = tensor(sigmaz(),sigmaz(),identity(2)) + tensor(identity(2),sigmaz(),sigmaz()) + 0.05 * tensor(sigmax(), sigmax(),sigmax()); psi0 = basis(8, 0); times = np.linspace(0.0, 10.0, 20.0); result = mesolve(H, psi0, times, [], [sigmaz()]). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-752e3e5ccdb6> in <module>(); 4 psi0 = basis(8, 0); 5 times = np.linspace(0.0, 10.0, 20.0); ----> 6 result = mesolve(H, psi0, times, [], [sigmaz()]). /Users/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 223 ; 224 if _safe_mode:; --> 225 _solver_safety_check(H, rho0, c_ops, e_ops, args); 226 ; 227 if progress_bar is None:. /Users/lib/python2.7/site-packages/qutip/solver.pyc in _solver_safety_check(H, state, c_ops, e_ops, args); 795 Hdims = H.dims; 796 Htype = H.type; --> 797 _structure_check(Hdims, Htype, state); 798 # Input H is function; 799 elif isinstance(H, (FunctionType, BuiltinFunctionType)):. /Users/lib/python2.7/site-packages/qutip/solver.pyc in _structure_check(Hdims, Htype, state); 870 if Htype == 'oper':; 871 if Hdims[1] != state.dims[0]:; --> 872 raise Exception('Input operator and ket do not share same structure.'); 873 # Input is super and state is ket; 874 elif Htype == 'super':. Exception: Input operator and ket do not share same structure.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/802
https://github.com/qutip/qutip/issues/805:263,Availability,error,error,263,"I am trying to calculate the expectation value of Mx. It is the order parameter of a hamiltonian, and I want to calculate the phase transition of it later on. I used commend expect(Mx, H.groundstate() while I have input a hamiltonian. Here is the code and I have error as the following:. ----------------------------------------; H.groundstate(). Out[193]:; (-21.1393191156312,; Quantum object: dims = [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], shape = (1024, 1), type = ket; Qobj data =; [[-0.00980414]; [ 0.01225526]; [ 0.01570169]; ...; [ 0.01570169]; [ 0.01225526]; [-0.00980414]]). **## expect(Mx, H.groundstate())**. ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-194-8e60f2d2c48d> in <module>(); ----> 1 expect(Mx, H.groundstate()). /Users/lib/python2.7/site-packages/qutip/expect.pyc in expect(oper, state); 95 dtype=complex); 96 else:; ---> 97 raise TypeError('Arguments must be quantum objects or eseries'); 98 ; 99 . **TypeError: Arguments must be quantum objects or eseries**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/805
https://github.com/qutip/qutip/issues/806:12,Availability,error,error,12,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:189,Availability,error,error,189,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:275,Availability,error,error,275,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:1725,Availability,error,error,1725,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:1884,Availability,error,error,1884,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:1713,Deployability,integrat,integration,1713,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:1872,Deployability,integrat,integration,1872,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:1713,Integrability,integrat,integration,1713,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/issues/806:1872,Integrability,integrat,integration,1872,"I have such error whenever my the ratio between j or h for my hamiltonian and the total duration time(now in the following code is 0.1) is a certain number and above, mesolve produces this error. However, I need this ratio to be a certain number and above which produces the error. What do you recommend that I do? Thank you so much!. Here is the code:. j = 1000; h = 100000. \begin{equation}; H= j \sum_{\langle ij\rangle} \sigma_i^x\sigma_j^x +h \sum_i \sigma_i^z; \end{equation}. psi0=tensor(basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0),basis(2, 0)). times = np.linspace(0.0, 0.1, 100). result3 = mesolve(H, psi0, times, [], []); ; print fidelity(result3.states[99],psi0). ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-25-49de88b6cc71> in <module>(); 8 times = np.linspace(0.0, 0.1, 100); 9 ; ---> 10 result3 = mesolve(H, psi0, times, [], []); 11 ; 12 print fidelity(result3.states[99],psi0). /Users/anaconda/lib/python2.7/site-packages/qutip/mesolve.pyc in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 341 else:; 342 res = _sesolve_const(H, rho0, tlist,; --> 343 e_ops, args, options, progress_bar); 344 ; 345 if e_ops_dict:. /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar); 325 #; 326 return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; --> 327 progress_bar, dims=psi0.dims); 328 ; 329 . /Users/anaconda/lib/python2.7/site-packages/qutip/sesolve.pyc in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims); 689 ; 690 if not r.successful():; --> 691 raise Exception(""ODE integration error: Try to increase ""; 692 ""the allowed number of substeps by increasing ""; 693 ""the nsteps parameter in the Options class.""). **Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/806
https://github.com/qutip/qutip/pull/809:32,Integrability,message,message,32,"Hi,. I noticed that the current message regarding the citations gets lost in the end of the build messages and warnings. A small modification to make the message stand out. @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/809
https://github.com/qutip/qutip/pull/809:98,Integrability,message,messages,98,"Hi,. I noticed that the current message regarding the citations gets lost in the end of the build messages and warnings. A small modification to make the message stand out. @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/809
https://github.com/qutip/qutip/pull/809:154,Integrability,message,message,154,"Hi,. I noticed that the current message regarding the citations gets lost in the end of the build messages and warnings. A small modification to make the message stand out. @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/809
https://github.com/qutip/qutip/pull/810:73,Integrability,depend,dependent,73,Pull allows for passing the interpolation Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/810
https://github.com/qutip/qutip/issues/811:310,Availability,error,error,310,"I was trying to see the phase transition of magnetization of a transverse Ising model, and I have the following graph. The magnetization changes unusually rapidly under the change of magnetic field and, I don't have this problem using my own library. Since the code I wrote is extremely simple and there is no error message, I wonder do you possibly have encountered the similar issues and have some suggestions on what it happens. Here is the code, and the graph. ----------------------------------------------------------; harray = np.zeros(11); for i in range(11):; harray[i] = 0.0001 * i; ; #print harray; ; marray4 = np.zeros(11). Mx = tensor(sigmaz(),identity(2),identity(2),identity(2))\; + tensor(identity(2),sigmaz(),identity(2),identity(2))\; + tensor(identity(2),identity(2),sigmaz(),identity(2))\; + tensor(identity(2),identity(2),identity(2),sigmaz()). earray4 = np.zeros(11); ; for ii in range(0, 11):; ; H = -(tensor(sigmaz(),sigmaz(),identity(2),identity(2)) \; + tensor(identity(2),sigmaz(),sigmaz(),identity(2)) \; + tensor(identity(2),identity(2),sigmaz(),sigmaz()) \; + tensor(sigmaz(),identity(2),identity(2),sigmaz())) \; - harray[ii]*(tensor(sigmax(),identity(2),identity(2),identity(2))\; + tensor(identity(2),sigmax(),identity(2),identity(2))\; + tensor(identity(2),identity(2),sigmax(),identity(2))\; + tensor(identity(2),identity(2),identity(2),sigmax())); . marray4[ii] = expect(Mx, H.eigenstates()[1][0]); ; plt.plot(harray, marray4, 'o-'); plt.show(). ![screen shot 2018-02-05 at 11 59 45 am](https://user-images.githubusercontent.com/35711575/35817669-17d7afe2-0a6c-11e8-859f-6ae1d686a7fe.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/811
https://github.com/qutip/qutip/issues/811:316,Integrability,message,message,316,"I was trying to see the phase transition of magnetization of a transverse Ising model, and I have the following graph. The magnetization changes unusually rapidly under the change of magnetic field and, I don't have this problem using my own library. Since the code I wrote is extremely simple and there is no error message, I wonder do you possibly have encountered the similar issues and have some suggestions on what it happens. Here is the code, and the graph. ----------------------------------------------------------; harray = np.zeros(11); for i in range(11):; harray[i] = 0.0001 * i; ; #print harray; ; marray4 = np.zeros(11). Mx = tensor(sigmaz(),identity(2),identity(2),identity(2))\; + tensor(identity(2),sigmaz(),identity(2),identity(2))\; + tensor(identity(2),identity(2),sigmaz(),identity(2))\; + tensor(identity(2),identity(2),identity(2),sigmaz()). earray4 = np.zeros(11); ; for ii in range(0, 11):; ; H = -(tensor(sigmaz(),sigmaz(),identity(2),identity(2)) \; + tensor(identity(2),sigmaz(),sigmaz(),identity(2)) \; + tensor(identity(2),identity(2),sigmaz(),sigmaz()) \; + tensor(sigmaz(),identity(2),identity(2),sigmaz())) \; - harray[ii]*(tensor(sigmax(),identity(2),identity(2),identity(2))\; + tensor(identity(2),sigmax(),identity(2),identity(2))\; + tensor(identity(2),identity(2),sigmax(),identity(2))\; + tensor(identity(2),identity(2),identity(2),sigmax())); . marray4[ii] = expect(Mx, H.eigenstates()[1][0]); ; plt.plot(harray, marray4, 'o-'); plt.show(). ![screen shot 2018-02-05 at 11 59 45 am](https://user-images.githubusercontent.com/35711575/35817669-17d7afe2-0a6c-11e8-859f-6ae1d686a7fe.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/811
https://github.com/qutip/qutip/issues/811:287,Usability,simpl,simple,287,"I was trying to see the phase transition of magnetization of a transverse Ising model, and I have the following graph. The magnetization changes unusually rapidly under the change of magnetic field and, I don't have this problem using my own library. Since the code I wrote is extremely simple and there is no error message, I wonder do you possibly have encountered the similar issues and have some suggestions on what it happens. Here is the code, and the graph. ----------------------------------------------------------; harray = np.zeros(11); for i in range(11):; harray[i] = 0.0001 * i; ; #print harray; ; marray4 = np.zeros(11). Mx = tensor(sigmaz(),identity(2),identity(2),identity(2))\; + tensor(identity(2),sigmaz(),identity(2),identity(2))\; + tensor(identity(2),identity(2),sigmaz(),identity(2))\; + tensor(identity(2),identity(2),identity(2),sigmaz()). earray4 = np.zeros(11); ; for ii in range(0, 11):; ; H = -(tensor(sigmaz(),sigmaz(),identity(2),identity(2)) \; + tensor(identity(2),sigmaz(),sigmaz(),identity(2)) \; + tensor(identity(2),identity(2),sigmaz(),sigmaz()) \; + tensor(sigmaz(),identity(2),identity(2),sigmaz())) \; - harray[ii]*(tensor(sigmax(),identity(2),identity(2),identity(2))\; + tensor(identity(2),sigmax(),identity(2),identity(2))\; + tensor(identity(2),identity(2),sigmax(),identity(2))\; + tensor(identity(2),identity(2),identity(2),sigmax())); . marray4[ii] = expect(Mx, H.eigenstates()[1][0]); ; plt.plot(harray, marray4, 'o-'); plt.show(). ![screen shot 2018-02-05 at 11 59 45 am](https://user-images.githubusercontent.com/35711575/35817669-17d7afe2-0a6c-11e8-859f-6ae1d686a7fe.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/811
https://github.com/qutip/qutip/pull/812:83,Safety,avoid,avoid,83,rho0 arguments replaced with psi0; references to density matrices removed; Just to avoid any confusion. No functional changes,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/812
https://github.com/qutip/qutip/issues/813:18,Usability,simpl,simple,18,"Hi all,. I have a simple toy model of a 2-dim Hamiltonian. When I use; `mesolve(H, c_states[prepare], t, [Qobj([[0,0],[0,0]])], args={'tau': tau})`; I get the right result - however, if I try; `mesolve(H, c_states[prepare], t, [], args={'tau': tau})` or; `mesolve(H, c_states[prepare], t, c_ops=[], args={'tau': tau})`; the result is most definitely wrong. Any ideas?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/813
https://github.com/qutip/qutip/pull/814:701,Availability,avail,available,701,"The include a new class to represent time dependent Qobj system.; It's take the list of Qobj and coefficient in the format normally accepted by solvers like mesolve and mcsolve and make an object of it.; The td_Qobj is callable and return the Qobj at the desired time, it support math (+,-,*) and unitary transformations: conj, dag, transpose.; The object has a cython compiled version with cython call to spmv and expect in order to be efficient in solvers.; I made it as a tool used by solver (stochatic/mcsolve), therefore may lack some features for users. Also the naming of some methods only make sense in a solver (rhs).; Lastly, this branch include it's own cubic spline code since the version available when I started working on it only accepted uniformly sampled data. This part may have become redundant. This branch only contain the new object, not the solvers using it.; This pull request replace half the ""cythonizing mcsolve"" pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/814
https://github.com/qutip/qutip/pull/814:804,Availability,redundant,redundant,804,"The include a new class to represent time dependent Qobj system.; It's take the list of Qobj and coefficient in the format normally accepted by solvers like mesolve and mcsolve and make an object of it.; The td_Qobj is callable and return the Qobj at the desired time, it support math (+,-,*) and unitary transformations: conj, dag, transpose.; The object has a cython compiled version with cython call to spmv and expect in order to be efficient in solvers.; I made it as a tool used by solver (stochatic/mcsolve), therefore may lack some features for users. Also the naming of some methods only make sense in a solver (rhs).; Lastly, this branch include it's own cubic spline code since the version available when I started working on it only accepted uniformly sampled data. This part may have become redundant. This branch only contain the new object, not the solvers using it.; This pull request replace half the ""cythonizing mcsolve"" pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/814
https://github.com/qutip/qutip/pull/814:437,Energy Efficiency,efficient,efficient,437,"The include a new class to represent time dependent Qobj system.; It's take the list of Qobj and coefficient in the format normally accepted by solvers like mesolve and mcsolve and make an object of it.; The td_Qobj is callable and return the Qobj at the desired time, it support math (+,-,*) and unitary transformations: conj, dag, transpose.; The object has a cython compiled version with cython call to spmv and expect in order to be efficient in solvers.; I made it as a tool used by solver (stochatic/mcsolve), therefore may lack some features for users. Also the naming of some methods only make sense in a solver (rhs).; Lastly, this branch include it's own cubic spline code since the version available when I started working on it only accepted uniformly sampled data. This part may have become redundant. This branch only contain the new object, not the solvers using it.; This pull request replace half the ""cythonizing mcsolve"" pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/814
https://github.com/qutip/qutip/pull/814:42,Integrability,depend,dependent,42,"The include a new class to represent time dependent Qobj system.; It's take the list of Qobj and coefficient in the format normally accepted by solvers like mesolve and mcsolve and make an object of it.; The td_Qobj is callable and return the Qobj at the desired time, it support math (+,-,*) and unitary transformations: conj, dag, transpose.; The object has a cython compiled version with cython call to spmv and expect in order to be efficient in solvers.; I made it as a tool used by solver (stochatic/mcsolve), therefore may lack some features for users. Also the naming of some methods only make sense in a solver (rhs).; Lastly, this branch include it's own cubic spline code since the version available when I started working on it only accepted uniformly sampled data. This part may have become redundant. This branch only contain the new object, not the solvers using it.; This pull request replace half the ""cythonizing mcsolve"" pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/814
https://github.com/qutip/qutip/pull/814:804,Safety,redund,redundant,804,"The include a new class to represent time dependent Qobj system.; It's take the list of Qobj and coefficient in the format normally accepted by solvers like mesolve and mcsolve and make an object of it.; The td_Qobj is callable and return the Qobj at the desired time, it support math (+,-,*) and unitary transformations: conj, dag, transpose.; The object has a cython compiled version with cython call to spmv and expect in order to be efficient in solvers.; I made it as a tool used by solver (stochatic/mcsolve), therefore may lack some features for users. Also the naming of some methods only make sense in a solver (rhs).; Lastly, this branch include it's own cubic spline code since the version available when I started working on it only accepted uniformly sampled data. This part may have become redundant. This branch only contain the new object, not the solvers using it.; This pull request replace half the ""cythonizing mcsolve"" pull request.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/814
https://github.com/qutip/qutip/pull/815:130,Availability,avail,available,130,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/815:84,Integrability,depend,dependent,84,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/815:326,Integrability,depend,dependent,326,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/815:722,Integrability,depend,dependent,722,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/815:1047,Security,access,access,1047,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/815:1240,Testability,test,tested,1240,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/815:1254,Testability,test,tests,1254,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/815:279,Usability,usab,usable,279,"The stochastic solver have been redone.; smesolve and ssesovle can be used for time dependent systems (H, c_ops and sc_ops).; The available solvers are : 'euler-maruyama', 'pc-euler, 'milstein', 'platen', 'milstein-imp', 'taylor15', 'taylor15-imp', 'explicit15'. All solvers are usable by both ssesolve and smesolve, for time-dependent cases and for both heterodyne and homodyne methods. There is no restriction on the number of sc_ops. The solvers are in cython, making them 2~3 time faster than the previous version, with the exception of the implicit solvers, where the timing is about the same. The photocurrent method as been moved to it's own functions: photocurrentmesolve and photocurrentsesolve. It can take time-dependent Hamiltonian. The stochastic (piecewse deterministic process) PDP solvers (ssepdpsolve and smepdpsolve) are untouched. The previous version of smesolve/ssesolve allowed the user to determine it's own d1 and d2 function. This capacity have been moved to the function general_stochastic. However the function only has access to some solver: 'euler-maruyama', 'platen', 'explicit15'. . I created a function which list the solvers with the references: stochastic_solver_info(). The convergence of the solvers was tested with a tests similar to https://github.com/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/815
https://github.com/qutip/qutip/pull/816:141,Integrability,depend,dependent,141,"This contain a new solver for mcsolve, dopri5 which don't go through scipy and is faster for small system, and replace the treatment of time dependent cases with the use of td_Qobj. Replace the ""cythonizing mcsolve"" pull request: The new pull request split the td_qobj part and mcsolve part so that the pull request for stochastic stays independent from this one (both use td_Qobj).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/816
https://github.com/qutip/qutip/pull/817:176,Safety,risk,risk,176,add isunitary attribute for checking if qobj is a unitary operator:; unitary checking func and property funcs added; initialisation of isunitary; clear flag on operations that risk unitarity; qobj unitarity testing added; preset isunitary for qeye,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/817
https://github.com/qutip/qutip/pull/817:207,Testability,test,testing,207,add isunitary attribute for checking if qobj is a unitary operator:; unitary checking func and property funcs added; initialisation of isunitary; clear flag on operations that risk unitarity; qobj unitarity testing added; preset isunitary for qeye,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/817
https://github.com/qutip/qutip/pull/817:146,Usability,clear,clear,146,add isunitary attribute for checking if qobj is a unitary operator:; unitary checking func and property funcs added; initialisation of isunitary; clear flag on operations that risk unitarity; qobj unitarity testing added; preset isunitary for qeye,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/817
https://github.com/qutip/qutip/issues/820:142,Availability,error,error,142,"enr_fock is incompatible with enr_destroy. Minimal code:; ```; x = enr_destroy([3,3],2); y = enr_fock([3,3],2,[1,1]); x[0]*y; ```; returns an error. I believe the problem is that the problem is that y has dim = [[3, 3], 1] instead of dim = [[3, 3], [1,1]].",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/820
https://github.com/qutip/qutip/pull/821:17,Energy Efficiency,power,power,17,"Finding the full power spectrum given a time-dependent Hamiltonian usually requires a 2-sided power spectrum. For convenience, it would be useful to be able to access this data in a properly ordered array. Additionally, the majority of literature regarding cavity optomechanics uses a positive e^(i w t) Fourier convention. Passing a simple boolean parameter to this function would allow for the use of scipy's ifft function, scaled by the number of elements.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/821
https://github.com/qutip/qutip/pull/821:94,Energy Efficiency,power,power,94,"Finding the full power spectrum given a time-dependent Hamiltonian usually requires a 2-sided power spectrum. For convenience, it would be useful to be able to access this data in a properly ordered array. Additionally, the majority of literature regarding cavity optomechanics uses a positive e^(i w t) Fourier convention. Passing a simple boolean parameter to this function would allow for the use of scipy's ifft function, scaled by the number of elements.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/821
https://github.com/qutip/qutip/pull/821:45,Integrability,depend,dependent,45,"Finding the full power spectrum given a time-dependent Hamiltonian usually requires a 2-sided power spectrum. For convenience, it would be useful to be able to access this data in a properly ordered array. Additionally, the majority of literature regarding cavity optomechanics uses a positive e^(i w t) Fourier convention. Passing a simple boolean parameter to this function would allow for the use of scipy's ifft function, scaled by the number of elements.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/821
https://github.com/qutip/qutip/pull/821:160,Security,access,access,160,"Finding the full power spectrum given a time-dependent Hamiltonian usually requires a 2-sided power spectrum. For convenience, it would be useful to be able to access this data in a properly ordered array. Additionally, the majority of literature regarding cavity optomechanics uses a positive e^(i w t) Fourier convention. Passing a simple boolean parameter to this function would allow for the use of scipy's ifft function, scaled by the number of elements.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/821
https://github.com/qutip/qutip/pull/821:334,Usability,simpl,simple,334,"Finding the full power spectrum given a time-dependent Hamiltonian usually requires a 2-sided power spectrum. For convenience, it would be useful to be able to access this data in a properly ordered array. Additionally, the majority of literature regarding cavity optomechanics uses a positive e^(i w t) Fourier convention. Passing a simple boolean parameter to this function would allow for the use of scipy's ifft function, scaled by the number of elements.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/821
https://github.com/qutip/qutip/issues/822:160,Availability,error,error,160,"Hi QuTip team,. when I run multiple `mesolve` calculations in parallel using. `enumerate(pool.imap(parallel_calculation, taus))`. I sometimes get the following error. ` ZVODE-- At current T (=R1), MXSTEP (=I1) steps; taken on this call before reaching TOUT; In above message, I1 = 1000; In above message, R1 = 0.9633584757678D+00; D:\...\Anaconda3\lib\site-packages\scipy\integrate\_ode.py:869: UserWarning: zvode: Excess work done on this call. (Perhaps wrong MF.); 'Unexpected istate=%s' % istate))`. Interestingly this only happens sometimes and as far as I can tell not in the single-threaded case...; Any ideas? Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/822
https://github.com/qutip/qutip/issues/822:372,Deployability,integrat,integrate,372,"Hi QuTip team,. when I run multiple `mesolve` calculations in parallel using. `enumerate(pool.imap(parallel_calculation, taus))`. I sometimes get the following error. ` ZVODE-- At current T (=R1), MXSTEP (=I1) steps; taken on this call before reaching TOUT; In above message, I1 = 1000; In above message, R1 = 0.9633584757678D+00; D:\...\Anaconda3\lib\site-packages\scipy\integrate\_ode.py:869: UserWarning: zvode: Excess work done on this call. (Perhaps wrong MF.); 'Unexpected istate=%s' % istate))`. Interestingly this only happens sometimes and as far as I can tell not in the single-threaded case...; Any ideas? Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/822
https://github.com/qutip/qutip/issues/822:267,Integrability,message,message,267,"Hi QuTip team,. when I run multiple `mesolve` calculations in parallel using. `enumerate(pool.imap(parallel_calculation, taus))`. I sometimes get the following error. ` ZVODE-- At current T (=R1), MXSTEP (=I1) steps; taken on this call before reaching TOUT; In above message, I1 = 1000; In above message, R1 = 0.9633584757678D+00; D:\...\Anaconda3\lib\site-packages\scipy\integrate\_ode.py:869: UserWarning: zvode: Excess work done on this call. (Perhaps wrong MF.); 'Unexpected istate=%s' % istate))`. Interestingly this only happens sometimes and as far as I can tell not in the single-threaded case...; Any ideas? Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/822
https://github.com/qutip/qutip/issues/822:296,Integrability,message,message,296,"Hi QuTip team,. when I run multiple `mesolve` calculations in parallel using. `enumerate(pool.imap(parallel_calculation, taus))`. I sometimes get the following error. ` ZVODE-- At current T (=R1), MXSTEP (=I1) steps; taken on this call before reaching TOUT; In above message, I1 = 1000; In above message, R1 = 0.9633584757678D+00; D:\...\Anaconda3\lib\site-packages\scipy\integrate\_ode.py:869: UserWarning: zvode: Excess work done on this call. (Perhaps wrong MF.); 'Unexpected istate=%s' % istate))`. Interestingly this only happens sometimes and as far as I can tell not in the single-threaded case...; Any ideas? Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/822
https://github.com/qutip/qutip/issues/822:372,Integrability,integrat,integrate,372,"Hi QuTip team,. when I run multiple `mesolve` calculations in parallel using. `enumerate(pool.imap(parallel_calculation, taus))`. I sometimes get the following error. ` ZVODE-- At current T (=R1), MXSTEP (=I1) steps; taken on this call before reaching TOUT; In above message, I1 = 1000; In above message, R1 = 0.9633584757678D+00; D:\...\Anaconda3\lib\site-packages\scipy\integrate\_ode.py:869: UserWarning: zvode: Excess work done on this call. (Perhaps wrong MF.); 'Unexpected istate=%s' % istate))`. Interestingly this only happens sometimes and as far as I can tell not in the single-threaded case...; Any ideas? Thanks",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/822
https://github.com/qutip/qutip/issues/823:180,Availability,error,errors,180,"I'm woundering what is the reason for doing this partial trace; https://github.com/qutip/qutip/blob/0b068fc4876727303644c42c181af82e1f089700/qutip/qobj.py#L490; becauseit leads to errors doing:; ```; O=tensor(sigmax(), qeye(1)); Psi = tensor(basis(2,0),basis(1,0)); O*O*Psi; ```. would it be possible to implement an Option in settings to dissable this behavior? I would be willing to provide a PR.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/823
https://github.com/qutip/qutip/issues/824:39,Integrability,depend,dependence,39,"Looks like sesolve with list func time-dependence and rhs_with_state option will fail.; `psi_list_td` and `psi_list_td_with_state` are exactly the same. However, looking at def of `constant_func`, in the latter, `H_td`, should take a third parameter, assumedly `psi`. Maybe no-one ever tried this. Found this by accident when doing something else. Just raised here as a reminder to investigate more some other time. Probably an easy fix.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/824
https://github.com/qutip/qutip/issues/826:38,Deployability,install,installed,38,"I am using Anaconda on windows 10 and installed qutip from conda-forge package, I don't have VS-15 on my system, Is it possible that that I could run qutip with VS-15 runtime liberaries instead of complete installation of visual studio. If it is possible please guide me.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/826
https://github.com/qutip/qutip/issues/826:206,Deployability,install,installation,206,"I am using Anaconda on windows 10 and installed qutip from conda-forge package, I don't have VS-15 on my system, Is it possible that that I could run qutip with VS-15 runtime liberaries instead of complete installation of visual studio. If it is possible please guide me.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/826
https://github.com/qutip/qutip/issues/826:262,Usability,guid,guide,262,"I am using Anaconda on windows 10 and installed qutip from conda-forge package, I don't have VS-15 on my system, Is it possible that that I could run qutip with VS-15 runtime liberaries instead of complete installation of visual studio. If it is possible please guide me.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/826
https://github.com/qutip/qutip/issues/828:1303,Integrability,wrap,wraparound,1303,"I'm hitting the limit of ints in python, which causes troubles with large ket vectors. . Minimal example (I can go up to size 16 before it crashes):; ```; ket = tensor([basis(2,0) for i in range(0,20)]); ket.ptrace(1); ```; Returns:; ```; OverflowError Traceback (most recent call last); <ipython-input-22-8485eed3b16f> in <module>(); 1 ket = tensor([basis(2,0) for i in range(0,20)]); ----> 2 ket.ptrace(1). /usr/lib/python2.7/site-packages/qutip-4.3.0.dev0+0b068fc4-py2.7-linux-x86_64.egg/qutip/qobj.pyc in ptrace(self, sel); 1282 """"""; 1283 q = Qobj(); -> 1284 q.data, q.dims, _ = _ptrace(self, sel); 1285 return q.tidyup() if settings.auto_tidyup else q; 1286 . /usr/lib/python2.7/site-packages/qutip-4.3.0.dev0+0b068fc4-py2.7-linux-x86_64.egg/qutip/cy/ptrace.pyx in qutip.cy.ptrace._ptrace(); 89 perm = fast_csr_matrix((data,ind,ptr),shape=(M * M, N * N)); 90 # No need to sort here, will be sorted in reshape; ---> 91 rhdata = zcsr_mult(perm, zcsr_reshape(rho.data, np.prod(rho.shape), 1), sorted=0); 92 rho1_data = zcsr_reshape(rhdata, M, M); 93 dims_kept0 = np.asarray(rho.dims[0], dtype=np.int32).take(sel). /usr/lib/python2.7/site-packages/qutip-4.3.0.dev0+0b068fc4-py2.7-linux-x86_64.egg/qutip/cy/spconvert.pyx in qutip.cy.spconvert.zcsr_reshape(); 187 @cython.boundscheck(False); 188 @cython.wraparound(False); --> 189 def zcsr_reshape(object A not None, int new_rows, int new_cols):; 190 """"""; 191 Reshapes a complex CSR matrix. OverflowError: value too large to convert to int. ```. Similar code works fine in MS LiQui|> using the same workstation so my hardware should be able to support this state size. What is the current ket size limit that is officially supported in qutip? 16?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/828
https://github.com/qutip/qutip/issues/831:78,Integrability,depend,depending,78,"I noticed that the action of a superoperator could be extremely slow in QuTiP depending on how it is called. This came up when I was writing some code which loops over repeatedly and calculates `spre(Q)*vec`. I understand that this is probably a subtle point which the user might overlook but using `np.dot(spre(Q).full(), rho)` take ns while the more readable `spre(Q)*vec` takes us. In most cases, we get away with this since we always pack the elements in `spre` into a sparse Liouvillian and invoke `cy_ode_rhs` but if there was some way to modify the `.__mul__` method of superoperators to use `np.dot`, it might be helpful to get up to 1000x speed improvement. This comes of use when the RHS is calculated on the fly by the action of these superoperators (eg., the Heom method). The comparisons are below. I pre-compute all the *operators* and *vectors* before running `%timeit` and these are the timing for the matrix-vector multiplication only. @nwlambert @ajgpitch Should we do something about this or mention it somewhere if it is important?. ```; np.dot(spre(Q).full(), vec); 789 ns ± 6.68 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each). spre(Q).data * vec; 5.66 µs ± 57.8 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each). spre(Q)*vec; 7.35 µs ± 213 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each). spre(Q)*operator_to_vector(rho); 62.5 µs ± 1.73 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each); ```. The code to reproduce this:; ```; from qutip.superoperator import spre, spost, operator_to_vector; from qutip import sigmax, basis; import numpy as np; from numpy.testing import assert_array_equal. Q = sigmax(); rho = basis(2,0)*basis(2,0).dag() \; + 0.25*basis(2,1)*basis(2,1).dag() \; - 0.1*basis(2,0)*basis(2,1).dag() . spreQ = spre(Q). numpy_vec = np.array(rho.data.todense().ravel(""F""), dtype=np.complex); vec = numpy_vec.T; qutip_vec = operator_to_vector(rho). spreQ_full = spreQ.full(); spreQ_data = spreQ.data. print(""np.dot(spre(Q).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/831
https://github.com/qutip/qutip/issues/831:1623,Testability,test,testing,1623,"at this is probably a subtle point which the user might overlook but using `np.dot(spre(Q).full(), rho)` take ns while the more readable `spre(Q)*vec` takes us. In most cases, we get away with this since we always pack the elements in `spre` into a sparse Liouvillian and invoke `cy_ode_rhs` but if there was some way to modify the `.__mul__` method of superoperators to use `np.dot`, it might be helpful to get up to 1000x speed improvement. This comes of use when the RHS is calculated on the fly by the action of these superoperators (eg., the Heom method). The comparisons are below. I pre-compute all the *operators* and *vectors* before running `%timeit` and these are the timing for the matrix-vector multiplication only. @nwlambert @ajgpitch Should we do something about this or mention it somewhere if it is important?. ```; np.dot(spre(Q).full(), vec); 789 ns ± 6.68 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each). spre(Q).data * vec; 5.66 µs ± 57.8 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each). spre(Q)*vec; 7.35 µs ± 213 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each). spre(Q)*operator_to_vector(rho); 62.5 µs ± 1.73 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each); ```. The code to reproduce this:; ```; from qutip.superoperator import spre, spost, operator_to_vector; from qutip import sigmax, basis; import numpy as np; from numpy.testing import assert_array_equal. Q = sigmax(); rho = basis(2,0)*basis(2,0).dag() \; + 0.25*basis(2,1)*basis(2,1).dag() \; - 0.1*basis(2,0)*basis(2,1).dag() . spreQ = spre(Q). numpy_vec = np.array(rho.data.todense().ravel(""F""), dtype=np.complex); vec = numpy_vec.T; qutip_vec = operator_to_vector(rho). spreQ_full = spreQ.full(); spreQ_data = spreQ.data. print(""np.dot(spre(Q).full(), vec)""); %timeit(np.dot(spreQ_full, vec)). print(""\nspre(Q).data * vec""); %timeit(spreQ_data*vec). print(""\nspre(Q)*vec""); %timeit(spreQ*vec). print(""\nspre(Q)*operator_to_vector(rho)""); %timeit(spreQ*qutip_vec); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/831
https://github.com/qutip/qutip/pull/832:125,Testability,test,tests,125,"Can now give unitary operator as initial `psi0` in sesolve. This way we solve the Schrodinger operator equation.; Also added tests for all the sesolve methods. Kind of a bit of waste of time, as `propagator` does almost exactly the same thing. However, I think it does add a bit of completeness. The tests at least should be valuable",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/832
https://github.com/qutip/qutip/pull/832:300,Testability,test,tests,300,"Can now give unitary operator as initial `psi0` in sesolve. This way we solve the Schrodinger operator equation.; Also added tests for all the sesolve methods. Kind of a bit of waste of time, as `propagator` does almost exactly the same thing. However, I think it does add a bit of completeness. The tests at least should be valuable",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/832
https://github.com/qutip/qutip/issues/836:127,Availability,down,downloads,127,"When I follow the example to generate animation for bloch sphere plotting, i.e., page 120-122 from [this doc](http://qutip.org/downloads/4.2.0/QuTiP_4.2.pdf), I faced ; `'Axes3D' object is not iterable`; problem, which happens for the `save` function. > .../matplotlib/animation.py in save(self, filename, writer, fps, dpi, codec, bitrate, extra_args, metadata, extra_anim, savefig_kwargs); 1192 for anim in all_anim:; 1193 # Clear the initial frame; -> 1194 anim._init_draw(); 1195 for data in zip(*[a.new_saved_frame_seq() for a in all_anim]):; 1196 for anim, d in zip(all_anim, data):. > .../matplotlib/animation.py in _init_draw(self); 1755 raise RuntimeError('The init_func must return a '; 1756 'sequence of Artist objects.'); -> 1757 for a in self._drawn_artists:; 1758 a.set_animated(self._blit); 1759 self._save_seq = []. >TypeError: 'Axes3D' object is not iterable. My environment:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.14.1; Scipy Version: 1.0.0; Cython Version: 0.27.3; Matplotlib Version: 2.2.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/836
https://github.com/qutip/qutip/issues/836:1222,Deployability,Install,Installed,1222,"When I follow the example to generate animation for bloch sphere plotting, i.e., page 120-122 from [this doc](http://qutip.org/downloads/4.2.0/QuTiP_4.2.pdf), I faced ; `'Axes3D' object is not iterable`; problem, which happens for the `save` function. > .../matplotlib/animation.py in save(self, filename, writer, fps, dpi, codec, bitrate, extra_args, metadata, extra_anim, savefig_kwargs); 1192 for anim in all_anim:; 1193 # Clear the initial frame; -> 1194 anim._init_draw(); 1195 for data in zip(*[a.new_saved_frame_seq() for a in all_anim]):; 1196 for anim, d in zip(all_anim, data):. > .../matplotlib/animation.py in _init_draw(self); 1755 raise RuntimeError('The init_func must return a '; 1756 'sequence of Artist objects.'); -> 1757 for a in self._drawn_artists:; 1758 a.set_animated(self._blit); 1759 self._save_seq = []. >TypeError: 'Axes3D' object is not iterable. My environment:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.14.1; Scipy Version: 1.0.0; Cython Version: 0.27.3; Matplotlib Version: 2.2.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/836
https://github.com/qutip/qutip/issues/836:426,Usability,Clear,Clear,426,"When I follow the example to generate animation for bloch sphere plotting, i.e., page 120-122 from [this doc](http://qutip.org/downloads/4.2.0/QuTiP_4.2.pdf), I faced ; `'Axes3D' object is not iterable`; problem, which happens for the `save` function. > .../matplotlib/animation.py in save(self, filename, writer, fps, dpi, codec, bitrate, extra_args, metadata, extra_anim, savefig_kwargs); 1192 for anim in all_anim:; 1193 # Clear the initial frame; -> 1194 anim._init_draw(); 1195 for data in zip(*[a.new_saved_frame_seq() for a in all_anim]):; 1196 for anim, d in zip(all_anim, data):. > .../matplotlib/animation.py in _init_draw(self); 1755 raise RuntimeError('The init_func must return a '; 1756 'sequence of Artist objects.'); -> 1757 for a in self._drawn_artists:; 1758 a.set_animated(self._blit); 1759 self._save_seq = []. >TypeError: 'Axes3D' object is not iterable. My environment:. QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.14.1; Scipy Version: 1.0.0; Cython Version: 0.27.3; Matplotlib Version: 2.2.0; Python Version: 3.5.2; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/836
https://github.com/qutip/qutip/issues/839:73,Availability,error,error,73,"Hello everyone, I tried to install qutip via pip on windows 10. I got an error stating that building the wheel failed because I didn't have Virtual Studio. I don't want to install that, so I just downloaded the wheel from this site: https://www.lfd.uci.edu/~gohlke/pythonlibs/#qutip; It installed fine, I thought. If I start a python interpreter in the command line, I can import qutip, and its functions work fine as far as I can tell. Now the problem: when I try to run a .py script, I get the error `AttributeError: module 'qutip' has no attribute 'states'`. So for some reason, python can't always locate the package correctly. Other packages work fine though. Does anyone know how to solve this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/839
https://github.com/qutip/qutip/issues/839:196,Availability,down,downloaded,196,"Hello everyone, I tried to install qutip via pip on windows 10. I got an error stating that building the wheel failed because I didn't have Virtual Studio. I don't want to install that, so I just downloaded the wheel from this site: https://www.lfd.uci.edu/~gohlke/pythonlibs/#qutip; It installed fine, I thought. If I start a python interpreter in the command line, I can import qutip, and its functions work fine as far as I can tell. Now the problem: when I try to run a .py script, I get the error `AttributeError: module 'qutip' has no attribute 'states'`. So for some reason, python can't always locate the package correctly. Other packages work fine though. Does anyone know how to solve this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/839
https://github.com/qutip/qutip/issues/839:496,Availability,error,error,496,"Hello everyone, I tried to install qutip via pip on windows 10. I got an error stating that building the wheel failed because I didn't have Virtual Studio. I don't want to install that, so I just downloaded the wheel from this site: https://www.lfd.uci.edu/~gohlke/pythonlibs/#qutip; It installed fine, I thought. If I start a python interpreter in the command line, I can import qutip, and its functions work fine as far as I can tell. Now the problem: when I try to run a .py script, I get the error `AttributeError: module 'qutip' has no attribute 'states'`. So for some reason, python can't always locate the package correctly. Other packages work fine though. Does anyone know how to solve this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/839
https://github.com/qutip/qutip/issues/839:27,Deployability,install,install,27,"Hello everyone, I tried to install qutip via pip on windows 10. I got an error stating that building the wheel failed because I didn't have Virtual Studio. I don't want to install that, so I just downloaded the wheel from this site: https://www.lfd.uci.edu/~gohlke/pythonlibs/#qutip; It installed fine, I thought. If I start a python interpreter in the command line, I can import qutip, and its functions work fine as far as I can tell. Now the problem: when I try to run a .py script, I get the error `AttributeError: module 'qutip' has no attribute 'states'`. So for some reason, python can't always locate the package correctly. Other packages work fine though. Does anyone know how to solve this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/839
https://github.com/qutip/qutip/issues/839:172,Deployability,install,install,172,"Hello everyone, I tried to install qutip via pip on windows 10. I got an error stating that building the wheel failed because I didn't have Virtual Studio. I don't want to install that, so I just downloaded the wheel from this site: https://www.lfd.uci.edu/~gohlke/pythonlibs/#qutip; It installed fine, I thought. If I start a python interpreter in the command line, I can import qutip, and its functions work fine as far as I can tell. Now the problem: when I try to run a .py script, I get the error `AttributeError: module 'qutip' has no attribute 'states'`. So for some reason, python can't always locate the package correctly. Other packages work fine though. Does anyone know how to solve this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/839
https://github.com/qutip/qutip/issues/839:287,Deployability,install,installed,287,"Hello everyone, I tried to install qutip via pip on windows 10. I got an error stating that building the wheel failed because I didn't have Virtual Studio. I don't want to install that, so I just downloaded the wheel from this site: https://www.lfd.uci.edu/~gohlke/pythonlibs/#qutip; It installed fine, I thought. If I start a python interpreter in the command line, I can import qutip, and its functions work fine as far as I can tell. Now the problem: when I try to run a .py script, I get the error `AttributeError: module 'qutip' has no attribute 'states'`. So for some reason, python can't always locate the package correctly. Other packages work fine though. Does anyone know how to solve this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/839
https://github.com/qutip/qutip/issues/840:77,Performance,optimiz,optimization,77,"which module we need to modify to get array of fidelities at the end of each optimization loop, I want to modify code to get fidelity vs. iterations plot.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/840
https://github.com/qutip/qutip/issues/841:174,Availability,error,error,174,"There seems to be a bug when trying to solve the Schrödinger equation with the sesolve and essolve functions using an initial state vector. The following code reproduces the error:; ```python; ### import dependencies; %matplotlib inline; from qutip import *; import numpy as np; import matplotlib.pyplot as plt. ### define spin operators at each site ; N = 3 # Number of spins; def sz(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmaz()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sp(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmap()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sm(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmam()] + [qeye(2) for j in range(i+1,N)]; return tensor(l). ### Hamiltonian with on-site field and XX-type coupling between spins 0&1 and spins 0&2; delta = 1; V1 = 0.1; V2 = 0.1 ; H0 = -0.5*delta*(sz(0) + sz(1) + sz(2)) + V1*(sp(0)*sm(1) + sm(0)*sp(1)) + V2*(sp(0)*sm(2) + sm(0)*sp(2)) . ### no collapse operaters; e_op is total magnetization in z-direction ; c_ops = []; e_ops = [sz(0)+sz(1)+sz(2)]. ### initial state: each spin polarized in x-y-plane; psi0 = tensor([(basis(2,0) + (1j)**i *basis(2,1)).unit() for i in range(0,N)]); rho0 = psi0*psi0.dag(). ### compute time evolution with different solvers; t_list = np.linspace(0, 50, 500); output0 = mesolve(H0, rho0, t_list, c_ops, e_ops); output1 = essolve(H0, rho0, t_list, c_ops, e_ops); output2 = sesolve(H0, psi0, t_list, e_ops). ### plot result; plt.plot(t_list, output0.expect[0], label='mesolve'); plt.plot(t_list, output1.expect[0], label='essolve'); plt.plot(t_list, output2.expect[0], label='sesolve'); plt.legend(). ### time evolution with essolve, use state vector --> Exception raised; output3 = essolve(H0, psi0, t_list, c_ops, e_ops); plt.plot(t_list, output0.expect[0], label='essolve, state vector'); plt.legend(); ```; The Hamiltonian commutes with the operator for which the expectation value is computed as is easily checked. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/841
https://github.com/qutip/qutip/issues/841:2124,Availability,error,error,2124,"([(basis(2,0) + (1j)**i *basis(2,1)).unit() for i in range(0,N)]); rho0 = psi0*psi0.dag(). ### compute time evolution with different solvers; t_list = np.linspace(0, 50, 500); output0 = mesolve(H0, rho0, t_list, c_ops, e_ops); output1 = essolve(H0, rho0, t_list, c_ops, e_ops); output2 = sesolve(H0, psi0, t_list, e_ops). ### plot result; plt.plot(t_list, output0.expect[0], label='mesolve'); plt.plot(t_list, output1.expect[0], label='essolve'); plt.plot(t_list, output2.expect[0], label='sesolve'); plt.legend(). ### time evolution with essolve, use state vector --> Exception raised; output3 = essolve(H0, psi0, t_list, c_ops, e_ops); plt.plot(t_list, output0.expect[0], label='essolve, state vector'); plt.legend(); ```; The Hamiltonian commutes with the operator for which the expectation value is computed as is easily checked. Therefore the expectation value should be time-independent. Using sesolve one obtains a wrong result. There seems to be an error when using state vectors instead of density matrices, as is seen by using the mesolve function instead. . I was not able to pinpoint the error in the code, but I checked the result with essolve and using an initial state vector. This raises an exception: ; > Exception: Operator and state do not have same tensor structure: [2, 2, 2] and [2]. essolve works as intended by using a density matrix instead, which should again indicate that there is some bug when using state vectors. Note however that the essolve bug might not be directly related to the sesolve bug, since essolve seems to work correctly when using a different initial state:; `psi0 = tensor([(basis(2,0) + 0.5*(-1j)**i *basis(2,1)).unit() for i in range(0,N)])`. I am using the newest versions of the necessary libraries: . > QuTiP Version: 4.2.0; > Numpy Version: 1.11.3; > Scipy Version: 1.0.0; > Cython Version: 0.27.3; > Matplotlib Version: 2.0.2; > Python Version: 3.6.4; > Number of CPUs: 4; > BLAS Info: OPENBLAS; > OPENMP Installed: False; > INTEL MKL Ext: False; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/841
https://github.com/qutip/qutip/issues/841:2267,Availability,error,error,2267,",1)).unit() for i in range(0,N)]); rho0 = psi0*psi0.dag(). ### compute time evolution with different solvers; t_list = np.linspace(0, 50, 500); output0 = mesolve(H0, rho0, t_list, c_ops, e_ops); output1 = essolve(H0, rho0, t_list, c_ops, e_ops); output2 = sesolve(H0, psi0, t_list, e_ops). ### plot result; plt.plot(t_list, output0.expect[0], label='mesolve'); plt.plot(t_list, output1.expect[0], label='essolve'); plt.plot(t_list, output2.expect[0], label='sesolve'); plt.legend(). ### time evolution with essolve, use state vector --> Exception raised; output3 = essolve(H0, psi0, t_list, c_ops, e_ops); plt.plot(t_list, output0.expect[0], label='essolve, state vector'); plt.legend(); ```; The Hamiltonian commutes with the operator for which the expectation value is computed as is easily checked. Therefore the expectation value should be time-independent. Using sesolve one obtains a wrong result. There seems to be an error when using state vectors instead of density matrices, as is seen by using the mesolve function instead. . I was not able to pinpoint the error in the code, but I checked the result with essolve and using an initial state vector. This raises an exception: ; > Exception: Operator and state do not have same tensor structure: [2, 2, 2] and [2]. essolve works as intended by using a density matrix instead, which should again indicate that there is some bug when using state vectors. Note however that the essolve bug might not be directly related to the sesolve bug, since essolve seems to work correctly when using a different initial state:; `psi0 = tensor([(basis(2,0) + 0.5*(-1j)**i *basis(2,1)).unit() for i in range(0,N)])`. I am using the newest versions of the necessary libraries: . > QuTiP Version: 4.2.0; > Numpy Version: 1.11.3; > Scipy Version: 1.0.0; > Cython Version: 0.27.3; > Matplotlib Version: 2.0.2; > Python Version: 3.6.4; > Number of CPUs: 4; > BLAS Info: OPENBLAS; > OPENMP Installed: False; > INTEL MKL Ext: False; > Platform Info: Linux (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/841
https://github.com/qutip/qutip/issues/841:3126,Deployability,Install,Installed,3126,",1)).unit() for i in range(0,N)]); rho0 = psi0*psi0.dag(). ### compute time evolution with different solvers; t_list = np.linspace(0, 50, 500); output0 = mesolve(H0, rho0, t_list, c_ops, e_ops); output1 = essolve(H0, rho0, t_list, c_ops, e_ops); output2 = sesolve(H0, psi0, t_list, e_ops). ### plot result; plt.plot(t_list, output0.expect[0], label='mesolve'); plt.plot(t_list, output1.expect[0], label='essolve'); plt.plot(t_list, output2.expect[0], label='sesolve'); plt.legend(). ### time evolution with essolve, use state vector --> Exception raised; output3 = essolve(H0, psi0, t_list, c_ops, e_ops); plt.plot(t_list, output0.expect[0], label='essolve, state vector'); plt.legend(); ```; The Hamiltonian commutes with the operator for which the expectation value is computed as is easily checked. Therefore the expectation value should be time-independent. Using sesolve one obtains a wrong result. There seems to be an error when using state vectors instead of density matrices, as is seen by using the mesolve function instead. . I was not able to pinpoint the error in the code, but I checked the result with essolve and using an initial state vector. This raises an exception: ; > Exception: Operator and state do not have same tensor structure: [2, 2, 2] and [2]. essolve works as intended by using a density matrix instead, which should again indicate that there is some bug when using state vectors. Note however that the essolve bug might not be directly related to the sesolve bug, since essolve seems to work correctly when using a different initial state:; `psi0 = tensor([(basis(2,0) + 0.5*(-1j)**i *basis(2,1)).unit() for i in range(0,N)])`. I am using the newest versions of the necessary libraries: . > QuTiP Version: 4.2.0; > Numpy Version: 1.11.3; > Scipy Version: 1.0.0; > Cython Version: 0.27.3; > Matplotlib Version: 2.0.2; > Python Version: 3.6.4; > Number of CPUs: 4; > BLAS Info: OPENBLAS; > OPENMP Installed: False; > INTEL MKL Ext: False; > Platform Info: Linux (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/841
https://github.com/qutip/qutip/issues/841:204,Integrability,depend,dependencies,204,"There seems to be a bug when trying to solve the Schrödinger equation with the sesolve and essolve functions using an initial state vector. The following code reproduces the error:; ```python; ### import dependencies; %matplotlib inline; from qutip import *; import numpy as np; import matplotlib.pyplot as plt. ### define spin operators at each site ; N = 3 # Number of spins; def sz(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmaz()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sp(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmap()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sm(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmam()] + [qeye(2) for j in range(i+1,N)]; return tensor(l). ### Hamiltonian with on-site field and XX-type coupling between spins 0&1 and spins 0&2; delta = 1; V1 = 0.1; V2 = 0.1 ; H0 = -0.5*delta*(sz(0) + sz(1) + sz(2)) + V1*(sp(0)*sm(1) + sm(0)*sp(1)) + V2*(sp(0)*sm(2) + sm(0)*sp(2)) . ### no collapse operaters; e_op is total magnetization in z-direction ; c_ops = []; e_ops = [sz(0)+sz(1)+sz(2)]. ### initial state: each spin polarized in x-y-plane; psi0 = tensor([(basis(2,0) + (1j)**i *basis(2,1)).unit() for i in range(0,N)]); rho0 = psi0*psi0.dag(). ### compute time evolution with different solvers; t_list = np.linspace(0, 50, 500); output0 = mesolve(H0, rho0, t_list, c_ops, e_ops); output1 = essolve(H0, rho0, t_list, c_ops, e_ops); output2 = sesolve(H0, psi0, t_list, e_ops). ### plot result; plt.plot(t_list, output0.expect[0], label='mesolve'); plt.plot(t_list, output1.expect[0], label='essolve'); plt.plot(t_list, output2.expect[0], label='sesolve'); plt.legend(). ### time evolution with essolve, use state vector --> Exception raised; output3 = essolve(H0, psi0, t_list, c_ops, e_ops); plt.plot(t_list, output0.expect[0], label='essolve, state vector'); plt.legend(); ```; The Hamiltonian commutes with the operator for which the expectation value is computed as is easily checked. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/841
https://github.com/qutip/qutip/issues/841:806,Modifiability,coupling,coupling,806,"There seems to be a bug when trying to solve the Schrödinger equation with the sesolve and essolve functions using an initial state vector. The following code reproduces the error:; ```python; ### import dependencies; %matplotlib inline; from qutip import *; import numpy as np; import matplotlib.pyplot as plt. ### define spin operators at each site ; N = 3 # Number of spins; def sz(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmaz()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sp(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmap()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sm(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmam()] + [qeye(2) for j in range(i+1,N)]; return tensor(l). ### Hamiltonian with on-site field and XX-type coupling between spins 0&1 and spins 0&2; delta = 1; V1 = 0.1; V2 = 0.1 ; H0 = -0.5*delta*(sz(0) + sz(1) + sz(2)) + V1*(sp(0)*sm(1) + sm(0)*sp(1)) + V2*(sp(0)*sm(2) + sm(0)*sp(2)) . ### no collapse operaters; e_op is total magnetization in z-direction ; c_ops = []; e_ops = [sz(0)+sz(1)+sz(2)]. ### initial state: each spin polarized in x-y-plane; psi0 = tensor([(basis(2,0) + (1j)**i *basis(2,1)).unit() for i in range(0,N)]); rho0 = psi0*psi0.dag(). ### compute time evolution with different solvers; t_list = np.linspace(0, 50, 500); output0 = mesolve(H0, rho0, t_list, c_ops, e_ops); output1 = essolve(H0, rho0, t_list, c_ops, e_ops); output2 = sesolve(H0, psi0, t_list, e_ops). ### plot result; plt.plot(t_list, output0.expect[0], label='mesolve'); plt.plot(t_list, output1.expect[0], label='essolve'); plt.plot(t_list, output2.expect[0], label='sesolve'); plt.legend(). ### time evolution with essolve, use state vector --> Exception raised; output3 = essolve(H0, psi0, t_list, c_ops, e_ops); plt.plot(t_list, output0.expect[0], label='essolve, state vector'); plt.legend(); ```; The Hamiltonian commutes with the operator for which the expectation value is computed as is easily checked. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/841
https://github.com/qutip/qutip/issues/842:324,Availability,avail,available,324,"I get a MemoryError computing a ptrace, although the output object would be smaller than the input object. Minimum working example:; `tensor(fock(2,0), fock(100,0), fock(100,0)).ptrace(0); `. The problem might be that internally the full density matrix is created before summation. This requires more RAM than is eventually available. Mathematically the operation should be possible without excessive RAM usage, as long as the input, as in this case, is a pure state vector. (related to [issue #828](https://github.com/qutip/qutip/issues/828 ) but not the same.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/842
https://github.com/qutip/qutip/issues/843:217,Modifiability,variab,variable,217,"I noticed that while operating in the batch mode of function propagator, it is not possible to use a user-defined options for the ODE solver. After inspecting the source code of propagator, I noticed that the options variable is redefined by the sentence ""options=Options(normalize_output=False))"" inside the function at line 183. I think it means that whatever options we input to the function, it will be restored to the default options because of this sentence.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/843
https://github.com/qutip/qutip/issues/844:349,Availability,error,error,349,"If I use a time-dependent collapse operator in `mcsolve`:. ``` python; import numpy as np; from qutip import destroy, basis, mcsolve. b = destroy(5); H = b.dag() * b; collapse = [[b, '9 * exp(-(t / 5.) ** 2)']]; psi0 = basis(5, 1). times = np.linspace(0, 100, 100); data = mcsolve(H, psi0, times, collapse, [b.dag() * b]) ; ```. I get the following error:. ``` python; Error compiling Cython file:; ------------------------------------------------------------; ...; @cython.boundscheck(False); @cython.wraparound(False); def col_expect(int which, double t, complex[::1] data, int[::1] idx, int[::1] ptr, complex[::1] vec):. if which == 0:; out *= conj(9 * exp(-(t / 5.) ** 2)); ^; ------------------------------------------------------------; ```. I looked into `cy/codegen.py` and found, that the line. ``` python; out_string.append("" out *= conj("" + self.c_tdterms[ind] + "")""); ```. of the function `func_which_expect(self)` (currently line 355) should be replaced with. ``` python; out_string.append("" out = conj("" + self.c_tdterms[ind] + "")""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/844
https://github.com/qutip/qutip/issues/844:369,Availability,Error,Error,369,"If I use a time-dependent collapse operator in `mcsolve`:. ``` python; import numpy as np; from qutip import destroy, basis, mcsolve. b = destroy(5); H = b.dag() * b; collapse = [[b, '9 * exp(-(t / 5.) ** 2)']]; psi0 = basis(5, 1). times = np.linspace(0, 100, 100); data = mcsolve(H, psi0, times, collapse, [b.dag() * b]) ; ```. I get the following error:. ``` python; Error compiling Cython file:; ------------------------------------------------------------; ...; @cython.boundscheck(False); @cython.wraparound(False); def col_expect(int which, double t, complex[::1] data, int[::1] idx, int[::1] ptr, complex[::1] vec):. if which == 0:; out *= conj(9 * exp(-(t / 5.) ** 2)); ^; ------------------------------------------------------------; ```. I looked into `cy/codegen.py` and found, that the line. ``` python; out_string.append("" out *= conj("" + self.c_tdterms[ind] + "")""); ```. of the function `func_which_expect(self)` (currently line 355) should be replaced with. ``` python; out_string.append("" out = conj("" + self.c_tdterms[ind] + "")""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/844
https://github.com/qutip/qutip/issues/844:16,Integrability,depend,dependent,16,"If I use a time-dependent collapse operator in `mcsolve`:. ``` python; import numpy as np; from qutip import destroy, basis, mcsolve. b = destroy(5); H = b.dag() * b; collapse = [[b, '9 * exp(-(t / 5.) ** 2)']]; psi0 = basis(5, 1). times = np.linspace(0, 100, 100); data = mcsolve(H, psi0, times, collapse, [b.dag() * b]) ; ```. I get the following error:. ``` python; Error compiling Cython file:; ------------------------------------------------------------; ...; @cython.boundscheck(False); @cython.wraparound(False); def col_expect(int which, double t, complex[::1] data, int[::1] idx, int[::1] ptr, complex[::1] vec):. if which == 0:; out *= conj(9 * exp(-(t / 5.) ** 2)); ^; ------------------------------------------------------------; ```. I looked into `cy/codegen.py` and found, that the line. ``` python; out_string.append("" out *= conj("" + self.c_tdterms[ind] + "")""); ```. of the function `func_which_expect(self)` (currently line 355) should be replaced with. ``` python; out_string.append("" out = conj("" + self.c_tdterms[ind] + "")""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/844
https://github.com/qutip/qutip/issues/844:502,Integrability,wrap,wraparound,502,"If I use a time-dependent collapse operator in `mcsolve`:. ``` python; import numpy as np; from qutip import destroy, basis, mcsolve. b = destroy(5); H = b.dag() * b; collapse = [[b, '9 * exp(-(t / 5.) ** 2)']]; psi0 = basis(5, 1). times = np.linspace(0, 100, 100); data = mcsolve(H, psi0, times, collapse, [b.dag() * b]) ; ```. I get the following error:. ``` python; Error compiling Cython file:; ------------------------------------------------------------; ...; @cython.boundscheck(False); @cython.wraparound(False); def col_expect(int which, double t, complex[::1] data, int[::1] idx, int[::1] ptr, complex[::1] vec):. if which == 0:; out *= conj(9 * exp(-(t / 5.) ** 2)); ^; ------------------------------------------------------------; ```. I looked into `cy/codegen.py` and found, that the line. ``` python; out_string.append("" out *= conj("" + self.c_tdterms[ind] + "")""); ```. of the function `func_which_expect(self)` (currently line 355) should be replaced with. ``` python; out_string.append("" out = conj("" + self.c_tdterms[ind] + "")""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/844
https://github.com/qutip/qutip/issues/845:106,Availability,down,down,106,"Hi QuTiP users,. I am not quite sure how I should introduce the issue that I have, but basically it comes down to the fact that my Hamiltonian and a particular function seems to require >500 GB of RAM for some parameters used. For the desired parameters, this can even become Terabytes which is hard to implement. . The main parameters by the way is N, which is the dimension of the Hilbert Space. The maximum is N=111 when running the program on the 500 GB node. The memory usage fits very good to a RAM (MB) = 0.0008804*N^4 dependence. A strange thing is that Slurm's MaxRSS command says that only 133,690 MB was needed to run the program, which is not close to the 500 GB. The memory profiler said that one function required 145,766.2 MiB (152,846.9 MB) at some point, and 327,769.4 MiB (343,691.1 MB) was freed. Together this comes close to the 500 GB, although I don't understand the numbers. I have no profound knowledge of the memory allocation in Python and QuTiP, but I would like to check if this can be improved. I went to two IT consultants who are in charge of the National Supercomputer in the Netherlands, and they also found no errors in my code. One of their suggestions was to ask you for advice on this topic. Of course, I can provide you with more details (the whole code, the outcome of the memory profiler, the meaning of the parameters and the infrastructure), but I don't want to overwhelm you. I look forward to hearing from you. Best regards,. Xavier",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/845
https://github.com/qutip/qutip/issues/845:1144,Availability,error,errors,1144,"Hi QuTiP users,. I am not quite sure how I should introduce the issue that I have, but basically it comes down to the fact that my Hamiltonian and a particular function seems to require >500 GB of RAM for some parameters used. For the desired parameters, this can even become Terabytes which is hard to implement. . The main parameters by the way is N, which is the dimension of the Hilbert Space. The maximum is N=111 when running the program on the 500 GB node. The memory usage fits very good to a RAM (MB) = 0.0008804*N^4 dependence. A strange thing is that Slurm's MaxRSS command says that only 133,690 MB was needed to run the program, which is not close to the 500 GB. The memory profiler said that one function required 145,766.2 MiB (152,846.9 MB) at some point, and 327,769.4 MiB (343,691.1 MB) was freed. Together this comes close to the 500 GB, although I don't understand the numbers. I have no profound knowledge of the memory allocation in Python and QuTiP, but I would like to check if this can be improved. I went to two IT consultants who are in charge of the National Supercomputer in the Netherlands, and they also found no errors in my code. One of their suggestions was to ask you for advice on this topic. Of course, I can provide you with more details (the whole code, the outcome of the memory profiler, the meaning of the parameters and the infrastructure), but I don't want to overwhelm you. I look forward to hearing from you. Best regards,. Xavier",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/845
https://github.com/qutip/qutip/issues/845:1064,Energy Efficiency,charge,charge,1064,"Hi QuTiP users,. I am not quite sure how I should introduce the issue that I have, but basically it comes down to the fact that my Hamiltonian and a particular function seems to require >500 GB of RAM for some parameters used. For the desired parameters, this can even become Terabytes which is hard to implement. . The main parameters by the way is N, which is the dimension of the Hilbert Space. The maximum is N=111 when running the program on the 500 GB node. The memory usage fits very good to a RAM (MB) = 0.0008804*N^4 dependence. A strange thing is that Slurm's MaxRSS command says that only 133,690 MB was needed to run the program, which is not close to the 500 GB. The memory profiler said that one function required 145,766.2 MiB (152,846.9 MB) at some point, and 327,769.4 MiB (343,691.1 MB) was freed. Together this comes close to the 500 GB, although I don't understand the numbers. I have no profound knowledge of the memory allocation in Python and QuTiP, but I would like to check if this can be improved. I went to two IT consultants who are in charge of the National Supercomputer in the Netherlands, and they also found no errors in my code. One of their suggestions was to ask you for advice on this topic. Of course, I can provide you with more details (the whole code, the outcome of the memory profiler, the meaning of the parameters and the infrastructure), but I don't want to overwhelm you. I look forward to hearing from you. Best regards,. Xavier",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/845
https://github.com/qutip/qutip/issues/845:526,Integrability,depend,dependence,526,"Hi QuTiP users,. I am not quite sure how I should introduce the issue that I have, but basically it comes down to the fact that my Hamiltonian and a particular function seems to require >500 GB of RAM for some parameters used. For the desired parameters, this can even become Terabytes which is hard to implement. . The main parameters by the way is N, which is the dimension of the Hilbert Space. The maximum is N=111 when running the program on the 500 GB node. The memory usage fits very good to a RAM (MB) = 0.0008804*N^4 dependence. A strange thing is that Slurm's MaxRSS command says that only 133,690 MB was needed to run the program, which is not close to the 500 GB. The memory profiler said that one function required 145,766.2 MiB (152,846.9 MB) at some point, and 327,769.4 MiB (343,691.1 MB) was freed. Together this comes close to the 500 GB, although I don't understand the numbers. I have no profound knowledge of the memory allocation in Python and QuTiP, but I would like to check if this can be improved. I went to two IT consultants who are in charge of the National Supercomputer in the Netherlands, and they also found no errors in my code. One of their suggestions was to ask you for advice on this topic. Of course, I can provide you with more details (the whole code, the outcome of the memory profiler, the meaning of the parameters and the infrastructure), but I don't want to overwhelm you. I look forward to hearing from you. Best regards,. Xavier",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/845
https://github.com/qutip/qutip/issues/846:1194,Deployability,install,installation,1194,"mesolve returns num_collapse =0, even when I pass collapse operators to it like this ; ``` python; from qutip import *; import numpy as np; import matplotlib.pyplot as plt; from math import *. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2,0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). result = mesolve(H, psi0, times, [np.sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); print(""result.num_collapse"",result.num_collapse); # I am getting the no of collapse operators as zero. print(""len(result.expect[0]): {}"".format(len(result.expect[0]))). fig1 = plt.figure(); ax1 = fig1.add_subplot(1, 1, 1). ax1.set_title(""Final evolution""); ax1.set_xlabel(""Time""); ax1.set_ylabel(""P""); ax1.plot(times, result.expect[0], 'b*', linewidth=2); ax1.plot(times, result.expect[1], 'g+', linewidth=2). plt.show(); ``` ; (Some of the code is from @ajgpitch ). PFA the test run of the qutip.testing module as [qutip_testing.pdf](https://github.com/qutip/qutip/files/1865397/qutip_testing.pdf) so that anyone interested could see if there is anything wrong with my installation. Also please let me know if there is any other piece of information that needs to be known. >Computer OS: MacOS 10.13.3 High Sierra. -- ; Thanking You,. Kind regards,. Tejas Shetty. Email ID: tejasshetty.1808@gmail.com",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/846
https://github.com/qutip/qutip/issues/846:999,Testability,test,test,999,"mesolve returns num_collapse =0, even when I pass collapse operators to it like this ; ``` python; from qutip import *; import numpy as np; import matplotlib.pyplot as plt; from math import *. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2,0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). result = mesolve(H, psi0, times, [np.sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); print(""result.num_collapse"",result.num_collapse); # I am getting the no of collapse operators as zero. print(""len(result.expect[0]): {}"".format(len(result.expect[0]))). fig1 = plt.figure(); ax1 = fig1.add_subplot(1, 1, 1). ax1.set_title(""Final evolution""); ax1.set_xlabel(""Time""); ax1.set_ylabel(""P""); ax1.plot(times, result.expect[0], 'b*', linewidth=2); ax1.plot(times, result.expect[1], 'g+', linewidth=2). plt.show(); ``` ; (Some of the code is from @ajgpitch ). PFA the test run of the qutip.testing module as [qutip_testing.pdf](https://github.com/qutip/qutip/files/1865397/qutip_testing.pdf) so that anyone interested could see if there is anything wrong with my installation. Also please let me know if there is any other piece of information that needs to be known. >Computer OS: MacOS 10.13.3 High Sierra. -- ; Thanking You,. Kind regards,. Tejas Shetty. Email ID: tejasshetty.1808@gmail.com",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/846
https://github.com/qutip/qutip/issues/846:1021,Testability,test,testing,1021,"mesolve returns num_collapse =0, even when I pass collapse operators to it like this ; ``` python; from qutip import *; import numpy as np; import matplotlib.pyplot as plt; from math import *. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2,0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). result = mesolve(H, psi0, times, [np.sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); print(""result.num_collapse"",result.num_collapse); # I am getting the no of collapse operators as zero. print(""len(result.expect[0]): {}"".format(len(result.expect[0]))). fig1 = plt.figure(); ax1 = fig1.add_subplot(1, 1, 1). ax1.set_title(""Final evolution""); ax1.set_xlabel(""Time""); ax1.set_ylabel(""P""); ax1.plot(times, result.expect[0], 'b*', linewidth=2); ax1.plot(times, result.expect[1], 'g+', linewidth=2). plt.show(); ``` ; (Some of the code is from @ajgpitch ). PFA the test run of the qutip.testing module as [qutip_testing.pdf](https://github.com/qutip/qutip/files/1865397/qutip_testing.pdf) so that anyone interested could see if there is anything wrong with my installation. Also please let me know if there is any other piece of information that needs to be known. >Computer OS: MacOS 10.13.3 High Sierra. -- ; Thanking You,. Kind regards,. Tejas Shetty. Email ID: tejasshetty.1808@gmail.com",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/846
https://github.com/qutip/qutip/issues/847:98,Availability,error,error,98,"Hi all. When I ran this code. ```python; import qutip as q; q.qdiags(q.basis(3, 0), 0); ````. The error that was thrown indicated an improper version of Scipy instead of an error associated with; the function itself. I think it's because the [exception clause here](https://github.com/qutip/qutip/blob/master/qutip/operators.py#L753) is too broad. I think it should be catching ``NameError``.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/847
https://github.com/qutip/qutip/issues/847:173,Availability,error,error,173,"Hi all. When I ran this code. ```python; import qutip as q; q.qdiags(q.basis(3, 0), 0); ````. The error that was thrown indicated an improper version of Scipy instead of an error associated with; the function itself. I think it's because the [exception clause here](https://github.com/qutip/qutip/blob/master/qutip/operators.py#L753) is too broad. I think it should be catching ``NameError``.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/847
https://github.com/qutip/qutip/issues/849:120,Deployability,install,installed,120,"I want to use parallel.parfor to speed up the calculation, but the parfor function seems not working on windows. I have installed the qutip and other packages. And I have tested my code on linux based python, it works well. So I wonder if anyone can tell me why and how to fix this problem? Thanks.; The following is my test code.; ```python; from qutip import *; import numpy as np; import matplotlib.pyplot as plt; import matplotlib; import time. L = 5; gamma = np.linspace(0, 1, L); Population = np.zeros(L); def evolution(gamma,Omega=1, omega=1):; H = Omega*sigmaz() + omega*sigmax(); result = mesolve(H, basis(2,1), np.linspace(0, np.pi/2/omega, 200), [np.sqrt(gamma)*sigmam()], [sigmaz()]); return result.expect[0][-1]; result = parfor(evolution, gamma,Omega=1.0, omega=1.0)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/849
https://github.com/qutip/qutip/issues/849:171,Testability,test,tested,171,"I want to use parallel.parfor to speed up the calculation, but the parfor function seems not working on windows. I have installed the qutip and other packages. And I have tested my code on linux based python, it works well. So I wonder if anyone can tell me why and how to fix this problem? Thanks.; The following is my test code.; ```python; from qutip import *; import numpy as np; import matplotlib.pyplot as plt; import matplotlib; import time. L = 5; gamma = np.linspace(0, 1, L); Population = np.zeros(L); def evolution(gamma,Omega=1, omega=1):; H = Omega*sigmaz() + omega*sigmax(); result = mesolve(H, basis(2,1), np.linspace(0, np.pi/2/omega, 200), [np.sqrt(gamma)*sigmam()], [sigmaz()]); return result.expect[0][-1]; result = parfor(evolution, gamma,Omega=1.0, omega=1.0)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/849
https://github.com/qutip/qutip/issues/849:320,Testability,test,test,320,"I want to use parallel.parfor to speed up the calculation, but the parfor function seems not working on windows. I have installed the qutip and other packages. And I have tested my code on linux based python, it works well. So I wonder if anyone can tell me why and how to fix this problem? Thanks.; The following is my test code.; ```python; from qutip import *; import numpy as np; import matplotlib.pyplot as plt; import matplotlib; import time. L = 5; gamma = np.linspace(0, 1, L); Population = np.zeros(L); def evolution(gamma,Omega=1, omega=1):; H = Omega*sigmaz() + omega*sigmax(); result = mesolve(H, basis(2,1), np.linspace(0, np.pi/2/omega, 200), [np.sqrt(gamma)*sigmam()], [sigmaz()]); return result.expect[0][-1]; result = parfor(evolution, gamma,Omega=1.0, omega=1.0)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/849
https://github.com/qutip/qutip/pull/851:83,Availability,error,error,83,"This is a fix for #847. Since we already have a minimum requirement for Scipy, the error catching here does not make sense. It is better to leave the error returned from the scipy function `scipy.diags` untouched as the qutip version just wraps the result into a `qutip.Qobj`. . @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/851
https://github.com/qutip/qutip/pull/851:150,Availability,error,error,150,"This is a fix for #847. Since we already have a minimum requirement for Scipy, the error catching here does not make sense. It is better to leave the error returned from the scipy function `scipy.diags` untouched as the qutip version just wraps the result into a `qutip.Qobj`. . @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/851
https://github.com/qutip/qutip/pull/851:239,Integrability,wrap,wraps,239,"This is a fix for #847. Since we already have a minimum requirement for Scipy, the error catching here does not make sense. It is better to leave the error returned from the scipy function `scipy.diags` untouched as the qutip version just wraps the result into a `qutip.Qobj`. . @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/851
https://github.com/qutip/qutip/issues/853:879,Availability,fault,faults,879,"qutip crashes for moderately big tensor products:. In the following example, the result should be identity, and due to operators being stored in a sparse format, I'd expect qutip to handle this without problems. ~~~; >>> import qutip; >>> qutip.__version__; '4.2.0'; >>> factors = [qutip.Qobj([[1, 0], [0, 1]]) for _ in range(40)]; >>> qutip.tensor(*factors); Traceback (most recent call last):; File ""<ipython-input-12-770cf2fe6b16>"", line 1, in <module>; qutip.tensor(*factors); File ""/Users/goerz/anaconda3/lib/python3.5/site-packages/qutip/tensor.py"", line 116, in tensor; out.data = zcsr_kron(out.data, q.data); File ""qutip/cy/spmath.pyx"", line 351, in qutip.cy.spmath.zcsr_kron (qutip/cy/spmath.cpp:10231); File ""qutip/cy/spmath.pyx"", line 625, in qutip.cy.spmath._safe_multiply (qutip/cy/spmath.cpp:12116); OverflowError: value too large; ~~~. I've also seen segmentation faults for examples where not all operators where the identity",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/853
https://github.com/qutip/qutip/issues/854:146,Availability,error,errors,146,"Hi!; I was thinking to use Floquet Formalism to solve some time-dependent problem.; So I firstly try the case in Users Guide, but some unexpected errors occurred. ---------------------------------------------------------------------------; ```; %matplotlib inline; import matplotlib.pyplot as plt; import numpy as np; from qutip import *; delta=0.2*2*np.pi;; eps0=1.0*2*np.pi;; A=2.5*2*np.pi;; omega=1.0*2*np.pi;; H0=-delta/2.0*sigmax()-eps0/2.0*sigmaz(); H1=A/2.0*sigmaz(); args={'w':omega}; H=[H0,[H1,'sin(w*t)']]; T=2*np.pi/omega; f_modes_0, f_energies = floquet_modes(H, T, args); ```. Here is the error information：. ---------------------------------------------------------------------------; ```; DistutilsPlatformError Traceback (most recent call last); F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, language_level=language_level); 217 mod = imp.load_dynamic(name, so_path). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path. F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:602,Availability,error,error,602,"Hi!; I was thinking to use Floquet Formalism to solve some time-dependent problem.; So I firstly try the case in Users Guide, but some unexpected errors occurred. ---------------------------------------------------------------------------; ```; %matplotlib inline; import matplotlib.pyplot as plt; import numpy as np; from qutip import *; delta=0.2*2*np.pi;; eps0=1.0*2*np.pi;; A=2.5*2*np.pi;; omega=1.0*2*np.pi;; H0=-delta/2.0*sigmax()-eps0/2.0*sigmaz(); H1=A/2.0*sigmaz(); args={'w':omega}; H=[H0,[H1,'sin(w*t)']]; T=2*np.pi/omega; f_modes_0, f_energies = floquet_modes(H, T, args); ```. Here is the error information：. ---------------------------------------------------------------------------; ```; DistutilsPlatformError Traceback (most recent call last); F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, language_level=language_level); 217 mod = imp.load_dynamic(name, so_path). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path. F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:8870,Availability,error,errors,8870,"5 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,; 306 sources, depends, extra_postargs). F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 195 plat_spec = PLAT_TO_VCVARS[plat_name]; 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:; 199 raise DistutilsPlatformError(""Unable to find a compatible "". F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 83 vcvarsall, vcruntime = _find_vcvarsall(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 ; 87 try:. ImportError: Building module rhs75680 failed: ['distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat\n']; ```; I have tried it many times. Any other functions in Floquet Formalism will still have this problem.; Here is my version information:; ![image](https://user-images.githubusercontent.com/30772228/38968512-6240026a-43be-11e8-9ca7-4179b5f4bac5.png). I would appreciate your reply!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:64,Integrability,depend,dependent,64,"Hi!; I was thinking to use Floquet Formalism to solve some time-dependent problem.; So I firstly try the case in Users Guide, but some unexpected errors occurred. ---------------------------------------------------------------------------; ```; %matplotlib inline; import matplotlib.pyplot as plt; import numpy as np; from qutip import *; delta=0.2*2*np.pi;; eps0=1.0*2*np.pi;; A=2.5*2*np.pi;; omega=1.0*2*np.pi;; H0=-delta/2.0*sigmax()-eps0/2.0*sigmaz(); H1=A/2.0*sigmaz(); args={'w':omega}; H=[H0,[H1,'sin(w*t)']]; T=2*np.pi/omega; f_modes_0, f_energies = floquet_modes(H, T, args); ```. Here is the error information：. ---------------------------------------------------------------------------; ```; DistutilsPlatformError Traceback (most recent call last); F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, language_level=language_level); 217 mod = imp.load_dynamic(name, so_path). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path. F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:2518,Integrability,depend,depends,2518,"args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 184 ; --> 185 _build_ext.build_ext.run(self); 186 . F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 . F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 . F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,. F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:. F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 . DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. ImportError Traceback (most recent call last); <ipython-input-9-be63b537dd61> in <module>(); 1 start_time = time.time(); ----> 2 q_energies, f_gnd_prob, wf_gnd_prob = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, ps",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:2530,Integrability,depend,depends,2530,"= dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 184 ; --> 185 _build_ext.build_ext.run(self); 186 . F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 . F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 . F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,. F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:. F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 . DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. ImportError Traceback (most recent call last); <ipython-input-9-be63b537dd61> in <module>(); 1 start_time = time.time(); ----> 2 q_energies, f_gnd_prob, wf_gnd_prob = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, T, ""dynamics""); 3 print('dynamics: time elapsed",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:2688,Integrability,depend,depends,2688,":\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 184 ; --> 185 _build_ext.build_ext.run(self); 186 . F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 . F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 . F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,. F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:. F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 . DistutilsPlatformError: Unable to find vcvarsall.bat. During handling of the above exception, another exception occurred:. ImportError Traceback (most recent call last); <ipython-input-9-be63b537dd61> in <module>(); 1 start_time = time.time(); ----> 2 q_energies, f_gnd_prob, wf_gnd_prob = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, T, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-7-05623eaf8178> in qubit_integrate(delta, eps0_vec, A, omeg",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:7910,Integrability,depend,depends,7910,"lib\distutils\dist.py in run_command(self, command); 972 cmd_obj = self.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,; 306 sources, depends, extra_postargs). F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 195 plat_spec = PLAT_TO_VCVARS[plat_name]; 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:; 199 raise DistutilsPlatformError(""Unable to find a compatible "". F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 83 vcvarsall, vcruntime = _find_vcvarsall(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 ; 87 try:. ImportError: Building module rhs75680 failed: ['distutils.errors.DistutilsPlatfo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:7922,Integrability,depend,depends,7922,"lf.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,; 306 sources, depends, extra_postargs). F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 195 plat_spec = PLAT_TO_VCVARS[plat_name]; 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:; 199 raise DistutilsPlatformError(""Unable to find a compatible "". F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 83 vcvarsall, vcruntime = _find_vcvarsall(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 ; 87 try:. ImportError: Building module rhs75680 failed: ['distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat\n']; ```; I have tried it many t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:8144,Integrability,depend,depends,8144,"ages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,; 306 sources, depends, extra_postargs). F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 195 plat_spec = PLAT_TO_VCVARS[plat_name]; 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:; 199 raise DistutilsPlatformError(""Unable to find a compatible "". F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 83 vcvarsall, vcruntime = _find_vcvarsall(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 ; 87 try:. ImportError: Building module rhs75680 failed: ['distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat\n']; ```; I have tried it many times. Any other functions in Floquet Formalism will still have this problem.; Here is my version information:; ![image](https://user-images.githubus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:8304,Integrability,depend,depends,8304,"5 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,; 306 sources, depends, extra_postargs). F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 195 plat_spec = PLAT_TO_VCVARS[plat_name]; 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:; 199 raise DistutilsPlatformError(""Unable to find a compatible "". F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 83 vcvarsall, vcruntime = _find_vcvarsall(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 ; 87 try:. ImportError: Building module rhs75680 failed: ['distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat\n']; ```; I have tried it many times. Any other functions in Floquet Formalism will still have this problem.; Here is my version information:; ![image](https://user-images.githubusercontent.com/30772228/38968512-6240026a-43be-11e8-9ca7-4179b5f4bac5.png). I would appreciate your reply!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:4860,Modifiability,config,config,4860," = f_energies. F:\Anaconda3\lib\site-packages\qutip\floquet.py in floquet_modes(H, T, args, sort, U); 98 if U is None:; 99 # get the unitary propagator; --> 100 U = propagator(H, T, [], args); 101 ; 102 # find the eigenstates for the propagator. F:\Anaconda3\lib\site-packages\qutip\propagator.py in propagator(H, t, c_op_list, args, options, unitary_mode, parallel, progress_bar, **kwargs); 181 output = sesolve(H2, psi0, tlist, [],; 182 args=args, _safe_mode=False,; --> 183 options=Options(normalize_output=False)); 184 for k, t in enumerate(tlist):; 185 u[k] = sp_reshape(output.states[k].data, (N, N)). F:\Anaconda3\lib\site-packages\qutip\sesolve.py in sesolve(H, rho0, tlist, e_ops, args, options, progress_bar, _safe_mode); 153 elif n_str > 0:; 154 res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; --> 155 progress_bar); 156 ; 157 elif isinstance(H, (types.FunctionType,. F:\Anaconda3\lib\site-packages\qutip\sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 432 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 433 '<string>', 'exec'); --> 434 exec(code, globals()); 435 config.tdfunc = cy_td_ode_rhs; 436 . F:\Anaconda3\lib\site-packages\qutip\sesolve.py in <module>(). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:4962,Modifiability,config,config,4962,"is None:; 99 # get the unitary propagator; --> 100 U = propagator(H, T, [], args); 101 ; 102 # find the eigenstates for the propagator. F:\Anaconda3\lib\site-packages\qutip\propagator.py in propagator(H, t, c_op_list, args, options, unitary_mode, parallel, progress_bar, **kwargs); 181 output = sesolve(H2, psi0, tlist, [],; 182 args=args, _safe_mode=False,; --> 183 options=Options(normalize_output=False)); 184 for k, t in enumerate(tlist):; 185 u[k] = sp_reshape(output.states[k].data, (N, N)). F:\Anaconda3\lib\site-packages\qutip\sesolve.py in sesolve(H, rho0, tlist, e_ops, args, options, progress_bar, _safe_mode); 153 elif n_str > 0:; 154 res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; --> 155 progress_bar); 156 ; 157 elif isinstance(H, (types.FunctionType,. F:\Anaconda3\lib\site-packages\qutip\sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 432 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 433 '<string>', 'exec'); --> 434 exec(code, globals()); 435 config.tdfunc = cy_td_ode_rhs; 436 . F:\Anaconda3\lib\site-packages\qutip\sesolve.py in <module>(). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = name; 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, lang",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:7957,Modifiability,variab,variable,7957,"lf.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,; 306 sources, depends, extra_postargs). F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 195 plat_spec = PLAT_TO_VCVARS[plat_name]; 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:; 199 raise DistutilsPlatformError(""Unable to find a compatible "". F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 83 vcvarsall, vcruntime = _find_vcvarsall(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 ; 87 try:. ImportError: Building module rhs75680 failed: ['distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat\n']; ```; I have tried it many t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:7166,Performance,optimiz,optimization,7166,"_level); 190 setup_args=sargs,; 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path; 194 . F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 100 try:; 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]; 104 if obj_build_ext.inplace:. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 953 """"""; 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 ; 957 # -- Methods that operate on its Commands --------------------------. F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 972 cmd_obj = self.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 30",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:1294,Testability,assert,assert,1294,"t as plt; import numpy as np; from qutip import *; delta=0.2*2*np.pi;; eps0=1.0*2*np.pi;; A=2.5*2*np.pi;; omega=1.0*2*np.pi;; H0=-delta/2.0*sigmax()-eps0/2.0*sigmaz(); H1=A/2.0*sigmaz(); args={'w':omega}; H=[H0,[H1,'sin(w*t)']]; T=2*np.pi/omega; f_modes_0, f_energies = floquet_modes(H, T, args); ```. Here is the error information：. ---------------------------------------------------------------------------; ```; DistutilsPlatformError Traceback (most recent call last); F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, language_level=language_level); 217 mod = imp.load_dynamic(name, so_path). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path. F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 184 ; --> 185 _build_ext.build_ext.run(self); 186 . F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extens",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:6268,Testability,assert,assert,6268,"odule; 447 . F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = name; 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, language_level=language_level); 217 mod = imp.load_dynamic(name, so_path); 218 if is_package and not hasattr(mod, '__path__'):. F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 190 setup_args=sargs,; 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path; 194 . F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 100 try:; 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]; 104 if obj_build_ext.inplace:. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 953 """"""; 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 ; 957 # -- Methods that operate on its Commands --------------------------. F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 972 cmd_obj = self.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/854:119,Usability,Guid,Guide,119,"Hi!; I was thinking to use Floquet Formalism to solve some time-dependent problem.; So I firstly try the case in Users Guide, but some unexpected errors occurred. ---------------------------------------------------------------------------; ```; %matplotlib inline; import matplotlib.pyplot as plt; import numpy as np; from qutip import *; delta=0.2*2*np.pi;; eps0=1.0*2*np.pi;; A=2.5*2*np.pi;; omega=1.0*2*np.pi;; H0=-delta/2.0*sigmax()-eps0/2.0*sigmaz(); H1=A/2.0*sigmaz(); args={'w':omega}; H=[H0,[H1,'sin(w*t)']]; T=2*np.pi/omega; f_modes_0, f_energies = floquet_modes(H, T, args); ```. Here is the error information：. ---------------------------------------------------------------------------; ```; DistutilsPlatformError Traceback (most recent call last); F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, language_level=language_level); 217 mod = imp.load_dynamic(name, so_path). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in build_module(name, pyxfilename, pyxbuild_dir, inplace, language_level); 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path. F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 . F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/854
https://github.com/qutip/qutip/issues/857:123,Availability,error,error,123,"Hi. I've been trying to use the Platen solver for ssesolve but it doesn't seem to work. Running the code below produces an error. Here's the code:; ```; from qutip import *; import numpy as np. N = 15; w0 = 1.0 * 2 * np.pi; A = 0.1 * 2 * np.pi; times = np.linspace(0, 1.5, 150); gamma = 0.25. ntraj = 1; nsubsteps = 1. a = destroy(N); x = a + a.dag(); y = -1.0j*(a - a.dag()). H = w0 * a.dag() * a + A * (a + a.dag()). rho0 = coherent(N, np.sqrt(5.0), method='analytic'); c_ops = [np.sqrt(gamma) * a]; e_ops = [a.dag() * a, x, y]. result = ssesolve(H, rho0, times, [np.sqrt(gamma) * a], e_ops, ntraj=ntraj, nsubsteps=nsubsteps, method='homodyne', map_func=parallel_map, solver='platen'); ```. Here's the error:; ```; Traceback (most recent call last):; File ""test.py"", line 23, in <module>; result = ssesolve(H, rho0, times, [np.sqrt(gamma) * a], e_ops, ntraj=ntraj, nsubsteps=nsubsteps, method='homodyne', map_func=parallel_map, solver='platen'); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 377, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 758, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/parallel.py"", line 183, in serial_map; result = task(value, *task_args, **task_kwargs); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 859, in _ssesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 1843, in _rhs_psi_platen; d1(A, psi_t) * dt +; TypeError: d1_psi_homodyne() takes exactly 4 arguments (2 given). ```; I've rewritten the _rhs_psi_platen function to fix this issue. Would you like me to make a pull request?; ~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/857
https://github.com/qutip/qutip/issues/857:704,Availability,error,error,704,"Hi. I've been trying to use the Platen solver for ssesolve but it doesn't seem to work. Running the code below produces an error. Here's the code:; ```; from qutip import *; import numpy as np. N = 15; w0 = 1.0 * 2 * np.pi; A = 0.1 * 2 * np.pi; times = np.linspace(0, 1.5, 150); gamma = 0.25. ntraj = 1; nsubsteps = 1. a = destroy(N); x = a + a.dag(); y = -1.0j*(a - a.dag()). H = w0 * a.dag() * a + A * (a + a.dag()). rho0 = coherent(N, np.sqrt(5.0), method='analytic'); c_ops = [np.sqrt(gamma) * a]; e_ops = [a.dag() * a, x, y]. result = ssesolve(H, rho0, times, [np.sqrt(gamma) * a], e_ops, ntraj=ntraj, nsubsteps=nsubsteps, method='homodyne', map_func=parallel_map, solver='platen'); ```. Here's the error:; ```; Traceback (most recent call last):; File ""test.py"", line 23, in <module>; result = ssesolve(H, rho0, times, [np.sqrt(gamma) * a], e_ops, ntraj=ntraj, nsubsteps=nsubsteps, method='homodyne', map_func=parallel_map, solver='platen'); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 377, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 758, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/parallel.py"", line 183, in serial_map; result = task(value, *task_args, **task_kwargs); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 859, in _ssesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 1843, in _rhs_psi_platen; d1(A, psi_t) * dt +; TypeError: d1_psi_homodyne() takes exactly 4 arguments (2 given). ```; I've rewritten the _rhs_psi_platen function to fix this issue. Would you like me to make a pull request?; ~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/857
https://github.com/qutip/qutip/issues/857:759,Testability,test,test,759,"Hi. I've been trying to use the Platen solver for ssesolve but it doesn't seem to work. Running the code below produces an error. Here's the code:; ```; from qutip import *; import numpy as np. N = 15; w0 = 1.0 * 2 * np.pi; A = 0.1 * 2 * np.pi; times = np.linspace(0, 1.5, 150); gamma = 0.25. ntraj = 1; nsubsteps = 1. a = destroy(N); x = a + a.dag(); y = -1.0j*(a - a.dag()). H = w0 * a.dag() * a + A * (a + a.dag()). rho0 = coherent(N, np.sqrt(5.0), method='analytic'); c_ops = [np.sqrt(gamma) * a]; e_ops = [a.dag() * a, x, y]. result = ssesolve(H, rho0, times, [np.sqrt(gamma) * a], e_ops, ntraj=ntraj, nsubsteps=nsubsteps, method='homodyne', map_func=parallel_map, solver='platen'); ```. Here's the error:; ```; Traceback (most recent call last):; File ""test.py"", line 23, in <module>; result = ssesolve(H, rho0, times, [np.sqrt(gamma) * a], e_ops, ntraj=ntraj, nsubsteps=nsubsteps, method='homodyne', map_func=parallel_map, solver='platen'); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 377, in ssesolve; res = _ssesolve_generic(sso, sso.options, sso.progress_bar); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 758, in _ssesolve_generic; task_args, task_kwargs, **map_kwargs); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/parallel.py"", line 183, in serial_map; result = task(value, *task_args, **task_kwargs); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 859, in _ssesolve_single_trajectory; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args); File ""/home/paul/anaconda3/envs/bistable/lib/python2.7/site-packages/qutip/stochastic.py"", line 1843, in _rhs_psi_platen; d1(A, psi_t) * dt +; TypeError: d1_psi_homodyne() takes exactly 4 arguments (2 given). ```; I've rewritten the _rhs_psi_platen function to fix this issue. Would you like me to make a pull request?; ~",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/857
https://github.com/qutip/qutip/issues/860:86,Availability,error,error,86,"I installed anaconda on windows 10. ; I used then ""pip install qutip"", and I get this error : ; File ""\lib\distutils\cygwinccompiler.py"" line 129, in __init__; if self.ld_version >= ""2.10.90"" : ; TypeError: '>=' not supported between instances of 'NoneType' and 'str'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/860
https://github.com/qutip/qutip/issues/860:2,Deployability,install,installed,2,"I installed anaconda on windows 10. ; I used then ""pip install qutip"", and I get this error : ; File ""\lib\distutils\cygwinccompiler.py"" line 129, in __init__; if self.ld_version >= ""2.10.90"" : ; TypeError: '>=' not supported between instances of 'NoneType' and 'str'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/860
https://github.com/qutip/qutip/issues/860:55,Deployability,install,install,55,"I installed anaconda on windows 10. ; I used then ""pip install qutip"", and I get this error : ; File ""\lib\distutils\cygwinccompiler.py"" line 129, in __init__; if self.ld_version >= ""2.10.90"" : ; TypeError: '>=' not supported between instances of 'NoneType' and 'str'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/860
https://github.com/qutip/qutip/pull/861:153,Deployability,update,updated,153,"Hi, we now have an arXiv entry for PIQS: https://arxiv.org/abs/1805.05129. This version adds `pisolve` a custom solver for diagonal initial state and is updated to be synced with the latest version in the paper. We have also made some documentation in [piqs.readthedocs.io](piqs.readthedocs.io). Corresponding notebooks and docs will be added too. @nathanshammah @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/861
https://github.com/qutip/qutip/issues/862:222,Availability,Error,Error,222,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:761,Availability,ERROR,ERROR,761,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:1909,Availability,error,errors,1909,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:463,Deployability,release,release,463,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:798,Energy Efficiency,power,power-gmres,798,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:1194,Energy Efficiency,power,power-gmres,1194,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:100,Testability,test,tests,100,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:210,Testability,test,tests,210,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:228,Testability,log,log,228,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:276,Testability,log,log,276,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:1030,Testability,test,test,1030,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:1086,Testability,test,tests,1086,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:1873,Testability,test,tests,1873,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/862:36,Usability,simpl,simply,36,"I can't quite figure out if this is simply due to the DeprecationWarnings or something else but all tests are failing due to `atol` not being set for the gmres solver. I will try to set `atol` and check if the tests pass. Error log: https://api.travis-ci.org/v3/job/379109482/log.txt.; ```; scipy/sparse/linalg/isolve/iterative.py:2: DeprecationWarning: scipy.sparse.linalg.bicgstab called without specifying `atol`. The default value will be changed in a future release. For compatibility, specify a value for `atol` explicitly, e.g., ``bicgstab(..., atol=0)``, or to retain the old behavior ``bicgstab(..., atol='legacy')``. ```. ```; ..................................................; ======================================================================; ERROR: Steady state: Thermal qubit - power-gmres solver; ----------------------------------------------------------------------; Traceback (most recent call last):; File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/Users/shahnawaz/dev/qutip/qutip/tests/test_steadystate.py"", line 145, in test_qubit_power_gmres; rho_ss = steadystate(H, c_op_list, method='power-gmres'); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 298, in steadystate; return _steadystate_power(A, ss_args); File ""/Users/shahnawaz/dev/qutip/qutip/steadystate.py"", line 863, in _steadystate_power; v = v / la.norm(v, np.inf); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/scipy/linalg/misc.py"", line 137, in norm; a = np.asarray_chkfinite(a); File ""/Users/shahnawaz/miniconda3/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 1233, in asarray_chkfinite; ""array must not contain infs or NaNs""); ValueError: array must not contain infs or NaNs. ----------------------------------------------------------------------; Ran 561 tests in 576.175s. FAILED (SKIP=19, errors=1); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/862
https://github.com/qutip/qutip/issues/867:200,Integrability,depend,dependence,200,"I have been spending quite a bit of time in sesolve.py and mesolve.py recently. I have noticed a few things that could potentially be tidied up. 1. There are deprecated functions for `list` type time dependence. Can these be deleted now.; 2. The order of the internal functions is slightly different. Confuses me a lot. Suggest changing both to (as this seems like some kind of valid hierarchy):; - const; - func; - list_func; - list_str; - generic_ode. 3. The parameters in the ode func are `L_list_and_args` in sesolve and `L_list, args` in mesolve. I can't see any reason for the difference.; 4. The ode functions (for const and list_func) could be considered internal. Should they have a leading underscore?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/867
https://github.com/qutip/qutip/pull/868:145,Testability,test,tests,145,"The unitary operator evolution implemented in #832 was flawed.; This is a complete overhaul. It uses the method from mesolve map evolution.; The tests implemented in #832 did not uncover the flaws, and so extra ones are added that would have.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/868
https://github.com/qutip/qutip/issues/869:334,Availability,error,error,334,"If I have a superoperator already in the Kraus form (that is, as a list of operators), I cannot directly compute its average gate fidelity: `average_gate_fidelity` will try to convert it to Kraus anyway:; https://github.com/qutip/qutip/blob/2aa51b92df57f995778940815d20d293f00f8a9d/qutip/metrics.py#L144; and `to_kraus` will raise an error because the input does not have a `type`:; https://github.com/qutip/qutip/blob/b0c6e59a4914816ff68163b03a37ab40ecf0d809/qutip/superop_reps.py#L543-L555. As a minimal example, shouldn't something like; ```; kraus_ops = [qutip.sigmax(), qutip.sigmay()]; qutip.average_gate_fidelity(kraus_ops); ```; be made to work?. What about adding a check in `average_gate_fidelity` so that if the input is already a list then don't do anything (although it seems more robust to have some kind of wrapper to flag an object as list of operators of a Kraus decomposition)?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/869
https://github.com/qutip/qutip/issues/869:794,Availability,robust,robust,794,"If I have a superoperator already in the Kraus form (that is, as a list of operators), I cannot directly compute its average gate fidelity: `average_gate_fidelity` will try to convert it to Kraus anyway:; https://github.com/qutip/qutip/blob/2aa51b92df57f995778940815d20d293f00f8a9d/qutip/metrics.py#L144; and `to_kraus` will raise an error because the input does not have a `type`:; https://github.com/qutip/qutip/blob/b0c6e59a4914816ff68163b03a37ab40ecf0d809/qutip/superop_reps.py#L543-L555. As a minimal example, shouldn't something like; ```; kraus_ops = [qutip.sigmax(), qutip.sigmay()]; qutip.average_gate_fidelity(kraus_ops); ```; be made to work?. What about adding a check in `average_gate_fidelity` so that if the input is already a list then don't do anything (although it seems more robust to have some kind of wrapper to flag an object as list of operators of a Kraus decomposition)?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/869
https://github.com/qutip/qutip/issues/869:822,Integrability,wrap,wrapper,822,"If I have a superoperator already in the Kraus form (that is, as a list of operators), I cannot directly compute its average gate fidelity: `average_gate_fidelity` will try to convert it to Kraus anyway:; https://github.com/qutip/qutip/blob/2aa51b92df57f995778940815d20d293f00f8a9d/qutip/metrics.py#L144; and `to_kraus` will raise an error because the input does not have a `type`:; https://github.com/qutip/qutip/blob/b0c6e59a4914816ff68163b03a37ab40ecf0d809/qutip/superop_reps.py#L543-L555. As a minimal example, shouldn't something like; ```; kraus_ops = [qutip.sigmax(), qutip.sigmay()]; qutip.average_gate_fidelity(kraus_ops); ```; be made to work?. What about adding a check in `average_gate_fidelity` so that if the input is already a list then don't do anything (although it seems more robust to have some kind of wrapper to flag an object as list of operators of a Kraus decomposition)?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/869
https://github.com/qutip/qutip/pull/870:88,Testability,test,tests,88,Hopefully this will fix #862 ; Unfortunately 'legacy' did not behave as scipy 0.x. Some tests still failed. I had to add facility to set much higher tol on the gmres method.; The missing kwarg is handled. So should work for scipy < 1.1,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/870
https://github.com/qutip/qutip/issues/871:127,Availability,fault,fault,127,This test seems to be failing with. ```; Sparse eigs Hermitian ... /home/travis/.travis/job_stages: line 57: 6699 Segmentation fault (core dumped) nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ```; I will try and recreate locally,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/871
https://github.com/qutip/qutip/issues/871:5,Testability,test,test,5,This test seems to be failing with. ```; Sparse eigs Hermitian ... /home/travis/.travis/job_stages: line 57: 6699 Segmentation fault (core dumped) nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; ```; I will try and recreate locally,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/871
https://github.com/qutip/qutip/issues/872:12,Testability,test,tests,12,Current 106 tests are failing. All seeming 'Metrics' test.; All failing with:; ```; TypeError: __init__() got multiple values for argument 'name'; ```; I will try and reproduce locally,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/872
https://github.com/qutip/qutip/issues/872:53,Testability,test,test,53,Current 106 tests are failing. All seeming 'Metrics' test.; All failing with:; ```; TypeError: __init__() got multiple values for argument 'name'; ```; I will try and reproduce locally,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/872
https://github.com/qutip/qutip/pull/873:78,Deployability,install,installed,78,cvxpy Variable and Parameter dims passed as tuple; cvxpy and its depends only installed in tests for NOMKL builds; Extra test added for NOMKL with OPENMP,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/873
https://github.com/qutip/qutip/pull/873:65,Integrability,depend,depends,65,cvxpy Variable and Parameter dims passed as tuple; cvxpy and its depends only installed in tests for NOMKL builds; Extra test added for NOMKL with OPENMP,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/873
https://github.com/qutip/qutip/pull/873:6,Modifiability,Variab,Variable,6,cvxpy Variable and Parameter dims passed as tuple; cvxpy and its depends only installed in tests for NOMKL builds; Extra test added for NOMKL with OPENMP,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/873
https://github.com/qutip/qutip/pull/873:91,Testability,test,tests,91,cvxpy Variable and Parameter dims passed as tuple; cvxpy and its depends only installed in tests for NOMKL builds; Extra test added for NOMKL with OPENMP,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/873
https://github.com/qutip/qutip/pull/873:121,Testability,test,test,121,cvxpy Variable and Parameter dims passed as tuple; cvxpy and its depends only installed in tests for NOMKL builds; Extra test added for NOMKL with OPENMP,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/873
https://github.com/qutip/qutip/issues/874:117,Availability,failure,failures,117,"The `metrics.dnorm` function uses the cvxpy library to calculate the diamond norm. Twice now it has caused many test failures out of the blue #484 and #872.; It would seem like the developers do not prioritise maintaining a conda package. As this is our recommended platform, then it is a risk having this cvxpy dependence. Perhaps there is a method using scipy that we could employ?. @cgranade perhaps could provide some context?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/874
https://github.com/qutip/qutip/issues/874:312,Integrability,depend,dependence,312,"The `metrics.dnorm` function uses the cvxpy library to calculate the diamond norm. Twice now it has caused many test failures out of the blue #484 and #872.; It would seem like the developers do not prioritise maintaining a conda package. As this is our recommended platform, then it is a risk having this cvxpy dependence. Perhaps there is a method using scipy that we could employ?. @cgranade perhaps could provide some context?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/874
https://github.com/qutip/qutip/issues/874:289,Safety,risk,risk,289,"The `metrics.dnorm` function uses the cvxpy library to calculate the diamond norm. Twice now it has caused many test failures out of the blue #484 and #872.; It would seem like the developers do not prioritise maintaining a conda package. As this is our recommended platform, then it is a risk having this cvxpy dependence. Perhaps there is a method using scipy that we could employ?. @cgranade perhaps could provide some context?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/874
https://github.com/qutip/qutip/issues/874:112,Testability,test,test,112,"The `metrics.dnorm` function uses the cvxpy library to calculate the diamond norm. Twice now it has caused many test failures out of the blue #484 and #872.; It would seem like the developers do not prioritise maintaining a conda package. As this is our recommended platform, then it is a risk having this cvxpy dependence. Perhaps there is a method using scipy that we could employ?. @cgranade perhaps could provide some context?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/874
https://github.com/qutip/qutip/issues/877:519,Energy Efficiency,efficient,efficient,519,"For map evolution in mesolve and unitary oper evolution is sesolve (in #868) has a python function for the ode rhs, for all td types. For const and list_str we have a Cython for dm / state evolution. Focusing on list_str: The spmv function(s) are called on each column of the vectorised map matrix. This could be done inside the custom rhs function. Or we could reshape the vector into a matrix and call some version of spmm (sparse matrix*dense matrix). Questions:; 1. which of these options do we think would be more efficient?; 2. I see we have a `cy_spmm_tr` function, but it's not apparent to me what it does. Does it compute the transpose of the sparse*dense matrix?; 3. There does not seem to be any `zspmm` or equiv in `cy/src`. Is this because it does not really exist anywhere?; 4. As 3 but using with `cy/openmp/src`. It would seem like the simplest option would be to spmv on each 'column', but inside the Cython RHS function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/877
https://github.com/qutip/qutip/issues/877:852,Usability,simpl,simplest,852,"For map evolution in mesolve and unitary oper evolution is sesolve (in #868) has a python function for the ode rhs, for all td types. For const and list_str we have a Cython for dm / state evolution. Focusing on list_str: The spmv function(s) are called on each column of the vectorised map matrix. This could be done inside the custom rhs function. Or we could reshape the vector into a matrix and call some version of spmm (sparse matrix*dense matrix). Questions:; 1. which of these options do we think would be more efficient?; 2. I see we have a `cy_spmm_tr` function, but it's not apparent to me what it does. Does it compute the transpose of the sparse*dense matrix?; 3. There does not seem to be any `zspmm` or equiv in `cy/src`. Is this because it does not really exist anywhere?; 4. As 3 but using with `cy/openmp/src`. It would seem like the simplest option would be to spmv on each 'column', but inside the Cython RHS function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/877
https://github.com/qutip/qutip/issues/878:74,Availability,error,errors,74,Doesn't install matplotlib when installing on windows.; And then produces errors,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/878
https://github.com/qutip/qutip/issues/878:8,Deployability,install,install,8,Doesn't install matplotlib when installing on windows.; And then produces errors,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/878
https://github.com/qutip/qutip/issues/878:32,Deployability,install,installing,32,Doesn't install matplotlib when installing on windows.; And then produces errors,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/878
https://github.com/qutip/qutip/issues/880:141,Availability,ERROR,ERROR,141,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:298,Availability,error,error,298,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:674,Availability,reliab,reliable,674,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:534,Deployability,install,installing,534,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:571,Deployability,configurat,configurations,571,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:468,Energy Efficiency,reduce,reduce,468,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:571,Modifiability,config,configurations,571,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:10,Testability,test,tests,10,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:566,Testability,test,test,566,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/issues/880:663,Testability,test,tests,663,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/880
https://github.com/qutip/qutip/pull/881:4,Deployability,install,installing,4,Not installing cvxpy will do this.; This is to deal with #880,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/881
https://github.com/qutip/qutip/issues/888:2721,Availability,error,error,2721,"m(1), identity(2), identity(2)) * basis(16,1); Traceback (most recent call last):. File ""<ipython-input-160-ae66af2f799c>"", line 1, in <module>; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""). TypeError: Incompatible Qobj shap; ```. but when i do each part separately as follow I notice that the shapes are compatible:; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)); Out[161]: ; Quantum object: dims = [[2, 2, 2, 2], [2, 2, 2, 2]], shape = (16, 16), type = oper, isherm = True; ```; ```python; basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/en",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:4297,Deployability,Install,Installed,4297," basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 1000:1000; netrc file : None; offline mode : False. ```. ```; >>> from qutip import *; >>> about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 1.1.0; Cython Version: 0.28.3; Matplotlib Version: 2.2.2; Python Version: 2.7.15; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip. ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:4367,Deployability,Install,Installation,4367," basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 1000:1000; netrc file : None; offline mode : False. ```. ```; >>> from qutip import *; >>> about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 1.1.0; Cython Version: 0.28.3; Matplotlib Version: 2.2.2; Python Version: 2.7.15; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip. ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:2910,Modifiability,config,config,2910," tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""). TypeError: Incompatible Qobj shap; ```. but when i do each part separately as follow I notice that the shapes are compatible:; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)); Out[161]: ; Quantum object: dims = [[2, 2, 2, 2], [2, 2, 2, 2]], shape = (16, 16), type = oper, isherm = True; ```; ```python; basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 10",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:2955,Modifiability,config,config,2955,"1). File ""/home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""). TypeError: Incompatible Qobj shap; ```. but when i do each part separately as follow I notice that the shapes are compatible:; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)); Out[161]: ; Quantum object: dims = [[2, 2, 2, 2], [2, 2, 2, 2]], shape = (16, 16), type = oper, isherm = True; ```; ```python; basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 1000:1000; netrc file : None; offline mode : False. ```. ```; >>> from qutip import *; >>> ab",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:15,Performance,perform,perform,15,"I am trying to perform this simple operation <a href=""https://www.codecogs.com/eqnedit.php?latex=(H^{\otimes&space;2}&space;\otimes&space;I^{\otimes&space;2}&space;)&space;\times&space;\psi"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?(H^{\otimes&space;2}&space;\otimes&space;I^{\otimes&space;2}&space;)&space;\times&space;\psi"" title=""(H^{\otimes 2} \otimes I^{\otimes 2} ) \times \psi"" /></a>; where ; <a href=""https://www.codecogs.com/eqnedit.php?latex=H&space;=&space;\frac{1}{\sqrt{2}}&space;\times&space;\begin{bmatrix}&space;1&space;&&space;1\\&space;1&space;&&space;-1&space;\end{bmatrix}&space;,&space;I&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;\\&space;0&space;&&space;1&space;\end{bmatrix}"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?H&space;=&space;\frac{1}{\sqrt{2}}&space;\times&space;\begin{bmatrix}&space;1&space;&&space;1\\&space;1&space;&&space;-1&space;\end{bmatrix}&space;,&space;I&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;\\&space;0&space;&&space;1&space;\end{bmatrix}"" title=""H = \frac{1}{\sqrt{2}} \times \begin{bmatrix} 1 & 1\\ 1 & -1 \end{bmatrix} , I = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}"" /></a>; and ; <a href=""https://www.codecogs.com/eqnedit.php?latex=\psi&space;=&space;\left|0\right\rangle^{\otimes&space;4}"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?\psi&space;=&space;\left|0\right\rangle^{\otimes&space;4}"" title=""\psi = \left|0\right\rangle^{\otimes 4}"" /></a>; I do that as follow: ; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); ```; and i got the following : . ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); Traceback (most recent call last):. File ""<ipython-input-160-ae66af2f799c>"", line 1, in <module>; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:2669,Performance,perform,performing,2669,"le^{\otimes&space;4}"" title=""\psi = \left|0\right\rangle^{\otimes 4}"" /></a>; I do that as follow: ; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); ```; and i got the following : . ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); Traceback (most recent call last):. File ""<ipython-input-160-ae66af2f799c>"", line 1, in <module>; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""). TypeError: Incompatible Qobj shap; ```. but when i do each part separately as follow I notice that the shapes are compatible:; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)); Out[161]: ; Quantum object: dims = [[2, 2, 2, 2], [2, 2, 2, 2]], shape = (16, 16), type = oper, isherm = True; ```; ```python; basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anacond",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:3600,Performance,cache,cache,3600," basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 1000:1000; netrc file : None; offline mode : False. ```. ```; >>> from qutip import *; >>> about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 1.1.0; Cython Version: 0.28.3; Matplotlib Version: 2.2.2; Python Version: 2.7.15; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip. ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/issues/888:28,Usability,simpl,simple,28,"I am trying to perform this simple operation <a href=""https://www.codecogs.com/eqnedit.php?latex=(H^{\otimes&space;2}&space;\otimes&space;I^{\otimes&space;2}&space;)&space;\times&space;\psi"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?(H^{\otimes&space;2}&space;\otimes&space;I^{\otimes&space;2}&space;)&space;\times&space;\psi"" title=""(H^{\otimes 2} \otimes I^{\otimes 2} ) \times \psi"" /></a>; where ; <a href=""https://www.codecogs.com/eqnedit.php?latex=H&space;=&space;\frac{1}{\sqrt{2}}&space;\times&space;\begin{bmatrix}&space;1&space;&&space;1\\&space;1&space;&&space;-1&space;\end{bmatrix}&space;,&space;I&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;\\&space;0&space;&&space;1&space;\end{bmatrix}"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?H&space;=&space;\frac{1}{\sqrt{2}}&space;\times&space;\begin{bmatrix}&space;1&space;&&space;1\\&space;1&space;&&space;-1&space;\end{bmatrix}&space;,&space;I&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;\\&space;0&space;&&space;1&space;\end{bmatrix}"" title=""H = \frac{1}{\sqrt{2}} \times \begin{bmatrix} 1 & 1\\ 1 & -1 \end{bmatrix} , I = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}"" /></a>; and ; <a href=""https://www.codecogs.com/eqnedit.php?latex=\psi&space;=&space;\left|0\right\rangle^{\otimes&space;4}"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?\psi&space;=&space;\left|0\right\rangle^{\otimes&space;4}"" title=""\psi = \left|0\right\rangle^{\otimes 4}"" /></a>; I do that as follow: ; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); ```; and i got the following : . ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); Traceback (most recent call last):. File ""<ipython-input-160-ae66af2f799c>"", line 1, in <module>; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/888
https://github.com/qutip/qutip/pull/889:38,Deployability,release,release,38,"It is about time that we made the 4.3 release, @ajgpitch @nonhermitian. Could you please check and merge this? I will build the 4.3 dist and the documentation and then update pip and the conda-forge version. We have the new scattering module and PIQS in this version.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/889
https://github.com/qutip/qutip/pull/889:168,Deployability,update,update,168,"It is about time that we made the 4.3 release, @ajgpitch @nonhermitian. Could you please check and merge this? I will build the 4.3 dist and the documentation and then update pip and the conda-forge version. We have the new scattering module and PIQS in this version.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/889
https://github.com/qutip/qutip/pull/890:20,Deployability,release,release,20,We are making a 4.3 release so that master is bumped to 4.4 now. @ajgpitch,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/890
https://github.com/qutip/qutip/issues/891:79,Availability,error,error,79,"Running this code; ```; import qutip.testing as qt; qt.run(); ```; produces an error:; ```; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""qutip/__init__.py"", line 171, in <module>; from qutip.qobj import *; File ""qutip/qobj.py"", line 60, in <module>; from qutip.fastsparse import fast_csr_matrix, fast_identity; File ""qutip/fastsparse.py"", line 406, in <module>; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult); File ""qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; ImportError: No module named spmatfuncs; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/891
https://github.com/qutip/qutip/issues/891:37,Testability,test,testing,37,"Running this code; ```; import qutip.testing as qt; qt.run(); ```; produces an error:; ```; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""qutip/__init__.py"", line 171, in <module>; from qutip.qobj import *; File ""qutip/qobj.py"", line 60, in <module>; from qutip.fastsparse import fast_csr_matrix, fast_identity; File ""qutip/fastsparse.py"", line 406, in <module>; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult); File ""qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; ImportError: No module named spmatfuncs; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/891
https://github.com/qutip/qutip/pull/896:12,Deployability,update,update,12,This is the update which fixes the inclusion of .pyx files when qutip source distribution is generated by sdist in the presence of MANIFEST.in. More discussions in #894,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/896
https://github.com/qutip/qutip/pull/897:12,Deployability,update,update,12,This is the update which fixes the inclusion of .pyx files when qutip source distribution is generated by sdist in the presence of MANIFEST.in. More discussions in #894,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/897
https://github.com/qutip/qutip/issues/898:2234,Integrability,depend,depend,2234,"p.pi * sigmax() # H2 applied for time 0.5 results in a full spin flip; H = [[H1, on_off_signal],; [H2, off_on_signal]]. ### Start in a Z basis state. psi0 = basis(2,0). ### Set the collapse operator as the zero matrix (since 1/T_dephasing = 0). T_dephasing = np.inf; c_ops = (1/T_dephasing) * sigmaz(). ### Run simulation. tlist = np.linspace(0, 2, 10000); e_ops = [sigmaz()]; output = mesolve(H, psi0, tlist, c_ops = c_ops, e_ops = e_ops); Z_expectation = output.expect[0]; ```. ### Notes on system:. - The Hamiltonian is periodic and formed of two-pulses.; - H2 applies a full spin flip when applied for time 0.5, so if we start in a Z basis state then Z_expectation should change from +1 to -1 or vice versa. ### Problem:. - When I set c_ops = [], I get the expected behaviour of Z_expectation.; - When I set c_ops to be the zero matrix as in the code above, Z_expectation remains constant, even though this should give exactly the same result as setting c_ops = [].; - This effect seems to depend on the choice of initial state. For a random pure state, setting c_ops to be the zero matrix seems to give the correct result, but for a Z basis state I get the inconsistency.; - This effect is not reproduced by the Monte Carlo based solver, mcsolve. However, I would like to use mesolve if possible because it is much faster for the systems I am considering. ### Some further notes:. - I think this is something to do with the fact that the Hamiltonian is time-dependent. ; - If I just simulate H2, then Z_expectation oscillates as expected. ; - Additionally, if I swap the order of H1 and H2 in the Hamiltonian, then I get the correct result.; - Setting c_ops as the zero matrix results in a much quicker simulation time than setting c_ops = []. This seems somewhat counter-intuitive, since I thought setting c_ops as the zero matrix would force the program to simulate the evolution of the density matrix rather than the state vector.; - Given this, I wonder if mesolve is making an approximation ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/898
https://github.com/qutip/qutip/issues/898:2703,Integrability,depend,dependent,2703,"np.inf; c_ops = (1/T_dephasing) * sigmaz(). ### Run simulation. tlist = np.linspace(0, 2, 10000); e_ops = [sigmaz()]; output = mesolve(H, psi0, tlist, c_ops = c_ops, e_ops = e_ops); Z_expectation = output.expect[0]; ```. ### Notes on system:. - The Hamiltonian is periodic and formed of two-pulses.; - H2 applies a full spin flip when applied for time 0.5, so if we start in a Z basis state then Z_expectation should change from +1 to -1 or vice versa. ### Problem:. - When I set c_ops = [], I get the expected behaviour of Z_expectation.; - When I set c_ops to be the zero matrix as in the code above, Z_expectation remains constant, even though this should give exactly the same result as setting c_ops = [].; - This effect seems to depend on the choice of initial state. For a random pure state, setting c_ops to be the zero matrix seems to give the correct result, but for a Z basis state I get the inconsistency.; - This effect is not reproduced by the Monte Carlo based solver, mcsolve. However, I would like to use mesolve if possible because it is much faster for the systems I am considering. ### Some further notes:. - I think this is something to do with the fact that the Hamiltonian is time-dependent. ; - If I just simulate H2, then Z_expectation oscillates as expected. ; - Additionally, if I swap the order of H1 and H2 in the Hamiltonian, then I get the correct result.; - Setting c_ops as the zero matrix results in a much quicker simulation time than setting c_ops = []. This seems somewhat counter-intuitive, since I thought setting c_ops as the zero matrix would force the program to simulate the evolution of the density matrix rather than the state vector.; - Given this, I wonder if mesolve is making an approximation to speed up the calculation which is not valid here. I would very much appreciate any insights into where this inconsistency comes from, and how to fix it. Since mcsolve does not reproduce it, I think this might be an issue with mesolve. Many thanks,. Oliver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/898
https://github.com/qutip/qutip/issues/898:837,Performance,optimiz,optimize,837,"(Apologies: this is a repost from the QuTiP Google group, but since this seems to be a possible bug with mesolve, I figured it was more appropriate to post it here. See the Google post [here](https://groups.google.com/forum/#!topic/qutip/KKqHcZxiAmg) for some images documenting this issue.). Hello,. I'm trying to simulate a system of qubits with a two-pulse periodic Hamiltonian and some dissipation using QuTiP's mesolve function. As a consistency check, I compared the results of setting c_ops = [], and setting c_ops as the zero matrix. These should give the same results, yet for certain basis states, setting c_ops as the zero matrix seems to give the wrong result. Here is a minimum working example that reproduces the effect:. ```; import numpy as np; from qutip import sigmax, sigmaz, mesolve, basis; from scipy import signal, optimize. ### Function definitions. def on_off_signal(t):; """"""; Generate a periodic signal that is +1 for half a period and 0 for the other half.; """""". return (1 + signal.square(2 * np.pi * t))/2. def off_on_signal(t):; """"""; Generate a periodic signal that is 0 for half a period and +1 for the other half.; """""". return (1 - signal.square(2 * np.pi * t))/2. ### Define Hamiltonian. H1 = sigmaz(); H2 = np.pi * sigmax() # H2 applied for time 0.5 results in a full spin flip; H = [[H1, on_off_signal],; [H2, off_on_signal]]. ### Start in a Z basis state. psi0 = basis(2,0). ### Set the collapse operator as the zero matrix (since 1/T_dephasing = 0). T_dephasing = np.inf; c_ops = (1/T_dephasing) * sigmaz(). ### Run simulation. tlist = np.linspace(0, 2, 10000); e_ops = [sigmaz()]; output = mesolve(H, psi0, tlist, c_ops = c_ops, e_ops = e_ops); Z_expectation = output.expect[0]; ```. ### Notes on system:. - The Hamiltonian is periodic and formed of two-pulses.; - H2 applies a full spin flip when applied for time 0.5, so if we start in a Z basis state then Z_expectation should change from +1 to -1 or vice versa. ### Problem:. - When I set c_ops = [], I get the ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/898
https://github.com/qutip/qutip/issues/898:3017,Usability,intuit,intuitive,3017,"np.inf; c_ops = (1/T_dephasing) * sigmaz(). ### Run simulation. tlist = np.linspace(0, 2, 10000); e_ops = [sigmaz()]; output = mesolve(H, psi0, tlist, c_ops = c_ops, e_ops = e_ops); Z_expectation = output.expect[0]; ```. ### Notes on system:. - The Hamiltonian is periodic and formed of two-pulses.; - H2 applies a full spin flip when applied for time 0.5, so if we start in a Z basis state then Z_expectation should change from +1 to -1 or vice versa. ### Problem:. - When I set c_ops = [], I get the expected behaviour of Z_expectation.; - When I set c_ops to be the zero matrix as in the code above, Z_expectation remains constant, even though this should give exactly the same result as setting c_ops = [].; - This effect seems to depend on the choice of initial state. For a random pure state, setting c_ops to be the zero matrix seems to give the correct result, but for a Z basis state I get the inconsistency.; - This effect is not reproduced by the Monte Carlo based solver, mcsolve. However, I would like to use mesolve if possible because it is much faster for the systems I am considering. ### Some further notes:. - I think this is something to do with the fact that the Hamiltonian is time-dependent. ; - If I just simulate H2, then Z_expectation oscillates as expected. ; - Additionally, if I swap the order of H1 and H2 in the Hamiltonian, then I get the correct result.; - Setting c_ops as the zero matrix results in a much quicker simulation time than setting c_ops = []. This seems somewhat counter-intuitive, since I thought setting c_ops as the zero matrix would force the program to simulate the evolution of the density matrix rather than the state vector.; - Given this, I wonder if mesolve is making an approximation to speed up the calculation which is not valid here. I would very much appreciate any insights into where this inconsistency comes from, and how to fix it. Since mcsolve does not reproduce it, I think this might be an issue with mesolve. Many thanks,. Oliver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/898
