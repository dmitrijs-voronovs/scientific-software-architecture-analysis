quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Availability,avail,available,"emove the last n template arguments from the name. ;  ; void ReplaceAll (std::string &str, const std::string &from, const std::string &to, bool recurse=false);  ; bool RequireCompleteType (const cling::Interpreter &interp, clang::SourceLocation Loc, clang::QualType Type);  ; bool RequireCompleteType (const cling::Interpreter &interp, const clang::CXXRecordDecl *cl);  ; clang::QualType ReSubstTemplateArg (clang::QualType input, const clang::Type *instance);  Check if 'input' or any of its template parameter was substituted when instantiating the class template instance and replace it with the partially sugared types we have from 'instance'. ;  ; const clang::CXXRecordDecl * ScopeSearch (const char *name, const cling::Interpreter &gInterp, bool diagnose, const clang::Type **resultType);  Return the scope corresponding to 'name' or std::'name'. ;  ; void SetPathsForRelocatability (std::vector< std::string > &clingArgs);  Organise the parameters for cling in order to guarantee relocatability It treats the gcc toolchain and the root include path FIXME: enables relocatability for experiments' framework headers until PCMs are available. ;  ; const char * ShortTypeName (const char *typeDesc);  Return the absolute type of typeDesc. ;  ; std::string ShortTypeName (const clang::FieldDecl &m);  Return the absolute type of typeDesc. ;  ; ROOT::ESTLType STLKind (const llvm::StringRef type);  Converts STL container name to number. vector -> 1, etc.. ;  ; void SysError (const char *location, const char *fmt,...);  ; std::string TrueName (const clang::FieldDecl &m);  TrueName strips the typedefs and array dimensions. ;  ; void Warning (const char *location, const char *fmt,...);  ; void WriteAuxFunctions (std::ostream &finalString, const AnnotatedRecordDecl &cl, const clang::CXXRecordDecl *decl, const cling::Interpreter &interp, const RConstructorTypes &ctorTypes, const TNormalizedCtxt &normCtxt);  std::string NormalizedName; GetNormalizedName(NormalizedName, decl->getASTContext().g",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Deployability,update,updated,"). const clang::FunctionDecl * ROOT::TMetaUtils::ClassInfo__HasMethod ; (; const clang::DeclContext * ; cl, . char const * ; name, . const cling::Interpreter & ; interp . ). Definition at line 762 of file TClingUtils.cxx. ◆ DataMemberInfo__ValidArrayIndex(). llvm::StringRef ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex ; (; const cling::Interpreter & ; interp, . const clang::DeclaratorDecl & ; m, . int * ; errnum = nullptr, . llvm::StringRef * ; errstr = nullptr . ). ValidArrayIndex return a static string (so use it or copy it immediatly, do not call GrabIndex twice in the same expression) containing the size of the array data member. ; In case of error, or if the size is not specified, GrabIndex returns 0. If errnum is not null, *errnum updated with the error number: Cint::G__DataMemberInfo::G__VALID : valid array index Cint::G__DataMemberInfo::G__NOT_INT : array index is not an int Cint::G__DataMemberInfo::G__NOT_DEF : index not defined before array (this IS an error for streaming to disk) Cint::G__DataMemberInfo::G__IS_PRIVATE: index exist in a parent class but is private Cint::G__DataMemberInfo::G__UNKNOWN : index is not known If errstr is not null, *errstr is updated with the address of a static string containing the part of the index with is invalid. ; Definition at line 3118 of file TClingUtils.cxx. ◆ DemangleNameForDlsym(). static std::string ROOT::TMetaUtils::DemangleNameForDlsym ; (; const std::string & ; name). inlinestatic . Definition at line 597 of file TClingUtils.h. ◆ ElementStreamer(). int ROOT::TMetaUtils::ElementStreamer ; (; std::ostream & ; finalString, . const clang::NamedDecl & ; forcontext, . const clang::QualType & ; qti, . const char * ; t, . int ; rwmode, . const cling::Interpreter & ; interp, . const char * ; tcl = nullptr . ). Definition at line 861 of file TClingUtils.cxx. ◆ EndsWith(). bool ROOT::TMetaUtils::EndsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5124 of file TCli",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Integrability,rout,routine,"sts and is public. ;  ; const clang::FunctionDecl * ClassInfo__HasMethod (const clang::DeclContext *cl, char const *, const cling::Interpreter &interp);  ; llvm::StringRef DataMemberInfo__ValidArrayIndex (const cling::Interpreter &interp, const clang::DeclaratorDecl &m, int *errnum=nullptr, llvm::StringRef *errstr=nullptr);  ValidArrayIndex return a static string (so use it or copy it immediatly, do not call GrabIndex twice in the same expression) containing the size of the array data member. ;  ; static std::string DemangleNameForDlsym (const std::string &name);  ; int ElementStreamer (std::ostream &finalString, const clang::NamedDecl &forcontext, const clang::QualType &qti, const char *t, int rwmode, const cling::Interpreter &interp, const char *tcl=nullptr);  ; bool EndsWith (const std::string &theString, const std::string &theSubstring);  ; void Error (const char *location, const char *fmt,...);  ; bool ExtractAttrIntPropertyFromName (const clang::Decl &decl, const std::string &propName, int &propValue);  This routine counts on the ""propName<separator>propValue"" format. ;  ; bool ExtractAttrPropertyFromName (const clang::Decl &decl, const std::string &propName, std::string &propValue);  This routine counts on the ""propName<separator>propValue"" format. ;  ; int extractAttrString (clang::Attr *attribute, std::string &attrString);  Extract attr string. ;  ; void ExtractCtxtEnclosingNameSpaces (const clang::DeclContext &, std::list< std::pair< std::string, bool > > &);  Extract enclosing namespaces recursively. ;  ; void ExtractEnclosingNameSpaces (const clang::Decl &, std::list< std::pair< std::string, bool > > &);  Extract the immediately outer namespace and then launch the recursion. ;  ; const clang::RecordDecl * ExtractEnclosingScopes (const clang::Decl &decl, std::list< std::pair< std::string, unsigned int > > &enclosingSc);  Extract the names and types of containing scopes. ;  ; int extractPropertyNameVal (clang::Attr *attribute, std::string &attrName, std::s",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Modifiability,inherit,inherit,"d::string &propName, std::string &propValue);  This routine counts on the ""propName<separator>propValue"" format. ;  ; int extractAttrString (clang::Attr *attribute, std::string &attrString);  Extract attr string. ;  ; void ExtractCtxtEnclosingNameSpaces (const clang::DeclContext &, std::list< std::pair< std::string, bool > > &);  Extract enclosing namespaces recursively. ;  ; void ExtractEnclosingNameSpaces (const clang::Decl &, std::list< std::pair< std::string, bool > > &);  Extract the immediately outer namespace and then launch the recursion. ;  ; const clang::RecordDecl * ExtractEnclosingScopes (const clang::Decl &decl, std::list< std::pair< std::string, unsigned int > > &enclosingSc);  Extract the names and types of containing scopes. ;  ; int extractPropertyNameVal (clang::Attr *attribute, std::string &attrName, std::string &attrValue);  ; int extractPropertyNameValFromString (const std::string attributeStr, std::string &attrName, std::string &attrValue);  ; clang::TemplateName ExtractTemplateNameFromQualType (const clang::QualType &qt);  These manipulations are necessary because a template specialisation type does not inherit from a record type (there is an asymmetry between the decls and the types in the clang interface). ;  ; void Fatal (const char *location, const char *fmt,...);  ; void foreachHeaderInModule (const clang::Module &module, const std::function< void(const clang::Module::Header &)> &closure, bool includeDirectlyUsedModules=true);  Calls the given lambda on every header in the given module. ;  ; const clang::TagDecl * GetAnnotatedRedeclarable (const clang::TagDecl *TND);  ; const clang::TypedefNameDecl * GetAnnotatedRedeclarable (const clang::TypedefNameDecl *TND);  ; template<typename T > ; const T * GetAnnotatedRedeclarable (const T *Redecl);  ; llvm::StringRef GetClassComment (const clang::CXXRecordDecl &decl, clang::SourceLocation *loc, const cling::Interpreter &interpreter);  Return the class comment after the ClassDef: class MyClass { .",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Performance,cache,cache,"ion at line 4106 of file TClingUtils.cxx. ◆ GetNameWithinNamespace(). bool ROOT::TMetaUtils::GetNameWithinNamespace ; (; std::string & ; fullname, . std::string & ; clsname, . std::string & ; nsname, . clang::CXXRecordDecl const * ; cl . ). Return true if one of the class' enclosing scope is a namespace and set fullname to the fully qualified name, clsname to the name within a namespace and nsname to the namespace fully qualified name. ; Definition at line 2197 of file TClingUtils.cxx. ◆ GetNormalizedName() [1/2]. void ROOT::TMetaUtils::GetNormalizedName ; (; std::string & ; norm_name, . const clang::QualType & ; type, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Return the type name normalized for ROOT, keeping only the ROOT opaque typedef (Double32_t, etc.) and adding default template argument for all types except the STL collections where we remove the default template argument if any. ; This routine might actually belong in the interpreter because cache the clang::Type might be intepreter specific. ; Definition at line 4049 of file TClingUtils.cxx. ◆ GetNormalizedName() [2/2]. void ROOT::TMetaUtils::GetNormalizedName ; (; std::string & ; norm_name, . const clang::TypeDecl * ; typeDecl, . const cling::Interpreter & ; interpreter . ). Definition at line 4089 of file TClingUtils.cxx. ◆ GetNormalizedType(). clang::QualType ROOT::TMetaUtils::GetNormalizedType ; (; const clang::QualType & ; type, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Return the type normalized for ROOT, keeping only the ROOT opaque typedef (Double32_t, etc.) and adding default template argument for all types except those explicitly requested to be drop by the user. ; Default template for STL collections are not yet removed by this routine. ; Definition at line 4023 of file TClingUtils.cxx. ◆ GetNumberOfErrors(). unsigned int & ROOT::TMetaUtils::GetNumberOfErrors ; (; ). inline . Definition at line 779 of file TCli",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Safety,safe,safely,"at line 344 of file TClingUtils.h. Enumeration Type Documentation. ◆ DataMemberInfo__ValidArrayIndex_error_code. enum ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex_error_code. EnumeratorVALID ; NOT_INT ; NOT_DEF ; IS_PRIVATE ; UNKNOWN . Definition at line 118 of file TClingUtils.h. ◆ EIOCtorCategory. enum class ROOT::TMetaUtils::EIOCtorCategory : short. strong . EnumeratorkAbsent ; kDefault ; kIOPtrType ; kIORefType . Definition at line 382 of file TClingUtils.h. Function Documentation. ◆ AddDefaultParameters(). clang::QualType ROOT::TMetaUtils::AddDefaultParameters ; (; clang::QualType ; instanceType, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ; Note: this does not strip any typedef but could be merged with cling::utils::Transform::GetPartiallyDesugaredType if we can safely replace TClassEdit::IsStd with a test on the declaring scope and if we can resolve the fact that the added parameter do not take into account possible use/dependences on Double32_t and if we decide that adding the default is the right long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2892 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5135 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1119 of file TClingUtils.cxx. ◆ CheckDefaultCons",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Security,access,accessible,"TNormalizedCtxt &normCtxt, std::ostream &dictStream, bool isAutoStreamer);  ; typedef std::list< RConstructorType > RConstructorTypes;  . Enumerations; enum  DataMemberInfo__ValidArrayIndex_error_code { ;   VALID; , NOT_INT; , NOT_DEF; , IS_PRIVATE; , ;   UNKNOWN. };  ; enum class  EIOCtorCategory : short { kAbsent; , kDefault; , kIOPtrType; , kIORefType; };  . Functions; clang::QualType AddDefaultParameters (clang::QualType instanceType, const cling::Interpreter &interpret, const TNormalizedCtxt &normCtxt);  Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ;  ; bool BeginsWith (const std::string &theString, const std::string &theSubstring);  ; EIOCtorCategory CheckConstructor (const clang::CXXRecordDecl *, const RConstructorType &, const cling::Interpreter &interp);  Check if class has constructor of provided type - either default or with single argument. ;  ; bool CheckDefaultConstructor (const clang::CXXRecordDecl *, const cling::Interpreter &interp);  Checks if default constructor exists and accessible. ;  ; EIOCtorCategory CheckIOConstructor (const clang::CXXRecordDecl *, const char *, const clang::CXXRecordDecl *, const cling::Interpreter &interp);  Checks IO constructor - must be public and with specified argument. ;  ; bool CheckPublicFuncWithProto (clang::CXXRecordDecl const *, char const *, char const *, const cling::Interpreter &, bool diagnose);  Return true, if the function (defined by the name and prototype) exists and is public. ;  ; const clang::FunctionDecl * ClassInfo__HasMethod (const clang::DeclContext *cl, char const *, const cling::Interpreter &interp);  ; llvm::StringRef DataMemberInfo__ValidArrayIndex (const cling::Interpreter &interp, const clang::DeclaratorDecl &m, int *errnum=nullptr, llvm::StringRef *errstr=nullptr);  ValidArrayIndex return a static string (so use it or copy it immediatly, do not call GrabIndex twice in the same expression) containing the size of the array data member",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Testability,test,test,"at line 344 of file TClingUtils.h. Enumeration Type Documentation. ◆ DataMemberInfo__ValidArrayIndex_error_code. enum ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex_error_code. EnumeratorVALID ; NOT_INT ; NOT_DEF ; IS_PRIVATE ; UNKNOWN . Definition at line 118 of file TClingUtils.h. ◆ EIOCtorCategory. enum class ROOT::TMetaUtils::EIOCtorCategory : short. strong . EnumeratorkAbsent ; kDefault ; kIOPtrType ; kIORefType . Definition at line 382 of file TClingUtils.h. Function Documentation. ◆ AddDefaultParameters(). clang::QualType ROOT::TMetaUtils::AddDefaultParameters ; (; clang::QualType ; instanceType, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ; Note: this does not strip any typedef but could be merged with cling::utils::Transform::GetPartiallyDesugaredType if we can safely replace TClassEdit::IsStd with a test on the declaring scope and if we can resolve the fact that the added parameter do not take into account possible use/dependences on Double32_t and if we decide that adding the default is the right long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2892 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5135 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1119 of file TClingUtils.cxx. ◆ CheckDefaultCons",MatchSource.WIKI,doc/master/namespaceROOT_1_1TMetaUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html
Usability,simpl,simple,". ROOT: ROOT::TreeUtils Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Functions ; ROOT::TreeUtils Namespace Reference. Classes; struct  InvalidTupleType;  ; struct  InvalidTupleType< TNtuple >;  ; struct  InvalidTupleType< TNtupleD >;  ; struct  RFriendInfo;  Information about friend trees of a certain TTree or TChain object. More...;  . Functions; template<class DataType , class Tuple > ; Long64_t FillNtupleFromStream (std::istream &inputStream, Tuple &tuple, char delimiter, bool strictMode);  Function to fill tuples (TNtuple/TNtupleD) from a simple ASCII data file. ;  ; template Long64_t FillNtupleFromStream< Double_t, TNtupleD > (std::istream &, TNtupleD &, char, bool);  ; template Long64_t FillNtupleFromStream< Float_t, TNtuple > (std::istream &, TNtuple &, char, bool);  ; bool NextCharacterIsEOL (std::istream &input);  Either '\r' | '\n' or eof of some problem. ;  ; void SkipComment (std::istream &input);  Skips everything from '#' to (including) '\r' or '\n'. ;  ; void SkipEmptyLines (std::istream &input);  Skips empty lines (newline-characters), ws-lines (consisting only of whitespace characters + newline-characters). ;  ; void SkipWSCharacters (std::istream &input);  Skip whitespace characters, but not newline-characters we support ('\r' or '\n'). ;  . Function Documentation. ◆ FillNtupleFromStream(). template<class DataType , class Tuple > . Long64_t ROOT::TreeUtils::FillNtupleFromStream ; (; std::istream & ; inputStream, . Tuple & ; tuple, . char ; delimiter, . bool ; strictMode . ). Function to fill tuples (TNtuple/TNtupleD) from a simple ASCII data file. ; With auto and decltype - we can get rid of DataType parameter :) (or with a simple typedef inside ntuple class). An input file consists of non-empty lines (separated by newline-characters), possibly empty lines, and comments (treated as empty lines). Each non-empty line should contain N numbers - entry for a tuple. Non-strict mode lets y",MatchSource.WIKI,doc/master/namespaceROOT_1_1TreeUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TreeUtils.html
Testability,log,log,"e<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > fmod (const T0 &x, const RVec< T1 > &v);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > fmod (const RVec< T0 > &v, const T1 &y);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > fmod (const RVec< T0 > &v0, const RVec< T1 > &v1);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > remainder (const T0 &x, const RVec< T1 > &v);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > remainder (const RVec< T0 > &v, const T1 &y);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > remainder (const RVec< T0 > &v0, const RVec< T1 > &v1);  ; template<typename T > ; RVec< PromoteType< T > > exp (const RVec< T > &v);  ; template<typename T > ; RVec< PromoteType< T > > exp2 (const RVec< T > &v);  ; template<typename T > ; RVec< PromoteType< T > > expm1 (const RVec< T > &v);  ; template<typename T > ; RVec< PromoteType< T > > log (const RVec< T > &v);  ; template<typename T > ; RVec< PromoteType< T > > log10 (const RVec< T > &v);  ; template<typename T > ; RVec< PromoteType< T > > log2 (const RVec< T > &v);  ; template<typename T > ; RVec< PromoteType< T > > log1p (const RVec< T > &v);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > pow (const T0 &x, const RVec< T1 > &v);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > pow (const RVec< T0 > &v, const T1 &y);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > pow (const RVec< T0 > &v0, const RVec< T1 > &v1);  ; template<typename T > ; RVec< PromoteType< T > > sqrt (const RVec< T > &v);  ; template<typename T > ; RVec< PromoteType< T > > cbrt (const RVec< T > &v);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > hypot (const T0 &x, const RVec< T1 > &v);  ; template<typename T0 , typename T1 > ; RVec< PromoteTypes< T0, T1 > > hypot (const RVec< T0 > &v, const T1 &y); ",MatchSource.WIKI,doc/master/namespaceROOT_1_1VecOps.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1VecOps.html
Availability,redundant,redundant,";   kInnerClass = 1<<3; , kInnedMostClass = 1<<4; , kDropStlDefault = 1<<5; , kDropComparator = 1<<6; , ;   kDropAllDefault = 1<<7; , kLong64 = 1<<8; , kDropStd = 1<<9; , kKeepOuterConst = 1<<10; , ;   kResolveTypedef = 1<<11; , kDropPredicate = 1<<12; , kDropHash = 1<<13. };  ; enum  ESTLType { ;   kNotSTL = ROOT::kNotSTL; , kVector = ROOT::kSTLvector; , kList = ROOT::kSTLlist; , kForwardlist = ROOT::kSTLforwardlist; , ;   kDeque = ROOT::kSTLdeque; , kMap = ROOT::kSTLmap; , kMultiMap = ROOT::kSTLmultimap; , kSet = ROOT::kSTLset; , ;   kMultiSet = ROOT::kSTLmultiset; , kUnorderedSet = ROOT::kSTLunorderedset; , kUnorderedMultiSet = ROOT::kSTLunorderedmultiset; , kUnorderedMap = ROOT::kSTLunorderedmap; , ;   kUnorderedMultiMap = ROOT::kSTLunorderedmultimap; , kBitSet = ROOT::kSTLbitset; , kEnd = ROOT::kSTLend. };  . Functions; std::string CleanType (const char *typeDesc, int mode=0, const char **tail=nullptr);  Cleanup type description, redundant blanks removed and redundant tail ignored return *tail = pointer to last used character if (mode==0) keep keywords if (mode==1) remove keywords outside the template params if (mode>=2) remove the keywords everywhere. ;  ; char * DemangleName (const char *mangled_name, int &errorCode);  ; char * DemangleTypeIdName (const std::type_info &ti, int &errorCode);  Demangle in a portable way the type id name. ;  ; EComplexType GetComplexType (const char *);  ; std::string GetLong64_Name (const char *original);  Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ;  ; std::string GetLong64_Name (const std::string &original);  Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ;  ; std::string GetNameForIO (const std::string &templateInstanceName, TClassEdit::EModType mode=TClassEdit::kNone, bool *hasChanged=nullptr);  ; void GetNormalizedName (std::string &norm_name, std::string_view name);  Return the normalized name. ;  ; int GetSplit (const char *type, std::vector< std::string > &out",MatchSource.WIKI,doc/master/namespaceTClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html
Integrability,rout,routines," ; original). Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ; Definition at line 908 of file TClassEdit.cxx. ◆ GetLong64_Name() [2/2]. string TClassEdit::GetLong64_Name ; (; const std::string & ; original). Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ; Definition at line 919 of file TClassEdit.cxx. ◆ GetNameForIO(). std::string TClassEdit::GetNameForIO ; (; const std::string & ; templateInstanceName, . TClassEdit::EModType ; mode = TClassEdit::kNone, . bool * ; hasChanged = nullptr . ). Definition at line 2095 of file TClassEdit.cxx. ◆ GetNormalizedName(). void TClassEdit::GetNormalizedName ; (; std::string & ; norm_name, . std::string_view ; name . ). Return the normalized name. ; See TMetaUtils::GetNormalizedName.; Return the type name normalized for ROOT, keeping only the ROOT opaque typedef (Double32_t, etc.) and removing the STL collections default parameter if any.; Compare to TMetaUtils::GetNormalizedName, this routines does not and can not add default template parameters. ; Definition at line 854 of file TClassEdit.cxx. ◆ GetSplit(). int TClassEdit::GetSplit ; (; const char * ; type, . std::vector< std::string > & ; output, . int & ; nestedLoc, . EModType ; mode = TClassEdit::kNone . ). Stores in output (after emptying it) the split type. ; Stores the location of the tail (nested names) in nestedLoc (0 indicates no tail). Return the number of elements stored.; First in list is the template name or is empty ""vector<list<int>,alloc>**"" to ""vector"" ""list<int>"" ""alloc"" ""**"" or ""TNamed*"" to """" ""TNamed"" ""*"" ; Definition at line 1029 of file TClassEdit.cxx. ◆ GetStdArrayProperties(). bool TClassEdit::GetStdArrayProperties ; (; const char * ; typeName, . std::string & ; typeNameBuf, . std::array< int, 5 > & ; maxIndices, . int & ; ndim . ). Definition at line 2117 of file TClassEdit.cxx. ◆ GetUniquePtrType(). std::string TClassEdit::GetUniquePtrType ; (; std::string_view ; name). inline . Definition at lin",MatchSource.WIKI,doc/master/namespaceTClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html
Modifiability,portab,portable,"<13. };  ; enum  ESTLType { ;   kNotSTL = ROOT::kNotSTL; , kVector = ROOT::kSTLvector; , kList = ROOT::kSTLlist; , kForwardlist = ROOT::kSTLforwardlist; , ;   kDeque = ROOT::kSTLdeque; , kMap = ROOT::kSTLmap; , kMultiMap = ROOT::kSTLmultimap; , kSet = ROOT::kSTLset; , ;   kMultiSet = ROOT::kSTLmultiset; , kUnorderedSet = ROOT::kSTLunorderedset; , kUnorderedMultiSet = ROOT::kSTLunorderedmultiset; , kUnorderedMap = ROOT::kSTLunorderedmap; , ;   kUnorderedMultiMap = ROOT::kSTLunorderedmultimap; , kBitSet = ROOT::kSTLbitset; , kEnd = ROOT::kSTLend. };  . Functions; std::string CleanType (const char *typeDesc, int mode=0, const char **tail=nullptr);  Cleanup type description, redundant blanks removed and redundant tail ignored return *tail = pointer to last used character if (mode==0) keep keywords if (mode==1) remove keywords outside the template params if (mode>=2) remove the keywords everywhere. ;  ; char * DemangleName (const char *mangled_name, int &errorCode);  ; char * DemangleTypeIdName (const std::type_info &ti, int &errorCode);  Demangle in a portable way the type id name. ;  ; EComplexType GetComplexType (const char *);  ; std::string GetLong64_Name (const char *original);  Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ;  ; std::string GetLong64_Name (const std::string &original);  Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ;  ; std::string GetNameForIO (const std::string &templateInstanceName, TClassEdit::EModType mode=TClassEdit::kNone, bool *hasChanged=nullptr);  ; void GetNormalizedName (std::string &norm_name, std::string_view name);  Return the normalized name. ;  ; int GetSplit (const char *type, std::vector< std::string > &output, int &nestedLoc, EModType mode=TClassEdit::kNone);  Stores in output (after emptying it) the split type. ;  ; bool GetStdArrayProperties (const char *typeName, std::string &typeNameBuf, std::array< int, 5 > &maxIndices, int &ndim);  ; std::string GetUniquePtrType (",MatchSource.WIKI,doc/master/namespaceTClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html
Safety,redund,redundant,";   kInnerClass = 1<<3; , kInnedMostClass = 1<<4; , kDropStlDefault = 1<<5; , kDropComparator = 1<<6; , ;   kDropAllDefault = 1<<7; , kLong64 = 1<<8; , kDropStd = 1<<9; , kKeepOuterConst = 1<<10; , ;   kResolveTypedef = 1<<11; , kDropPredicate = 1<<12; , kDropHash = 1<<13. };  ; enum  ESTLType { ;   kNotSTL = ROOT::kNotSTL; , kVector = ROOT::kSTLvector; , kList = ROOT::kSTLlist; , kForwardlist = ROOT::kSTLforwardlist; , ;   kDeque = ROOT::kSTLdeque; , kMap = ROOT::kSTLmap; , kMultiMap = ROOT::kSTLmultimap; , kSet = ROOT::kSTLset; , ;   kMultiSet = ROOT::kSTLmultiset; , kUnorderedSet = ROOT::kSTLunorderedset; , kUnorderedMultiSet = ROOT::kSTLunorderedmultiset; , kUnorderedMap = ROOT::kSTLunorderedmap; , ;   kUnorderedMultiMap = ROOT::kSTLunorderedmultimap; , kBitSet = ROOT::kSTLbitset; , kEnd = ROOT::kSTLend. };  . Functions; std::string CleanType (const char *typeDesc, int mode=0, const char **tail=nullptr);  Cleanup type description, redundant blanks removed and redundant tail ignored return *tail = pointer to last used character if (mode==0) keep keywords if (mode==1) remove keywords outside the template params if (mode>=2) remove the keywords everywhere. ;  ; char * DemangleName (const char *mangled_name, int &errorCode);  ; char * DemangleTypeIdName (const std::type_info &ti, int &errorCode);  Demangle in a portable way the type id name. ;  ; EComplexType GetComplexType (const char *);  ; std::string GetLong64_Name (const char *original);  Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ;  ; std::string GetLong64_Name (const std::string &original);  Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ;  ; std::string GetNameForIO (const std::string &templateInstanceName, TClassEdit::EModType mode=TClassEdit::kNone, bool *hasChanged=nullptr);  ; void GetNormalizedName (std::string &norm_name, std::string_view name);  Return the normalized name. ;  ; int GetSplit (const char *type, std::vector< std::string > &out",MatchSource.WIKI,doc/master/namespaceTClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html
Security,hash,hashname,"or< std::string > &output, int &nestedLoc, EModType mode=TClassEdit::kNone);  Stores in output (after emptying it) the split type. ;  ; bool GetStdArrayProperties (const char *typeName, std::string &typeNameBuf, std::array< int, 5 > &maxIndices, int &ndim);  ; std::string GetUniquePtrType (std::string_view name);  ; const char * GetUnqualifiedName (const char *name);  Return the start of the unqualified name include in 'original'. ;  ; void Init (TClassEdit::TInterpreterLookupHelper *helper);  ; std::string InsertStd (const char *tname);  ; bool IsArtificial (std::string_view name);  ; bool IsDefAlloc (const char *alloc, const char *classname);  return whether or not 'allocname' is the STL default allocator for type 'classname' ;  ; bool IsDefAlloc (const char *alloc, const char *keyclassname, const char *valueclassname);  return whether or not 'allocname' is the STL default allocator for a key of type 'keyclassname' and a value of type 'valueclassname' ;  ; bool IsDefComp (const char *comp, const char *classname);  return whether or not 'compare' is the STL default comparator for type 'classname' ;  ; bool IsDefHash (const char *hashname, const char *classname);  return whether or not 'hashname' is the STL default hash for type 'classname' ;  ; bool IsDefPred (const char *predname, const char *classname);  return whether or not 'predname' is the STL default predicate for type 'classname' ;  ; bool IsInterpreterDetail (const char *type);  Return true if the type is one the interpreter details which are only forward declared (ClassInfo_t etc..) ;  ; bool IsStdArray (std::string_view name);  ; bool IsStdClass (const char *type);  return true if the class belongs to the std namespace ;  ; bool IsStdPair (std::string_view name);  ; bool IsStdPairBase (std::string_view name);  ; bool IsSTLBitset (const char *type);  Return true is the name is std::bitset<number> or bitset<number> ;  ; int IsSTLCont (const char *type, int testAlloc);  type : type name: vector<list<classA,a",MatchSource.WIKI,doc/master/namespaceTClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html
Testability,test,testAlloc,"classname' ;  ; bool IsDefPred (const char *predname, const char *classname);  return whether or not 'predname' is the STL default predicate for type 'classname' ;  ; bool IsInterpreterDetail (const char *type);  Return true if the type is one the interpreter details which are only forward declared (ClassInfo_t etc..) ;  ; bool IsStdArray (std::string_view name);  ; bool IsStdClass (const char *type);  return true if the class belongs to the std namespace ;  ; bool IsStdPair (std::string_view name);  ; bool IsStdPairBase (std::string_view name);  ; bool IsSTLBitset (const char *type);  Return true is the name is std::bitset<number> or bitset<number> ;  ; int IsSTLCont (const char *type, int testAlloc);  type : type name: vector<list<classA,allocator>,allocator> testAlloc: if true, we test allocator, if it is not default result is negative result: 0 : not stl container abs(result): code of container 1=vector,2=list,3=deque,4=map 5=multimap,6=set,7=multiset positive val: we have a vector or list with default allocator to any depth like vector<list<vector<int>>> negative val: STL container other than vector or list, or non default allocator For example: vector<deque<int>> has answer -1 ;  ; ROOT::ESTLType IsSTLCont (std::string_view type);  type : type name: vector<list<classA,allocator>,allocator> result: 0 : not stl container code of container 1=vector,2=list,3=deque,4=map 5=multimap,6=set,7=multiset ;  ; bool IsUniquePtr (std::string_view name);  ; bool IsVectorBool (const char *name);  ; std::string ResolveTypedef (const char *tname, bool resolveAll=false);  ; std::string ShortType (const char *typeDesc, int mode);  Return the absolute type of typeDesc. ;  ; bool SplitFunction (std::string_view decl, FunctionSplitInfo &result);  Split a function declaration into its different parts. ;  ; int STLArgs (int kind);  Return number of arguments for STL container before allocator. ;  ; ROOT::ESTLType STLKind (std::string_view type);  Converts STL container name to number.",MatchSource.WIKI,doc/master/namespaceTClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html
Availability,error,error,"nstexpr Double_t Ccgs ();  \( cm s^{-1} \) ;  ; Double_t Ceil (Double_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t E ();  Base of natural log: \( e \). ;  ; Double_t Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t EulerGamma ();  Euler-Mascheroni Constant. ;  ; Bool_t Even (Long_t a);  Returns true if a is even. ;  ; Double_t Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t Finite (Double_t x);  Check if it is finite with a mask in",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Deployability,continuous,continuous,"rr1 with arr2[0] corresponding to the largest arr1 value and arr2[Narr] the smallest. AuthorAdrian Bevan (bevan.nosp@m.@sla.nosp@m.c.sta.nosp@m.nfor.nosp@m.d.edu) ; Definition at line 1314 of file TMath.cxx. ◆ BubbleLow(). void TMath::BubbleLow ; (; Int_t ; Narr, . Double_t * ; arr1, . Int_t * ; arr2 . ). Opposite ordering of the array arr2[] to that of BubbleHigh. ; AuthorAdrian Bevan (bevan.nosp@m.@sla.nosp@m.c.sta.nosp@m.nfor.nosp@m.d.edu) ; Definition at line 1353 of file TMath.cxx. ◆ C(). constexpr Double_t TMath::C ; (; ). constexpr . Velocity of light in \( m s^{-1} \). ; Definition at line 114 of file TMath.h. ◆ CauchyDist(). Double_t TMath::CauchyDist ; (; Double_t ; x, . Double_t ; t = 0, . Double_t ; s = 1 . ). Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is used (t=0, s=1) . t is the location parameter; s is the scale parameter. The Cauchy distribution, also called Lorentzian distribution, is a continuous distribution describing resonance behavior The mean and standard deviation of the Cauchy distribution are undefined. The practical meaning of this is that collecting 1,000 data points gives no more accurate an estimate of the mean and standard deviation than does a single point. The formula was taken from ""Engineering Statistics Handbook"" on site http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();; TF11-Dim function classDefinition TF1.h:233; TF1::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF1.cxx:1333; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; AuthorAnna Kreshuk ; Definition at line 2175 of file TMath.cxx. ◆ Ccgs(). constexpr Double_t TMath::Ccgs ; (; ). constexpr . \( cm s^{-1} \) ; Definition at line 121 of file TMath.h. ◆ Ceil(). Double_t TMath::Ceil ; (; Double_t ; x).",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Energy Efficiency,power,power,"le_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t E ();  Base of natural log: \( e \). ;  ; Double_t Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t EulerGamma ();  Euler-Mascheroni Constant. ;  ; Bool_t Even (Long_t a);  Returns true if a is even. ;  ; Double_t Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t Floor (Double_t x);  Rounds x downward, returning the largest integral value that is not greater than x. ;  ; Int_t FloorNint (Double_t x);  Returns the nearest integer of TMath::Floor(x). ;  ; Double_t Freq (Double_t x);  Computation of the normal frequency function freq(x). ;  ; constexpr Dou",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Integrability,rout,routine,"vogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; Long_t NextPrime (Long_t x);  ; template<typename T > ; Int_t Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Modifiability,adapt,adapted,"vogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; Long_t NextPrime (Long_t x);  ; template<typename T > ; Int_t Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Performance,perform,perform,"rt_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; For the last case, a=b, the algorithm advances each array by one index in an attempt to move through the equality. However, this is incorrect when one or the other of a or b (or both) have a repeated value, call it x. For the KS statistic to be computed properly, rdiff needs to be calculated after all of the a and b at x have been tallied (this is due to the definition of the empirical distribution function; another way to convince yourself that the old CERNLIB method is wrong is that it implies that the function defined as the difference between a and b is multi-valued at x – besides being ugly, this would invalidate Kolmogorov's theorem).; The solution is to just add while-loops into the equality-case handling to perform the tally:; } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; xDouble_t x[n]Definition legend1.C:17. Note:; A good description of the Kolmogorov test can be seen at: http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm ; Definition at line 805 of file TMath.cxx. ◆ KOrdStat(). template<class Element , typename Size > . Element TMath::KOrdStat ; (; Size ; n, . const Element * ; a, . Size ; k, . Size * ; work = 0 . ). Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements). ; C-convention is used for array indexing, so if you want the second smallest element, call KOrdStat(n, a, 1).; If work is supplied, it is used to store the sorting index and assumed to be >= n. If work=0, local storage is used, either on the stack if n < kWorkMax or on the heap for n >= kWorkMax. Note that the work index array will not contain the sorted indices but all indices of the sma",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Security,hash,hash,"e_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE);  Calculates a gaussian function with mean and sigma. ;  ; constexpr Double_t Gcgs ();  \( cm^{3} g^{-1} s^{-2} \) ;  ; template<typename Iterator > ; Double_t GeomMean (Iterator first, Iterator last);  Returns the geometric mean of an array defined by the iterators. ;  ; template<typename T > ; Double_t GeomMean (Long64_t n, const T *a);  Returns the geometric mean of an array a of size n. ;  ; constexpr Double_t GhbarC ();  \( \frac{G}{\hbar C} \) in \( (GeV/c^{2})^{-2} \) ;  ; constexpr Double_t GhbarCUncertainty ();  \( \frac{G}{\hbar C} \) uncertainty. ;  ; constexpr Double_t Gn ();  Standard acceleration of gravity in \( m s^{-2} \). ;  ; constexpr Double_t GnUncertainty ();  Standard acceleration of gravity uncertainty. ;  ; constexpr Double_t GUncertainty ();  Gravitational constant uncertainty. ;  ; constexpr Double_t H ();  Planck's constant in \( J s \): \( h \). ;  ; ULong_t Hash (const char *str);  ; ULong_t Hash (const void *txt, Int_t ntxt);  Calculates hash index from any char string. ;  ; constexpr Double_t Hbar ();  \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ;  ; constexpr Double_t Hbarcgs ();  \( erg s \) ;  ; constexpr Double_t HbarUncertainty ();  \( \hbar \) uncertainty. ;  ; constexpr Double_t HC ();  \( hc \) in \( J m \) ;  ; constexpr Double_t HCcgs ();  \( erg cm \) ;  ; constexpr Double_t Hcgs ();  \( erg s \) ;  ; constexpr Double_t HUncertainty ();  Planck's constant uncertainty. ;  ; Double_t Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in arrays x and y, kFALSE otherwise. ;  ; Bool_t IsNaN (Dou",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Testability,log,log," by default, standard Cauchy distribution is used (t=0, s=1) ;  ; constexpr Double_t Ccgs ();  \( cm s^{-1} \) ;  ; Double_t Ceil (Double_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t E ();  Base of natural log: \( e \). ;  ; Double_t Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t EulerGamma ();  Euler-Mascheroni Constant. ;  ; Bool_t Even (Long_t a);  Returns true if a is even. ;  ; Double_t Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;",MatchSource.WIKI,doc/master/namespaceTMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMath.html
Integrability,rout,routine,"t > ; TVectorT< Element > & AddElemDiv (TVectorT< Element > &target, Element scalar, const TVectorT< Element > &source1, const TVectorT< Element > &source2, const TVectorT< Element > &select);  Modify addition: target += scalar * ElementDiv(source1,source2) only for those elements where select[i] != 0.0. ;  ; template<class Element > ; TVectorT< Element > & AddElemMult (TVectorT< Element > &target, Element scalar, const TVectorT< Element > &source1, const TVectorT< Element > &source2);  Modify addition: target += scalar * ElementMult(source1,source2) . ;  ; template<class Element > ; TVectorT< Element > & AddElemMult (TVectorT< Element > &target, Element scalar, const TVectorT< Element > &source1, const TVectorT< Element > &source2, const TVectorT< Element > &select);  Modify addition: target += scalar * ElementMult(source1,source2) only for those elements where select[i] != 0.0. ;  ; template<class Element > ; void AMultB (const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp);  Elementary routine to calculate matrix multiplication A*B. ;  ; template<class Element > ; void AMultBt (const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp);  Elementary routine to calculate matrix multiplication A*B^T. ;  ; template<class Element1 , class Element2 > ; Bool_t AreCompatible (const TMatrixT< Element1 > &m, const TVectorT< Element2 > &v, Int_t verbose=0);  Check if m and v are both valid and have compatible shapes for M * v. ;  ; template<class Element1 , class Element2 > ; Bool_t AreCompatible (const TMatrixTBase< Element1 > &m1, const TMatrixTBase< Element2 > &m2, Int_t verbose=0);  Check that matrice sm1 and m2 areboth valid and have identical shapes . ;  ; template<class Element1 , class Element2 > ; Bool_t AreCompatible (const TVectorT< Element1 > &v, const TMatrixT< Element2 > &m, Int_t verbose=0);  Check if m and v are both valid and have compatible shapes f",MatchSource.WIKI,doc/master/namespaceTMatrixTAutoloadOps.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html
Testability,log,logical,"by-element. ;  ; template<class Element > ; TVectorT< Element > & ElementMult (TVectorT< Element > &target, const TVectorT< Element > &source);  Multiply target by the source, element-by-element. ;  ; template<class Element > ; TVectorT< Element > & ElementMult (TVectorT< Element > &target, const TVectorT< Element > &source, const TVectorT< Element > &select);  Multiply target by the source, element-by-element only where select[i] != 0.0. ;  ; template<class Element1 , class Element2 , class Element3 > ; Element1 Mult (const TVectorT< Element1 > &v1, const TMatrixT< Element2 > &m, const TVectorT< Element3 > &v2);  Perform v1 * M * v2, a scalar result. ;  ; template<class Element > ; TMatrixT< Element > operator!= (const TMatrixT< Element > &source1, const TMatrixT< Element > &source2);  logical operation source1 != source2 ;  ; template<class Element > ; TMatrixT< Element > operator!= (const TMatrixT< Element > &source1, const TMatrixTSym< Element > &source2);  logical operation source1 != source2 ;  ; template<class Element > ; TMatrixT< Element > operator!= (const TMatrixTSym< Element > &source1, const TMatrixT< Element > &source2);  logical operation source1 != source2 ;  ; template<class Element > ; TMatrixT< Element > operator&& (const TMatrixT< Element > &source1, const TMatrixT< Element > &source2);  Logical AND. ;  ; template<class Element > ; TMatrixT< Element > operator&& (const TMatrixT< Element > &source1, const TMatrixTSym< Element > &source2);  Logical AND. ;  ; template<class Element > ; TMatrixT< Element > operator&& (const TMatrixTSym< Element > &source1, const TMatrixT< Element > &source2);  Logical AND. ;  ; template<class Element > ; TVectorT< Element > operator* (const TMatrixT< Element > &a, const TVectorT< Element > &source);  return A * source ;  ; template<class Element > ; TMatrixT< Element > operator* (const TMatrixT< Element > &source, Element val);  operation this = val*source ;  ; template<class Element > ; TMatrixT< Element > operator*",MatchSource.WIKI,doc/master/namespaceTMatrixTAutoloadOps.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html
Availability,error,error,"sification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class  DataInputHandler;  Class that contains all the data information. More...;  ; class  DataLoader;  ; class  DataSet;  Class that contains all the data information. More...;  ; class  DataSetFactory;  Class that contains all the data information. More...;  ; class  DataSetInfo;  Class that contains all the data information. More...;  ; class  DataSetManager;  Class that contains all the data information. More...;  ; class  DecisionTree;  Implementation of a Decision Tree. More...;  ; class  DecisionTreeNode;  ; struct  DeleteFunctor_t;  ; class  DTNodeTrainingInfo;  ; class  Envelope;  Abstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP. More...;  ; class  Event;  ; class  Executor;  Base Executor class. More...;  ; class  ExpectedErrorPruneTool;  A helper class to prune a decision tree using the expected error (C4.5) method. More...;  ; class  Factory;  This is the main MVA steering class. More...;  ; class  FitterBase;  Base class for TMVA fitters. More...;  ; class  GeneticAlgorithm;  Base definition for genetic algorithm. More...;  ; class  GeneticFitter;  Fitter using a Genetic Algorithm. More...;  ; class  GeneticGenes;  Cut optimisation interface class for genetic algorithm. More...;  ; class  GeneticPopulation;  Population definition for genetic algorithm. More...;  ; class  GeneticRange;  Range definition for genetic algorithm. More...;  ; class  GiniIndex;  Implementation of the GiniIndex as separation criterion. More...;  ; class  GiniIndexWithLaplace;  Implementation of the GiniIndex With Laplace correction as separation criterion. More...;  ; class  HuberLossFunction;  Huber Loss Function. More...;  ; class  HuberLossFunctionBDT;  Huber BDT Loss Function. More...;  ; class  HyperParameterOptimisation;  ; class  HyperParameterOptimi",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Deployability,configurat,configuration,"amespaces; namespace  DNN;  ; namespace  Experimental;  ; namespace  Internal;  ; namespace  kNN;  ; namespace  TMVAGlob;  . Classes; class  AbsoluteDeviationLossFunction;  Absolute Deviation Loss Function. More...;  ; class  AbsoluteDeviationLossFunctionBDT;  Absolute Deviation BDT Loss Function. More...;  ; class  AbsValue;  ; class  BDTEventWrapper;  ; class  BinarySearchTree;  A simple Binary search tree including a volume search method. More...;  ; class  BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class  DataInputHandler;  Class that contains all the data information. More...;  ; class  DataLoader;  ; class  DataSet;  Class that contains all the data information. More...;  ; class  DataSetFactory;  Class that contains a",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Integrability,interface,interface,"  Class that contains all the data information. More...;  ; class  DataSetInfo;  Class that contains all the data information. More...;  ; class  DataSetManager;  Class that contains all the data information. More...;  ; class  DecisionTree;  Implementation of a Decision Tree. More...;  ; class  DecisionTreeNode;  ; struct  DeleteFunctor_t;  ; class  DTNodeTrainingInfo;  ; class  Envelope;  Abstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP. More...;  ; class  Event;  ; class  Executor;  Base Executor class. More...;  ; class  ExpectedErrorPruneTool;  A helper class to prune a decision tree using the expected error (C4.5) method. More...;  ; class  Factory;  This is the main MVA steering class. More...;  ; class  FitterBase;  Base class for TMVA fitters. More...;  ; class  GeneticAlgorithm;  Base definition for genetic algorithm. More...;  ; class  GeneticFitter;  Fitter using a Genetic Algorithm. More...;  ; class  GeneticGenes;  Cut optimisation interface class for genetic algorithm. More...;  ; class  GeneticPopulation;  Population definition for genetic algorithm. More...;  ; class  GeneticRange;  Range definition for genetic algorithm. More...;  ; class  GiniIndex;  Implementation of the GiniIndex as separation criterion. More...;  ; class  GiniIndexWithLaplace;  Implementation of the GiniIndex With Laplace correction as separation criterion. More...;  ; class  HuberLossFunction;  Huber Loss Function. More...;  ; class  HuberLossFunctionBDT;  Huber BDT Loss Function. More...;  ; class  HyperParameterOptimisation;  ; class  HyperParameterOptimisationResult;  ; class  IFitterTarget;  Interface for a fitter 'target'. More...;  ; class  IMethod;  Interface for all concrete MVA method implementations. More...;  ; class  Increment;  ; class  Interval;  The TMVA::Interval Class. More...;  ; class  IPruneTool;  IPruneTool - a helper interface class to prune a decision tree. More...;  ; class  IPythonInteractive;  This class is n",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Modifiability,variab,variable,". ROOT: TMVA Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes |; Functions ; TMVA Namespace Reference. create variable transformations ; More... Namespaces; namespace  DNN;  ; namespace  Experimental;  ; namespace  Internal;  ; namespace  kNN;  ; namespace  TMVAGlob;  . Classes; class  AbsoluteDeviationLossFunction;  Absolute Deviation Loss Function. More...;  ; class  AbsoluteDeviationLossFunctionBDT;  Absolute Deviation BDT Loss Function. More...;  ; class  AbsValue;  ; class  BDTEventWrapper;  ; class  BinarySearchTree;  A simple Binary search tree including a volume search method. More...;  ; class  BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class ",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Performance,perform,perform,"le Binary search tree including a volume search method. More...;  ; class  BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class  DataInputHandler;  Class that contains all the data information. More...;  ; class  DataLoader;  ; class  DataSet;  Class that contains all the data information. More...;  ; class  DataSetFactory;  Class that contains all the data information. More...;  ; class  DataSetInfo;  Class that contains all the data information. More...;  ; class  DataSetManager;  Class that contains all the data information. More...;  ; class  DecisionTree;  Implementation of a Decision Tree. More...;  ; class  DecisionTreeNode;  ; struct  DeleteFunctor_t;  ; class  DTNodeTrainingInfo;  ; class  Envelope;  Abstract base class ",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Security,validat,validation,"le Binary search tree including a volume search method. More...;  ; class  BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class  DataInputHandler;  Class that contains all the data information. More...;  ; class  DataLoader;  ; class  DataSet;  Class that contains all the data information. More...;  ; class  DataSetFactory;  Class that contains all the data information. More...;  ; class  DataSetInfo;  Class that contains all the data information. More...;  ; class  DataSetManager;  Class that contains all the data information. More...;  ; class  DecisionTree;  Implementation of a Decision Tree. More...;  ; class  DecisionTreeNode;  ; struct  DeleteFunctor_t;  ; class  DTNodeTrainingInfo;  ; class  Envelope;  Abstract base class ",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Testability,log,log,"_Id"", TString title=""TMVA Input Variable"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE);  ; void correlationscattersMultiClass (TString dataset, TString fin=""TMVA.root"", TString var=""var3"", TString dirName_=""InputVariables_Id"", TString title=""TMVA Input Variable"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE);  ; void correlationsMultiClass (TString dataset, TString fin=""TMVA.root"", Bool_t isRegression=kFALSE, Bool_t greyScale=kFALSE, Bool_t useTMVAStyle=kTRUE);  ; void CorrGui (TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variable"", Bool_t isRegression=kFALSE);  ; void CorrGui_DeleteTBar ();  ; void CorrGuiMultiClass (TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variable"", Bool_t isRegression=kFALSE);  ; void CorrGuiMultiClass_DeleteTBar ();  ; void CreateVariableTransforms (const TString &trafoDefinition, TMVA::DataSetInfo &dataInfo, TMVA::TransformationHandler &transformationHandler, TMVA::MsgLogger &log);  ; void DataLoaderCopy (TMVA::DataLoader *des, TMVA::DataLoader *src);  ; template<class T > ; DeleteFunctor_t< const T > DeleteFunctor ();  ; void deviations (TString dataset, TString fin=""TMVAReg.root"", HistType htype=kMVAType, Bool_t showTarget=kTRUE, Bool_t useTMVAStyle=kTRUE);  ; void draw_activation (TCanvas *c, Double_t cx, Double_t cy, Double_t radx, Double_t rady, Int_t whichActivation);  ; void draw_input_labels (TString dataset, Int_t nInputs, Double_t *cy, Double_t rad, Double_t layerWidth);  ; void draw_layer (TString dataset, TCanvas *c, TH2F *h, Int_t iHist, Int_t nLayers, Double_t maxWeight);  ; void draw_layer_labels (Int_t nLayers);  ; void draw_network (TString dataset, TFile *f, TDirectory *d, const TString &hName=""weights_hist"", Bool_t movieMode=kFALSE, const TString &epoch="""");  ; void draw_synapse (Double_t cx1, Double_t cy1, Double_t cx2, Double_t cy2, Double_t rad1, Double_t rad2, Double_t weightNorme",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Usability,simpl,simple,". ROOT: TMVA Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes |; Functions ; TMVA Namespace Reference. create variable transformations ; More... Namespaces; namespace  DNN;  ; namespace  Experimental;  ; namespace  Internal;  ; namespace  kNN;  ; namespace  TMVAGlob;  . Classes; class  AbsoluteDeviationLossFunction;  Absolute Deviation Loss Function. More...;  ; class  AbsoluteDeviationLossFunctionBDT;  Absolute Deviation BDT Loss Function. More...;  ; class  AbsValue;  ; class  BDTEventWrapper;  ; class  BinarySearchTree;  A simple Binary search tree including a volume search method. More...;  ; class  BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class ",MatchSource.WIKI,doc/master/namespaceTMVA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html
Availability,error,error,"SoftmaxCrossEntropy = 'S'; };  Enum that represents objective functions for the net, i.e. More...;  ; enum class  EnumFunction { ;   ZERO = '0'; , LINEAR = 'L'; , TANH = 'T'; , RELU = 'R'; , ;   SYMMRELU = 'r'; , TANHSHIFT = 't'; , SIGMOID = 's'; , SOFTSIGN = 'S'; , ;   GAUSS = 'G'; , GAUSSCOMPLEMENT = 'C'. };  ; enum class  EnumRegularization { NONE; , L1; , L2; , L1MAX; };  ; enum class  EOptimizer { ;   kSGD = 0; , kAdam = 1; , kAdagrad = 2; , kRMSProp = 3; , ;   kAdadelta = 4. };  Enum representing the optimizer used for training. More...;  ; enum class  EOutputFunction { kIdentity = 'I'; , kSigmoid = 'S'; , kSoftmax = 'M'; };  Enum that represents output functions. More...;  ; enum class  ERegularization { kNone = '0'; , kL1 = '1'; , kL2 = '2'; };  Enum representing the regularization type applied for a given layer. More...;  ; enum  MinimizerType { fSteepest; };  < list all the minimizer types More...;  ; enum class  ModeErrorFunction { SUMOFSQUARES = 'S'; , CROSSENTROPY = 'C'; , CROSSENTROPY_MUTUALEXCLUSIVE = 'M'; };  error functions to be chosen from More...;  ; enum class  ModeOutput { FETCH; };  ; enum class  ModeOutputValues : int { DIRECT = 0x01; , SIGMOID = 0x02; , SOFTMAX = 0x04; , BATCHNORMALIZATION = 0x08; };  ; enum class  WeightInitializationStrategy { XAVIER; , TEST; , LAYERSIZE; , XAVIERUNIFORM; };  weight initialization strategies to be chosen from More...;  . Functions; template<typename Architecture_t > ; void addRegularizationGradients (typename Architecture_t::Matrix_t &A, const typename Architecture_t::Matrix_t &W, typename Architecture_t::Scalar_t weightDecay, ERegularization R);  Add the regularization gradient corresponding to weight matrix W, to the matrix A. ;  ; template<typename ItValue , typename Fnc > ; void applyFunctions (ItValue itValue, ItValue itValueEnd, Fnc fnc);  apply the activation functions ;  ; template<typename ItValue , typename Fnc , typename InvFnc , typename ItGradient > ; void applyFunctions (ItValue itValue, ItVa",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html
Deployability,update,update,"atternWeight);  soft-max-cross-entropy error function (for mutual exclusive cross-entropy) ;  ; double studenttDouble (double distributionParameter);  ; template<typename ItOutput , typename ItTruth , typename ItDelta , typename ItInvActFnc > ; double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight);  ; template<typename ItOutput , typename ItTruth , typename ItDelta , typename InvFnc > ; double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth, ItDelta itDelta, ItDelta itDeltaEnd, InvFnc invFnc, double patternWeight);  sum of squares error function ;  ; template<typename Container , typename T > ; void uniformDouble (Container &container, T maxValue);  ; double uniformDouble (double minValue, double maxValue);  ; template<typename T > ; T uniformFromTo (T from, T to);  ; template<typename LAYERDATA > ; void update (const LAYERDATA &prevLayerData, LAYERDATA &currLayerData, double factorWeightDecay, EnumRegularization regularization);  update the node values ;  ; template<typename ItSource , typename ItDelta , typename ItTargetGradient , typename ItGradient > ; void update (ItSource itSource, ItSource itSourceEnd, ItDelta itTargetDeltaBegin, ItDelta itTargetDeltaEnd, ItTargetGradient itTargetGradientBegin, ItGradient itGradient);  update the gradients ;  ; template<EnumRegularization Regularization, typename ItSource , typename ItDelta , typename ItTargetGradient , typename ItGradient , typename ItWeight > ; void update (ItSource itSource, ItSource itSourceEnd, ItDelta itTargetDeltaBegin, ItDelta itTargetDeltaEnd, ItTargetGradient itTargetGradientBegin, ItGradient itGradient, ItWeight itWeight, double weightDecay);  update the gradients, using regularization ;  ; template<typename ItWeight > ; double weightDecay (double error, ItWeight itWeight, ItWeight itWeightEnd, double factorWeightDecay, E",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html
Modifiability,layers,layers,"daDeviceBuffer;  TCudaDeviceBuffer. More...;  ; class  TCudaDeviceReference;  TCudaDeviceReference. More...;  ; class  TCudaHostBuffer;  TCudaHostBuffer. More...;  ; class  TCudaMatrix;  TCudaMatrix Class. More...;  ; class  TCudaTensor;  TCudaTensor Class. More...;  ; class  TDataLoader;  TDataLoader. More...;  ; class  TDataLoader< AData, TReference< AReal > >;  ; class  TDeepNet;  Generic Deep Neural Network class. More...;  ; class  TDenseLayer;  Generic layer class. More...;  ; struct  TDescriptors;  ; class  TDevice;  TDevice. More...;  ; class  TDLGradientDescent;  ; struct  TDNNGenDescriptors;  ; class  TGradientDescent;  ; class  TLayer;  Generic layer class. More...;  ; class  TNet;  Generic neural network class. More...;  ; class  TReference;  The reference architecture class. More...;  ; class  TReshapeLayer;  ; class  TRMSProp;  RMSProp Optimizer class. More...;  ; class  TSGD;  Stochastic Batch Gradient Descent Optimizer class. More...;  ; class  TSharedLayer;  Layer class width shared weight and bias layers. More...;  ; class  TTensorBatch;  TTensorBatch. More...;  ; class  TTensorBatchIterator;  TTensorBatchIterator. More...;  ; class  TTensorDataLoader;  TTensorDataLoader. More...;  ; class  TTensorDataLoader< AData, TReference< AReal > >;  ; struct  TWorkspace;  ; class  VGeneralLayer;  Generic General Layer class. More...;  ; class  VOptimizer;  Generic Optimizer class. More...;  . Typedefs; typedef std::vector< char > DropContainer;  ; using IndexIterator_t = typename std::vector< size_t >::iterator;  ; using MatrixInput_t = std::tuple< const TMatrixT< Double_t > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & >;  ; using MemoryLayout = TMVA::Experimental::MemoryLayout;  ; typedef std::tuple< Settings &, Batch &, DropContainer & > pass_through_type;  ; using TensorInput = std::tuple< const std::vector< TMatrixT< Double_t > > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & >;  ; using TMVAInput_t = std::tuple< const std:",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html
Performance,optimiz,optimizer," & >;  . Enumerations; enum class  EActivationFunction { ;   kIdentity = 0; , kRelu = 1; , kSigmoid = 2; , kTanh = 3; , ;   kSymmRelu = 4; , kSoftSign = 5; , kGauss = 6; , kFastTanh = 7. };  Enum that represents layer activation functions. More...;  ; enum class  EInitialization { ;   kGauss = 'G'; , kUniform = 'U'; , kIdentity = 'I'; , kZero = 'Z'; , ;   kGlorotNormal = 'X'; , kGlorotUniform = 'F'. };  ; enum class  ELossFunction { kCrossEntropy = 'C'; , kMeanSquaredError = 'R'; , kSoftmaxCrossEntropy = 'S'; };  Enum that represents objective functions for the net, i.e. More...;  ; enum class  EnumFunction { ;   ZERO = '0'; , LINEAR = 'L'; , TANH = 'T'; , RELU = 'R'; , ;   SYMMRELU = 'r'; , TANHSHIFT = 't'; , SIGMOID = 's'; , SOFTSIGN = 'S'; , ;   GAUSS = 'G'; , GAUSSCOMPLEMENT = 'C'. };  ; enum class  EnumRegularization { NONE; , L1; , L2; , L1MAX; };  ; enum class  EOptimizer { ;   kSGD = 0; , kAdam = 1; , kAdagrad = 2; , kRMSProp = 3; , ;   kAdadelta = 4. };  Enum representing the optimizer used for training. More...;  ; enum class  EOutputFunction { kIdentity = 'I'; , kSigmoid = 'S'; , kSoftmax = 'M'; };  Enum that represents output functions. More...;  ; enum class  ERegularization { kNone = '0'; , kL1 = '1'; , kL2 = '2'; };  Enum representing the regularization type applied for a given layer. More...;  ; enum  MinimizerType { fSteepest; };  < list all the minimizer types More...;  ; enum class  ModeErrorFunction { SUMOFSQUARES = 'S'; , CROSSENTROPY = 'C'; , CROSSENTROPY_MUTUALEXCLUSIVE = 'M'; };  error functions to be chosen from More...;  ; enum class  ModeOutput { FETCH; };  ; enum class  ModeOutputValues : int { DIRECT = 0x01; , SIGMOID = 0x02; , SOFTMAX = 0x04; , BATCHNORMALIZATION = 0x08; };  ; enum class  WeightInitializationStrategy { XAVIER; , TEST; , LAYERSIZE; , XAVIERUNIFORM; };  weight initialization strategies to be chosen from More...;  . Functions; template<typename Architecture_t > ; void addRegularizationGradients (typename Architecture_t::Mat",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html
Safety,abort,abort,"egin, ItTarget itTargetEnd);  ; template<bool HasDropOut, typename ItSource , typename ItWeight , typename ItTarget , typename ItDrop > ; void applyWeights (ItSource itSourceBegin, ItSource itSourceEnd, ItWeight itWeight, ItTarget itTargetBegin, ItTarget itTargetEnd, ItDrop itDrop);  apply weights using drop-out; for no drop out, provide (&bool = true) to itDrop such that *itDrop becomes ""true"" ;  ; template<typename ItSource , typename ItWeight , typename ItPrev > ; void applyWeightsBackwards (ItSource itCurrBegin, ItSource itCurrEnd, ItWeight itWeight, ItPrev itPrevBegin, ItPrev itPrevEnd);  ; template<bool HasDropOut, typename ItSource , typename ItWeight , typename ItPrev , typename ItDrop > ; void applyWeightsBackwards (ItSource itCurrBegin, ItSource itCurrEnd, ItWeight itWeight, ItPrev itPrevBegin, ItPrev itPrevEnd, ItDrop itDrop);  apply weights backwards (for backprop); for no drop out, provide (&bool = true) to itDrop such that *itDrop becomes ""true"" ;  ; template<typename LAYERDATA > ; void backward (LAYERDATA &prevLayerData, LAYERDATA &currLayerData);  backward application of the weights (back-propagation of the error) ;  ; template<EnumRegularization Regularization> ; double computeRegularization (double weight, const double &factorWeightDecay);  compute the regularization (L1, L2) ;  ; template<> ; double computeRegularization< EnumRegularization::L1 > (double weight, const double &factorWeightDecay);  ; template<> ; double computeRegularization< EnumRegularization::L2 > (double weight, const double &factorWeightDecay);  ; template<typename ItProbability , typename ItTruth , typename ItDelta , typename ItInvActFnc > ; double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbabilityEnd, ItTruth itTruthBegin, ItTruth, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc, double patternWeight);  cross entropy error function ;  ; void cudaError (cudaError_t code, const char *file, int line, bool abort=true);  Function to check cuda return code.",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html
Testability,log,log," ? 1.0 : 0; });  ; std::shared_ptr< std::function< double(double)> > InvTanh = std::make_shared<std::function<double(double)>> ([](double value){ return 1.0 - std::pow (value, 2.0); });  ; std::shared_ptr< std::function< double(double)> > InvTanhShift = std::make_shared<std::function<double(double)>> ([](double value){ return 0.3 + (1.0 - std::pow (value, 2.0)); });  ; std::shared_ptr< std::function< double(double)> > Linear = std::make_shared<std::function<double(double)>> ([](double value){ return value; });  ; std::shared_ptr< std::function< double(double)> > ReLU = std::make_shared<std::function<double(double)>> ([](double value){ const double margin = 0.0; return value > margin ? value-margin : 0; });  ; std::shared_ptr< std::function< double(double)> > Sigmoid = std::make_shared<std::function<double(double)>> ([](double value){ value = std::max (-100.0, std::min (100.0,value)); return 1.0/(1.0 + std::exp (-value)); });  ; std::shared_ptr< std::function< double(double)> > SoftPlus = std::make_shared<std::function<double(double)>> ([](double value){ return std::log (1.0+ std::exp (value)); });  ; std::shared_ptr< std::function< double(double)> > SoftSign = std::make_shared<std::function<double(double)>> ([](double value){ return value / (1.0 + fabs (value)); });  ; std::shared_ptr< std::function< double(double)> > SymmReLU = std::make_shared<std::function<double(double)>> ([](double value){ const double margin = 0.3; return value > margin ? value-margin : value < -margin ? value+margin : 0; });  ; std::shared_ptr< std::function< double(double)> > Tanh = std::make_shared<std::function<double(double)>> ([](double value){ return tanh (value); });  ; std::shared_ptr< std::function< double(double)> > TanhShift = std::make_shared<std::function<double(double)>> ([](double value){ return tanh (value-0.3); });  ; std::shared_ptr< std::function< double(double)> > ZeroFnc = std::make_shared<std::function<double(double)>> ([](double ){ return 0; });  . Typedef Documentation",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html
Modifiability,layers,layers,"r filling one cell of the output matrix \A. It does so by computing the correct element to copy from the input matrix \B. We therefore never need to block. When reading this kernel it is important to keep in mind that TCudaMatrix objects are saved in column major order for compatibility with cuBLAS. ; Definition at line 256 of file Kernels.cuh. ◆ max(). template<typename AFloat > . __device__ AFloat TMVA::DNN::Cuda::max ; (; AFloat ; x, . AFloat ; y . ). Definition at line 207 of file Kernels.cuh. ◆ MaxPoolBackward(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::MaxPoolBackward ; (; AFloat * ; activationGradientsBackward, . const AFloat * ; activationGradients, . const AFloat * ; indexMatrix, . int ; depth, . int ; imgHeight, . int ; imgWidth, . int ; fltHeight, . int ; fltWidth, . int ; strideRows, . int ; strideCols . ). Back-propagate the gradients through a max-pooling layer. ; Parameters. [out]gradientsBackwardThe gradients to be written. One gradient for each neuron at the layers's input. ; [in]gradientsThe gradients coming from the next layer. One gradient for each receptive field. ; [in]indexMatrixWinning indices. One index for each receptive field. ; [in]depthThe depth of the input tensor. ; [in]imgHeightThe height of the input tensor. ; [in]imgWidthThe output of the input tensor ; [in]fltHeightHeight of the filter. ; [in]fltWidthWidth of the filter. ; [in]strideRowsstride size in the horizontal dimension. ; [in]strideColsstride size in the vertical dimension. . Definition at line 1059 of file Kernels.cuh. ◆ MeanSquaredError(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::MeanSquaredError ; (; AFloat * ; result, . const AFloat * ; Y, . const AFloat * ; output, . const AFloat * ; weights, . int ; m, . int ; n . ). Definition at line 681 of file Kernels.cuh. ◆ MeanSquaredErrorGradients(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::MeanSquaredErrorGradients ; (; AFloat * ; dY, . const AFloat * ; Y, . const A",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html
Performance,optimiz,optimizer,". ROOT: TMVA::DNN::Cuda Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; TMVA::DNN::Cuda Namespace Reference. Functions; template<typename AFloat > ; __global__ void AbsoluteSum (AFloat *result, const AFloat *A, int m, int n);  ; template<typename AFloat > ; __global__ void AdamUpdate (AFloat *A, const AFloat *M, const AFloat *V, int m, int n, AFloat alpha, AFloat eps);  optimizer kernel functions ;  ; template<typename AFloat > ; __global__ void AdamUpdateFirstMom (AFloat *A, const AFloat *B, int m, int n, AFloat beta);  ; template<typename AFloat > ; __global__ void AdamUpdateSecondMom (AFloat *A, const AFloat *B, int m, int n, AFloat beta);  ; template<typename AFloat > ; __global__ void AddBiases (AFloat *A, const AFloat *B, int nRows, int nCols);  ; template<typename AFloat > ; __global__ void AddL1RegularizationGradients (AFloat *A, const AFloat *B, AFloat weightDecay, int m, int n);  ; template<typename AFloat > ; __global__ void AddL2RegularizationGradients (AFloat *A, const AFloat *B, AFloat weightDecay, int m, int n);  ; template<typename AFloat > ; __global__ void AddRowWise (AFloat *W, const AFloat *theta, int m, int n);  ; template<typename AFloat > ; __global__ void AlmostEquals (bool *result, const AFloat *A, const AFloat *B, double epsilon, int m, int n);  ; template<typename AFloat > ; __device__ AFloat AtomicAdd (AFloat *address, AFloat val);  ; template<> ; __device__ double AtomicAdd (double *address, double val);  ; template<> ; __device__ float AtomicAdd (float *address, float val);  ; __device__ int calculateDimension (int imgDim, int fltDim, int padding, int stride);  Calculate the dimension of an output volume, given the sliding parameters and the input shape. ;  ; template<typename AFloat > ; __global__ void ConstAdd (AFloat *A, AFloat beta, int m, int n);  ; template<typename AFloat > ; __global__ void ConstMult (AFloat *A, AFloat beta, int m, int n);  ; template<typename AFlo",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html
Security,access,access,". ◆ Downsample(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::Downsample ; (; AFloat * ; output, . AFloat * ; indexMatrix, . const AFloat * ; input, . int ; depth, . int ; imgHeight, . int ; imgWidth, . int ; fltHeight, . int ; fltWidth, . int ; strideRows, . int ; strideCols . ). Downsampling kernel used as the forward propagation step of a Max-Pooling layer. ; Parameters. [out]AThe output matrix. Each row corresponds to a slice and each element is the max within a receptive field. ; [out]BThe winning indices matrix. Each element is the index of the max element. ; [in]CThe input matrix. Each row is a slice. ; [in]imgHeightThe heigh of the input. ; [in]imgWidthThe output of the input. ; [in]fltHeightHeight of the kernel. ; [in]fltWidthWidth of the kernel. ; [in]strideRowsstride size in the horizontal dimension. ; [in]strideColsstride size in the vertical dimension. Each output element is the maximum of the receptive field. The caller launches one thread per output element in order to eliminate shared write access. ; Definition at line 1002 of file Kernels.cuh. ◆ Dropout(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::Dropout ; (; AFloat * ; A, . int ; m, . int ; n, . AFloat ; dropoutProbability, . curandState_t * ; state . ). Definition at line 964 of file Kernels.cuh. ◆ Flatten(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::Flatten ; (; AFloat * ; A, . const AFloat * ; B, . int ; size, . int ; nRows, . int ; nCols . ). Flatten an array of 2D-arrays into a single 2D-array. ; Parameters. [out]AOutput 2D-array saved in column major order. ; [in]BInput array of 2D-arrays. Each element is a matrix to be concatenated. ; [in]sizeNumber of 2D-arrays in the input. ; [in]nRowsNumber of rows in each matrix of the input. ; [in]nColsNumber of columns on each matrix of the input. B is a pointer to size raw TCudaMatrix pointers. Each of those contains elements saved on column major order. However the concatenation is performed r",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html
Testability,assert,assert,". __device__ AFloat TMVA::DNN::Cuda::AtomicAdd ; (; AFloat * ; address, . AFloat ; val . ). ◆ AtomicAdd() [2/3]. template<> . __device__ double TMVA::DNN::Cuda::AtomicAdd ; (; double * ; address, . double ; val . ). Definition at line 34 of file Kernels.cuh. ◆ AtomicAdd() [3/3]. template<> . __device__ float TMVA::DNN::Cuda::AtomicAdd ; (; float * ; address, . float ; val . ). Definition at line 48 of file Kernels.cuh. ◆ calculateDimension(). __device__ int TMVA::DNN::Cuda::calculateDimension ; (; int ; imgDim, . int ; fltDim, . int ; padding, . int ; stride . ). Calculate the dimension of an output volume, given the sliding parameters and the input shape. ; Parameters. [in]imgDimThe size of the input tensor in a spatial dimension. ; [in]fltDimThe size of the sliding filter in the same dimension. ; [in]paddingNumber of zeroes to pad the input with. ; [in]strideNumber of pixels the kernel is sliding in each iteration. . ReturnsThe output dimension.; Note that no checks are performed to assert validity of the input parameters. We are allowed to assume them valid because those checks have already been performed prior to the invocation of the kernel. ; Definition at line 226 of file Kernels.cuh. ◆ ConstAdd(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::ConstAdd ; (; AFloat * ; A, . AFloat ; beta, . int ; m, . int ; n . ). Definition at line 335 of file Kernels.cuh. ◆ ConstMult(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::ConstMult ; (; AFloat * ; A, . AFloat ; beta, . int ; m, . int ; n . ). Definition at line 349 of file Kernels.cuh. ◆ CrossEntropy(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::CrossEntropy ; (; AFloat * ; result, . const AFloat * ; Y, . const AFloat * ; output, . const AFloat * ; weights, . int ; m, . int ; n . ). Definition at line 800 of file Kernels.cuh. ◆ CrossEntropyGradients(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::CrossEntropyGradients ; (; AFloat * ; dY, . const AFl",MatchSource.WIKI,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html
Integrability,interface,interface,". ROOT: TMVA::Experimental Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes |; Enumerations |; Functions ; TMVA::Experimental Namespace Reference. Namespaces; namespace  Internal;  ; namespace  SOFIE;  . Classes; class  Classification;  ; class  ClassificationResult;  ; class  RBDT;  ; class  RReader;  A replacement for the TMVA::Reader legacy interface. More...;  ; class  RSofieReader;  TMVA::RSofieReader class for reading external Machine Learning models in ONNX files, Keras .h5 files or PyTorch .pt files and performing the inference using SOFIE It is reccomended to use ONNX if possible since there is a larger support for model operators. More...;  ; class  RStandardScaler;  ; class  RTensor;  RTensor is a container with contiguous memory and shape information. More...;  ; class  SofieFunctorHelper;  Helper class used by SOFIEFunctor to wrap the infer signature interface to RDataFrame. More...;  ; class  SofieFunctorHelper< std::index_sequence< N... >, Session_t, T >;  . Enumerations; enum class  MemoryLayout : uint8_t { RowMajor = 0x01; , ColumnMajor = 0x02; , RowMajor = 0x01; , ColumnMajor = 0x02; };  Memory layout type (copy from RTensor.hxx) More...;  ; enum class  MemoryLayout : uint8_t { RowMajor = 0x01; , ColumnMajor = 0x02; , RowMajor = 0x01; , ColumnMajor = 0x02; };  Memory layout type. More...;  . Functions; template<typename T , typename U > ; RTensor< T > AsTensor (U &dataframe, std::vector< std::string > columns={}, MemoryLayout layout=MemoryLayout::RowMajor);  Convert the content of an RDataFrame to an RTensor. ;  ; template<std::size_t N, typename T , typename F > ; auto Compute (F &&f) -> Internal::ComputeHelper< std::make_index_sequence< N >, T, F >;  Helper to pass TMVA model to RDataFrame.Define nodes. ;  ; template<typename T > ; std::ostream & operator<< (std::ostream &os, RTensor< T > &x);  Pretty printing. ;  ; template<std::size_t N, typename Session_t > ; auto SofieF",MatchSource.WIKI,doc/master/namespaceTMVA_1_1Experimental.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1Experimental.html
Performance,perform,performing,". ROOT: TMVA::Experimental Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes |; Enumerations |; Functions ; TMVA::Experimental Namespace Reference. Namespaces; namespace  Internal;  ; namespace  SOFIE;  . Classes; class  Classification;  ; class  ClassificationResult;  ; class  RBDT;  ; class  RReader;  A replacement for the TMVA::Reader legacy interface. More...;  ; class  RSofieReader;  TMVA::RSofieReader class for reading external Machine Learning models in ONNX files, Keras .h5 files or PyTorch .pt files and performing the inference using SOFIE It is reccomended to use ONNX if possible since there is a larger support for model operators. More...;  ; class  RStandardScaler;  ; class  RTensor;  RTensor is a container with contiguous memory and shape information. More...;  ; class  SofieFunctorHelper;  Helper class used by SOFIEFunctor to wrap the infer signature interface to RDataFrame. More...;  ; class  SofieFunctorHelper< std::index_sequence< N... >, Session_t, T >;  . Enumerations; enum class  MemoryLayout : uint8_t { RowMajor = 0x01; , ColumnMajor = 0x02; , RowMajor = 0x01; , ColumnMajor = 0x02; };  Memory layout type (copy from RTensor.hxx) More...;  ; enum class  MemoryLayout : uint8_t { RowMajor = 0x01; , ColumnMajor = 0x02; , RowMajor = 0x01; , ColumnMajor = 0x02; };  Memory layout type. More...;  . Functions; template<typename T , typename U > ; RTensor< T > AsTensor (U &dataframe, std::vector< std::string > columns={}, MemoryLayout layout=MemoryLayout::RowMajor);  Convert the content of an RDataFrame to an RTensor. ;  ; template<std::size_t N, typename T , typename F > ; auto Compute (F &&f) -> Internal::ComputeHelper< std::make_index_sequence< N >, T, F >;  Helper to pass TMVA model to RDataFrame.Define nodes. ;  ; template<typename T > ; std::ostream & operator<< (std::ostream &os, RTensor< T > &x);  Pretty printing. ;  ; template<std::size_t N, typename Session_t > ; auto SofieF",MatchSource.WIKI,doc/master/namespaceTMVA_1_1Experimental.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1Experimental.html
Modifiability,inherit,inherits,"kNorm; , kDecorrelated; , kPCA; , ;   kGaussDecorr; , kNumOfMethods. };  . Functions; void DestroyCanvases ();  ; Bool_t ExistMethodName (TString name, TDirectory *dir=nullptr);  ; TImage * findImage (const char *imageName);  ; TKey * FindMethod (TString name, TDirectory *dir=nullptr);  ; Int_t getBackgroundFill ();  ; Int_t getBackgroundLine ();  ; Int_t getCanvas ();  ; std::vector< TString > GetClassNames (TDirectory *dir);  ; TDirectory * GetCorrelationPlotsDir (TMVAGlob::TypeOfPlot type, TDirectory *dir=nullptr);  ; Int_t getFrameFill ();  ; std::vector< TString > GetInputVariableNames (TDirectory *dir);  ; TDirectory * GetInputVariablesDir (TMVAGlob::TypeOfPlot type, TDirectory *dir=nullptr);  ; UInt_t GetListOfJobs (TFile *file, TList &jobdirs);  ; UInt_t GetListOfKeys (TList &keys, TString inherits, TDirectory *dir=nullptr);  ; UInt_t GetListOfMethods (TList &methods, TDirectory *dir=nullptr);  ; UInt_t GetListOfTitles (TDirectory *rfdir, TList &titles);  ; UInt_t GetListOfTitles (TString &methodName, TList &titles, TDirectory *dir=nullptr);  ; void GetMethodName (TString &name, TDirectory *mdir);  ; void GetMethodName (TString &name, TKey *mkey);  ; void GetMethodTitle (TString &name, TDirectory *idir);  ; void GetMethodTitle (TString &name, TKey *ikey);  ; Int_t getNovelBlue ();  ; Int_t GetNumberOfInputVariables (TDirectory *dir);  ; Int_t GetNumberOfInputVariablesMultiClass (TDirectory *dir);  ; Int_t GetNumberOfTargets (TDirectory *dir);  ; Int_t getSignalFill ();  ; Int_t getSignalLine ();  ; Int_t getTitleBorder ();  ; Int_t getTitleBox ();  ; Int_t getTitleText ();  ; void imgconv (TCanvas *c, const TString &fname);  ; void Initialize (Bool_t useTMVAStyle=kTRUE);  ; TKey * NextKey (TIter &keyIter, TString className);  ; void NormalizeHist (TH1 *h);  ; void NormalizeHists (TH1 *sig, TH1 *bkg=nullptr);  ; TFile * OpenFile (const TString &fin);  ; void plot_logo (Float_t v_scale=1.0, Float_t skew=1.0);  ; void SetFrameStyle (TH1 *frame, Float_t scale=1.0",MatchSource.WIKI,doc/master/namespaceTMVA_1_1TMVAGlob.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1TMVAGlob.html
Integrability,rout,routines,". ROOT: TStreamerInfoActions Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations |; Functions ; TStreamerInfoActions Namespace Reference. Classes; struct  AssociativeLooper;  ; struct  BitsMarker;  ; struct  ConvertBasicType;  ; struct  ConvertBasicType< BitsMarker, To >;  ; struct  ConvertBasicType< NoFactorMarker< From >, To >;  ; struct  ConvertBasicType< WithFactorMarker< From >, To >;  ; struct  GenericLooper;  ; struct  NoFactorMarker;  ; class  TActionSequence;  ; class  TAssocLoopConfig;  ; struct  TBitsConfiguration;  ; class  TConfigSTL;  ; class  TConfiguration;  Base class of the Configurations. More...;  ; class  TConfigurationPushDataCache;  ; class  TConfigurationUseCache;  ; class  TConfiguredAction;  ; class  TConfNoFactor;  ; class  TConfSTLNoFactor;  ; class  TConfSTLWithFactor;  ; class  TConfWithFactor;  ; struct  TGenericConfiguration;  ; class  TGenericLoopConfig;  ; struct  TIDNode;  ; class  TLoopConfiguration;  Base class of the Configurations for the member wise looping routines. More...;  ; struct  TNestedIDs;  ; class  TVectorLoopConfig;  ; struct  VectorLooper;  ; struct  VectorPtrLooper;  ; struct  WithFactorMarker;  . Typedefs; typedef std::vector< TConfiguredAction > ActionContainer_t;  ; typedef TVirtualCollectionProxy::Next_t Next_t;  ; using TIDs = std::vector< TIDNode >;  ; typedef Int_t(* TStreamerInfoAction_t) (TBuffer &buf, void *obj, const TConfiguration *conf);  ; typedef Int_t(* TStreamerInfoLoopAction_t) (TBuffer &buf, void *iter, const void *end, const TLoopConfiguration *loopconf, const TConfiguration *conf);  ; typedef Int_t(* TStreamerInfoVecPtrLoopAction_t) (TBuffer &buf, void *iter, const void *end, const TConfiguration *conf);  . Enumerations; enum  ESelectLooper { kVectorLooper; , kVectorPtrLooper; , kAssociativeLooper; , kGenericLooper; };  . Functions; Int_t GenericReadAction (TBuffer &buf, void *addr, const TConfiguration *confi",MatchSource.WIKI,doc/master/namespaceTStreamerInfoActions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTStreamerInfoActions.html
Modifiability,config,config," Functions; Int_t GenericReadAction (TBuffer &buf, void *addr, const TConfiguration *confi",MatchSource.WIKI,doc/master/namespaceTStreamerInfoActions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/namespaceTStreamerInfoActions.html
Availability,error,error,"titions); 252 , fMinimizerType (_eMinimizerType); 253 , m_convergenceCount (0); 254 , m_maxConvergenceCount (0); 255 , m_minError (1e10); 256 , m_useMultithreading (_useMultithreading); 257 , fMonitoring (NULL); 258 {; 259 }; 260 ; 261 Settings::~Settings () ; 262 {; 263 }; 264 ; 265 ; 266 ; 267 ; 268 ; 269 ; 270 ; 271 ; 272 ; 273 ; 274 ; 275 ; 276 ; 277 ; 278 /** \brief action to be done when the training cycle is started (e.g. update some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVa",MatchSource.WIKI,doc/master/NeuralNet_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html
Deployability,update,update,"ceSteps); 241 , m_batchSize (_batchSize); 242 , m_testRepetitions (_testRepetitions); 243 , m_factorWeightDecay (_factorWeightDecay); 244 , count_E (0); 245 , count_dE (0); 246 , count_mb_E (0); 247 , count_mb_dE (0); 248 , m_regularization (eRegularization); 249 , fLearningRate (_learningRate); 250 , fMomentum (_momentum); 251 , fRepetitions (_repetitions); 252 , fMinimizerType (_eMinimizerType); 253 , m_convergenceCount (0); 254 , m_maxConvergenceCount (0); 255 , m_minError (1e10); 256 , m_useMultithreading (_useMultithreading); 257 , fMonitoring (NULL); 258 {; 259 }; 260 ; 261 Settings::~Settings () ; 262 {; 263 }; 264 ; 265 ; 266 ; 267 ; 268 ; 269 ; 270 ; 271 ; 272 ; 273 ; 274 ; 275 ; 276 ; 277 ; 278 /** \brief action to be done when the training cycle is started (e.g. update some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear (",MatchSource.WIKI,doc/master/NeuralNet_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html
Energy Efficiency,monitor,monitoring,"ceSteps); 241 , m_batchSize (_batchSize); 242 , m_testRepetitions (_testRepetitions); 243 , m_factorWeightDecay (_factorWeightDecay); 244 , count_E (0); 245 , count_dE (0); 246 , count_mb_E (0); 247 , count_mb_dE (0); 248 , m_regularization (eRegularization); 249 , fLearningRate (_learningRate); 250 , fMomentum (_momentum); 251 , fRepetitions (_repetitions); 252 , fMinimizerType (_eMinimizerType); 253 , m_convergenceCount (0); 254 , m_maxConvergenceCount (0); 255 , m_minError (1e10); 256 , m_useMultithreading (_useMultithreading); 257 , fMonitoring (NULL); 258 {; 259 }; 260 ; 261 Settings::~Settings () ; 262 {; 263 }; 264 ; 265 ; 266 ; 267 ; 268 ; 269 ; 270 ; 271 ; 272 ; 273 ; 274 ; 275 ; 276 ; 277 ; 278 /** \brief action to be done when the training cycle is started (e.g. update some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear (",MatchSource.WIKI,doc/master/NeuralNet_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html
Modifiability,variab,variable,"::InvReLUstd::shared_ptr< std::function< double(double)> > InvReLUDefinition NeuralNet.cxx:17; TMVA::DNN::GaussComplementstd::shared_ptr< std::function< double(double)> > GaussComplementDefinition NeuralNet.cxx:13; TMVA::DNN::Gaussstd::shared_ptr< std::function< double(double)> > GaussDefinition NeuralNet.cxx:12; TMVA::DNN::MinimizerTypeMinimizerType< list all the minimizer typesDefinition NeuralNet.h:321; TMVA::DNN::Sigmoidstd::shared_ptr< std::function< double(double)> > SigmoidDefinition NeuralNet.cxx:26; TMVA::DNN::gaussDoubledouble gaussDouble(double mean, double sigma)Definition NeuralNet.cxx:35; TMVA::DNN::ModeOutputValuesModeOutputValuesDefinition NeuralNet.h:179; TMVA::DNN::ModeOutputValues::SOFTMAX@ SOFTMAX; TMVA::DNN::ModeOutputValues::DIRECT@ DIRECT; TMVA::DNN::ModeOutputValues::SIGMOID@ SIGMOID; TMVA::DNN::SoftSignstd::shared_ptr< std::function< double(double)> > SoftSignDefinition NeuralNet.cxx:32; TMVA::DNN::InvSoftPlusstd::shared_ptr< std::function< double(double)> > InvSoftPlusDefinition NeuralNet.cxx:19; TMVA::DNN::ReLUstd::shared_ptr< std::function< double(double)> > ReLUDefinition NeuralNet.cxx:25; TMVA::DNN::isFlagSetbool isFlagSet(T flag, T value)Definition NeuralNet.h:212; TMVA::DNN::randomIntint randomInt(int maxValue)Definition NeuralNet.cxx:52; TMVA::DNN::InvTanhShiftstd::shared_ptr< std::function< double(double)> > InvTanhShiftDefinition NeuralNet.cxx:23; TMVA::DNN::DropContainerstd::vector< char > DropContainerDefinition NeuralNet.h:227; TMVA::DNN::InvSymmReLUstd::shared_ptr< std::function< double(double)> > InvSymmReLUDefinition NeuralNet.cxx:21; TMVA::DNN::InvLinearstd::shared_ptr< std::function< double(double)> > InvLinearDefinition NeuralNet.cxx:16; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; outputstatic void output(). tmvatmvasrcNeuralNet.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/NeuralNet_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html
Testability,log,log,"e < -margin ? 1.0 : 0; });; 22 std::shared_ptr<std::function<double(double)>> InvTanh = std::make_shared<std::function<double(double)>> ([](double value){ return 1.0 - std::pow (value, 2.0); });; 23 std::shared_ptr<std::function<double(double)>> InvTanhShift = std::make_shared<std::function<double(double)>> ([](double value){ return 0.3 + (1.0 - std::pow (value, 2.0)); });; 24 std::shared_ptr<std::function<double(double)>> Linear = std::make_shared<std::function<double(double)>> ([](double value){ return value; });; 25 std::shared_ptr<std::function<double(double)>> ReLU = std::make_shared<std::function<double(double)>> ([](double value){ const double margin = 0.0; return value > margin ? value-margin : 0; });; 26 std::shared_ptr<std::function<double(double)>> Sigmoid = std::make_shared<std::function<double(double)>> ([](double value){ value = std::max (-100.0, std::min (100.0,value)); return 1.0/(1.0 + std::exp (-value)); });; 27 std::shared_ptr<std::function<double(double)>> SoftPlus = std::make_shared<std::function<double(double)>> ([](double value){ return std::log (1.0+ std::exp (value)); });; 28 std::shared_ptr<std::function<double(double)>> ZeroFnc = std::make_shared<std::function<double(double)>> ([](double /*value*/){ return 0; });; 29 std::shared_ptr<std::function<double(double)>> Tanh = std::make_shared<std::function<double(double)>> ([](double value){ return tanh (value); });; 30 std::shared_ptr<std::function<double(double)>> SymmReLU = std::make_shared<std::function<double(double)>> ([](double value){ const double margin = 0.3; return value > margin ? value-margin : value < -margin ? value+margin : 0; });; 31 std::shared_ptr<std::function<double(double)>> TanhShift = std::make_shared<std::function<double(double)>> ([](double value){ return tanh (value-0.3); });; 32 std::shared_ptr<std::function<double(double)>> SoftSign = std::make_shared<std::function<double(double)>> ([](double value){ return value / (1.0 + fabs (value)); });; 33 ; 34 ; 35 double gauss",MatchSource.WIKI,doc/master/NeuralNet_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html
Usability,clear,clear,"nificance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> falsePositives (numBinsROC+1, 0);; 337 std::vector<double> trueNegatives (numBinsROC+1, 0);; 338 std::vector<double> falseNegatives (numBinsROC+1, 0);; 339 ; 340 std::vector<double> x (numBinsData, 0);; 341 std::vector<double> datSig (numBinsData+1, 0);; 342 std::vector<double> datBkg (numBinsData+1, 0);; 343 ; 344 double binSizeROC = (maxVal - minVal)/(double)numBinsROC;; 345 double binSizeData = (maxVal ",MatchSource.WIKI,doc/master/NeuralNet_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html
Availability,error,error,"name ItDelta, typename ItInvActFnc>; 397 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight);; 398 ; 399 ; 400 ; 401 template <typename ItProbability, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 402 double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbabilityEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight);; 403 ; 404 ; 405 ; 406 ; 407 template <typename ItOutput, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 408 double softMaxCrossEntropy (ItOutput itProbabilityBegin, ItOutput itProbabilityEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight);; 409 ; 410 ; 411 ; 412 ; 413 ; 414 template <typename ItWeight>; 415 double weightDecay (double error, ItWeight itWeight, ItWeight itWeightEnd, double factorWeightDecay, EnumRegularization eRegularization);; 416 ; 417 ; 418 ; 419 ; 420 ; 421 ; 422 ; 423 ; 424 ; 425 ; 426 ; 427 ; 428 ; 429 ; 430 /*! \brief LayerData holds the data of one layer; 431 *; 432 * LayerData holds the data of one layer, but not its layout; 433 *; 434 *; 435 */; 436 class LayerData; 437 {; 438 public:; 439 typedef std::vector<double> container_type;; 440 ; 441 typedef container_type::iterator iterator_type;; 442 typedef container_type::const_iterator const_iterator_type;; 443 ; 444 typedef std::vector<std::function<double(double)> > function_container_type;; 445 typedef function_container_type::iterator function_iterator_type;; 446 typedef function_container_type::const_iterator const_function_iterator_type;; 447 ; 448 typedef DropContainer::const_iterator const_dropout_iterator;; 449 ; 450 /*! \brief c'tor of LayerData; 451 *; 452 * C'tor of LayerData for the input layer; 453 *; 454 * \param itInputBegin ite",MatchSource.WIKI,doc/master/NeuralNet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html
Deployability,update,update,"; 258 ; 259 template <typename ItSource, typename ItWeight, typename ItTarget>; 260 void applyWeights (ItSource itSourceBegin, ItSource itSourceEnd, ItWeight itWeight, ItTarget itTargetBegin, ItTarget itTargetEnd);; 261 ; 262 ; 263 ; 264 template <typename ItSource, typename ItWeight, typename ItPrev>; 265 void applyWeightsBackwards (ItSource itCurrBegin, ItSource itCurrEnd, ItWeight itWeight, ItPrev itPrevBegin, ItPrev itPrevEnd);; 266 ; 267 ; 268 ; 269 ; 270 ; 271 template <typename ItValue, typename ItFunction>; 272 void applyFunctions (ItValue itValue, ItValue itValueEnd, ItFunction itFunction);; 273 ; 274 ; 275 template <typename ItValue, typename ItFunction, typename ItInverseFunction, typename ItGradient>; 276 void applyFunctions (ItValue itValue, ItValue itValueEnd, ItFunction itFunction, ItInverseFunction itInverseFunction, ItGradient itGradient);; 277 ; 278 ; 279 ; 280 template <typename ItSource, typename ItDelta, typename ItTargetGradient, typename ItGradient>; 281 void update (ItSource itSource, ItSource itSourceEnd,; 282 ItDelta itTargetDeltaBegin, ItDelta itTargetDeltaEnd,; 283 ItTargetGradient itTargetGradientBegin,; 284 ItGradient itGradient);; 285 ; 286 ; 287 ; 288 template <EnumRegularization Regularization, typename ItSource, typename ItDelta, typename ItTargetGradient, typename ItGradient, typename ItWeight>; 289 void update (ItSource itSource, ItSource itSourceEnd,; 290 ItDelta itTargetDeltaBegin, ItDelta itTargetDeltaEnd,; 291 ItTargetGradient itTargetGradientBegin,; 292 ItGradient itGradient,; 293 ItWeight itWeight, double weightDecay);; 294 ; 295 ; 296 ; 297 // ----- signature of a minimizer -------------; 298 // class Minimizer; 299 // {; 300 // public:; 301 ; 302 // template <typename Function, typename Variables, typename PassThrough>; 303 // double operator() (Function& fnc, Variables& vars, PassThrough& passThrough); 304 // {; 305 // // auto itVars = begin (vars);; 306 // // auto itVarsEnd = end (vars);; 307 ; 308 // std::vector<double> ",MatchSource.WIKI,doc/master/NeuralNet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html
Energy Efficiency,monitor,monitoring," ; 752 /*! \brief set the drop-out configuration (layer-wise); 753 *; 754 * \param begin begin of an array or vector denoting the drop-out probabilities for each layer; 755 * \param end end of an array or vector denoting the drop-out probabilities for each layer; 756 * \param _dropRepetitions denotes after how many repetitions the drop-out setting (which nodes are dropped out exactly) is changed; 757 */; 758 template <typename Iterator>; 759 void setDropOut (Iterator begin, Iterator end, size_t _dropRepetitions) { m_dropOut.assign (begin, end); m_dropRepetitions = _dropRepetitions; }; 760 ; 761 size_t dropRepetitions () const { return m_dropRepetitions; }; 762 const std::vector<double>& dropFractions () const { return m_dropOut; }; 763 ; 764 void setMonitoring (std::shared_ptr<Monitoring> ptrMonitoring) { fMonitoring = ptrMonitoring; } ///< prepared for monitoring; 765 ; 766 size_t convergenceSteps () const { return m_convergenceSteps; } ///< how many steps until training is deemed to have converged; 767 size_t batchSize () const { return m_batchSize; } ///< mini-batch size; 768 size_t testRepetitions () const { return m_testRepetitions; } ///< how often is the test data tested; 769 double factorWeightDecay () const { return m_factorWeightDecay; } ///< get the weight-decay factor; 770 ; 771 double learningRate () const { return fLearningRate; } ///< get the learning rate; 772 double momentum () const { return fMomentum; } ///< get the momentum (e.g. for SGD); 773 int repetitions () const { return fRepetitions; } ///< how many steps have to be gone until the batch is changed; 774 MinimizerType minimizerType () const { return fMinimizerType; } ///< which minimizer shall be used (e.g. SGD); 775 ; 776 ; 777 ; 778 ; 779 ; 780 ; 781 virtual void testSample (double /*error*/, double /*output*/, double /*target*/, double /*weight*/) {} ///< virtual function to be used for monitoring (callback); 782 virtual void startTrainCycle () ///< callback for monitoring and logging; 783",MatchSource.WIKI,doc/master/NeuralNet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html
Modifiability,layers,layers," begin of a vector which holds the values of the nodes of the neural net; 455 * \param itInputEnd iterator to the end of a vector which holdsd the values of the nodes of the neural net; 456 * \param eModeOutput indicates a potential tranformation of the output values before further computation; 457 * DIRECT does not further transformation; SIGMOID applies a sigmoid transformation to each; 458 * output value (to create a probability); SOFTMAX applies a softmax transformation to all; 459 * output values (mutually exclusive probability); 460 */; 461 LayerData (const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput = ModeOutputValues::DIRECT);; 462 ; 463 ; 464 /*! \brief c'tor of LayerData; 465 *; 466 * C'tor of LayerData for the input layer; 467 *; 468 * \param inputSize input size of this layer; 469 */; 470 LayerData (size_t inputSize);; 471 ~LayerData () {}; 472 ; 473 ; 474 /*! \brief c'tor of LayerData; 475 *; 476 * C'tor of LayerData for all layers which are not the input layer; Used during the training of the DNN; 477 *; 478 * \param size size of the layer; 479 * \param itWeightBegin indicates the start of the weights for this layer on the weight vector; 480 * \param itGradientBegin indicates the start of the gradients for this layer on the gradient vector; 481 * \param activationFunction indicates activation functions for this layer; 482 * \param inverseActivationFunction indicates the inverse activation functions for this layer; 483 * \param eModeOutput indicates a potential tranformation of the output values before further computation; 484 * DIRECT does not further transformation; SIGMOID applies a sigmoid transformation to each; 485 * output value (to create a probability); SOFTMAX applies a softmax transformation to all; 486 * output values (mutually exclusive probability); 487 */; 488 LayerData (size_t size,; 489 const_iterator_type itWeightBegin,; 490 iterator_type itGradientBegin,; 491 std::shared_ptr<std::function<do",MatchSource.WIKI,doc/master/NeuralNet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html
Testability,assert,assert,,MatchSource.WIKI,doc/master/NeuralNet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html
Usability,clear,clear,"////////////////////////////////////////////////////////////; 23 ; 24#ifndef TMVA_NEURAL_NET; 25#define TMVA_NEURAL_NET; 26#pragma once; 27 ; 28#include <vector>; 29#include <iostream>; 30#include <algorithm>; 31#include <iterator>; 32#include <functional>; 33#include <tuple>; 34#include <cmath>; 35#include <cassert>; 36#include <random>; 37#include <thread>; 38#include <future>; 39#include <type_traits>; 40#include <string>; 41#include <utility>; 42 ; 43#include ""Pattern.h""; 44#include ""Monitoring.h""; 45 ; 46#include ""TApplication.h""; 47#include ""Timer.h""; 48 ; 49#include ""TH1F.h""; 50#include ""TH2F.h""; 51 ; 52#include <fenv.h> // turn on or off exceptions for NaN and other numeric exceptions; 53 ; 54 ; 55namespace TMVA; 56{; 57 ; 58 class IPythonInteractive;; 59 ; 60 namespace DNN; 61 {; 62 ; 63 // double gaussDoubl (edouble mean, double sigma);; 64 ; 65 ; 66 ; 67 double gaussDouble (double mean, double sigma);; 68 double uniformDouble (double minValue, double maxValue);; 69 int randomInt (int maxValue);; 70 ; 71 ; 72 ; 73 ; 74 class MeanVariance; 75 {; 76 public:; 77 MeanVariance(); 78 : m_n(0); 79 , m_sumWeights(0); 80 , m_mean(0); 81 , m_squared(0); 82 {}; 83 ; 84 inline void clear(); 85 {; 86 m_n = 0;; 87 m_sumWeights = 0;; 88 m_mean = 0;; 89 m_squared = 0;; 90 }; 91 ; 92 template <typename T>; 93 inline void add(T value, double weight = 1.0); 94 {; 95 ++m_n; // a value has been added; 96 ; 97 if (m_n == 1) // initialization; 98 {; 99 m_mean = value;; 100 m_squared = 0.0;; 101 m_sumWeights = weight;; 102 return;; 103 }; 104 ; 105 double tmpWeight = m_sumWeights+weight;; 106 double Q = value - m_mean;; 107 ; 108 double R = Q*weight/tmpWeight;; 109 m_mean += R;; 110 m_squared += m_sumWeights*R*Q;; 111 ; 112 m_sumWeights = tmpWeight;; 113 }; 114 ; 115 template <typename ITERATOR>; 116 inline void add (ITERATOR itBegin, ITERATOR itEnd); 117 {; 118 for (ITERATOR it = itBegin; it != itEnd; ++it); 119 add (*it);; 120 }; 121 ; 122 ; 123 ; 124 inline int count() const {",MatchSource.WIKI,doc/master/NeuralNet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html
Availability,error,error,". ROOT: tmva/tmva/inc/TMVA/NeuralNet.icc Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. NeuralNet.icc. Go to the documentation of this file. 1#ifndef TMVA_NEURAL_NET_I; 2#define TMVA_NEURAL_NET_I; 3 ; 4#ifndef TMVA_NEURAL_NET; 5#error ""Do not use NeuralNet.icc directly. #include \""NeuralNet.h\"" instead.""; 6#endif // TMVA_NEURAL_NET; 7#pragma once; 8#ifndef _MSC_VER; 9#pragma GCC diagnostic ignored ""-Wunused-variable""; 10#endif; 11 ; 12#include ""Math/Util.h""; 13 ; 14#include ""TMVA/Pattern.h""; 15#include ""TMVA/MethodBase.h""; 16 ; 17#include <tuple>; 18#include <future>; 19#include <random>; 20 ; 21namespace TMVA; 22{; 23 namespace DNN; 24 {; 25 ; 26 ; 27 ; 28 ; 29 ; 30 ; 31 ; 32 ; 33 template <typename T>; 34 T uniformFromTo (T from, T to); 35 {; 36 return from + (rand ()* (to - from)/RAND_MAX);; 37 }; 38 ; 39 ; 40 ; 41 template <typename Container, typename T>; 42 void uniformDouble (Container& container, T maxValue); 43 {; 44 for (auto it = begin (container), itEnd = end (container); it != itEnd; ++it); 45 {; 46// (*it) = uniformFromTo (-1.0*maxValue, 1.0*maxValue);; 47 (*it) = TMVA::DNN::uniformFromTo (-1.0*maxValue, 1.0*maxValue);; 48 }; 49 }; 50 ; 51 ; 52 extern std::shared_ptr<std::function<double(double)>> ZeroFnc;; 53 ; 54 ; 55 extern std::shared_ptr<std::function<double(double)>> Sigmoid;; 56 extern std::shared_ptr<std::function<double(double)>> InvSigmoid;; 57 ; 58 extern std::shared_ptr<std::function<double(double)>> Tanh;; 59 extern std::shared_ptr<std::function<double(double)>> InvTanh;; 60 ; 61 extern std::shared_ptr<std::function<double(double)>> Linear;; 62 extern std::shared_ptr<std::function<double(double)>> InvLinear;; 63 ; 64 extern std::shared_ptr<std::function<double(double)>> SymmReLU;; 65 extern std::shared_ptr<std::function<double(double)>> InvSymmReLU;; 66 ; 67 extern std::shared_ptr<std::function<double(double)>> ReLU;; 68 extern std::shared_ptr<std::function<double(double)>> InvReLU;; 69 ; 70 ex",MatchSource.WIKI,doc/master/NeuralNet_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html
Deployability,update,update,"plate <typename ItValue, typename Fnc, typename InvFnc, typename ItGradient>; 164 void applyFunctions (ItValue itValue, ItValue itValueEnd, Fnc fnc, InvFnc invFnc, ItGradient itGradient); 165 {; 166 while (itValue != itValueEnd); 167 {; 168 auto& value = (*itValue);; 169 value = (*fnc.get ()) (value);; 170 (*itGradient) = (*invFnc.get ()) (value);; 171 ; 172 ++itValue; ++itGradient;; 173 }; 174 }; 175 ; 176 ; 177 ; 178/*! \brief update the gradients; 179 *; 180 *; 181 */; 182 template <typename ItSource, typename ItDelta, typename ItTargetGradient, typename ItGradient>; 183 void update (ItSource itSource, ItSource itSourceEnd,; 184 ItDelta itTargetDeltaBegin, ItDelta itTargetDeltaEnd,; 185 ItTargetGradient itTargetGradientBegin,; 186 ItGradient itGradient); 187 {; 188 while (itSource != itSourceEnd); 189 {; 190 auto itTargetDelta = itTargetDeltaBegin;; 191 auto itTargetGradient = itTargetGradientBegin;; 192 while (itTargetDelta != itTargetDeltaEnd); 193 {; 194 (*itGradient) -= (*itTargetDelta) * (*itSource) * (*itTargetGradient);; 195 ++itTargetDelta; ++itTargetGradient; ++itGradient;; 196 }; 197 ++itSource;; 198 }; 199 }; 200 ; 201 ; 202 ; 203 ; 204/*! \brief compute the regularization (L1, L2); 205 *; 206 *; 207 */; 208 template <EnumRegularization Regularization>; 209 inline double computeRegularization (double weight, const double& factorWeightDecay); 210 {; 211 MATH_UNUSED(weight);; 212 MATH_UNUSED(factorWeightDecay);; 213 ; 214 return 0;; 215 }; 216 ; 217// L1 regularization; 218 template <>; 219 inline double computeRegularization<EnumRegularization::L1> (double weight, const double& factorWeightDecay); 220 {; 221 return weight == 0.0 ? 0.0 : std::copysign (factorWeightDecay, weight);; 222 }; 223 ; 224// L2 regularization; 225 template <>; 226 inline double computeRegularization<EnumRegularization::L2> (double weight, const double& factorWeightDecay); 227 {; 228 return factorWeightDecay * weight;; 229 }; 230 ; 231 ; 232/*! \brief update the gradients, using re",MatchSource.WIKI,doc/master/NeuralNet_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html
Energy Efficiency,reduce,reduced,"omentum ---; 297 // apply momentum before computing the new gradient; 298 auto itPrevG = begin (m_prevGradients);; 299 auto itPrevGEnd = end (m_prevGradients);; 300 auto itLocWeight = begin (m_localWeights);; 301 for (; itPrevG != itPrevGEnd; ++itPrevG, ++itLocWeight); 302 {; 303 (*itPrevG) *= m_beta;; 304 (*itLocWeight) += (*itPrevG);; 305 }; 306 ; 307 E = fitnessFunction (passThrough, m_localWeights, m_localGradients);; 308// plotGradients (gradients);; 309// plotWeights (localWeights);; 310 ; 311 double alpha = gaussDouble (m_alpha, m_alpha/2.0);; 312// double alpha = m_alpha;; 313 ; 314 auto itG = begin (m_localGradients);; 315 auto itGEnd = end (m_localGradients);; 316 itPrevG = begin (m_prevGradients);; 317 double maxGrad = 0.0;; 318 for (; itG != itGEnd; ++itG, ++itPrevG); 319 {; 320 double currGrad = (*itG);; 321 double prevGrad = (*itPrevG);; 322 currGrad *= alpha;; 323 ; 324 //(*itPrevG) = m_beta * (prevGrad + currGrad);; 325 currGrad += prevGrad;; 326 (*itG) = currGrad;; 327 (*itPrevG) = currGrad;; 328 ; 329 if (std::fabs (currGrad) > maxGrad); 330 maxGrad = currGrad;; 331 }; 332 ; 333 if (maxGrad > 1); 334 {; 335 m_alpha /= 2;; 336 std::cout << ""\nlearning rate reduced to "" << m_alpha << std::endl;; 337 std::for_each (weights.begin (), weights.end (), [maxGrad](double& w); 338 {; 339 w /= maxGrad;; 340 });; 341 m_prevGradients.clear ();; 342 }; 343 else; 344 {; 345 auto itW = std::begin (weights);; 346 std::for_each (std::begin (m_localGradients), std::end (m_localGradients), [&itW](double& g); 347 {; 348 *itW += g;; 349 ++itW;; 350 });; 351 }; 352 ; 353 ++currentRepetition;; 354 }; 355 return E;; 356 }; 357 ; 358 ; 359 ; 360 ; 361 ; 362 ; 363 ; 364 ; 365 ; 366 ; 367 ; 368 ; 369 ; 370 ; 371 ; 372 ; 373 ; 374 ; 375 ; 376 ; 377/*! \brief sum of squares error function; 378 *; 379 *; 380 */; 381 template <typename ItOutput, typename ItTruth, typename ItDelta, typename InvFnc>; 382 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itT",MatchSource.WIKI,doc/master/NeuralNet_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html
Modifiability,variab,variable,". ROOT: tmva/tmva/inc/TMVA/NeuralNet.icc Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. NeuralNet.icc. Go to the documentation of this file. 1#ifndef TMVA_NEURAL_NET_I; 2#define TMVA_NEURAL_NET_I; 3 ; 4#ifndef TMVA_NEURAL_NET; 5#error ""Do not use NeuralNet.icc directly. #include \""NeuralNet.h\"" instead.""; 6#endif // TMVA_NEURAL_NET; 7#pragma once; 8#ifndef _MSC_VER; 9#pragma GCC diagnostic ignored ""-Wunused-variable""; 10#endif; 11 ; 12#include ""Math/Util.h""; 13 ; 14#include ""TMVA/Pattern.h""; 15#include ""TMVA/MethodBase.h""; 16 ; 17#include <tuple>; 18#include <future>; 19#include <random>; 20 ; 21namespace TMVA; 22{; 23 namespace DNN; 24 {; 25 ; 26 ; 27 ; 28 ; 29 ; 30 ; 31 ; 32 ; 33 template <typename T>; 34 T uniformFromTo (T from, T to); 35 {; 36 return from + (rand ()* (to - from)/RAND_MAX);; 37 }; 38 ; 39 ; 40 ; 41 template <typename Container, typename T>; 42 void uniformDouble (Container& container, T maxValue); 43 {; 44 for (auto it = begin (container), itEnd = end (container); it != itEnd; ++it); 45 {; 46// (*it) = uniformFromTo (-1.0*maxValue, 1.0*maxValue);; 47 (*it) = TMVA::DNN::uniformFromTo (-1.0*maxValue, 1.0*maxValue);; 48 }; 49 }; 50 ; 51 ; 52 extern std::shared_ptr<std::function<double(double)>> ZeroFnc;; 53 ; 54 ; 55 extern std::shared_ptr<std::function<double(double)>> Sigmoid;; 56 extern std::shared_ptr<std::function<double(double)>> InvSigmoid;; 57 ; 58 extern std::shared_ptr<std::function<double(double)>> Tanh;; 59 extern std::shared_ptr<std::function<double(double)>> InvTanh;; 60 ; 61 extern std::shared_ptr<std::function<double(double)>> Linear;; 62 extern std::shared_ptr<std::function<double(double)>> InvLinear;; 63 ; 64 extern std::shared_ptr<std::function<double(double)>> SymmReLU;; 65 extern std::shared_ptr<std::function<double(double)>> InvSymmReLU;; 66 ; 67 extern std::shared_ptr<std::function<double(double)>> ReLU;; 68 extern std::shared_ptr<std::function<double(double)>> InvReLU;; 69 ; 70 ex",MatchSource.WIKI,doc/master/NeuralNet_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html
Testability,assert,assert,"40 });; 341 m_prevGradients.clear ();; 342 }; 343 else; 344 {; 345 auto itW = std::begin (weights);; 346 std::for_each (std::begin (m_localGradients), std::end (m_localGradients), [&itW](double& g); 347 {; 348 *itW += g;; 349 ++itW;; 350 });; 351 }; 352 ; 353 ++currentRepetition;; 354 }; 355 return E;; 356 }; 357 ; 358 ; 359 ; 360 ; 361 ; 362 ; 363 ; 364 ; 365 ; 366 ; 367 ; 368 ; 369 ; 370 ; 371 ; 372 ; 373 ; 374 ; 375 ; 376 ; 377/*! \brief sum of squares error function; 378 *; 379 *; 380 */; 381 template <typename ItOutput, typename ItTruth, typename ItDelta, typename InvFnc>; 382 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, InvFnc invFnc, double patternWeight); 383 {; 384 double errorSum = 0.0;; 385 ; 386 // output - truth; 387 ItTruth itTruth = itTruthBegin;; 388 bool hasDeltas = (itDelta != itDeltaEnd);; 389 for (ItOutput itOutput = itOutputBegin; itOutput != itOutputEnd; ++itOutput, ++itTruth); 390 {; 391// assert (itTruth != itTruthEnd);; 392 double output = (*itOutput);; 393 double error = output - (*itTruth);; 394 if (hasDeltas); 395 {; 396 (*itDelta) = (*invFnc.get ()) (output) * error * patternWeight;; 397 ++itDelta;; 398 }; 399 errorSum += error*error * patternWeight;; 400 }; 401 ; 402 return 0.5*errorSum;; 403 }; 404 ; 405 ; 406 ; 407/*! \brief cross entropy error function; 408 *; 409 *; 410 */; 411 template <typename ItProbability, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 412 double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbabilityEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc /*itInvActFnc*/, double patternWeight); 413 {; 414 bool hasDeltas = (itDelta != itDeltaEnd);; 415 ; 416 double errorSum = 0.0;; 417 for (ItProbability itProbability = itProbabilityBegin; itProbability != itProbabilityEnd; ++itProbability); 418 {; 419 double probability = *itProbabil",MatchSource.WIKI,doc/master/NeuralNet_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html
Usability,clear,clear,";; 251 ++itTargetDelta; ++itTargetGradient; ++itGradient; ++itWeight;; 252 }; 253 ++itSource;; 254 }; 255 }; 256 ; 257 ; 258 ; 259 ; 260 ; 261 ; 262#define USELOCALWEIGHTS 1; 263 ; 264 ; 265 ; 266/*! \brief implementation of the steepest gradient descent algorithm; 267 *; 268 * Can be used with multithreading (i.e. ""HogWild!"" style); see call in trainCycle; 269 */; 270 template <typename Function, typename Weights, typename PassThrough>; 271 double Steepest::operator() (Function& fitnessFunction, Weights& weights, PassThrough& passThrough); 272 {; 273 size_t numWeights = weights.size ();; 274 // std::vector<double> gradients (numWeights, 0.0);; 275 m_localGradients.assign (numWeights, 0.0);; 276 // std::vector<double> localWeights (begin (weights), end (weights));; 277 // m_localWeights.reserve (numWeights);; 278 m_localWeights.assign (begin (weights), end (weights));; 279 ; 280 double E = 1e10;; 281 if (m_prevGradients.size () != numWeights); 282 {; 283 m_prevGradients.clear ();; 284 m_prevGradients.assign (weights.size (), 0);; 285 }; 286 ; 287 bool success = true;; 288 size_t currentRepetition = 0;; 289 while (success); 290 {; 291 if (currentRepetition >= m_repetitions); 292 break;; 293 ; 294 m_localGradients.assign (numWeights, 0.0);; 295 ; 296 // --- nesterov momentum ---; 297 // apply momentum before computing the new gradient; 298 auto itPrevG = begin (m_prevGradients);; 299 auto itPrevGEnd = end (m_prevGradients);; 300 auto itLocWeight = begin (m_localWeights);; 301 for (; itPrevG != itPrevGEnd; ++itPrevG, ++itLocWeight); 302 {; 303 (*itPrevG) *= m_beta;; 304 (*itLocWeight) += (*itPrevG);; 305 }; 306 ; 307 E = fitnessFunction (passThrough, m_localWeights, m_localGradients);; 308// plotGradients (gradients);; 309// plotWeights (localWeights);; 310 ; 311 double alpha = gaussDouble (m_alpha, m_alpha/2.0);; 312// double alpha = m_alpha;; 313 ; 314 auto itG = begin (m_localGradients);; 315 auto itGEnd = end (m_localGradients);; 316 itPrevG = begin (m_prevGradients",MatchSource.WIKI,doc/master/NeuralNet_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html
Availability,mask,mask,"m->Integral(), ""width"");; ; // Drawing everything; TCanvas *c1 = new TCanvas(""c1"", ""Histogram Normalization"", 700, 900);; c1->Divide(1, 2);; ; c1->cd(1);; orig->Draw();; c1->cd(2);; norm->Draw();; }; TCanvas.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2F.h; TRandom.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::Scalevirtual void Scale(Double_t c1=1, Option_t *option="""")Multiply this histogram by a constant c1.Definition TH1.cxx:6604; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom2::RndmDouble_t Rndm() overrideTausWorth generator from L'Ecuyer, uses as seed 3x32bits integers Use a mask of 0xffffffffUL to make ...Definition TRandom2.cxx:55; TStyle::SetTitleFontSizevoid SetTitleFontSize(Float_t size=0)Definition TStyle.h:407; c1return c1Definition legend1.C:41; AuthorAdvait Dhingra ; Definition in file NormalizeHistogram.C. tutorialshistNormalizeHistogram.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/NormalizeHistogram_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NormalizeHistogram_8C.html
Integrability,depend,dependency,". ROOT: graf3d/eve7/glu/normal.c File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros |; Functions ; normal.c File Reference. #include ""gluos.h""; #include ""mesh.h""; #include ""tess.h""; #include ""normal.h""; #include <math.h>; #include <assert.h>. Include dependency graph for normal.c:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ABS(x)   ((x) < 0 ? -(x) : (x));  ; #define Dot(u, v)   (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);  ; #define FALSE   0;  ; #define S_UNIT_X   1.0;  ; #define S_UNIT_Y   0.0;  ; #define TRUE   1;  . Functions; void __gl_projectPolygon (GLUtesselator *tess);  ; static void CheckOrientation (GLUtesselator *tess);  ; static void ComputeNormal (GLUtesselator *tess, GLdouble norm[3]);  ; static int LongAxis (GLdouble v[3]);  . Macro Definition Documentation. ◆ ABS. #define ABS; (;  ; x);    ((x) < 0 ? -(x) : (x)). Definition at line 65 of file normal.c. ◆ Dot. #define Dot; (;  ; u, .  ; v . );    (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]). Definition at line 49 of file normal.c. ◆ FALSE. #define FALSE   0. Definition at line 46 of file normal.c. ◆ S_UNIT_X. #define S_UNIT_X   1.0. Definition at line 190 of file normal.c. ◆ S_UNIT_Y. #define S_UNIT_Y   0.0. Definition at line 191 of file normal.c. ◆ TRUE. #define TRUE   1. Definition at line 43 of file normal.c. Function Documentation. ◆ __gl_projectPolygon(). void __gl_projectPolygon ; (; GLUtesselator * ; tess). Definition at line 198 of file normal.c. ◆ CheckOrientation(). static void CheckOrientation ; (; GLUtesselator * ; tess). static . Definition at line 141 of file normal.c. ◆ ComputeNormal(). static void ComputeNormal ; (; GLUtesselator * ; tess, . GLdouble ; norm[3] . ). static . Definition at line 76 of file normal.c. ◆ LongAxis(). static int LongAxis ; (; GLdouble ; v[3]). static . Definition at line 67 of file normal.c. graf3deve7glunormal.c. ROOT master - Reference Guide Generated on Tue Nov 5",MatchSource.WIKI,doc/master/normal_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/normal_8c.html
Testability,assert,assert,". ROOT: graf3d/eve7/glu/normal.c File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros |; Functions ; normal.c File Reference. #include ""gluos.h""; #include ""mesh.h""; #include ""tess.h""; #include ""normal.h""; #include <math.h>; #include <assert.h>. Include dependency graph for normal.c:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ABS(x)   ((x) < 0 ? -(x) : (x));  ; #define Dot(u, v)   (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);  ; #define FALSE   0;  ; #define S_UNIT_X   1.0;  ; #define S_UNIT_Y   0.0;  ; #define TRUE   1;  . Functions; void __gl_projectPolygon (GLUtesselator *tess);  ; static void CheckOrientation (GLUtesselator *tess);  ; static void ComputeNormal (GLUtesselator *tess, GLdouble norm[3]);  ; static int LongAxis (GLdouble v[3]);  . Macro Definition Documentation. ◆ ABS. #define ABS; (;  ; x);    ((x) < 0 ? -(x) : (x)). Definition at line 65 of file normal.c. ◆ Dot. #define Dot; (;  ; u, .  ; v . );    (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]). Definition at line 49 of file normal.c. ◆ FALSE. #define FALSE   0. Definition at line 46 of file normal.c. ◆ S_UNIT_X. #define S_UNIT_X   1.0. Definition at line 190 of file normal.c. ◆ S_UNIT_Y. #define S_UNIT_Y   0.0. Definition at line 191 of file normal.c. ◆ TRUE. #define TRUE   1. Definition at line 43 of file normal.c. Function Documentation. ◆ __gl_projectPolygon(). void __gl_projectPolygon ; (; GLUtesselator * ; tess). Definition at line 198 of file normal.c. ◆ CheckOrientation(). static void CheckOrientation ; (; GLUtesselator * ; tess). static . Definition at line 141 of file normal.c. ◆ ComputeNormal(). static void ComputeNormal ; (; GLUtesselator * ; tess, . GLdouble ; norm[3] . ). static . Definition at line 76 of file normal.c. ◆ LongAxis(). static int LongAxis ; (; GLdouble ; v[3]). static . Definition at line 67 of file normal.c. graf3deve7glunormal.c. ROOT master - Reference Guide Generated on Tue Nov 5",MatchSource.WIKI,doc/master/normal_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/normal_8c.html
Integrability,interface,interface,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C File ReferenceTutorials » ROOT 7 tutorials » ROOT 7 ntuple tutorials. Detailed Description; Write and read tabular data with RNTuple. ; Adapted from the cernbuild and cernstaff tree tutorials. Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step taken by an ntuple reader or writer. ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RNTupleWriter.hxx>; ; #include <TCanvas.h>; #include <TH1I.h>; #include <TROOT.h>; #include <TString.h>; ; #include <cassert>; #include <cstdio>; #include <fstream>; #include <iostream>; #include <memory>; #include <string>; #include <sstream>; #include <utility>; ; // Import classes from experimental namespace for the time being; using RNTupleModel = ROOT::Experimental::RNTupleModel;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; ; constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; ; void Ingest() {; // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; assert(fin.is_open());; ; // We create a unique pointer to an empty data model; auto model = RNTupleModel::Create();; ; // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; auto fldCategory = model->MakeField<int>(""Category"");; auto fldFlag = model->MakeField<unsigned int>(""Flag"");; auto fldAge = model->MakeField<int>(""Age"");; auto fldServi",MatchSource.WIKI,doc/master/ntpl001__staff_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html
Safety,safe,safe,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C File ReferenceTutorials » ROOT 7 tutorials » ROOT 7 ntuple tutorials. Detailed Description; Write and read tabular data with RNTuple. ; Adapted from the cernbuild and cernstaff tree tutorials. Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step taken by an ntuple reader or writer. ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RNTupleWriter.hxx>; ; #include <TCanvas.h>; #include <TH1I.h>; #include <TROOT.h>; #include <TString.h>; ; #include <cassert>; #include <cstdio>; #include <fstream>; #include <iostream>; #include <memory>; #include <string>; #include <sstream>; #include <utility>; ; // Import classes from experimental namespace for the time being; using RNTupleModel = ROOT::Experimental::RNTupleModel;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; ; constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; ; void Ingest() {; // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; assert(fin.is_open());; ; // We create a unique pointer to an empty data model; auto model = RNTupleModel::Create();; ; // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; auto fldCategory = model->MakeField<int>(""Category"");; auto fldFlag = model->MakeField<unsigned int>(""Flag"");; auto fldAge = model->MakeField<int>(""Age"");; auto fldServi",MatchSource.WIKI,doc/master/ntpl001__staff_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html
Testability,assert,assert,"r writer. ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RNTupleWriter.hxx>; ; #include <TCanvas.h>; #include <TH1I.h>; #include <TROOT.h>; #include <TString.h>; ; #include <cassert>; #include <cstdio>; #include <fstream>; #include <iostream>; #include <memory>; #include <string>; #include <sstream>; #include <utility>; ; // Import classes from experimental namespace for the time being; using RNTupleModel = ROOT::Experimental::RNTupleModel;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; ; constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; ; void Ingest() {; // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; assert(fin.is_open());; ; // We create a unique pointer to an empty data model; auto model = RNTupleModel::Create();; ; // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; auto fldCategory = model->MakeField<int>(""Category"");; auto fldFlag = model->MakeField<unsigned int>(""Flag"");; auto fldAge = model->MakeField<int>(""Age"");; auto fldService = model->MakeField<int>(""Service"");; auto fldChildren = model->MakeField<int>(""Children"");; auto fldGrade = model->MakeField<int>(""Grade"");; auto fldStep = model->MakeField<int>(""Step"");; auto fldHrweek = model->MakeField<int>(""Hrweek"");; auto fldCost = model->MakeField<int>(""Cost"");; auto fldDivision = model->MakeField<std::string>(""Division"");; auto fldNation = model->MakeField<std::string>(""Nation"");; ; // We hand-over the data model to a newly created ntuple of name ""Staff"", st",MatchSource.WIKI,doc/master/ntpl001__staff_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html
Integrability,interface,interface,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_ntuple; 3/// \notebook; 4/// Write and read tabular data with RNTuple. Adapted from the cernbuild and cernstaff tree tutorials.; 5/// Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step; 6/// taken by an ntuple reader or writer.; 7///; 8/// \macro_image; 9/// \macro_code; 10///; 11/// \date April 2019; 12/// \author The ROOT Team; 13 ; 14// NOTE: The RNTuple classes are experimental at this point.; 15// Functionality, interface, and data format is still subject to changes.; 16// Do not use for real data!; 17 ; 18#include <ROOT/RNTupleModel.hxx>; 19#include <ROOT/RNTupleReader.hxx>; 20#include <ROOT/RNTupleWriter.hxx>; 21 ; 22#include <TCanvas.h>; 23#include <TH1I.h>; 24#include <TROOT.h>; 25#include <TString.h>; 26 ; 27#include <cassert>; 28#include <cstdio>; 29#include <fstream>; 30#include <iostream>; 31#include <memory>; 32#include <string>; 33#include <sstream>; 34#include <utility>; 35 ; 36// Import classes from experimental namespace for the time being; 37using RNTupleModel = ROOT::Experimental::RNTupleModel;; 38using RNTupleReader = ROOT::Experimental::RNTupleReader;; 39using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; 40 ; 41constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; 42 ; 43void Ingest() {; 44 // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; 45 ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; 46 assert(fin.is_open());; 47 ; 48 // We create a unique pointer to an empty data model; 49 auto model = RNTupleModel::Create();; 50 ; 51 // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; 52 // MakeField returns a shared pointer to a memory location th",MatchSource.WIKI,doc/master/ntpl001__staff_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C_source.html
Safety,safe,safe,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_ntuple; 3/// \notebook; 4/// Write and read tabular data with RNTuple. Adapted from the cernbuild and cernstaff tree tutorials.; 5/// Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step; 6/// taken by an ntuple reader or writer.; 7///; 8/// \macro_image; 9/// \macro_code; 10///; 11/// \date April 2019; 12/// \author The ROOT Team; 13 ; 14// NOTE: The RNTuple classes are experimental at this point.; 15// Functionality, interface, and data format is still subject to changes.; 16// Do not use for real data!; 17 ; 18#include <ROOT/RNTupleModel.hxx>; 19#include <ROOT/RNTupleReader.hxx>; 20#include <ROOT/RNTupleWriter.hxx>; 21 ; 22#include <TCanvas.h>; 23#include <TH1I.h>; 24#include <TROOT.h>; 25#include <TString.h>; 26 ; 27#include <cassert>; 28#include <cstdio>; 29#include <fstream>; 30#include <iostream>; 31#include <memory>; 32#include <string>; 33#include <sstream>; 34#include <utility>; 35 ; 36// Import classes from experimental namespace for the time being; 37using RNTupleModel = ROOT::Experimental::RNTupleModel;; 38using RNTupleReader = ROOT::Experimental::RNTupleReader;; 39using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; 40 ; 41constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; 42 ; 43void Ingest() {; 44 // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; 45 ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; 46 assert(fin.is_open());; 47 ; 48 // We create a unique pointer to an empty data model; 49 auto model = RNTupleModel::Create();; 50 ; 51 // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; 52 // MakeField returns a shared pointer to a memory location th",MatchSource.WIKI,doc/master/ntpl001__staff_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C_source.html
Testability,assert,assert,"; 15// Functionality, interface, and data format is still subject to changes.; 16// Do not use for real data!; 17 ; 18#include <ROOT/RNTupleModel.hxx>; 19#include <ROOT/RNTupleReader.hxx>; 20#include <ROOT/RNTupleWriter.hxx>; 21 ; 22#include <TCanvas.h>; 23#include <TH1I.h>; 24#include <TROOT.h>; 25#include <TString.h>; 26 ; 27#include <cassert>; 28#include <cstdio>; 29#include <fstream>; 30#include <iostream>; 31#include <memory>; 32#include <string>; 33#include <sstream>; 34#include <utility>; 35 ; 36// Import classes from experimental namespace for the time being; 37using RNTupleModel = ROOT::Experimental::RNTupleModel;; 38using RNTupleReader = ROOT::Experimental::RNTupleReader;; 39using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; 40 ; 41constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; 42 ; 43void Ingest() {; 44 // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; 45 ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; 46 assert(fin.is_open());; 47 ; 48 // We create a unique pointer to an empty data model; 49 auto model = RNTupleModel::Create();; 50 ; 51 // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; 52 // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; 53 auto fldCategory = model->MakeField<int>(""Category"");; 54 auto fldFlag = model->MakeField<unsigned int>(""Flag"");; 55 auto fldAge = model->MakeField<int>(""Age"");; 56 auto fldService = model->MakeField<int>(""Service"");; 57 auto fldChildren = model->MakeField<int>(""Children"");; 58 auto fldGrade = model->MakeField<int>(""Grade"");; 59 auto fldStep = model->MakeField<int>(""Step"");; 60 auto fldHrweek = model->MakeField<int>(""Hrweek"");; 61 auto fldCost = model->MakeField<int>(""Cost"");; 62 auto fldDivision = model->MakeField<std::string>(""Division"");; 63 auto fldNation = model->MakeField<std::string>(""Nation"");; 64 ; 65 // We hand-over t",MatchSource.WIKI,doc/master/ntpl001__staff_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C_source.html
Integrability,interface,interface,". ROOT: tutorials/v7/ntuple/ntpl008_import.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl008_import.C File ReferenceTutorials » ROOT 7 tutorials » ROOT 7 ntuple tutorials. Detailed Description; Example of converting data stored in a TTree into an RNTuple . ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleDS.hxx>; #include <ROOT/RNTupleImporter.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RPageStorageFile.hxx>; ; #include <TFile.h>; #include <TROOT.h>; #include <TSystem.h>; ; // Import classes from experimental namespace for the time being.; using RNTupleImporter = ROOT::Experimental::RNTupleImporter;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; ; // Input and output.; constexpr char const *kTreeFileName = ""http://root.cern.ch/files/HiggsTauTauReduced/GluGluToHToTauTau.root"";; constexpr char const *kTreeName = ""Events"";; constexpr char const *kNTupleFileName = ""ntpl008_import.root"";; ; void ntpl008_import(); {; // RNTupleImporter appends keys to the output file; make sure a second run of the tutorial does not fail; // with `Key 'Events' already exists in file ntpl008_import.root` by removing the output file.; gSystem->Unlink(kNTupleFileName);; ; // Use multiple threads to compress RNTuple data.; ROOT::EnableImplicitMT();; ; // Create a new RNTupleImporter object.; auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; ; // Begin importing.; importer->Import();; ; // Inspect the schema of the written RNTuple.; auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; if (!file || file->IsZombie()) {; std::cerr << ""cannot open "" << kNTupleFileName << std::endl;; return;; }; auto ntpl = std::unique_ptr<ROOT::RNTuple>(file->Get<ROOT::RNTuple>(""Events""));; auto reader = RNTupleReader::Open(*ntpl);; reader->PrintI",MatchSource.WIKI,doc/master/ntpl008__import_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C.html
Performance,multi-thread,multi-threading,"TupleImporter object.; auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; ; // Begin importing.; importer->Import();; ; // Inspect the schema of the written RNTuple.; auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; if (!file || file->IsZombie()) {; std::cerr << ""cannot open "" << kNTupleFileName << std::endl;; return;; }; auto ntpl = std::unique_ptr<ROOT::RNTuple>(file->Get<ROOT::RNTuple>(""Events""));; auto reader = RNTupleReader::Open(*ntpl);; reader->PrintInfo();; ; ROOT::RDataFrame df(""Events"", kNTupleFileName);; df.Histo1D({""Jet_pt"", ""Jet_pt"", 100, 0, 0}, ""Jet_pt"")->DrawCopy();; }; RNTupleDS.hxx; RNTupleImporter.hxx; RNTupleReader.hxx; RPageStorageFile.hxx; TFile.h; TROOT.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::Experimental::RNTupleImporterConverts a TTree into an RNTuple.Definition RNTupleImporter.hxx:103; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RNTupleRepresentation of an RNTuple data set in a ROOT file.Definition RNTuple.hxx:69; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; DateDecember 2022 ; AuthorThe ROOT Team ; Definition in file ntpl008_import.C. tutorialsv7ntuplentpl008_import.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ntpl008__import_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C.html
Integrability,interface,interface,". ROOT: tutorials/v7/ntuple/ntpl008_import.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl008_import.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_ntuple; 3/// \notebook; 4/// Example of converting data stored in a TTree into an RNTuple; 5///; 6/// \macro_image; 7/// \macro_code; 8///; 9/// \date December 2022; 10/// \author The ROOT Team; 11 ; 12// NOTE: The RNTuple classes are experimental at this point.; 13// Functionality, interface, and data format is still subject to changes.; 14// Do not use for real data!; 15 ; 16#include <ROOT/RNTupleDS.hxx>; 17#include <ROOT/RNTupleImporter.hxx>; 18#include <ROOT/RNTupleReader.hxx>; 19#include <ROOT/RPageStorageFile.hxx>; 20 ; 21#include <TFile.h>; 22#include <TROOT.h>; 23#include <TSystem.h>; 24 ; 25// Import classes from experimental namespace for the time being.; 26using RNTupleImporter = ROOT::Experimental::RNTupleImporter;; 27using RNTupleReader = ROOT::Experimental::RNTupleReader;; 28 ; 29// Input and output.; 30constexpr char const *kTreeFileName = ""http://root.cern.ch/files/HiggsTauTauReduced/GluGluToHToTauTau.root"";; 31constexpr char const *kTreeName = ""Events"";; 32constexpr char const *kNTupleFileName = ""ntpl008_import.root"";; 33 ; 34void ntpl008_import(); 35{; 36 // RNTupleImporter appends keys to the output file; make sure a second run of the tutorial does not fail; 37 // with `Key 'Events' already exists in file ntpl008_import.root` by removing the output file.; 38 gSystem->Unlink(kNTupleFileName);; 39 ; 40 // Use multiple threads to compress RNTuple data.; 41 ROOT::EnableImplicitMT();; 42 ; 43 // Create a new RNTupleImporter object.; 44 auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; 45 ; 46 // Begin importing.; 47 importer->Import();; 48 ; 49 // Inspect the schema of the written RNTuple.; 50 auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; 51 if (!file || file->IsZombie()) ",MatchSource.WIKI,doc/master/ntpl008__import_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C_source.html
Performance,multi-thread,multi-threading,"42 ; 43 // Create a new RNTupleImporter object.; 44 auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; 45 ; 46 // Begin importing.; 47 importer->Import();; 48 ; 49 // Inspect the schema of the written RNTuple.; 50 auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; 51 if (!file || file->IsZombie()) {; 52 std::cerr << ""cannot open "" << kNTupleFileName << std::endl;; 53 return;; 54 }; 55 auto ntpl = std::unique_ptr<ROOT::RNTuple>(file->Get<ROOT::RNTuple>(""Events""));; 56 auto reader = RNTupleReader::Open(*ntpl);; 57 reader->PrintInfo();; 58 ; 59 ROOT::RDataFrame df(""Events"", kNTupleFileName);; 60 df.Histo1D({""Jet_pt"", ""Jet_pt"", 100, 0, 0}, ""Jet_pt"")->DrawCopy();; 61}; RNTupleDS.hxx; RNTupleImporter.hxx; RNTupleReader.hxx; RPageStorageFile.hxx; TFile.h; TROOT.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::Experimental::RNTupleImporterConverts a TTree into an RNTuple.Definition RNTupleImporter.hxx:103; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RNTupleRepresentation of an RNTuple data set in a ROOT file.Definition RNTuple.hxx:69; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539. tutorialsv7ntuplentpl008_import.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ntpl008__import_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C_source.html
Modifiability,variab,variables,"_t align=11)Set the text alignment.Definition TAttText.h:42; TBenchmark::GetBenchInt_t GetBench(const char *name) constReturns index of Benchmark name.Definition TBenchmark.cxx:106; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TPad::SetLogyvoid SetLogy(Int_t value=1) overrideSet Lin/Log scale for Y.Definition TPad.cxx:6100; TPad::RedrawAxisvoid RedrawAxis(Option_t *option="""") overrideRedraw the frame axis.Definition TPad.cxx:5450; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::GetFrameTFrame * GetFrame() overrideGet frame.Definition TPad.cxx:2955; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cx",MatchSource.WIKI,doc/master/ntuple1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntuple1_8C.html
Usability,simpl,simple,"_t align=11)Set the text alignment.Definition TAttText.h:42; TBenchmark::GetBenchInt_t GetBench(const char *name) constReturns index of Benchmark name.Definition TBenchmark.cxx:106; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TPad::SetLogyvoid SetLogy(Int_t value=1) overrideSet Lin/Log scale for Y.Definition TPad.cxx:6100; TPad::RedrawAxisvoid RedrawAxis(Option_t *option="""") overrideRedraw the frame axis.Definition TPad.cxx:5450; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::GetFrameTFrame * GetFrame() overrideGet frame.Definition TPad.cxx:2955; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cx",MatchSource.WIKI,doc/master/ntuple1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ntuple1_8C.html
Availability,down,down,">Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + y*y + z*z) < 1) {; x = (2 * x - 1) * NucleusRadius;; y = (2 * y - 1) * NucleusRadius;; z = (2 * z - 1) * NucleusRadius;; top->AddNode(proton, i, new TGeoTranslation(x, y, z));; i++;; }; }; i = 0;; while ( i < nNeutrons) {; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + y*y + z*z) < 1) {; x = (2 * x - 1) * NucleusRadius;; y = (2 * y - 1) * NucleusRadius;; z = (2 * z - 1) * NucleusRadius;; top->AddNode(neutron, i + nProtons, new TGeoTranslation(x, y, z));; i++;; }; }; geom->CloseGeometry();; geom->SetVisLevel(4);; top->Draw(""ogl"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::SetNsegmentsvoid Se",MatchSource.WIKI,doc/master/nucleus_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/nucleus_8C.html
Energy Efficiency,power,power,"ble_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::SetNsegmentsvoid SetNsegments(Int_t nseg)Set number of segments for approximating circles in drawing.Definition TGeoManager.cxx:3594; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; AuthorOtto Schaile ; Definition in file nucleus.C. tutorialsglnucleus.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/nucleus_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/nucleus_8C.html
Performance,perform,performedDefinition,">Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + y*y + z*z) < 1) {; x = (2 * x - 1) * NucleusRadius;; y = (2 * y - 1) * NucleusRadius;; z = (2 * z - 1) * NucleusRadius;; top->AddNode(proton, i, new TGeoTranslation(x, y, z));; i++;; }; }; i = 0;; while ( i < nNeutrons) {; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + y*y + z*z) < 1) {; x = (2 * x - 1) * NucleusRadius;; y = (2 * y - 1) * NucleusRadius;; z = (2 * z - 1) * NucleusRadius;; top->AddNode(neutron, i + nProtons, new TGeoTranslation(x, y, z));; i++;; }; }; geom->CloseGeometry();; geom->SetVisLevel(4);; top->Draw(""ogl"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::SetNsegmentsvoid Se",MatchSource.WIKI,doc/master/nucleus_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/nucleus_8C.html
Deployability,update,updated,". ROOT: tutorials/pyroot/numberEntry.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; numberEntry.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; import ROOT; ; ; class pMyMainFrame(ROOT.TGMainFrame):; def __init__(self, parent, width, height):; ROOT.TGMainFrame.__init__(self, parent, width, height); ; self.fHor1 = ROOT.TGHorizontalFrame(self, 60, 20, ROOT.kFixedWidth); self.fExit = ROOT.TGTextButton(self.fHor1, ""&Exit"", ""gApplication->Terminate(0)""); self.fExit.SetCommand('TPython::Exec( ""raise SystemExit"" )'); self.fHor1.AddFrame(self.fExit, ROOT.TGLayoutHints(; ROOT.kLHintsTop | ROOT.kLHintsLeft | ROOT.kLHintsExpandX, 4, 4, 4, 4)); self.AddFrame(self.fHor1, ROOT.TGLayoutHints(ROOT.kLHintsBottom | ROOT.kLHintsRight, 2, 2, 5, 1)); ; self.fNumber = ROOT.TGNumberEntry(self, 0, 9, 999, ROOT.TGNumberFormat.kNESInteger,; ROOT.TGNumberFormat.kNEANonNegative,; ROOT.TGNumberFormat.kNELLimitMinMax,; 0, 99999); self.fLabelDispatch = ROOT.TPyDispatcher(self.DoSetlabel); self.fNumber.Connect(""ValueSet(Long_t)"", ""TPyDispatcher"", self.fLabelDispatch, ""Dispatch()""); self.fNumber.GetNumberEntry().Connect(""ReturnPressed()"", ""TPyDispatcher"", self.fLabelDispatch, ""Dispatch()""); self.AddFrame(self.fNumber, ROOT.TGLayoutHints(ROOT.kLHintsTop | ROOT.kLHintsLeft, 5, 5, 5, 5)); self.fGframe = ROOT.TGGroupFrame(self, ""Value""); self.fLabel = ROOT.TGLabel(self.fGframe, ""No input.""); self.fGframe.AddFrame(self.fLabel, ROOT.TGLayoutHints(ROOT.kLHintsTop | ROOT.kLHintsLeft, 5, 5, 5, 5)); self.AddFrame(self.fGframe, ROOT.TGLayoutHints(ROOT.kLHintsExpandX, 2, 2, 1, 1)); ; self.SetCleanup(ROOT.kDeepCleanup); self.SetWindowName(""Number Entry""); self.MapSubwindows(); self.Resize(self.GetDefaultSize()); self.MapWindow(); ; def __del__(self):; self.Cleanup(); ; def DoSetlabel(self):; self.fLa",MatchSource.WIKI,doc/master/numberEntry_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/numberEntry_8py.html
Availability,toler,tolerance," #include ""Math/Factory.h""; #include ""Math/Functor.h""; #include ""TRandom2.h""; #include ""TError.h""; #include <iostream>; ; double RosenBrock(const double *xx ); {; const double x = xx[0];; const double y = xx[1];; const double tmp1 = y-x*x;; const double tmp2 = 1-x;; return 100*tmp1*tmp1+tmp2*tmp2;; }; ; int NumericalMinimization(const char * minName = ""Minuit2"",; const char *algoName = """" ,; int randomSeed = -1); {; // create minimizer giving a name and a name (optionally) for the specific; // algorithm; // possible choices are:; // minName algoName; // Minuit /Minuit2 Migrad, Simplex,Combined,Scan (default is Migrad); // Minuit2 Fumili2; // Fumili; // GSLMultiMin ConjugateFR, ConjugatePR, BFGS,; // BFGS2, SteepestDescent; // GSLMultiFit; // GSLSimAn; // Genetic; ROOT::Math::Minimizer* minimum =; ROOT::Math::Factory::CreateMinimizer(minName, algoName);; if (!minimum) {; std::cerr << ""Error: cannot create minimizer \"""" << minName; << ""\"". Maybe the required library was not built?"" << std::endl;; return 1;; }; ; // set tolerance , etc...; minimum->SetMaxFunctionCalls(1000000); // for Minuit/Minuit2; minimum->SetMaxIterations(10000); // for GSL; minimum->SetTolerance(0.001);; minimum->SetPrintLevel(1);; ; // create function wrapper for minimizer; // a IMultiGenFunction type; ROOT::Math::Functor f(&RosenBrock,2);; double step[2] = {0.01,0.01};; // starting point; ; double variable[2] = { -1.,1.2};; if (randomSeed >= 0) {; TRandom2 r(randomSeed);; variable[0] = r.Uniform(-20,20);; variable[1] = r.Uniform(-20,20);; }; ; minimum->SetFunction(f);; ; // Set the free variables to be minimized !; minimum->SetVariable(0,""x"",variable[0], step[0]);; minimum->SetVariable(1,""y"",variable[1], step[1]);; ; // do the minimization; minimum->Minimize();; ; const double *xs = minimum->X();; std::cout << ""Minimum: f("" << xs[0] << "","" << xs[1] << ""): ""; << minimum->MinValue() << std::endl;; ; // expected minimum is 0; if ( minimum->MinValue() < 1.E-4 ); std::cout << ""Minimizer "" << minName ",MatchSource.WIKI,doc/master/NumericalMinimization_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NumericalMinimization_8C.html
Integrability,wrap,wrapper,"eturn 100*tmp1*tmp1+tmp2*tmp2;; }; ; int NumericalMinimization(const char * minName = ""Minuit2"",; const char *algoName = """" ,; int randomSeed = -1); {; // create minimizer giving a name and a name (optionally) for the specific; // algorithm; // possible choices are:; // minName algoName; // Minuit /Minuit2 Migrad, Simplex,Combined,Scan (default is Migrad); // Minuit2 Fumili2; // Fumili; // GSLMultiMin ConjugateFR, ConjugatePR, BFGS,; // BFGS2, SteepestDescent; // GSLMultiFit; // GSLSimAn; // Genetic; ROOT::Math::Minimizer* minimum =; ROOT::Math::Factory::CreateMinimizer(minName, algoName);; if (!minimum) {; std::cerr << ""Error: cannot create minimizer \"""" << minName; << ""\"". Maybe the required library was not built?"" << std::endl;; return 1;; }; ; // set tolerance , etc...; minimum->SetMaxFunctionCalls(1000000); // for Minuit/Minuit2; minimum->SetMaxIterations(10000); // for GSL; minimum->SetTolerance(0.001);; minimum->SetPrintLevel(1);; ; // create function wrapper for minimizer; // a IMultiGenFunction type; ROOT::Math::Functor f(&RosenBrock,2);; double step[2] = {0.01,0.01};; // starting point; ; double variable[2] = { -1.,1.2};; if (randomSeed >= 0) {; TRandom2 r(randomSeed);; variable[0] = r.Uniform(-20,20);; variable[1] = r.Uniform(-20,20);; }; ; minimum->SetFunction(f);; ; // Set the free variables to be minimized !; minimum->SetVariable(0,""x"",variable[0], step[0]);; minimum->SetVariable(1,""y"",variable[1], step[1]);; ; // do the minimization; minimum->Minimize();; ; const double *xs = minimum->X();; std::cout << ""Minimum: f("" << xs[0] << "","" << xs[1] << ""): ""; << minimum->MinValue() << std::endl;; ; // expected minimum is 0; if ( minimum->MinValue() < 1.E-4 ); std::cout << ""Minimizer "" << minName << "" - "" << algoName; << "" converged to the right minimum"" << std::endl;; else {; std::cout << ""Minimizer "" << minName << "" - "" << algoName; << "" failed to converge !!!"" << std::endl;; Error(""NumericalMinimization"",""fail to converge"");; }; ; return 0;; }; Functor.h; Mi",MatchSource.WIKI,doc/master/NumericalMinimization_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NumericalMinimization_8C.html
Modifiability,variab,variable,"ame = """" ,; int randomSeed = -1); {; // create minimizer giving a name and a name (optionally) for the specific; // algorithm; // possible choices are:; // minName algoName; // Minuit /Minuit2 Migrad, Simplex,Combined,Scan (default is Migrad); // Minuit2 Fumili2; // Fumili; // GSLMultiMin ConjugateFR, ConjugatePR, BFGS,; // BFGS2, SteepestDescent; // GSLMultiFit; // GSLSimAn; // Genetic; ROOT::Math::Minimizer* minimum =; ROOT::Math::Factory::CreateMinimizer(minName, algoName);; if (!minimum) {; std::cerr << ""Error: cannot create minimizer \"""" << minName; << ""\"". Maybe the required library was not built?"" << std::endl;; return 1;; }; ; // set tolerance , etc...; minimum->SetMaxFunctionCalls(1000000); // for Minuit/Minuit2; minimum->SetMaxIterations(10000); // for GSL; minimum->SetTolerance(0.001);; minimum->SetPrintLevel(1);; ; // create function wrapper for minimizer; // a IMultiGenFunction type; ROOT::Math::Functor f(&RosenBrock,2);; double step[2] = {0.01,0.01};; // starting point; ; double variable[2] = { -1.,1.2};; if (randomSeed >= 0) {; TRandom2 r(randomSeed);; variable[0] = r.Uniform(-20,20);; variable[1] = r.Uniform(-20,20);; }; ; minimum->SetFunction(f);; ; // Set the free variables to be minimized !; minimum->SetVariable(0,""x"",variable[0], step[0]);; minimum->SetVariable(1,""y"",variable[1], step[1]);; ; // do the minimization; minimum->Minimize();; ; const double *xs = minimum->X();; std::cout << ""Minimum: f("" << xs[0] << "","" << xs[1] << ""): ""; << minimum->MinValue() << std::endl;; ; // expected minimum is 0; if ( minimum->MinValue() < 1.E-4 ); std::cout << ""Minimizer "" << minName << "" - "" << algoName; << "" converged to the right minimum"" << std::endl;; else {; std::cout << ""Minimizer "" << minName << "" - "" << algoName; << "" failed to converge !!!"" << std::endl;; Error(""NumericalMinimization"",""fail to converge"");; }; ; return 0;; }; Functor.h; Minimizer.h; f#define f(i)Definition RSha256.hxx:104; TError.h; Errorvoid Error(const char *location, const char *msg",MatchSource.WIKI,doc/master/NumericalMinimization_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NumericalMinimization_8C.html
Performance,perform,perform,"="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::MinValuevirtual double MinValue() const =0return minimum function value; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; Factory.h; NumericalMinimizationDefinition NumericalMinimization.py:1; AuthorLorenzo Moneta ; Definition in file NumericalMinimization.C. tutorialsfitNumericalMinimization.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/NumericalMinimization_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/NumericalMinimization_8C.html
Integrability,depend,dependency,". ROOT: bindings/r/tests/Object.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; Object.C File Reference. #include <TRInterface.h>. Include dependency graph for Object.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; void Object ();  . Variables; ROOT::R::TRInterface & r = ROOT::R::TRInterface::Instance();  . Function Documentation. ◆ Object(). void Object ; (; ). Definition at line 6 of file Object.C. Variable Documentation. ◆ r. ROOT::R::TRInterface& r = ROOT::R::TRInterface::Instance(). Definition at line 4 of file Object.C. bindingsrtestsObject.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Object_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Object_8C.html
Testability,test,tests,". ROOT: bindings/r/tests/Object.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; Object.C File Reference. #include <TRInterface.h>. Include dependency graph for Object.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; void Object ();  . Variables; ROOT::R::TRInterface & r = ROOT::R::TRInterface::Instance();  . Function Documentation. ◆ Object(). void Object ; (; ). Definition at line 6 of file Object.C. Variable Documentation. ◆ r. ROOT::R::TRInterface& r = ROOT::R::TRInterface::Instance(). Definition at line 4 of file Object.C. bindingsrtestsObject.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Object_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Object_8C.html
Availability,avail,available,". ROOT: tutorials/graphics/palettes.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. palettes.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro draws all the high definition palettes available in ROOT. ; It generates a png file for each palette and one pdf file, with a table of content, containing all the palettes.; In ROOT, more than 60 high quality palettes are predefined with 255 colors each.; These palettes can be accessed ""by name"" with gStyle->SetPalette(num). num can be taken within the enum given in the previous link. As an example gStyle->SetPalette(kCividis) will select the following palette. ; TCanvas *c = nullptr;; ; void draw_palette(int p, TString n); {; delete c;; c = new TCanvas(""c"",""Contours"",0,0,500,500);; TF2 *f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",0.999,3.002,0.999,3.002);; f2->SetContour(99);; gStyle->SetPalette(p);; f2->SetLineWidth(1);; f2->SetLineColor(kBlack);; f2->Draw(""surf1z"");; ; // Title; TPaveText *pt = new TPaveText(10,11,10,11,""blNDC"");; pt->SetName(""title"");; pt->Draw();; TString num = n;; num.ReplaceAll("" "","""");; TLatex *l = new TLatex(-0.8704441,0.9779387,TString::Format(""Palette #%d: %s #scale[0.7]{(#font[82]{k%s})}"",p,n.Data(),num.Data()));; l->SetTextFont(42);; l->SetTextSize(0.035);; l->Draw();; c->Update();; c->Print(TString::Format(""palette_%d.png"", p));; ; TString opt = TString(""Title:"") + n;; if (p == kDeepSea); c->Print(""palettes.pdf("", opt.Data());; else if (p == kCividis); c->Print(""palettes.pdf)"", opt.Data());; else; c->Print(""palettes.pdf"", opt.Data());; }; ; void palettes(); {; gROOT->SetBatch(1);; draw_palette(kDeepSea, ""Deap Sea"");; draw_palette(kGreyScale, ""Grey Scale"");; draw_palette(kDarkBodyRadiator, ""Dark Body Radiator"");; draw_palette(kBlueYellow, ""Blue Yellow"");; draw_palette(kRainBow, ""Rain Bow"");; draw_palette(kInvertedDarkBodyRadiator, ""Inverted Dark Body Radiator"");; draw_palette(kBird, ""Bird"");; draw_palette",MatchSource.WIKI,doc/master/palettes_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/palettes_8C.html
Security,access,accessed,". ROOT: tutorials/graphics/palettes.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. palettes.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro draws all the high definition palettes available in ROOT. ; It generates a png file for each palette and one pdf file, with a table of content, containing all the palettes.; In ROOT, more than 60 high quality palettes are predefined with 255 colors each.; These palettes can be accessed ""by name"" with gStyle->SetPalette(num). num can be taken within the enum given in the previous link. As an example gStyle->SetPalette(kCividis) will select the following palette. ; TCanvas *c = nullptr;; ; void draw_palette(int p, TString n); {; delete c;; c = new TCanvas(""c"",""Contours"",0,0,500,500);; TF2 *f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",0.999,3.002,0.999,3.002);; f2->SetContour(99);; gStyle->SetPalette(p);; f2->SetLineWidth(1);; f2->SetLineColor(kBlack);; f2->Draw(""surf1z"");; ; // Title; TPaveText *pt = new TPaveText(10,11,10,11,""blNDC"");; pt->SetName(""title"");; pt->Draw();; TString num = n;; num.ReplaceAll("" "","""");; TLatex *l = new TLatex(-0.8704441,0.9779387,TString::Format(""Palette #%d: %s #scale[0.7]{(#font[82]{k%s})}"",p,n.Data(),num.Data()));; l->SetTextFont(42);; l->SetTextSize(0.035);; l->Draw();; c->Update();; c->Print(TString::Format(""palette_%d.png"", p));; ; TString opt = TString(""Title:"") + n;; if (p == kDeepSea); c->Print(""palettes.pdf("", opt.Data());; else if (p == kCividis); c->Print(""palettes.pdf)"", opt.Data());; else; c->Print(""palettes.pdf"", opt.Data());; }; ; void palettes(); {; gROOT->SetBatch(1);; draw_palette(kDeepSea, ""Deap Sea"");; draw_palette(kGreyScale, ""Grey Scale"");; draw_palette(kDarkBodyRadiator, ""Dark Body Radiator"");; draw_palette(kBlueYellow, ""Blue Yellow"");; draw_palette(kRainBow, ""Rain Bow"");; draw_palette(kInvertedDarkBodyRadiator, ""Inverted Dark Body Radiator"");; draw_palette(kBird, ""Bird"");; draw_palette",MatchSource.WIKI,doc/master/palettes_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/palettes_8C.html
Modifiability,variab,variables,"nge+9);; firstaxis->AddRange(new TParallelCoordRange(firstaxis,-1.263024,-0.755292));; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kOrange@ kOrangeDefinition Rtypes.h:67; kViolet@ kVioletDefinition Rtypes.h:67; TCanvas.h; TFile.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordRangeA TParallelCoordRange is a range used for parallel coordinates plots.Definition TParallelCoordRange.h:25; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::AddRangevoid AddRange(TParallelCoordRange *range)Add a range to the current selection on the axis.Definition TParallelCoordVar.cxx:102; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::AddSelectionvoid AddSelection(const char *title)Add a selection.Definition TParallelCoord.cxx:242; TParallelCoord::GetCurrentSelectionTParallelCoordSelect * GetCurrentSelection()Return the selection currently being edited.Definition TParallelCoord.cxx:438",MatchSource.WIKI,doc/master/parallelcoord_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/parallelcoord_8C.html
Usability,simpl,simple,"nge+9);; firstaxis->AddRange(new TParallelCoordRange(firstaxis,-1.263024,-0.755292));; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kOrange@ kOrangeDefinition Rtypes.h:67; kViolet@ kVioletDefinition Rtypes.h:67; TCanvas.h; TFile.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordRangeA TParallelCoordRange is a range used for parallel coordinates plots.Definition TParallelCoordRange.h:25; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::AddRangevoid AddRange(TParallelCoordRange *range)Add a range to the current selection on the axis.Definition TParallelCoordVar.cxx:102; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::AddSelectionvoid AddSelection(const char *title)Add a selection.Definition TParallelCoord.cxx:242; TParallelCoord::GetCurrentSelectionTParallelCoordSelect * GetCurrentSelection()Return the selection currently being edited.Definition TParallelCoord.cxx:438",MatchSource.WIKI,doc/master/parallelcoord_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/parallelcoord_8C.html
Availability,error,errors,". ROOT: tutorials/geom/parallel_world.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. parallel_world.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ; This typically generates inconsistent response of the navigation methods, leading to inefficiencies during tracking, errors in the material budget calculations, and so on. Among those, there are dangerous cases when the hidden volumes are sensitive. This macro demonstrates how to use the ""parallel world"" feature to assign highest navigation priority to some physical paths in geometry. ; void align();; ; //______________________________________________________________________________; void parallel_world(Bool_t usepw=kTRUE, Bool_t useovlp=kTRUE); {; // web geometry display does not support ""parallel world"" feature; gROOT->SetWebDisplay(""off"");; ; TGeoManager *geom = new TGeoManager(""parallel_world"", ""Showcase for prioritized physical paths"");; TGeoMaterial *matV = new TGeoMaterial(""Vac"", 0,0,0);; TGeoMedium *medV = new TGeoMedium(""MEDVAC"",1,matV);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *medAl = new TGeoMedium(""MEDAL"",2,matAl);; TGeoMaterial *matSi = new TGeoMaterial(""Si"", 28.085,14,2.329);; TGeoMedium *medSi = new TGeoMedium(""MEDSI"",3,matSi);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",medV,100,400,1000);; gGeoManager->SetTopVolume(top);; ; // Shape for the support block; TGeoBBox *sblock = new TGeoBBox(""sblock"", 20,10,2);; // The volume for the support; TGeoVolume *support = new TGeoVolume(""block"",sblock, medAl);; support->SetLineColor(kGreen);; ; // Shape for the sensor to be prioritized in case of overlap; TGeoBBox *ssensor = new TGeoBBox(""sensor"", 19,9,0.2);; // The volume for the sensor; TGeoVolume *sensor = new TGeoV",MatchSource.WIKI,doc/master/parallel__world_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html
Energy Efficiency,sensor,sensor,"ow to use the ""parallel world"" feature to assign highest navigation priority to some physical paths in geometry. ; void align();; ; //______________________________________________________________________________; void parallel_world(Bool_t usepw=kTRUE, Bool_t useovlp=kTRUE); {; // web geometry display does not support ""parallel world"" feature; gROOT->SetWebDisplay(""off"");; ; TGeoManager *geom = new TGeoManager(""parallel_world"", ""Showcase for prioritized physical paths"");; TGeoMaterial *matV = new TGeoMaterial(""Vac"", 0,0,0);; TGeoMedium *medV = new TGeoMedium(""MEDVAC"",1,matV);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *medAl = new TGeoMedium(""MEDAL"",2,matAl);; TGeoMaterial *matSi = new TGeoMaterial(""Si"", 28.085,14,2.329);; TGeoMedium *medSi = new TGeoMedium(""MEDSI"",3,matSi);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",medV,100,400,1000);; gGeoManager->SetTopVolume(top);; ; // Shape for the support block; TGeoBBox *sblock = new TGeoBBox(""sblock"", 20,10,2);; // The volume for the support; TGeoVolume *support = new TGeoVolume(""block"",sblock, medAl);; support->SetLineColor(kGreen);; ; // Shape for the sensor to be prioritized in case of overlap; TGeoBBox *ssensor = new TGeoBBox(""sensor"", 19,9,0.2);; // The volume for the sensor; TGeoVolume *sensor = new TGeoVolume(""sensor"",ssensor, medSi);; sensor->SetLineColor(kRed);; ; // Chip assembly of support+sensor; TGeoVolumeAssembly *chip = new TGeoVolumeAssembly(""chip"");; chip->AddNode(support, 1);; chip->AddNode(sensor,1, new TGeoTranslation(0,0,-2.1));; ; // A ladder that normally sags; TGeoBBox *sladder = new TGeoBBox(""sladder"", 20,300,5);; // The volume for the ladder; TGeoVolume *ladder = new TGeoVolume(""ladder"",sladder, medAl);; ladder->SetLineColor(kBlue);; ; // Add nodes; top->AddNode(ladder,1);; for (Int_t i=0; i<10; i++); top->AddNode(chip, i+1, new TGeoTranslation(0, -225.+50.*i, 10));; ; gGeoManager->CloseGeometry();; TGeoParallelWorld *pw = nullptr;; if (usepw) pw = gGeoManager->Cr",MatchSource.WIKI,doc/master/parallel__world_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html
Performance,optimiz,optimization,"elWorldTGeoParallelWorld * CreateParallelWorld(const char *name)Create a parallel world for prioritised navigation.Definition TGeoManager.cxx:4277; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoParallelWorldBase class for a flat parallel geometry.Definition TGeoParallelWorld.h:23; TGeoParallelWorld::CloseGeometryBool_t CloseGeometry()The main geometry must be closed.Definition TGeoParallelWorld.cxx:165; TGeoParallelWorld::AddNodevoid AddNode(const char *path)Add a node normally to this world. Overlapping nodes not allowed.Definition TGeoParallelWorld.cxx:92; TGeoParallelWorld::PrintDetectedOverlapsInt_t PrintDetectedOverlaps() constPrint the overlaps which were detected during real tracking.Definition TGeoParallelWorld.cxx:135; TGeoParallelWorld::AddOverlapvoid AddOverlap(TGeoVolume *vol, Bool_t activate=kTRUE)To use this optimization, the user should declare the full list of volumes which may overlap with any...Definition TGeoParallelWorld.cxx:108; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeAssembly::AddNodeTGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""") overrideAdd a component to the assembly.Definition TGeoVolume.cxx:2978; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::RandomRaysvoid RandomRays(I",MatchSource.WIKI,doc/master/parallel__world_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html
Safety,detect,detected,"cxx:3655; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManager.cxx:4288; TGeoManager::CreateParallelWorldTGeoParallelWorld * CreateParallelWorld(const char *name)Create a parallel world for prioritised navigation.Definition TGeoManager.cxx:4277; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoParallelWorldBase class for a flat parallel geometry.Definition TGeoParallelWorld.h:23; TGeoParallelWorld::CloseGeometryBool_t CloseGeometry()The main geometry must be closed.Definition TGeoParallelWorld.cxx:165; TGeoParallelWorld::AddNodevoid AddNode(const char *path)Add a node normally to this world. Overlapping nodes not allowed.Definition TGeoParallelWorld.cxx:92; TGeoParallelWorld::PrintDetectedOverlapsInt_t PrintDetectedOverlaps() constPrint the overlaps which were detected during real tracking.Definition TGeoParallelWorld.cxx:135; TGeoParallelWorld::AddOverlapvoid AddOverlap(TGeoVolume *vol, Bool_t activate=kTRUE)To use this optimization, the user should declare the full list of volumes which may overlap with any...Definition TGeoParallelWorld.cxx:108; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeAssembly::AddNodeTGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""") overrideAdd a componen",MatchSource.WIKI,doc/master/parallel__world_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html
Availability,error,error,"Error.h>; 16 ; 17namespace ROOT {; 18 ; 19namespace Fit {; 20 ; 21/// set a double side limit,; 22/// if low == up the parameter is fixed if low > up the limits are removed; 23/// The current parameter value should be within the given limits [low,up].; 24/// If the value is outside the limits, then a new parameter value is set to = (up+low)/2; 25void ParameterSettings::SetLimits(double low, double up); 26{; 27 ; 28 if (low > up) {; 29 RemoveLimits();; 30 return;; 31 }; 32 if (low == up && low == fValue) {; 33 Fix();; 34 return;; 35 }; 36 if (low > fValue || up < fValue) {; 37 MATH_INFO_MSG(""ParameterSettings"",; 38 ""lower/upper bounds outside current parameter value. The value will be set to (low+up)/2 "");; 39 fValue = 0.5 * (up + low);; 40 }; 41 fLowerLimit = low;; 42 fUpperLimit = up;; 43 fHasLowerLimit = true;; 44 fHasUpperLimit = true;; 45}; 46 ; 47} // end namespace Fit; 48 ; 49} // end namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; ParameterSettings.h; ROOT::Fit::ParameterSettings::RemoveLimitsvoid RemoveLimits()remove all limitDefinition ParameterSettings.h:140; ROOT::Fit::ParameterSettings::fLowerLimitdouble fLowerLimitlower parameter limitDefinition ParameterSettings.h:152; ROOT::Fit::ParameterSettings::fUpperLimitdouble fUpperLimitupper parameter limitDefinition ParameterSettings.h:153; ROOT::Fit::ParameterSettings::fHasUpperLimitbool fHasUpperLimitflag to control upper parameter limitDefinition ParameterSettings.h:155; ROOT::Fit::ParameterSettings::fHasLowerLimitbool fHasLowerLimitflag to control lower parameter limitDefinition ParameterSettings.h:154; ROOT::Fit::ParameterSettings::SetLimitsvoid SetLimits(double low, double up)set a double side limit, if low == up the parameter is fixed if low > up the limits are removed The c...Definition ParameterSettings.cxx:25; ROOT::Fit::ParameterSettings::fValuedouble fVa",MatchSource.WIKI,doc/master/ParameterSettings_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParameterSettings_8cxx_source.html
Integrability,message,messages,"Error.h>; 16 ; 17namespace ROOT {; 18 ; 19namespace Fit {; 20 ; 21/// set a double side limit,; 22/// if low == up the parameter is fixed if low > up the limits are removed; 23/// The current parameter value should be within the given limits [low,up].; 24/// If the value is outside the limits, then a new parameter value is set to = (up+low)/2; 25void ParameterSettings::SetLimits(double low, double up); 26{; 27 ; 28 if (low > up) {; 29 RemoveLimits();; 30 return;; 31 }; 32 if (low == up && low == fValue) {; 33 Fix();; 34 return;; 35 }; 36 if (low > fValue || up < fValue) {; 37 MATH_INFO_MSG(""ParameterSettings"",; 38 ""lower/upper bounds outside current parameter value. The value will be set to (low+up)/2 "");; 39 fValue = 0.5 * (up + low);; 40 }; 41 fLowerLimit = low;; 42 fUpperLimit = up;; 43 fHasLowerLimit = true;; 44 fHasUpperLimit = true;; 45}; 46 ; 47} // end namespace Fit; 48 ; 49} // end namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; ParameterSettings.h; ROOT::Fit::ParameterSettings::RemoveLimitsvoid RemoveLimits()remove all limitDefinition ParameterSettings.h:140; ROOT::Fit::ParameterSettings::fLowerLimitdouble fLowerLimitlower parameter limitDefinition ParameterSettings.h:152; ROOT::Fit::ParameterSettings::fUpperLimitdouble fUpperLimitupper parameter limitDefinition ParameterSettings.h:153; ROOT::Fit::ParameterSettings::fHasUpperLimitbool fHasUpperLimitflag to control upper parameter limitDefinition ParameterSettings.h:155; ROOT::Fit::ParameterSettings::fHasLowerLimitbool fHasLowerLimitflag to control lower parameter limitDefinition ParameterSettings.h:154; ROOT::Fit::ParameterSettings::SetLimitsvoid SetLimits(double low, double up)set a double side limit, if low == up the parameter is fixed if low > up the limits are removed The c...Definition ParameterSettings.cxx:25; ROOT::Fit::ParameterSettings::fValuedouble fVa",MatchSource.WIKI,doc/master/ParameterSettings_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParameterSettings_8cxx_source.html
Modifiability,config,configured,"Error.h>; 16 ; 17namespace ROOT {; 18 ; 19namespace Fit {; 20 ; 21/// set a double side limit,; 22/// if low == up the parameter is fixed if low > up the limits are removed; 23/// The current parameter value should be within the given limits [low,up].; 24/// If the value is outside the limits, then a new parameter value is set to = (up+low)/2; 25void ParameterSettings::SetLimits(double low, double up); 26{; 27 ; 28 if (low > up) {; 29 RemoveLimits();; 30 return;; 31 }; 32 if (low == up && low == fValue) {; 33 Fix();; 34 return;; 35 }; 36 if (low > fValue || up < fValue) {; 37 MATH_INFO_MSG(""ParameterSettings"",; 38 ""lower/upper bounds outside current parameter value. The value will be set to (low+up)/2 "");; 39 fValue = 0.5 * (up + low);; 40 }; 41 fLowerLimit = low;; 42 fUpperLimit = up;; 43 fHasLowerLimit = true;; 44 fHasUpperLimit = true;; 45}; 46 ; 47} // end namespace Fit; 48 ; 49} // end namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; ParameterSettings.h; ROOT::Fit::ParameterSettings::RemoveLimitsvoid RemoveLimits()remove all limitDefinition ParameterSettings.h:140; ROOT::Fit::ParameterSettings::fLowerLimitdouble fLowerLimitlower parameter limitDefinition ParameterSettings.h:152; ROOT::Fit::ParameterSettings::fUpperLimitdouble fUpperLimitupper parameter limitDefinition ParameterSettings.h:153; ROOT::Fit::ParameterSettings::fHasUpperLimitbool fHasUpperLimitflag to control upper parameter limitDefinition ParameterSettings.h:155; ROOT::Fit::ParameterSettings::fHasLowerLimitbool fHasLowerLimitflag to control lower parameter limitDefinition ParameterSettings.h:154; ROOT::Fit::ParameterSettings::SetLimitsvoid SetLimits(double low, double up)set a double side limit, if low == up the parameter is fixed if low > up the limits are removed The c...Definition ParameterSettings.cxx:25; ROOT::Fit::ParameterSettings::fValuedouble fVa",MatchSource.WIKI,doc/master/ParameterSettings_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParameterSettings_8cxx_source.html
Usability,simpl,simply,"Error.h>; 16 ; 17namespace ROOT {; 18 ; 19namespace Fit {; 20 ; 21/// set a double side limit,; 22/// if low == up the parameter is fixed if low > up the limits are removed; 23/// The current parameter value should be within the given limits [low,up].; 24/// If the value is outside the limits, then a new parameter value is set to = (up+low)/2; 25void ParameterSettings::SetLimits(double low, double up); 26{; 27 ; 28 if (low > up) {; 29 RemoveLimits();; 30 return;; 31 }; 32 if (low == up && low == fValue) {; 33 Fix();; 34 return;; 35 }; 36 if (low > fValue || up < fValue) {; 37 MATH_INFO_MSG(""ParameterSettings"",; 38 ""lower/upper bounds outside current parameter value. The value will be set to (low+up)/2 "");; 39 fValue = 0.5 * (up + low);; 40 }; 41 fLowerLimit = low;; 42 fUpperLimit = up;; 43 fHasLowerLimit = true;; 44 fHasUpperLimit = true;; 45}; 46 ; 47} // end namespace Fit; 48 ; 49} // end namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; ParameterSettings.h; ROOT::Fit::ParameterSettings::RemoveLimitsvoid RemoveLimits()remove all limitDefinition ParameterSettings.h:140; ROOT::Fit::ParameterSettings::fLowerLimitdouble fLowerLimitlower parameter limitDefinition ParameterSettings.h:152; ROOT::Fit::ParameterSettings::fUpperLimitdouble fUpperLimitupper parameter limitDefinition ParameterSettings.h:153; ROOT::Fit::ParameterSettings::fHasUpperLimitbool fHasUpperLimitflag to control upper parameter limitDefinition ParameterSettings.h:155; ROOT::Fit::ParameterSettings::fHasLowerLimitbool fHasLowerLimitflag to control lower parameter limitDefinition ParameterSettings.h:154; ROOT::Fit::ParameterSettings::SetLimitsvoid SetLimits(double low, double up)set a double side limit, if low == up the parameter is fixed if low > up the limits are removed The c...Definition ParameterSettings.cxx:25; ROOT::Fit::ParameterSettings::fValuedouble fVa",MatchSource.WIKI,doc/master/ParameterSettings_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParameterSettings_8cxx_source.html
Deployability,release,release,"alue(value);; 71 SetStepSize(step);; 72 }; 73 ; 74 /// set a limited parameter. The given value should be within the given limits [min,max]; 75 void Set(const std::string & name, double value, double step, double lower, double upper ) {; 76 SetName(name);; 77 SetValue(value);; 78 SetStepSize(step);; 79 SetLimits(lower,upper);; 80 }; 81 ; 82 /// set a fixed parameter; 83 void Set(const std::string & name, double value) {; 84 SetName(name);; 85 SetValue(value);; 86 Fix();; 87 }; 88 ; 89 /// return parameter value; 90 double Value() const { return fValue; }; 91 /// return step size; 92 double StepSize() const { return fStepSize; }; 93 /// return lower limit value; 94 double LowerLimit() const {return fLowerLimit;}; 95 /// return upper limit value; 96 double UpperLimit() const {return fUpperLimit;}; 97 /// check if is fixed; 98 bool IsFixed() const { return fFix; }; 99 /// check if parameter has lower limit; 100 bool HasLowerLimit() const {return fHasLowerLimit; }; 101 /// check if parameter has upper limit; 102 bool HasUpperLimit() const {return fHasUpperLimit; }; 103 /// check if is bound; 104 bool IsBound() const { return fHasLowerLimit || fHasUpperLimit; }; 105 /// check if is double bound (upper AND lower limit); 106 bool IsDoubleBound() const { return fHasLowerLimit && fHasUpperLimit; }; 107 /// return name; 108 const std::string & Name() const { return fName; }; 109 ; 110 /** interaction **/; 111 ; 112 /// set name; 113 void SetName(const std::string & name ) { fName = name; }; 114 ; 115 /// fix the parameter; 116 void Fix() {fFix = true;}; 117 /// release the parameter; 118 void Release() {fFix = false;}; 119 /// set the value; 120 void SetValue(double val) {fValue = val;}; 121 /// set the step size; 122 void SetStepSize(double err) {fStepSize = err;}; 123 void SetLimits(double low, double up);; 124 /// set a single upper limit; 125 void SetUpperLimit(double up) {; 126 fLowerLimit = 0.;; 127 fUpperLimit = up;; 128 fHasLowerLimit = false;; 129 fHasUpperLimit = tru",MatchSource.WIKI,doc/master/ParameterSettings_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParameterSettings_8h_source.html
Deployability,release,release,"torTempl(FreeFunc f) :; 312 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>,FreeFunc>(f) ); 313 {; 314 }; 315 ; 316 // specialization used in TF1; 317 ParamFunctorTempl(const std::function<T(const T *f, const Double_t *param)> &func) :; 318 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>, const std::function<T(const T *f, const Double_t *param)>>(func)); 319 {; 320 }; 321 ; 322 /**; 323 Destructor (no operations); 324 */; 325 virtual ~ParamFunctorTempl () {; 326 if (fImpl) delete fImpl;; 327 }; 328 ; 329 /**; 330 Copy constructor; 331 */; 332 ParamFunctorTempl(const ParamFunctorTempl & rhs) :; 333 fImpl(nullptr); 334 {; 335// if (rhs.fImpl.get() != 0); 336// fImpl = std::unique_ptr<Impl>( (rhs.fImpl)->Clone() );; 337 if (rhs.fImpl) fImpl = rhs.fImpl->Clone();; 338 }; 339 ; 340 /**; 341 Assignment operator; 342 */; 343 ParamFunctorTempl & operator = (const ParamFunctorTempl & rhs) {; 344// ParamFunctor copy(rhs);; 345 // swap unique_ptr by hand; 346// Impl * p = fImpl.release();; 347// fImpl.reset(copy.fImpl.release());; 348// copy.fImpl.reset(p);; 349 ; 350 if(this != &rhs) {; 351 if (fImpl) delete fImpl;; 352 fImpl = nullptr;; 353 if (rhs.fImpl); 354 fImpl = rhs.fImpl->Clone();; 355 }; 356 return *this;; 357 }; 358 ; 359 void * GetImpl() { return (void *) fImpl; }; 360 ; 361 ; 362 T operator() ( T * x, double * p) {; 363 return (*fImpl)(x,p);; 364 }; 365 ; 366 T operator() (const T * x, const double * p) {; 367 return (*fImpl)(x,p);; 368 }; 369 ; 370 ; 371 bool Empty() const { return !fImpl; }; 372 ; 373 ; 374 void SetFunction(Impl * f) {; 375 fImpl = f;; 376 }; 377 ; 378private :; 379 ; 380 ; 381 //std::unique_ptr<Impl> fImpl;; 382 Impl * fImpl;; 383 ; 384 ; 385};; 386 ; 387 ; 388using ParamFunctor = ParamFunctorTempl<double>;; 389 ; 390 } // end namespace Math; 391 ; 392} // end namespace ROOT; 393 ; 394 ; 395#endif /* ROOT_Math_ParamFunctor */; f#define f(i)Definition RSha256.hxx:104; RtypesCore.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TG",MatchSource.WIKI,doc/master/ParamFunctor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParamFunctor_8h_source.html
Integrability,wrap,wrapping,"3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for Functor classes.; 12// design is inspired by the Loki Functor; 13 ; 14#ifndef ROOT_Math_ParamFunctor; 15#define ROOT_Math_ParamFunctor; 16 ; 17// #ifndef ROOT_Math_IFunction; 18// #include ""Math/IFunction.h""; 19// #endif; 20 ; 21// #ifndef Root_Math_StaticCheck; 22// #include ""Math/StaticCheck.h""; 23// #endif; 24 ; 25//#include <memory>; 26 ; 27#include ""RtypesCore.h""; 28#include <functional>; 29#include <iostream>; 30 ; 31namespace ROOT {; 32 ; 33namespace Math {; 34 ; 35/**; 36 * \defgroup ParamFunctor_int N-D parametric functions; 37 * \brief Multi-dimensional parametric functions; 38 */; 39 ; 40/** class defining the signature for multi-dim parametric functions; 41 ; 42 @ingroup ParamFunctor_int; 43 */; 44template<class T>; 45class ParamFunctionBase {; 46 public:; 47 virtual ~ParamFunctionBase() {}; 48 virtual T operator() (const T * x, const double *p) = 0;; 49 virtual T operator() (T * x, double *p) = 0;; 50 virtual ParamFunctionBase * Clone() const = 0;; 51};; 52 ; 53 ; 54 ; 55/**; 56 ParamFunctor Handler class is responsible for wrapping any other functor and pointer to; 57 free C functions.; 58 It can be created from any function implementing the correct signature; 59 corresponding to the requested type; 60 ; 61 @ingroup ParamFunctor_int; 62 ; 63*/; 64 ; 65template<class ParentFunctor, class Func >; 66class ParamFunctorHandler : public ParentFunctor::Impl {; 67 ; 68 typedef typename ParentFunctor::EvalType EvalType;; 69 typedef typename ParentFunctor::Impl Base;; 70 ; 71public:; 72 ; 73 // constructor; 74 ParamFunctorHandler(const Func & fun) : fFunc(fun) {}; 75 ; 76 ; 77 virtual ~ParamFunctorHandler() {}; 78 ; 79 ; 80 // for 1D functions; 81 inline EvalType operator() (EvalType x, double *p) {; 82 retur",MatchSource.WIKI,doc/master/ParamFunctor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParamFunctor_8h_source.html
Usability,simpl,simple,"61/**; 262 Param Functor class for Multidimensional functions.; 263 It is used to wrap in a very simple and convenient way; 264 any other C++ callable object (implementation double operator( const double *, const double * ) ); 265 or a member function with the correct signature,; 266 like Foo::EvalPar(const double *, const double *); 267 ; 268 @ingroup ParamFunc; 269 ; 270 */; 271 ; 272 ; 273template<class T>; 274class ParamFunctorTempl {; 275 ; 276 ; 277public:; 278 ; 279 typedef T EvalType;; 280 typedef ParamFunctionBase<T> Impl;; 281 ; 282 ; 283 /**; 284 Default constructor; 285 */; 286 ParamFunctorTempl () : fImpl(nullptr) {}; 287 ; 288 ; 289 /**; 290 construct from a pointer to member function (multi-dim type); 291 */; 292 template <class PtrObj, typename MemFn>; 293 ParamFunctorTempl(const PtrObj& p, MemFn memFn); 294 : fImpl(new ParamMemFunHandler<ParamFunctorTempl<T>, PtrObj, MemFn>(p, memFn)); 295 {}; 296 ; 297 ; 298 ; 299 /**; 300 construct from another generic Functor of multi-dimension; 301 */; 302 template <typename Func>; 303 explicit ParamFunctorTempl( const Func & f) :; 304 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>,Func>(f) ); 305 {}; 306 ; 307 ; 308 ; 309 // specialization used in TF1; 310 typedef T (* FreeFunc ) (T * , double *);; 311 ParamFunctorTempl(FreeFunc f) :; 312 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>,FreeFunc>(f) ); 313 {; 314 }; 315 ; 316 // specialization used in TF1; 317 ParamFunctorTempl(const std::function<T(const T *f, const Double_t *param)> &func) :; 318 fImpl(new ParamFunctorHandler<ParamFunctorTempl<T>, const std::function<T(const T *f, const Double_t *param)>>(func)); 319 {; 320 }; 321 ; 322 /**; 323 Destructor (no operations); 324 */; 325 virtual ~ParamFunctorTempl () {; 326 if (fImpl) delete fImpl;; 327 }; 328 ; 329 /**; 330 Copy constructor; 331 */; 332 ParamFunctorTempl(const ParamFunctorTempl & rhs) :; 333 fImpl(nullptr); 334 {; 335// if (rhs.fImpl.get() != 0); 336// fImpl = std::unique_ptr<Impl>( (rhs.f",MatchSource.WIKI,doc/master/ParamFunctor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ParamFunctor_8h_source.html
Safety,avoid,avoiding,"the first line, strip the new lines; # and split it into a list along 'tab' boundaries; header_row = open(afile).readline().strip().split('\t'); # Create the branch descriptor; branch_descriptor = ':'.join([header_mapping_dictionary[row][0]+'/'+; type_mapping_dictionary[header_mapping_dictionary[row][1]]; for row in header_row]); #print(branch_descriptor); ; # Handling the input and output names. Using the same; # base name for the ROOT output file.; output_ROOT_file_name = os.path.splitext(afile)[0] + '.root'; output_file = ROOT.TFile(output_ROOT_file_name, 'recreate'); print(""Outputting %s -> %s"" % (afile, output_ROOT_file_name)); ; output_tree = ROOT.TTree(tree_name, tree_name); file_lines = open(afile).readlines(); ; # Clean the data entries: remove the first (header) row.; # Ensure empty strings are tagged as such since; # ROOT doesn't differentiate between different types; # of white space. Therefore, we change all of these; # entries to 'empty'. Also, avoiding any lines that begin; # with '#'; file_lines = ['\t'.join([val if (val.find(' ') == -1 and val != ''); else 'empty' for val in line.split('\t')]); for line in file_lines[1:] if line[0] != '#' ]; ; # Removing NaN, setting these entries to 0.0.; # Also joining the list of strings into one large string.; file_as_string = ('\n'.join(file_lines)).replace('NaN', str(0.0)); #print(file_as_string); ; # creating an istringstream to pass into ReadStream; istring = ROOT.istringstream(file_as_string); ; # Now read the stream; output_tree.ReadStream(istring, branch_descriptor); ; output_file.cd(); output_tree.Write(); ; ; if __name__ == '__main__':; if len(sys.argv) < 2:; print(""Usage: %s file_to_parse.dat"" % sys.argv[0]); sys.exit(1); parse_CSV_file_with_TTree_ReadStream(""example_tree"", sys.argv[1]); ; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float",MatchSource.WIKI,doc/master/parse__CSV__file__with__TTree__ReadStream_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/parse__CSV__file__with__TTree__ReadStream_8py.html
Performance,load,load,"**********************************************/; 24 ; 25 ; 26#ifndef ROOT_Math_PdfFuncMathMore; 27#define ROOT_Math_PdfFuncMathMore; 28 ; 29namespace ROOT {; 30 namespace Math {; 31 ; 32 ; 33 /**; 34 ; 35 Probability density function of the non central \f$\chi^2\f$ distribution with \f$r\f$; 36 degrees of freedom and the noon-central parameter \f$\lambda\f$; 37 ; 38 \f[ p_r(x) = \frac{1}{\Gamma(r/2) 2^{r/2}} x^{r/2-1} e^{-x/2} \f]; 39 ; 40 for \f$x \geq 0\f$.; 41 For detailed description see; 42 <A HREF=""http://mathworld.wolfram.com/NoncentralChi-SquaredDistribution.html"">; 43 Mathworld</A>.; 44 ; 45 @ingroup PdfFunc; 46 ; 47 */; 48 ; 49 double noncentral_chisquared_pdf(double x, double r, double lambda);; 50 ; 51 } //end namespace Math; 52} // end namespace ROOT; 53 ; 54 ; 55// make a fake class to auto-load functions from MathMore; 56 ; 57namespace ROOT {; 58 namespace Math {; 59 ; 60 class MathMoreLib {; 61 ; 62 public:; 63 ; 64 // adding this method with force the auto-loading of the library; 65 static void Load();; 66 };; 67 ; 68 typedef MathMoreLib MathMoreLibrary; ; 69 }; 70 ; 71}; 72 ; 73 ; 74 ; 75#endif // ROOT_Math_PdfFuncMathMore; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Math::MathMoreLibDefinition PdfFuncMathMore.h:60; ROOT::Math::MathMoreLib::Loadstatic void Load()Definition PdfFuncMathMore.cxx:73; ROOT::Math::noncentral_chisquared_pdfdouble noncentral_chisquared_pdf(double x, double r, double lambda)Probability density function of the non central distribution with degrees of freedom and the noon-c...Definition PdfFuncMathMore.cxx:22; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::MathMoreLibraryMathMoreLib MathMoreLibraryDefinition PdfFuncMathMore.h:68; ROOTtbb::task_arena is an alias o",MatchSource.WIKI,doc/master/PdfFuncMathMore_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PdfFuncMathMore_8h_source.html
Energy Efficiency,schedul,scheduler,"1.cxx:1439; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TSpectrumAdvanced Spectra Processing.Definition TSpectrum.h:18; TSpectrum::Backgroundvirtual TH1 * Background(const TH1 *hist, Int_t niter=20, Option_t *option="""")One-dimensional background estimation function.Definition TSpectrum.cxx:145; TSpectrum::Searchvirtual Int_t Search(const TH1 *hist, Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05)One-dimensional peak search function.Definition TSpectrum.cxx:259; TSpectrum::GetPositionXDouble_t * GetPositionX() constDefinition TSpectrum.h:58; TVirtualFitter::Fitterstatic TVirtualFitter * Fitter(TObject *obj, Int_t maxpar=25)Static function returning a pointer to the current fitter.Definition TVirtualFitter.cxx:159; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; c1return c1Definition legend1.C:41; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; AuthorRene Brun ; Definition in file peaks.C. tutorialsspectrumpeaks.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/peaks_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/peaks_8C.html
Integrability,inject,injected,". ROOT: tutorials/spectrum/peaks.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. peaks.C File ReferenceTutorials » Spectrum tutorials. Detailed Description; Illustrates how to find peaks in histograms. ; This script generates a random number of gaussian peaks on top of a linear background. The position of the peaks is found via TSpectrum and injected as initial values of parameters to make a global fit. The background is computed and drawn on top of the original histogram.; This script can fit ""peaks' heights"" or ""peaks' areas"" (comment out or uncomment the line which defines __PEAKS_C_FIT_AREAS__).; To execute this example, do (in ROOT 5 or ROOT 6):; root > .x peaks.C (generate 10 peaks by default); root > .x peaks.C++ (use the compiler); root > .x peaks.C++(30) (generates 30 peaks); xDouble_t x[n]Definition legend1.C:17; To execute only the first part of the script (without fitting) specify a negative value for the number of peaks, eg; root > .x peaks.C(-20); ; Found 9 candidate peaks to fit; Found 9 useful peaks to fit; Now fitting: Be patient; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 596.686; NDf = 471; Edm = 1.7299e-05; NCalls = 1747; p0 = 527.684 +/- 2.02282 ; p1 = -0.395029 +/- 0.00304651 ; p2 = 634.668 +/- 20.672 ; p3 = 519.331 +/- 0.111412 ; p4 = 3.49861 +/- 0.109353 ; p5 = 664.735 +/- 18.7022 ; p6 = 319.147 +/- 0.131874 ; p7 = 4.69145 +/- 0.126752 ; p8 = 670.916 +/- 17.6455 ; p9 = 754.806 +/- 0.108202 ; p10 = 4.29739 +/- 0.101204 ; p11 = 669.613 +/- 20.0806 ; p12 = 475.964 +/- 0.113649 ; p13 = 3.89314 +/- 0.110985 ; p14 = 648.09 +/- 18.199 ; p15 = 989.666 +/- 0.0884478 ; p16 = 3.34535 +/- 0.0786714 ; p17 = 662.552 +/- 17.8619 ; p18 = 539.268 +/- 0.122694 ; p19 = 4.56069 +/- 0.113882 ; p20 = 659.417 +/- 16.1804 ; p21 = 948.476 +/- 0.101982 ; p22 = 4.41156 +/- 0.091998 ; p23 = 753.529 +/- 15.2593 ; p24 = 232.585 +/- 0.151403 ; p25 = 6.95019 +/- 0.122555 ; p26 = 645.477 +",MatchSource.WIKI,doc/master/peaks_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/peaks_8C.html
Performance,optimiz,optimizer,"1.cxx:1439; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TSpectrumAdvanced Spectra Processing.Definition TSpectrum.h:18; TSpectrum::Backgroundvirtual TH1 * Background(const TH1 *hist, Int_t niter=20, Option_t *option="""")One-dimensional background estimation function.Definition TSpectrum.cxx:145; TSpectrum::Searchvirtual Int_t Search(const TH1 *hist, Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05)One-dimensional peak search function.Definition TSpectrum.cxx:259; TSpectrum::GetPositionXDouble_t * GetPositionX() constDefinition TSpectrum.h:58; TVirtualFitter::Fitterstatic TVirtualFitter * Fitter(TObject *obj, Int_t maxpar=25)Static function returning a pointer to the current fitter.Definition TVirtualFitter.cxx:159; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; c1return c1Definition legend1.C:41; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; AuthorRene Brun ; Definition in file peaks.C. tutorialsspectrumpeaks.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/peaks_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/peaks_8C.html
Security,inject,injected,". ROOT: tutorials/spectrum/peaks.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. peaks.C File ReferenceTutorials » Spectrum tutorials. Detailed Description; Illustrates how to find peaks in histograms. ; This script generates a random number of gaussian peaks on top of a linear background. The position of the peaks is found via TSpectrum and injected as initial values of parameters to make a global fit. The background is computed and drawn on top of the original histogram.; This script can fit ""peaks' heights"" or ""peaks' areas"" (comment out or uncomment the line which defines __PEAKS_C_FIT_AREAS__).; To execute this example, do (in ROOT 5 or ROOT 6):; root > .x peaks.C (generate 10 peaks by default); root > .x peaks.C++ (use the compiler); root > .x peaks.C++(30) (generates 30 peaks); xDouble_t x[n]Definition legend1.C:17; To execute only the first part of the script (without fitting) specify a negative value for the number of peaks, eg; root > .x peaks.C(-20); ; Found 9 candidate peaks to fit; Found 9 useful peaks to fit; Now fitting: Be patient; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 596.686; NDf = 471; Edm = 1.7299e-05; NCalls = 1747; p0 = 527.684 +/- 2.02282 ; p1 = -0.395029 +/- 0.00304651 ; p2 = 634.668 +/- 20.672 ; p3 = 519.331 +/- 0.111412 ; p4 = 3.49861 +/- 0.109353 ; p5 = 664.735 +/- 18.7022 ; p6 = 319.147 +/- 0.131874 ; p7 = 4.69145 +/- 0.126752 ; p8 = 670.916 +/- 17.6455 ; p9 = 754.806 +/- 0.108202 ; p10 = 4.29739 +/- 0.101204 ; p11 = 669.613 +/- 20.0806 ; p12 = 475.964 +/- 0.113649 ; p13 = 3.89314 +/- 0.110985 ; p14 = 648.09 +/- 18.199 ; p15 = 989.666 +/- 0.0884478 ; p16 = 3.34535 +/- 0.0786714 ; p17 = 662.552 +/- 17.8619 ; p18 = 539.268 +/- 0.122694 ; p19 = 4.56069 +/- 0.113882 ; p20 = 659.417 +/- 16.1804 ; p21 = 948.476 +/- 0.101982 ; p22 = 4.41156 +/- 0.091998 ; p23 = 753.529 +/- 15.2593 ; p24 = 232.585 +/- 0.151403 ; p25 = 6.95019 +/- 0.122555 ; p26 = 645.477 +",MatchSource.WIKI,doc/master/peaks_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/peaks_8C.html
Testability,test,test," ; p16 = 3.34535 +/- 0.0786714 ; p17 = 662.552 +/- 17.8619 ; p18 = 539.268 +/- 0.122694 ; p19 = 4.56069 +/- 0.113882 ; p20 = 659.417 +/- 16.1804 ; p21 = 948.476 +/- 0.101982 ; p22 = 4.41156 +/- 0.091998 ; p23 = 753.529 +/- 15.2593 ; p24 = 232.585 +/- 0.151403 ; p25 = 6.95019 +/- 0.122555 ; p26 = 645.477 +/- 17.9858 ; p27 = 286.947 +/- 0.140814 ; p28 = 4.98705 +/- 0.133049 ; . ; #include ""TCanvas.h""; #include ""TMath.h""; #include ""TH1.h""; #include ""TF1.h""; #include ""TRandom.h""; #include ""TSpectrum.h""; #include ""TVirtualFitter.h""; ; //; // Comment out the line below, if you want ""peaks' heights"".; // Uncomment the line below, if you want ""peaks' areas"".; //; // #define __PEAKS_C_FIT_AREAS__ 1 /* fit peaks' areas */; ; Int_t npeaks = 30;; Double_t fpeaks(Double_t *x, Double_t *par) {; Double_t result = par[0] + par[1]*x[0];; for (Int_t p=0;p<npeaks;p++) {; Double_t norm = par[3*p+2]; // ""height"" or ""area""; Double_t mean = par[3*p+3];; Double_t sigma = par[3*p+4];; #if defined(__PEAKS_C_FIT_AREAS__); norm /= sigma * (TMath::Sqrt(TMath::TwoPi())); // ""area""; #endif /* defined(__PEAKS_C_FIT_AREAS__) */; result += norm*TMath::Gaus(x[0],mean,sigma);; }; return result;; }; void peaks(Int_t np=10) {; npeaks = TMath::Abs(np);; TH1F *h = new TH1F(""h"",""test"",500,0,1000);; // Generate n peaks at random; Double_t par[3000];; par[0] = 0.8;; par[1] = -0.6/1000;; Int_t p;; for (p=0;p<npeaks;p++) {; par[3*p+2] = 1; // ""height""; par[3*p+3] = 10+gRandom->Rndm()*980; // ""mean""; par[3*p+4] = 3+2*gRandom->Rndm(); // ""sigma""; #if defined(__PEAKS_C_FIT_AREAS__); par[3*p+2] *= par[3*p+4] * (TMath::Sqrt(TMath::TwoPi())); // ""area""; #endif /* defined(__PEAKS_C_FIT_AREAS__) */; }; TF1 *f = new TF1(""f"",fpeaks,0,1000,2+3*npeaks);; f->SetNpx(1000);; f->SetParameters(par);; TCanvas *c1 = new TCanvas(""c1"",""c1"",10,10,1000,900);; c1->Divide(1,2);; c1->cd(1);; h->FillRandom(""f"",200000);; h->Draw();; TH1F *h2 = (TH1F*)h->Clone(""h2"");; // Use TSpectrum to find the peak candidates; TSpectrum *s = new TSpect",MatchSource.WIKI,doc/master/peaks_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/peaks_8C.html
Testability,test,test,". ROOT: tutorials/graphics/piechart.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. piechart.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Pie chart example. . ; void piechart(); {; Float_t vals[] = {.2,1.1,.6,.9,2.3};; Int_t colors[] = {2,3,4,5,6};; Int_t nvals = sizeof(vals)/sizeof(vals[0]);; ; TCanvas *cpie = new TCanvas(""cpie"",""TPie test"",700,700);; cpie->Divide(2,2);; ; TPie *pie1 = new TPie(""pie1"",; ""Pie with offset and no colors"",nvals,vals);; TPie *pie2 = new TPie(""pie2"",; ""Pie with radial labels"",nvals,vals,colors);; TPie *pie3 = new TPie(""pie3"",; ""Pie with tangential labels"",nvals,vals,colors);; TPie *pie4 = new TPie(""pie4"",; ""Pie with verbose labels"",nvals,vals,colors);; ; cpie->cd(1);; pie1->SetAngularOffset(30.);; pie1->SetEntryRadiusOffset( 4, 0.1);; pie1->SetRadius(.35);; pie1->Draw(""3d"");; ; cpie->cd(2);; pie2->SetEntryRadiusOffset(2,.05);; pie2->SetEntryLineColor(2,2);; pie2->SetEntryLineWidth(2,5);; pie2->SetEntryLineStyle(2,2);; pie2->SetEntryFillStyle(1,3030);; pie2->SetCircle(.5,.45,.3);; pie2->Draw(""rsc"");; ; cpie->cd(3);; pie3->SetY(.32);; pie3->GetSlice(0)->SetValue(.8);; pie3->GetSlice(1)->SetFillStyle(3031);; pie3->SetLabelsOffset(-.1);; pie3->Draw(""3d t nol"");; TLegend *pieleg = pie3->MakeLegend();; pieleg->SetY1(.56); pieleg->SetY2(.86);; ; cpie->cd(4);; pie4->SetRadius(.2);; pie4->SetLabelsOffset(.01);; pie4->SetLabelFormat(""#splitline{%val (%perc)}{%txt}"");; pie4->Draw(""nol <"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; colorsColor * colorsDefinition X3DBuffer.c:21; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TLegendThis class displays a legend box (TPaveText) containing several legend en",MatchSource.WIKI,doc/master/piechart_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/piechart_8C.html
Integrability,depend,dependency,". ROOT: math/genvector/inc/Math/Point2D.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Point2D.h File Reference. #include ""Math/Point2Dfwd.h""; #include ""Math/GenVector/Cartesian2D.h""; #include ""Math/GenVector/Polar2D.h""; #include ""Math/GenVector/PositionVector2D.h"". Include dependency graph for Point2D.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. mathgenvectorincMathPoint2D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Point2D_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Point2D_8h.html
Deployability,update,update,". ROOT: math/genvector/inc/Math/Point3Dfwd.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Point3Dfwd.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file Point3Dfwd; 12//; 13// Created by: Lorenzo Moneta at Mon May 30 18:12:14 2005; 14//; 15// Last update: Mon May 30 18:12:14 2005; 16//; 17#ifndef ROOT_Math_Point3Dfwd; 18#define ROOT_Math_Point3Dfwd 1; 19 ; 20// forward declareations of position vectors (Points) and type defs definitions; 21 ; 22namespace ROOT {; 23 ; 24 namespace Math {; 25 ; 26 template<class CoordSystem, class Tag> class PositionVector3D;; 27 ; 28 template<typename T> class Cartesian3D;; 29 template<typename T> class Cylindrical3D;; 30 template<typename T> class CylindricalEta3D;; 31 template<typename T> class Polar3D;; 32 ; 33 class DefaultCoordinateSystemTag;; 34 ; 35 /**; 36 3D Point based on the cartesian coordinates x,y,z in double precision; 37 */; 38 typedef PositionVector3D< Cartesian3D<double>, DefaultCoordinateSystemTag > XYZPoint;; 39 ; 40 /**; 41 3D Point based on the cartesian coordinates x,y,z in single precision; 42 */; 43 typedef PositionVector3D< Cartesian3D<float>, DefaultCoordinateSystemTag > XYZPointF;; 44 typedef XYZPoint XYZPointD;; 45 ; 46 /**; 47 3D Point based on the eta based cylindrical coordinates rho, eta, phi in double precision.; 48 */; 49 typedef PositionVector3D< CylindricalEta3D<double>, DefaultCoordinateSystemTag > RhoEtaPhiPoint;; 50 /**; 51 3D Point based on the eta based cylindrical coordinates rho, eta, phi in single precision.; 52 */; 53 typedef PositionVector3D< CylindricalEta3D<float>, DefaultCoordinateSystemTag > RhoEtaPhiPointF;; 54 typedef RhoEta",MatchSource.WIKI,doc/master/Point3Dfwd_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Point3Dfwd_8h_source.html
Integrability,depend,dependency,". ROOT: math/genvector/inc/Math/Point3D.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Point3D.h File Reference. #include ""Math/Point3Dfwd.h""; #include ""Math/GenVector/Cartesian3D.h""; #include ""Math/GenVector/CylindricalEta3D.h""; #include ""Math/GenVector/Polar3D.h""; #include ""Math/GenVector/Cylindrical3D.h""; #include ""Math/GenVector/PositionVector3D.h"". Include dependency graph for Point3D.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. mathgenvectorincMathPoint3D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Point3D_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Point3D_8h.html
Availability,error,errors,,MatchSource.WIKI,doc/master/PoissonLikelihoodFCN_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PoissonLikelihoodFCN_8h_source.html
Integrability,interface,interface,,MatchSource.WIKI,doc/master/PoissonLikelihoodFCN_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PoissonLikelihoodFCN_8h_source.html
Modifiability,extend,extended,"OT_Fit_FitUtilParallel; 28// #include ""Fit/FitUtilParallel.h""; 29// #endif; 30// #endif; 31 ; 32namespace ROOT {; 33 ; 34 namespace Fit {; 35 ; 36 ; 37//___________________________________________________________________________________; 38/**; 39 class evaluating the log likelihood; 40 for binned Poisson likelihood fits; 41 it is template to distinguish gradient and non-gradient case; 42 ; 43 @ingroup FitMethodFunc; 44*/; 45template<class DerivFunType, class ModelFunType = ROOT::Math::IParamMultiFunction>; 46class PoissonLikelihoodFCN : public BasicFCN<DerivFunType,ModelFunType,BinData> {; 47 ; 48public:; 49 typedef typename ModelFunType::BackendType T;; 50 typedef BasicFCN<DerivFunType,ModelFunType,BinData> BaseFCN;; 51 ; 52 typedef ::ROOT::Math::BasicFitMethodFunction<DerivFunType> BaseObjFunction;; 53 typedef typename BaseObjFunction::BaseFunction BaseFunction;; 54 ; 55 typedef ::ROOT::Math::IParamMultiFunctionTempl<T> IModelFunction;; 56 typedef typename BaseObjFunction::Type_t Type_t;; 57 ; 58 /**; 59 Constructor from unbin data set and model function (pdf); 60 */; 61 PoissonLikelihoodFCN (const std::shared_ptr<BinData> & data, const std::shared_ptr<IModelFunction> & func, int weight = 0, bool extended = true, const ::ROOT::EExecutionPolicy &executionPolicy = ::ROOT::EExecutionPolicy::kSequential ) :; 62 BaseFCN( data, func),; 63 fIsExtended(extended),; 64 fWeight(weight),; 65 fNEffPoints(0),; 66 fGrad ( std::vector<double> ( func->NPar() ) ),; 67 fExecutionPolicy(executionPolicy); 68 { }; 69 ; 70 /**; 71 Constructor from unbin data set and model function (pdf) managed by the users; 72 */; 73 PoissonLikelihoodFCN (const BinData & data, const IModelFunction & func, int weight = 0, bool extended = true, const ::ROOT::EExecutionPolicy &executionPolicy = ::ROOT::EExecutionPolicy::kSequential ) :; 74 BaseFCN(std::make_shared<BinData>(data), std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction*>(func.Clone() ) ) ),; 75 fIsExtended(extended),; 76 fWeight(weigh",MatchSource.WIKI,doc/master/PoissonLikelihoodFCN_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PoissonLikelihoodFCN_8h_source.html
Testability,log,log,"OT_Fit_FitUtilParallel; 28// #include ""Fit/FitUtilParallel.h""; 29// #endif; 30// #endif; 31 ; 32namespace ROOT {; 33 ; 34 namespace Fit {; 35 ; 36 ; 37//___________________________________________________________________________________; 38/**; 39 class evaluating the log likelihood; 40 for binned Poisson likelihood fits; 41 it is template to distinguish gradient and non-gradient case; 42 ; 43 @ingroup FitMethodFunc; 44*/; 45template<class DerivFunType, class ModelFunType = ROOT::Math::IParamMultiFunction>; 46class PoissonLikelihoodFCN : public BasicFCN<DerivFunType,ModelFunType,BinData> {; 47 ; 48public:; 49 typedef typename ModelFunType::BackendType T;; 50 typedef BasicFCN<DerivFunType,ModelFunType,BinData> BaseFCN;; 51 ; 52 typedef ::ROOT::Math::BasicFitMethodFunction<DerivFunType> BaseObjFunction;; 53 typedef typename BaseObjFunction::BaseFunction BaseFunction;; 54 ; 55 typedef ::ROOT::Math::IParamMultiFunctionTempl<T> IModelFunction;; 56 typedef typename BaseObjFunction::Type_t Type_t;; 57 ; 58 /**; 59 Constructor from unbin data set and model function (pdf); 60 */; 61 PoissonLikelihoodFCN (const std::shared_ptr<BinData> & data, const std::shared_ptr<IModelFunction> & func, int weight = 0, bool extended = true, const ::ROOT::EExecutionPolicy &executionPolicy = ::ROOT::EExecutionPolicy::kSequential ) :; 62 BaseFCN( data, func),; 63 fIsExtended(extended),; 64 fWeight(weight),; 65 fNEffPoints(0),; 66 fGrad ( std::vector<double> ( func->NPar() ) ),; 67 fExecutionPolicy(executionPolicy); 68 { }; 69 ; 70 /**; 71 Constructor from unbin data set and model function (pdf) managed by the users; 72 */; 73 PoissonLikelihoodFCN (const BinData & data, const IModelFunction & func, int weight = 0, bool extended = true, const ::ROOT::EExecutionPolicy &executionPolicy = ::ROOT::EExecutionPolicy::kSequential ) :; 74 BaseFCN(std::make_shared<BinData>(data), std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction*>(func.Clone() ) ) ),; 75 fIsExtended(extended),; 76 fWeight(weigh",MatchSource.WIKI,doc/master/PoissonLikelihoodFCN_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PoissonLikelihoodFCN_8h_source.html
Energy Efficiency,reduce,reduces,". ROOT: tutorials/graphics/polytest1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. polytest1.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro is testing the ""compacting"" algorithm in TPadPainter. ; It reduces the number of polygon's vertices using actual pixel coordinates. It's not really useful, but just to test that the resulting polygon is still reasonable. Initial number of points is 1000000, after ""compression"" it's 523904 (with default canvas size, before you tried to resize it) - so almost half of vertices were removed but you can still see the reasonable shape. If you resize a canvas to a smaller size, the number of vertices after compression can be something like 5000 and even less. It's easy to 'fool' this algorithm though in this particular case (ellipse is a kind of fringe case, you can easily have a sequence of almost unique vertices (at a pixel level).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""Rtypes.h""; #include ""TNamed.h""; #include ""TMath.h""; ; class PolyTest1 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest1(unsigned nVertices);; ; void Paint(const Option_t *notUsed) override;; void Reset(unsigned nVertices);; ; private:; enum {; kNPointsDefault = 10000//minimal number of points.; };; ; std::vector<Double_t> fXs;; std::vector<Double_t> fYs;; };; ; //_____________________________________________________________; PolyTest1::PolyTest1(unsigned nVertices); : TNamed(""polygon_compression_test1"", ""polygon_compression_test1""); {; Reset(nVertices);; }; ; //_____________________________________________________________; void PolyTest1::Reset(unsigned nVertices); {; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""Reset, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""Reset, gRandom is null"");; ; if (nV",MatchSource.WIKI,doc/master/polytest1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/polytest1_8C.html
Testability,test,testing,". ROOT: tutorials/graphics/polytest1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. polytest1.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro is testing the ""compacting"" algorithm in TPadPainter. ; It reduces the number of polygon's vertices using actual pixel coordinates. It's not really useful, but just to test that the resulting polygon is still reasonable. Initial number of points is 1000000, after ""compression"" it's 523904 (with default canvas size, before you tried to resize it) - so almost half of vertices were removed but you can still see the reasonable shape. If you resize a canvas to a smaller size, the number of vertices after compression can be something like 5000 and even less. It's easy to 'fool' this algorithm though in this particular case (ellipse is a kind of fringe case, you can easily have a sequence of almost unique vertices (at a pixel level).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""Rtypes.h""; #include ""TNamed.h""; #include ""TMath.h""; ; class PolyTest1 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest1(unsigned nVertices);; ; void Paint(const Option_t *notUsed) override;; void Reset(unsigned nVertices);; ; private:; enum {; kNPointsDefault = 10000//minimal number of points.; };; ; std::vector<Double_t> fXs;; std::vector<Double_t> fYs;; };; ; //_____________________________________________________________; PolyTest1::PolyTest1(unsigned nVertices); : TNamed(""polygon_compression_test1"", ""polygon_compression_test1""); {; Reset(nVertices);; }; ; //_____________________________________________________________; void PolyTest1::Reset(unsigned nVertices); {; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""Reset, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""Reset, gRandom is null"");; ; if (nV",MatchSource.WIKI,doc/master/polytest1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/polytest1_8C.html
Energy Efficiency,reduce,reduces,". ROOT: tutorials/graphics/polytest2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. polytest2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; ; This macro is testing the ""compacting"" algorithm in TPadPainter. ; It reduces the number of polygon's vertices using actual pixel coordinates. This macro is testing new ""compacting"" algorithm in TPadPainter (it reduces the number of polygon's vertices using actual pixel coordinates). In principle, this test case is what our histograms (fringe cases) are: ""saw-like"" polygon (bins == teeth).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""Rtypes.h""; #include ""TNamed.h""; ; class PolyTest2 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest2();; ; void Paint(const Option_t *notUsed) override;; ; private:; enum TestSize {; kNSawPoints = 10000; };; ; //Part 1.; std::vector<Double_t> fXs1;; std::vector<Double_t> fYs1;; //Part 2.; ; std::vector<Double_t> fXs2;; std::vector<Double_t> fYs2;; };; ; //_____________________________________________________________; PolyTest2::PolyTest2(); : TNamed(""polygon_compression_test2"", ""polygon_compression_test2""); {; //Polygon 1, n of points is 10003, after 'compression' : 1897; //Polygon 2, n of points is 10003, after 'compression' : 2093; ; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""PolyTest2, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""PolyTest2, gRandom is null"");; ; Double_t xMin = 0., xMax = 0., yMin = 0., yMax = 0.;; gPad->GetRange(xMin, yMin, xMax, yMax);; assert(xMax - xMin > 0 && yMax - yMin > 0 && ""PolyTest2, invalid canvas' ranges"");; ; ; // .(0/the last)--------.(1); // | /; // | \; // | /; // .(kNSawPoints + 1)--.(kNSawPoints); ; const unsigned nVertices = 3 + kNSawPoints;; ; {; //Polygon 1, ""vertical saw"":; fXs1.resize(nVertices);; fYs1.resize(nVertices);",MatchSource.WIKI,doc/master/polytest2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/polytest2_8C.html
Testability,test,testing,". ROOT: tutorials/graphics/polytest2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. polytest2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; ; This macro is testing the ""compacting"" algorithm in TPadPainter. ; It reduces the number of polygon's vertices using actual pixel coordinates. This macro is testing new ""compacting"" algorithm in TPadPainter (it reduces the number of polygon's vertices using actual pixel coordinates). In principle, this test case is what our histograms (fringe cases) are: ""saw-like"" polygon (bins == teeth).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""Rtypes.h""; #include ""TNamed.h""; ; class PolyTest2 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest2();; ; void Paint(const Option_t *notUsed) override;; ; private:; enum TestSize {; kNSawPoints = 10000; };; ; //Part 1.; std::vector<Double_t> fXs1;; std::vector<Double_t> fYs1;; //Part 2.; ; std::vector<Double_t> fXs2;; std::vector<Double_t> fYs2;; };; ; //_____________________________________________________________; PolyTest2::PolyTest2(); : TNamed(""polygon_compression_test2"", ""polygon_compression_test2""); {; //Polygon 1, n of points is 10003, after 'compression' : 1897; //Polygon 2, n of points is 10003, after 'compression' : 2093; ; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""PolyTest2, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""PolyTest2, gRandom is null"");; ; Double_t xMin = 0., xMax = 0., yMin = 0., yMax = 0.;; gPad->GetRange(xMin, yMin, xMax, yMax);; assert(xMax - xMin > 0 && yMax - yMin > 0 && ""PolyTest2, invalid canvas' ranges"");; ; ; // .(0/the last)--------.(1); // | /; // | \; // | /; // .(kNSawPoints + 1)--.(kNSawPoints); ; const unsigned nVertices = 3 + kNSawPoints;; ; {; //Polygon 1, ""vertical saw"":; fXs1.resize(nVertices);; fYs1.resize(nVertices);",MatchSource.WIKI,doc/master/polytest2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/polytest2_8C.html
Deployability,install,installation,"QP formulation.Definition TQpDataDens.h:63; TQpProbDensdense matrix problem formulationDefinition TQpProbDens.h:61; TQpProbDens::MakeVariablesTQpVar * MakeVariables(const TQpDataBase *data) overrideSetup the variables.Definition TQpProbDens.cxx:182; TQpProbDens::MakeDatavirtual TQpDataBase * MakeData(Double_t *c, Double_t *Q, Double_t *xlo, Bool_t *ixlo, Double_t *xup, Bool_t *ixup, Double_t *A, Double_t *bA, Double_t *C, Double_t *clo, Bool_t *iclo, Double_t *cup, Bool_t *icup)Setup the data.Definition TQpProbDens.cxx:80; TQpProbDens::MakeResidualsTQpResidual * MakeResiduals(const TQpDataBase *data) overrideSetup the residuals.Definition TQpProbDens.cxx:172; TQpResidualThe Residuals class calculates and stores the quantities that appear on the right-hand side of the li...Definition TQpResidual.h:62; TQpVarClass containing the variables for the general QP formulation.Definition TQpVar.h:60; TQpVar::fXTVectorD fXDefinition TQpVar.h:91; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TVectorT< Double_t >; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1",MatchSource.WIKI,doc/master/portfolio_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/portfolio_8C.html
Energy Efficiency,power,power,"ion TQpProbDens.cxx:172; TQpResidualThe Residuals class calculates and stores the quantities that appear on the right-hand side of the li...Definition TQpResidual.h:62; TQpVarClass containing the variables for the general QP formulation.Definition TQpVar.h:60; TQpVar::fXTVectorD fXDefinition TQpVar.h:91; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TVectorT< Double_t >; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; AuthorEddy Offermann ; Definition in file portfolio.C. tutorialsquadpportfolio.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/portfolio_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/portfolio_8C.html
Modifiability,variab,variables,".x portfolio.C+; or; gSystem->Load(""libQuadp"");; .L portFolio.C+; portfolio(); gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Let's first review what we exactly mean by ""quadratic programming"" :; We want to minimize the following objective function :; \( c^T x + ( 1/2 ) x^T Q x \) wrt. the vector \( x \); \( c \) is a vector and \( Q \) a symmetric positive definite matrix; You might wonder what is so special about this objective which is quadratic in the unknowns, that can not be done by Minuit/Fumili . Well, we have in addition the following boundary conditions on \( x \):. \[; A x = b \\; clo \le C x \le cup \\; xlo \le x \le xup; \]. where A and C are arbitrary matrices and the rest are vectors; Not all these constraints have to be defined . Our example will only use \( xlo \), \( A \) and \( b \) Still, this could be handled by a general non-linear minimizer like Minuit by introducing so-called ""slack"" variables . However, quadp is tailored to objective functions not more complex than being quadratic . This allows usage of solving techniques which are even stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Effi",MatchSource.WIKI,doc/master/portfolio_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/portfolio_8C.html
Performance,optimiz,optimization,"a stock; For 10 stocks we got the historical daily data for Sep-2000 to Jun-2004:. GE : General Electric Co; SUNW : Sun Microsystems Inc; QCOM : Qualcomm Inc; BRCM : Broadcom Corp; TYC : Tyco International Ltd; IBM : International Business Machines Corp; AMAT : Applied Materials Inc; C : Citigroup Inc; PFE : Pfizer Inc; HD : Home Depot Inc. We calculate the optimal portfolio for 2.0 and 10.0 .; Food for thought :; We assumed that the stock returns have a Normal distribution . Check this assumption by histogramming the stock returns !; We used for the expected return in the objective function, the flat average over a time period . Investment firms will put significant resources in improving the return prediction .; If you want to trade significant number of shares, several other considerations have to be taken into account :; If you are going to buy, you will drive the price up (so-called ""slippage"") . This can be taken into account by adding terms to the objective (Google for ""slippage optimization""); FTC regulations might have to be added to the inequality constraints. Investment firms do not want to be exposed to the ""market"" as defined by a broad index like the S&P and ""hedge"" this exposure away . A perfect hedge this can be added as an equality constrain, otherwise add an inequality constrain . ; stock daily daily w1 w2; symb return sdv ; GE : 1.001 0.022 0.000 0.134; SUNW : 1.004 0.047 0.676 0.145; QCOM : 1.001 0.039 0.000 0.000; BRCM : 1.003 0.056 0.179 0.035; TYC : 1.001 0.042 0.145 0.069; IBM : 1.001 0.023 0.000 0.096; AMAT : 1.001 0.040 0.000 0.000; C : 1.000 0.023 0.000 0.000; PFE : 1.000 0.019 0.000 0.424; HD : 1.001 0.029 0.000 0.098; ; #include ""Riostream.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TMath.h""; #include ""TTree.h""; #include ""TArrayF.h""; #include ""TH1.h""; #include ""TF1.h""; #include ""TLegend.h""; #include ""TSystem.h""; ; #include ""TMatrixD.h""; #include ""TMatrixDSym.h""; #include ""TVectorD.h""; #include ""TQpProbDens.h""; #include ""TGond",MatchSource.WIKI,doc/master/portfolio_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/portfolio_8C.html
Safety,risk,risks,"on \( x \):. \[; A x = b \\; clo \le C x \le cup \\; xlo \le x \le xup; \]. where A and C are arbitrary matrices and the rest are vectors; Not all these constraints have to be defined . Our example will only use \( xlo \), \( A \) and \( b \) Still, this could be handled by a general non-linear minimizer like Minuit by introducing so-called ""slack"" variables . However, quadp is tailored to objective functions not more complex than being quadratic . This allows usage of solving techniques which are even stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we",MatchSource.WIKI,doc/master/portfolio_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/portfolio_8C.html
Security,expose,exposed,"m Inc; BRCM : Broadcom Corp; TYC : Tyco International Ltd; IBM : International Business Machines Corp; AMAT : Applied Materials Inc; C : Citigroup Inc; PFE : Pfizer Inc; HD : Home Depot Inc. We calculate the optimal portfolio for 2.0 and 10.0 .; Food for thought :; We assumed that the stock returns have a Normal distribution . Check this assumption by histogramming the stock returns !; We used for the expected return in the objective function, the flat average over a time period . Investment firms will put significant resources in improving the return prediction .; If you want to trade significant number of shares, several other considerations have to be taken into account :; If you are going to buy, you will drive the price up (so-called ""slippage"") . This can be taken into account by adding terms to the objective (Google for ""slippage optimization""); FTC regulations might have to be added to the inequality constraints. Investment firms do not want to be exposed to the ""market"" as defined by a broad index like the S&P and ""hedge"" this exposure away . A perfect hedge this can be added as an equality constrain, otherwise add an inequality constrain . ; stock daily daily w1 w2; symb return sdv ; GE : 1.001 0.022 0.000 0.134; SUNW : 1.004 0.047 0.676 0.145; QCOM : 1.001 0.039 0.000 0.000; BRCM : 1.003 0.056 0.179 0.035; TYC : 1.001 0.042 0.145 0.069; IBM : 1.001 0.023 0.000 0.096; AMAT : 1.001 0.040 0.000 0.000; C : 1.000 0.023 0.000 0.000; PFE : 1.000 0.019 0.000 0.424; HD : 1.001 0.029 0.000 0.098; ; #include ""Riostream.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TMath.h""; #include ""TTree.h""; #include ""TArrayF.h""; #include ""TH1.h""; #include ""TF1.h""; #include ""TLegend.h""; #include ""TSystem.h""; ; #include ""TMatrixD.h""; #include ""TMatrixDSym.h""; #include ""TVectorD.h""; #include ""TQpProbDens.h""; #include ""TGondzioSolver.h""; ; const Int_t nrStocks = 10;; static const Char_t *stocks[] =; {""GE"",""SUNW"",""QCOM"",""BRCM"",""TYC"",""IBM"",""AMAT"",""C"",""PFE"",""HD""};; ; class TSto",MatchSource.WIKI,doc/master/portfolio_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/portfolio_8C.html
Usability,clear,clear,"ven stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we have for nrStocks the historical daily returns \( r = closing_price(n) - closing_price(n-1) \). Define a vector \( x \) of length of \( nrStocks \), which contains the fraction of our money invested in each stock . We can calculate the average daily return \( z \) of our portfolio and its variance using the portfolio covariance Covar :; \( z = r^T x \) and \( var = x^T Covar x \); Assuming that the daily returns have a Normal distribution, \( N(x) \), so will \( z \) with mean \( r^T x \) and varia",MatchSource.WIKI,doc/master/portfolio_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/portfolio_8C.html
Integrability,depend,dependent,". ROOT: tutorials/math/principal.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. principal.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_math; 3## \notebook; 4## Principal Components Analysis (PCA) example; 5##; 6## Example of using TPrincipal as a stand alone class.; 7##; 8## I create n-dimensional data points, where c = trunc(n / 5) + 1; 9## are correlated with the rest n - c randomly distributed variables.; 10##; 11## Based on principal.C by Rene Brun and Christian Holm Christensen; 12##; 13## \macro_output; 14## \macro_code; 15##; 16## \authors Juan Fernando, Jaramillo Botero; 17 ; 18from ROOT import TPrincipal, gRandom, TBrowser, vector; 19 ; 20 ; 21n = 10; 22m = 10000; 23 ; 24c = int(n / 5) + 1; 25 ; 26print (""""""*************************************************; 27* Principal Component Analysis *; 28* *; 29* Number of variables: {0:4d} *; 30* Number of data points: {1:8d} *; 31* Number of dependent variables: {2:4d} *; 32* *; 33*************************************************"""""".format(n, m, c)); 34 ; 35# Initilase the TPrincipal object. Use the empty string for the; 36# final argument, if you don't wan't the covariance; 37# matrix. Normalising the covariance matrix is a good idea if your; 38# variables have different orders of magnitude.; 39principal = TPrincipal(n, ""ND""); 40 ; 41# Use a pseudo-random number generator; 42randomNum = gRandom; 43 ; 44# Make the m data-points; 45# Make a variable to hold our data; 46# Allocate memory for the data point; 47data = vector('double')(); 48for i in range(m):; 49 # First we create the un-correlated, random variables, according; 50 # to one of three distributions; 51 for j in range(n - c):; 52 if j % 3 == 0:; 53 data.push_back(randomNum.Gaus(5, 1)); 54 elif j % 3 == 1:; 55 data.push_back(randomNum.Poisson(8)); 56 else:; 57 data.push_back(randomNum.Exp(2)); 58 ; 59 # Then we create the correlated variables; 60 for j in range(c):; 61 data.push_b",MatchSource.WIKI,doc/master/principal_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/principal_8py_source.html
Modifiability,variab,variables,". ROOT: tutorials/math/principal.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. principal.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_math; 3## \notebook; 4## Principal Components Analysis (PCA) example; 5##; 6## Example of using TPrincipal as a stand alone class.; 7##; 8## I create n-dimensional data points, where c = trunc(n / 5) + 1; 9## are correlated with the rest n - c randomly distributed variables.; 10##; 11## Based on principal.C by Rene Brun and Christian Holm Christensen; 12##; 13## \macro_output; 14## \macro_code; 15##; 16## \authors Juan Fernando, Jaramillo Botero; 17 ; 18from ROOT import TPrincipal, gRandom, TBrowser, vector; 19 ; 20 ; 21n = 10; 22m = 10000; 23 ; 24c = int(n / 5) + 1; 25 ; 26print (""""""*************************************************; 27* Principal Component Analysis *; 28* *; 29* Number of variables: {0:4d} *; 30* Number of data points: {1:8d} *; 31* Number of dependent variables: {2:4d} *; 32* *; 33*************************************************"""""".format(n, m, c)); 34 ; 35# Initilase the TPrincipal object. Use the empty string for the; 36# final argument, if you don't wan't the covariance; 37# matrix. Normalising the covariance matrix is a good idea if your; 38# variables have different orders of magnitude.; 39principal = TPrincipal(n, ""ND""); 40 ; 41# Use a pseudo-random number generator; 42randomNum = gRandom; 43 ; 44# Make the m data-points; 45# Make a variable to hold our data; 46# Allocate memory for the data point; 47data = vector('double')(); 48for i in range(m):; 49 # First we create the un-correlated, random variables, according; 50 # to one of three distributions; 51 for j in range(n - c):; 52 if j % 3 == 0:; 53 data.push_back(randomNum.Gaus(5, 1)); 54 elif j % 3 == 1:; 55 data.push_back(randomNum.Poisson(8)); 56 else:; 57 data.push_back(randomNum.Exp(2)); 58 ; 59 # Then we create the correlated variables; 60 for j in range(c):; 61 data.push_b",MatchSource.WIKI,doc/master/principal_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/principal_8py_source.html
Usability,clear,clear,"n't the covariance; 37# matrix. Normalising the covariance matrix is a good idea if your; 38# variables have different orders of magnitude.; 39principal = TPrincipal(n, ""ND""); 40 ; 41# Use a pseudo-random number generator; 42randomNum = gRandom; 43 ; 44# Make the m data-points; 45# Make a variable to hold our data; 46# Allocate memory for the data point; 47data = vector('double')(); 48for i in range(m):; 49 # First we create the un-correlated, random variables, according; 50 # to one of three distributions; 51 for j in range(n - c):; 52 if j % 3 == 0:; 53 data.push_back(randomNum.Gaus(5, 1)); 54 elif j % 3 == 1:; 55 data.push_back(randomNum.Poisson(8)); 56 else:; 57 data.push_back(randomNum.Exp(2)); 58 ; 59 # Then we create the correlated variables; 60 for j in range(c):; 61 data.push_back(0); 62 for k in range(n - c - j):; 63 data[n - c + j] += data[k]; 64 ; 65 # Finally we're ready to add this datapoint to the PCA; 66 principal.AddRow(data.data()); 67 data.clear(); 68 ; 69# Do the actual analysis; 70principal.MakePrincipals(); 71 ; 72# Print out the result on; 73principal.Print(); 74 ; 75# Test the PCA; 76principal.Test(); 77 ; 78# Make some histograms of the original, principal, residue, etc data; 79principal.MakeHistograms(); 80 ; 81# Make two functions to map between feature and pattern space; 82# Start a browser, so that we may browse the histograms generated; 83# above; 84principal.MakeCode(); 85b = TBrowser(""principalBrowser"", principal); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/principal_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/principal_8py_source.html
Availability,error,errors,"./(n-1)) * std::exp(-alpha*alpha/2.);; 136 intpow = C - A /(n-1.) * std::pow(B-z,-n+1) ;; 137 }; 138 else {; 139 // for n=1 the primitive of 1/x is log(x); 140 intpow = -A * std::log( n / abs_alpha ) + A * std::log( B -z );; 141 }; 142 intgaus = sqrtpiover2*(1.+ROOT::Math::erf(abs_alpha*oneoversqrt2));; 143 }; 144 else; 145 {; 146 intgaus = ROOT::Math::gaussian_cdf_c(z, 1);; 147 intgaus *= sqrt2pi;; 148 intpow = 0; ; 149 }; 150 return sigma * (intgaus + intpow);; 151 }; 152 ; 153 ; 154 double exponential_cdf_c(double x, double lambda, double x0); 155 {; 156 if ((x-x0) < 0) return 1.0;; 157 else return std::exp(- lambda * (x-x0));; 158 }; 159 ; 160 ; 161 double exponential_cdf(double x, double lambda, double x0); 162 {; 163 if ((x-x0) < 0) return 0.0;; 164 else // use expm1 function to avoid errors at small x; 165 return - ROOT::Math::expm1( - lambda * (x-x0) ) ;; 166 }; 167 ; 168 ; 169 double fdistribution_cdf_c(double x, double n, double m, double x0); 170 {; 171 // f distribution is defined only for both n and m > 0; 172 if (n < 0 || m < 0) return std::numeric_limits<double>::quiet_NaN();; 173 ; 174 double z = m/(m + n*(x-x0));; 175 // fox z->1 and large a and b IB looses precision use complement function; 176 if (z > 0.9 && n > 1 && m > 1) return 1.- fdistribution_cdf(x,n,m,x0);; 177 ; 178 // for the complement use the fact that IB(x,a,b) = 1. - IB(1-x,b,a); 179 return ROOT::Math::inc_beta(m/(m + n*(x-x0)), .5*m, .5*n);; 180 }; 181 ; 182 ; 183 double fdistribution_cdf(double x, double n, double m, double x0); 184 {; 185 // f distribution is defined only for both n and m > 0; 186 if (n < 0 || m < 0); 187 return std::numeric_limits<double>::quiet_NaN();; 188 ; 189 double z = n*(x-x0)/(m + n*(x-x0));; 190 // fox z->1 and large a and b IB looses precision use complement function; 191 if (z > 0.9 && n > 1 && m > 1); 192 return 1. - fdistribution_cdf_c(x,n,m,x0);; 193 ; 194 return ROOT::Math::inc_beta(z, .5*n, .5*m);; 195 }; 196 ; 197 ; 198 double gamma_cdf_c(double x,",MatchSource.WIKI,doc/master/ProbFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html
Deployability,integrat,integrating,"e x0=0)Cumulative distribution function of the gamma distribution (lower tail).Definition ProbFuncMathCore.cxx:204; ROOT::Math::exponential_cdfdouble exponential_cdf(double x, double lambda, double x0=0)Cumulative distribution function of the exponential distribution (lower tail).Definition ProbFuncMathCore.cxx:161; ROOT::Math::inc_gamma_cdouble inc_gamma_c(double a, double x)Calculates the normalized (regularized) upper incomplete gamma function (upper integral)Definition SpecFuncMathCore.cxx:103; ROOT::Math::inc_betadouble inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; ROOT::Math::landau_xm1double landau_xm1(double x, double xi=1, double x0=0)First moment (mean) of the truncated Landau distribution.Definition ProbFuncMathCore.cxx:409; ROOT::Math::landau_xm2double landau_xm2(double x, double xi=1, double x0=0)Second moment of the truncated Landau distribution.Definition ProbFuncMathCore.cxx:489; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::Math::expm1double expm1(double x)exp(x) -1 with error cancellation when x is smallDefinition Math.h:110; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::kSqrt2static const double kSqrt2Definition ProbFuncMathCore.cxx:18; ROOT::Math::gaussian_cdf_cdouble gaussian_cdf_c(double ",MatchSource.WIKI,doc/master/ProbFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html
Energy Efficiency,power,power-law," 88 return std::numeric_limits<double>::quiet_NaN();; 89 }; 90 double abs_alpha = std::abs(alpha);; 91 double C = n/abs_alpha * 1./(n-1.) * std::exp(-alpha*alpha/2.);; 92 double D = std::sqrt(M_PI/2.)*(1.+ROOT::Math::erf(abs_alpha/std::sqrt(2.)));; 93 double totIntegral = sigma*(C+D);; 94 ; 95 double integral = crystalball_integral(x,alpha,n,sigma,mean); ; 96 return (alpha > 0) ? integral/totIntegral : 1. - (integral/totIntegral); ; 97 }; 98 double crystalball_integral(double x, double alpha, double n, double sigma, double mean); 99 {; 100 // compute the integral of the crystal ball function (ROOT::Math::crystalball_function); 101 // If alpha > 0 the integral is the right tail integral.; 102 // If alpha < 0 is the left tail integrals which are always finite for finite x. ; 103 // parameters:; 104 // alpha : is non equal to zero, define the # of sigma from which it becomes a power-law function (from mean-alpha*sigma); 105 // n > 1 : is integrer, is the power of the low tail; 106 // add a value xmin for cases when n <=1 the integral diverges ; 107 if (sigma == 0) return 0;; 108 if (alpha==0); 109 {; 110 MATH_ERROR_MSG(""crystalball_integral"",""CrystalBall function not defined at alpha=0"");; 111 return 0.;; 112 }; 113 bool useLog = (n == 1.0); ; 114 if (n<=0) MATH_WARN_MSG(""crystalball_integral"",""No physical meaning when n<=0"");; 115 ; 116 double z = (x-mean)/sigma;; 117 if (alpha < 0 ) z = -z;; 118 ; 119 double abs_alpha = std::abs(alpha);; 120 ; 121 //double D = *(1.+ROOT::Math::erf(abs_alpha/std::sqrt(2.)));; 122 //double N = 1./(sigma*(C+D));; 123 double intgaus = 0.;; 124 double intpow = 0.;; 125 ; 126 const double sqrtpiover2 = std::sqrt(M_PI/2.);; 127 const double sqrt2pi = std::sqrt( 2.*M_PI); ; 128 const double oneoversqrt2 = 1./sqrt(2.);; 129 if (z <= -abs_alpha); 130 {; 131 double A = std::pow(n/abs_alpha,n) * std::exp(-0.5 * alpha*alpha);; 132 double B = n/abs_alpha - abs_alpha;; 133 ; 134 if (!useLog) {; 135 double C = (n/abs_alpha) * (1./(n-1)) * std::exp(-",MatchSource.WIKI,doc/master/ProbFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html
Integrability,integrat,integrating,"e x0=0)Cumulative distribution function of the gamma distribution (lower tail).Definition ProbFuncMathCore.cxx:204; ROOT::Math::exponential_cdfdouble exponential_cdf(double x, double lambda, double x0=0)Cumulative distribution function of the exponential distribution (lower tail).Definition ProbFuncMathCore.cxx:161; ROOT::Math::inc_gamma_cdouble inc_gamma_c(double a, double x)Calculates the normalized (regularized) upper incomplete gamma function (upper integral)Definition SpecFuncMathCore.cxx:103; ROOT::Math::inc_betadouble inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; ROOT::Math::landau_xm1double landau_xm1(double x, double xi=1, double x0=0)First moment (mean) of the truncated Landau distribution.Definition ProbFuncMathCore.cxx:409; ROOT::Math::landau_xm2double landau_xm2(double x, double xi=1, double x0=0)Second moment of the truncated Landau distribution.Definition ProbFuncMathCore.cxx:489; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::Math::expm1double expm1(double x)exp(x) -1 with error cancellation when x is smallDefinition Math.h:110; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::kSqrt2static const double kSqrt2Definition ProbFuncMathCore.cxx:18; ROOT::Math::gaussian_cdf_cdouble gaussian_cdf_c(double ",MatchSource.WIKI,doc/master/ProbFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html
Safety,avoid,avoid,"./(n-1)) * std::exp(-alpha*alpha/2.);; 136 intpow = C - A /(n-1.) * std::pow(B-z,-n+1) ;; 137 }; 138 else {; 139 // for n=1 the primitive of 1/x is log(x); 140 intpow = -A * std::log( n / abs_alpha ) + A * std::log( B -z );; 141 }; 142 intgaus = sqrtpiover2*(1.+ROOT::Math::erf(abs_alpha*oneoversqrt2));; 143 }; 144 else; 145 {; 146 intgaus = ROOT::Math::gaussian_cdf_c(z, 1);; 147 intgaus *= sqrt2pi;; 148 intpow = 0; ; 149 }; 150 return sigma * (intgaus + intpow);; 151 }; 152 ; 153 ; 154 double exponential_cdf_c(double x, double lambda, double x0); 155 {; 156 if ((x-x0) < 0) return 1.0;; 157 else return std::exp(- lambda * (x-x0));; 158 }; 159 ; 160 ; 161 double exponential_cdf(double x, double lambda, double x0); 162 {; 163 if ((x-x0) < 0) return 0.0;; 164 else // use expm1 function to avoid errors at small x; 165 return - ROOT::Math::expm1( - lambda * (x-x0) ) ;; 166 }; 167 ; 168 ; 169 double fdistribution_cdf_c(double x, double n, double m, double x0); 170 {; 171 // f distribution is defined only for both n and m > 0; 172 if (n < 0 || m < 0) return std::numeric_limits<double>::quiet_NaN();; 173 ; 174 double z = m/(m + n*(x-x0));; 175 // fox z->1 and large a and b IB looses precision use complement function; 176 if (z > 0.9 && n > 1 && m > 1) return 1.- fdistribution_cdf(x,n,m,x0);; 177 ; 178 // for the complement use the fact that IB(x,a,b) = 1. - IB(1-x,b,a); 179 return ROOT::Math::inc_beta(m/(m + n*(x-x0)), .5*m, .5*n);; 180 }; 181 ; 182 ; 183 double fdistribution_cdf(double x, double n, double m, double x0); 184 {; 185 // f distribution is defined only for both n and m > 0; 186 if (n < 0 || m < 0); 187 return std::numeric_limits<double>::quiet_NaN();; 188 ; 189 double z = n*(x-x0)/(m + n*(x-x0));; 190 // fox z->1 and large a and b IB looses precision use complement function; 191 if (z > 0.9 && n > 1 && m > 1); 192 return 1. - fdistribution_cdf_c(x,n,m,x0);; 193 ; 194 return ROOT::Math::inc_beta(z, .5*n, .5*m);; 195 }; 196 ; 197 ; 198 double gamma_cdf_c(double x,",MatchSource.WIKI,doc/master/ProbFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html
Testability,log,log,"lball_integral"",""CrystalBall function not defined at alpha=0"");; 111 return 0.;; 112 }; 113 bool useLog = (n == 1.0); ; 114 if (n<=0) MATH_WARN_MSG(""crystalball_integral"",""No physical meaning when n<=0"");; 115 ; 116 double z = (x-mean)/sigma;; 117 if (alpha < 0 ) z = -z;; 118 ; 119 double abs_alpha = std::abs(alpha);; 120 ; 121 //double D = *(1.+ROOT::Math::erf(abs_alpha/std::sqrt(2.)));; 122 //double N = 1./(sigma*(C+D));; 123 double intgaus = 0.;; 124 double intpow = 0.;; 125 ; 126 const double sqrtpiover2 = std::sqrt(M_PI/2.);; 127 const double sqrt2pi = std::sqrt( 2.*M_PI); ; 128 const double oneoversqrt2 = 1./sqrt(2.);; 129 if (z <= -abs_alpha); 130 {; 131 double A = std::pow(n/abs_alpha,n) * std::exp(-0.5 * alpha*alpha);; 132 double B = n/abs_alpha - abs_alpha;; 133 ; 134 if (!useLog) {; 135 double C = (n/abs_alpha) * (1./(n-1)) * std::exp(-alpha*alpha/2.);; 136 intpow = C - A /(n-1.) * std::pow(B-z,-n+1) ;; 137 }; 138 else {; 139 // for n=1 the primitive of 1/x is log(x); 140 intpow = -A * std::log( n / abs_alpha ) + A * std::log( B -z );; 141 }; 142 intgaus = sqrtpiover2*(1.+ROOT::Math::erf(abs_alpha*oneoversqrt2));; 143 }; 144 else; 145 {; 146 intgaus = ROOT::Math::gaussian_cdf_c(z, 1);; 147 intgaus *= sqrt2pi;; 148 intpow = 0; ; 149 }; 150 return sigma * (intgaus + intpow);; 151 }; 152 ; 153 ; 154 double exponential_cdf_c(double x, double lambda, double x0); 155 {; 156 if ((x-x0) < 0) return 1.0;; 157 else return std::exp(- lambda * (x-x0));; 158 }; 159 ; 160 ; 161 double exponential_cdf(double x, double lambda, double x0); 162 {; 163 if ((x-x0) < 0) return 0.0;; 164 else // use expm1 function to avoid errors at small x; 165 return - ROOT::Math::expm1( - lambda * (x-x0) ) ;; 166 }; 167 ; 168 ; 169 double fdistribution_cdf_c(double x, double n, double m, double x0); 170 {; 171 // f distribution is defined only for both n and m > 0; 172 if (n < 0 || m < 0) return std::numeric_limits<double>::quiet_NaN();; 173 ; 174 double z = m/(m + n*(x-x0));; 175 // fox z->",MatchSource.WIKI,doc/master/ProbFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html
Deployability,release,releases,"05; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#ifndef ROOT_Math_ProbFuncMathCore; 12#define ROOT_Math_ProbFuncMathCore; 13 ; 14 ; 15namespace ROOT {; 16namespace Math {; 17 ; 18 ; 19 /** @defgroup ProbFunc Cumulative Distribution Functions (CDF); 20 ; 21 @ingroup StatFunc; 22 ; 23 * Cumulative distribution functions of various distributions.; 24 * The functions with the extension <em>_cdf</em> calculate the; 25 * lower tail integral of the probability density function; 26 *; 27 * \f[ D(x) = \int_{-\infty}^{x} p(x') dx' \f]; 28 *; 29 * while those with the <em>_cdf_c</em> extension calculate the complement of; 30 * cumulative distribution function, called in statistics the survival; 31 * function.; 32 * It corresponds to the upper tail integral of the; 33 * probability density function; 34 *; 35 * \f[ D(x) = \int_{x}^{+\infty} p(x') dx' \f]; 36 *; 37 *; 38 * <strong>NOTE:</strong> In the old releases (< 5.14) the <em>_cdf</em> functions were called; 39 * <em>_quant</em> and the <em>_cdf_c</em> functions were called; 40 * <em>_prob</em>.; 41 * These names are currently kept for backward compatibility, but; 42 * their usage is deprecated.; 43 *; 44 * These functions are defined in the header file <em>Math/ProbFunc.h</em> or in the global one; 45 * including all statistical functions <em>Math/DistFunc.h</em>; 46 *; 47 */; 48 ; 49 ; 50 ; 51 /**; 52 ; 53 Complement of the cumulative distribution function of the beta distribution.; 54 Upper tail of the integral of the #beta_pdf; 55 ; 56 @ingroup ProbFunc; 57 ; 58 */; 59 ; 60 double beta_cdf_c(double x, double a, double b);; 61 ; 62 ; 63 ; 64 /**; 65 ; 66 Cumulative distribution function of the beta distribution; 67 Upper tail of the integral of the #beta_pdf; 68 ; 69 @ingroup ProbFunc; 70 ; 71 */; 72 ; 73 double beta_cdf(double x, double ",MatchSource.WIKI,doc/master/ProbFuncMathCore_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8h_source.html
Testability,log,log,"9 */; 330 ; 331 double gamma_cdf_c(double x, double alpha, double theta, double x0 = 0);; 332 ; 333 ; 334 ; 335 ; 336 /**; 337 ; 338 Cumulative distribution function of the gamma distribution; 339 (lower tail).; 340 ; 341 \f[ D(x) = \int_{-\infty}^{x} {1 \over \Gamma(\alpha) \theta^{\alpha}} x'^{\alpha-1} e^{-x'/\theta} dx' \f]; 342 ; 343 For detailed description see; 344 <A HREF=""http://mathworld.wolfram.com/GammaDistribution.html"">; 345 Mathworld</A>. It is implemented using the incomplete gamma function, ROOT::Math::inc_gamma,; 346 from <A HREF=""http://www.netlib.org/cephes"">Cephes</A>; 347 ; 348 @ingroup ProbFunc; 349 ; 350 */; 351 ; 352 double gamma_cdf(double x, double alpha, double theta, double x0 = 0);; 353 ; 354 ; 355 ; 356 /**; 357 ; 358 Cumulative distribution function of the Landau; 359 distribution (lower tail).; 360 ; 361 \f[ D(x) = \int_{-\infty}^{x} p(x) dx \f]; 362 ; 363 where \f$p(x)\f$ is the Landau probability density function :; 364 \f[ p(x) = \frac{1}{\xi} \phi (\lambda) \f]; 365 with; 366 \f[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\f]; 367 with \f$\lambda = (x-x_0)/\xi\f$. For a detailed description see; 368 K.S. K&ouml;lbig and B. Schorr, A program package for the Landau distribution,; 369 <A HREF=""http://dx.doi.org/10.1016/0010-4655(84)90085-7"">Computer Phys. Comm. 31 (1984) 97-111</A>; 370 <A HREF=""http://dx.doi.org/10.1016/j.cpc.2008.03.002"">[Erratum-ibid. 178 (2008) 972]</A>.; 371 The same algorithms as in; 372 <A HREF=""https://cern-tex.web.cern.ch/cern-tex/shortwrupsdir/g110/top.html"">; 373 CERNLIB</A> (DISLAN) is used.; 374 ; 375 @param x The argument \f$x\f$; 376 @param xi The width parameter \f$\xi\f$; 377 @param x0 The location parameter \f$x_0\f$; 378 ; 379 @ingroup ProbFunc; 380 ; 381 */; 382 ; 383 double landau_cdf(double x, double xi = 1, double x0 = 0);; 384 ; 385 /**; 386 ; 387 Complement of the distribution function of the Landau; 388 distribution (upper tail).; 389 ; 390 \f[ ",MatchSource.WIKI,doc/master/ProbFuncMathCore_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8h_source.html
Usability,simpl,simply,"\f]; 367 with \f$\lambda = (x-x_0)/\xi\f$. For a detailed description see; 368 K.S. K&ouml;lbig and B. Schorr, A program package for the Landau distribution,; 369 <A HREF=""http://dx.doi.org/10.1016/0010-4655(84)90085-7"">Computer Phys. Comm. 31 (1984) 97-111</A>; 370 <A HREF=""http://dx.doi.org/10.1016/j.cpc.2008.03.002"">[Erratum-ibid. 178 (2008) 972]</A>.; 371 The same algorithms as in; 372 <A HREF=""https://cern-tex.web.cern.ch/cern-tex/shortwrupsdir/g110/top.html"">; 373 CERNLIB</A> (DISLAN) is used.; 374 ; 375 @param x The argument \f$x\f$; 376 @param xi The width parameter \f$\xi\f$; 377 @param x0 The location parameter \f$x_0\f$; 378 ; 379 @ingroup ProbFunc; 380 ; 381 */; 382 ; 383 double landau_cdf(double x, double xi = 1, double x0 = 0);; 384 ; 385 /**; 386 ; 387 Complement of the distribution function of the Landau; 388 distribution (upper tail).; 389 ; 390 \f[ D(x) = \int_{x}^{+\infty} p(x) dx \f]; 391 ; 392 where p(x) is the Landau probability density function.; 393 It is implemented simply as 1. - #landau_cdf; 394 ; 395 @param x The argument \f$x\f$; 396 @param xi The width parameter \f$\xi\f$; 397 @param x0 The location parameter \f$x_0\f$; 398 ; 399 @ingroup ProbFunc; 400 ; 401 */; 402 inline double landau_cdf_c(double x, double xi = 1, double x0 = 0) {; 403 return 1. - landau_cdf(x,xi,x0);; 404 }; 405 ; 406 /**; 407 ; 408 Complement of the cumulative distribution function of the lognormal distribution; 409 (upper tail).; 410 ; 411 \f[ D(x) = \int_{x}^{+\infty} {1 \over x' \sqrt{2 \pi s^2} } e^{-(\ln{x'} - m)^2/2 s^2} dx' \f]; 412 ; 413 For detailed description see; 414 <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; 415 Mathworld</A>.; 416 ; 417 @ingroup ProbFunc; 418 ; 419 */; 420 ; 421 double lognormal_cdf_c(double x, double m, double s, double x0 = 0);; 422 ; 423 ; 424 ; 425 ; 426 /**; 427 ; 428 Cumulative distribution function of the lognormal distribution; 429 (lower tail).; 430 ; 431 \f[ D(x) = \int_{-\infty}^{x} {1 \over x' \sqr",MatchSource.WIKI,doc/master/ProbFuncMathCore_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8h_source.html
Integrability,depend,dependency,". ROOT: tmva/sofie/src/Prototype.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; Prototype.cxx File Reference. #include <memory>; #include ""TMVA/RModel.hxx""; #include ""TMVA/RModelParser_ONNX.hxx""; #include <cctype>; #include <algorithm>. Include dependency graph for Prototype.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; int main ();  . Function Documentation. ◆ main(). int main ; (; ). Definition at line 12 of file Prototype.cxx. tmvasofiesrcPrototype.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Prototype_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Prototype_8cxx.html
Usability,simpl,simple,"; t.DrawText(xc1,y,text);; sprintf(text,""`%s"",symbol[i]);; t.DrawText(xc2,y,text);; sprintf(text,""'%s"",symbol[i]);; t.DrawText(xc3,y,text);; sprintf(text,""~%s"",symbol[i]);; t.DrawText(xc4,y,text);; y -= dy;; }; }; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TTextBase class for several text objects.Definition TText.h:22; TText::DrawTextvirtual TText * DrawText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:176; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; nconst Int_t nDefinition legend1.C:16; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; AuthorOlivier Couet ; Definition in file pstable.C. tutorialsgraphicspstable.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/pstable_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pstable_8C.html
Deployability,install,install,". ROOT: tutorials/graphics/psview.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. psview.C File ReferenceTutorials » Graphics tutorials. Detailed Description; An example how to display PS, EPS, PDF files in canvas. ; To load a PS file in a TCanvas, the ghostscript program needs to be install.; On most unix systems it is installed by default.; On Windows it has to be installed from http://pages.cs.wisc.edu/~ghost/ also the place where gswin32c.exe sits should be added in the PATH. One way to do it is:; Start the Control Panel; Double click on System 3, Open the ""Advanced"" tab; Click on the ""Environment Variables"" button; Find ""Path"" in ""System variable list"", click on it.; Click on the ""Edit"" button.; In the ""Variable value"" field add the path of gswin32c (after a "";"") it should be something like: ""C:\Program Files\gs\gs8.13\bin""; click ""OK"" as much as needed. ; #include ""TROOT.h""; #include ""TCanvas.h""; #include ""TImage.h""; ; void psview(); {; // set to batch mode -> do not display graphics; gROOT->SetBatch(1);; ; // create a PostScript file; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphics/feynman.C"");; gROOT->Macro(dir);; gPad->Print(""feynman.eps"");; ; // back to graphics mode; gROOT->SetBatch(0);; ; // create an image from PS file; TImage *ps = TImage::Open(""feynman.eps"");; ; if (!ps) {; printf(""GhostScript (gs) program must be installed\n"");; return;; }; ; new TCanvas(""psexam"", ""Example how to display PS file in canvas"", 600, 400);; TLatex *tex = new TLatex(0.06,0.9,""The picture below has been loaded from a PS file:"");; tex->Draw();; ; TPad *eps = new TPad(""eps"", ""eps"", 0., 0., 1., 0.75);; eps->Draw();; eps->cd();; ps->Draw(""xxx"");; }; TCanvas.h; TImage.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Openstatic TIma",MatchSource.WIKI,doc/master/psview_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/psview_8C.html
Integrability,interface,interface,""" as much as needed. ; #include ""TROOT.h""; #include ""TCanvas.h""; #include ""TImage.h""; ; void psview(); {; // set to batch mode -> do not display graphics; gROOT->SetBatch(1);; ; // create a PostScript file; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphics/feynman.C"");; gROOT->Macro(dir);; gPad->Print(""feynman.eps"");; ; // back to graphics mode; gROOT->SetBatch(0);; ; // create an image from PS file; TImage *ps = TImage::Open(""feynman.eps"");; ; if (!ps) {; printf(""GhostScript (gs) program must be installed\n"");; return;; }; ; new TCanvas(""psexam"", ""Example how to display PS file in canvas"", 600, 400);; TLatex *tex = new TLatex(0.06,0.9,""The picture below has been loaded from a PS file:"");; tex->Draw();; ; TPad *eps = new TPad(""eps"", ""eps"", 0., 0., 1., 0.75);; eps->Draw();; eps->cd();; ps->Draw(""xxx"");; }; TCanvas.h; TImage.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Openstatic TImage * Open(const char *file, EImageFileTypes type=kUnknown)Open a specified image file.Definition TImage.cxx:118; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TStringBasic string class.Definition TString.h:139; TString::AppendTString & Append(const char *cs)Definition TString.h:572; AuthorValeriy Onoutchin ; Definition in file psview.C. tutorialsgraphicspsview.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/psview_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/psview_8C.html
Modifiability,variab,variable,". ROOT: tutorials/graphics/psview.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. psview.C File ReferenceTutorials » Graphics tutorials. Detailed Description; An example how to display PS, EPS, PDF files in canvas. ; To load a PS file in a TCanvas, the ghostscript program needs to be install.; On most unix systems it is installed by default.; On Windows it has to be installed from http://pages.cs.wisc.edu/~ghost/ also the place where gswin32c.exe sits should be added in the PATH. One way to do it is:; Start the Control Panel; Double click on System 3, Open the ""Advanced"" tab; Click on the ""Environment Variables"" button; Find ""Path"" in ""System variable list"", click on it.; Click on the ""Edit"" button.; In the ""Variable value"" field add the path of gswin32c (after a "";"") it should be something like: ""C:\Program Files\gs\gs8.13\bin""; click ""OK"" as much as needed. ; #include ""TROOT.h""; #include ""TCanvas.h""; #include ""TImage.h""; ; void psview(); {; // set to batch mode -> do not display graphics; gROOT->SetBatch(1);; ; // create a PostScript file; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphics/feynman.C"");; gROOT->Macro(dir);; gPad->Print(""feynman.eps"");; ; // back to graphics mode; gROOT->SetBatch(0);; ; // create an image from PS file; TImage *ps = TImage::Open(""feynman.eps"");; ; if (!ps) {; printf(""GhostScript (gs) program must be installed\n"");; return;; }; ; new TCanvas(""psexam"", ""Example how to display PS file in canvas"", 600, 400);; TLatex *tex = new TLatex(0.06,0.9,""The picture below has been loaded from a PS file:"");; tex->Draw();; ; TPad *eps = new TPad(""eps"", ""eps"", 0., 0., 1., 0.75);; eps->Draw();; eps->cd();; ps->Draw(""xxx"");; }; TCanvas.h; TImage.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Openstatic TIma",MatchSource.WIKI,doc/master/psview_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/psview_8C.html
Performance,load,load,". ROOT: tutorials/graphics/psview.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. psview.C File ReferenceTutorials » Graphics tutorials. Detailed Description; An example how to display PS, EPS, PDF files in canvas. ; To load a PS file in a TCanvas, the ghostscript program needs to be install.; On most unix systems it is installed by default.; On Windows it has to be installed from http://pages.cs.wisc.edu/~ghost/ also the place where gswin32c.exe sits should be added in the PATH. One way to do it is:; Start the Control Panel; Double click on System 3, Open the ""Advanced"" tab; Click on the ""Environment Variables"" button; Find ""Path"" in ""System variable list"", click on it.; Click on the ""Edit"" button.; In the ""Variable value"" field add the path of gswin32c (after a "";"") it should be something like: ""C:\Program Files\gs\gs8.13\bin""; click ""OK"" as much as needed. ; #include ""TROOT.h""; #include ""TCanvas.h""; #include ""TImage.h""; ; void psview(); {; // set to batch mode -> do not display graphics; gROOT->SetBatch(1);; ; // create a PostScript file; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphics/feynman.C"");; gROOT->Macro(dir);; gPad->Print(""feynman.eps"");; ; // back to graphics mode; gROOT->SetBatch(0);; ; // create an image from PS file; TImage *ps = TImage::Open(""feynman.eps"");; ; if (!ps) {; printf(""GhostScript (gs) program must be installed\n"");; return;; }; ; new TCanvas(""psexam"", ""Example how to display PS file in canvas"", 600, 400);; TLatex *tex = new TLatex(0.06,0.9,""The picture below has been loaded from a PS file:"");; tex->Draw();; ; TPad *eps = new TPad(""eps"", ""eps"", 0., 0., 1., 0.75);; eps->Draw();; eps->cd();; ps->Draw(""xxx"");; }; TCanvas.h; TImage.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Openstatic TIma",MatchSource.WIKI,doc/master/psview_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/psview_8C.html
Availability,alive,alive,") {; 177 Log << kFATAL << ""Can't init global namespace"" << Endl;; 178 Log << Endl;; 179 }; 180 Py_INCREF(fGlobalNS);; 181 ; 182 #if PY_MAJOR_VERSION < 3; 183 //preparing objects for eval; 184 PyObject *bName = PyUnicode_FromString(""__builtin__"");; 185 // Import the file as a Python module.; 186 // returns a new reference; 187 fModuleBuiltin = PyImport_Import(bName);; 188 if (!fModuleBuiltin) {; 189 Log << kFATAL << ""Can't import __builtin__"" << Endl;; 190 Log << Endl;; 191 }; 192 #else; 193 //preparing objects for eval; 194 PyObject *bName = PyUnicode_FromString(""builtins"");; 195 // Import the file as a Python module.; 196 fModuleBuiltin = PyImport_Import(bName);; 197 if (!fModuleBuiltin) {; 198 Log << kFATAL << ""Can't import builtins"" << Endl;; 199 Log << Endl;; 200 }; 201 #endif; 202 ; 203 // note mDict is a borrowed reference; 204 PyObject *mDict = PyModule_GetDict(fModuleBuiltin);; 205 fEval = PyDict_GetItemString(mDict, ""eval"");; 206 fOpen = PyDict_GetItemString(mDict, ""open"");; 207 // fEval and fOpen are borrowed referencers and we need to keep them alive; 208 if (fEval) Py_INCREF(fEval);; 209 if (fOpen) Py_INCREF(fOpen);; 210 ; 211 // bName is a new reference (from PyUnicode_FromString); 212 Py_DECREF(bName);; 213 ; 214 //preparing objects for pickle; 215 PyObject *pName = PyUnicode_FromString(""pickle"");; 216 // Import the file as a Python module.; 217 // return object is a new reference !; 218 fModulePickle = PyImport_Import(pName);; 219 if (!fModulePickle) {; 220 Log << kFATAL << ""Can't import pickle"" << Endl;; 221 Log << Endl;; 222 }; 223 PyObject *pDict = PyModule_GetDict(fModulePickle);; 224 // note the following return objects are borrowed references; 225 fPickleDumps = PyDict_GetItemString(pDict, ""dump"");; 226 fPickleLoads = PyDict_GetItemString(pDict, ""load"");; 227 if (fPickleDumps) Py_INCREF(fPickleDumps);; 228 if (fPickleLoads) Py_INCREF(fPickleLoads);; 229 ; 230 Py_DECREF(pName);; 231}; 232 ; 233//////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/PyMethodBase_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html
Deployability,integrat,integrated,". ROOT: tmva/pymva/src/PyMethodBase.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. PyMethodBase.cxx. Go to the documentation of this file. 1// @(#)root/tmva/pymva $Id$; 2// Authors: Omar Zapata, Lorenzo Moneta, Sergei Gleyzer 2015, Stefan Wunsch 2017; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : PyMethodBase *; 8 * *; 9 * Description: *; 10 * Virtual base class for all MVA method based on python *; 11 * *; 12 **********************************************************************************/; 13 ; 14#include <Python.h> // Needs to be included first to avoid redefinition of _POSIX_C_SOURCE; 15#include <TMVA/PyMethodBase.h>; 16 ; 17#include ""TMVA/DataSet.h""; 18#include ""TMVA/DataSetInfo.h""; 19#include ""TMVA/MsgLogger.h""; 20#include ""TMVA/Results.h""; 21#include ""TMVA/Timer.h""; 22#include ""TMVA/Tools.h""; 23 ; 24#include ""TSystem.h""; 25 ; 26#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; 27#include <numpy/arrayobject.h>; 28 ; 29using namespace TMVA;; 30 ; 31namespace TMVA {; 32namespace Internal {; 33class PyGILRAII {; 34 PyGILState_STATE m_GILState;; 35 ; 36public:; 37 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 38 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 39};; 40} // namespace Internal; 41 ; 42/// get current Python executable used by ROOT; 43TString Python_Executable() {; 44 TString python_version = gSystem->GetFromPipe(""root-config --python-version"");; 45 if (python_version.IsNull()) {; 46 TMVA::gTools().Log() << kFATAL << ""Can't find a valid Python version used to build ROOT"" << Endl;; 47 return nullptr;; 48 }; 49#ifdef _MSC_VER; 50 // on Windows there is a space before the version and the executable is python.exe; 51 // for both versions of Python; 52 python_version.ReplaceAll("" "", """");; 53 if (python_version[0] == '2' || python_version[0] == ",MatchSource.WIKI,doc/master/PyMethodBase_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html
Integrability,integrat,integrated,". ROOT: tmva/pymva/src/PyMethodBase.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. PyMethodBase.cxx. Go to the documentation of this file. 1// @(#)root/tmva/pymva $Id$; 2// Authors: Omar Zapata, Lorenzo Moneta, Sergei Gleyzer 2015, Stefan Wunsch 2017; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : PyMethodBase *; 8 * *; 9 * Description: *; 10 * Virtual base class for all MVA method based on python *; 11 * *; 12 **********************************************************************************/; 13 ; 14#include <Python.h> // Needs to be included first to avoid redefinition of _POSIX_C_SOURCE; 15#include <TMVA/PyMethodBase.h>; 16 ; 17#include ""TMVA/DataSet.h""; 18#include ""TMVA/DataSetInfo.h""; 19#include ""TMVA/MsgLogger.h""; 20#include ""TMVA/Results.h""; 21#include ""TMVA/Timer.h""; 22#include ""TMVA/Tools.h""; 23 ; 24#include ""TSystem.h""; 25 ; 26#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; 27#include <numpy/arrayobject.h>; 28 ; 29using namespace TMVA;; 30 ; 31namespace TMVA {; 32namespace Internal {; 33class PyGILRAII {; 34 PyGILState_STATE m_GILState;; 35 ; 36public:; 37 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 38 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 39};; 40} // namespace Internal; 41 ; 42/// get current Python executable used by ROOT; 43TString Python_Executable() {; 44 TString python_version = gSystem->GetFromPipe(""root-config --python-version"");; 45 if (python_version.IsNull()) {; 46 TMVA::gTools().Log() << kFATAL << ""Can't find a valid Python version used to build ROOT"" << Endl;; 47 return nullptr;; 48 }; 49#ifdef _MSC_VER; 50 // on Windows there is a space before the version and the executable is python.exe; 51 // for both versions of Python; 52 python_version.ReplaceAll("" "", """");; 53 if (python_version[0] == '2' || python_version[0] == ",MatchSource.WIKI,doc/master/PyMethodBase_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html
Modifiability,config,config,"***********; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : PyMethodBase *; 8 * *; 9 * Description: *; 10 * Virtual base class for all MVA method based on python *; 11 * *; 12 **********************************************************************************/; 13 ; 14#include <Python.h> // Needs to be included first to avoid redefinition of _POSIX_C_SOURCE; 15#include <TMVA/PyMethodBase.h>; 16 ; 17#include ""TMVA/DataSet.h""; 18#include ""TMVA/DataSetInfo.h""; 19#include ""TMVA/MsgLogger.h""; 20#include ""TMVA/Results.h""; 21#include ""TMVA/Timer.h""; 22#include ""TMVA/Tools.h""; 23 ; 24#include ""TSystem.h""; 25 ; 26#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; 27#include <numpy/arrayobject.h>; 28 ; 29using namespace TMVA;; 30 ; 31namespace TMVA {; 32namespace Internal {; 33class PyGILRAII {; 34 PyGILState_STATE m_GILState;; 35 ; 36public:; 37 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 38 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 39};; 40} // namespace Internal; 41 ; 42/// get current Python executable used by ROOT; 43TString Python_Executable() {; 44 TString python_version = gSystem->GetFromPipe(""root-config --python-version"");; 45 if (python_version.IsNull()) {; 46 TMVA::gTools().Log() << kFATAL << ""Can't find a valid Python version used to build ROOT"" << Endl;; 47 return nullptr;; 48 }; 49#ifdef _MSC_VER; 50 // on Windows there is a space before the version and the executable is python.exe; 51 // for both versions of Python; 52 python_version.ReplaceAll("" "", """");; 53 if (python_version[0] == '2' || python_version[0] == '3'); 54 return ""python"";; 55#endif; 56 if (python_version[0] == '2'); 57 return ""python"";; 58 else if (python_version[0] == '3'); 59 return ""python3"";; 60 ; 61 TMVA::gTools().Log() << kFATAL << ""Invalid Python version used to build ROOT : "" << python_version << Endl;; 62 return nullptr;; 63}; 64 ; 65} // namespace TMVA; 66 ; 67ClassImp(PyMethodBase);; 68 ; 69// NOTE: Introduce",MatchSource.WIKI,doc/master/PyMethodBase_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html
Performance,load,load,"(""pickle"");; 216 // Import the file as a Python module.; 217 // return object is a new reference !; 218 fModulePickle = PyImport_Import(pName);; 219 if (!fModulePickle) {; 220 Log << kFATAL << ""Can't import pickle"" << Endl;; 221 Log << Endl;; 222 }; 223 PyObject *pDict = PyModule_GetDict(fModulePickle);; 224 // note the following return objects are borrowed references; 225 fPickleDumps = PyDict_GetItemString(pDict, ""dump"");; 226 fPickleLoads = PyDict_GetItemString(pDict, ""load"");; 227 if (fPickleDumps) Py_INCREF(fPickleDumps);; 228 if (fPickleLoads) Py_INCREF(fPickleLoads);; 229 ; 230 Py_DECREF(pName);; 231}; 232 ; 233///////////////////////////////////////////////////////////////////////////////; 234// Finalize Python interpreter; 235 ; 236void PyMethodBase::PyFinalize(); 237{; 238 if (fEval) Py_DECREF(fEval);; 239 if (fOpen) Py_DECREF(fOpen);; 240 if (fModuleBuiltin) Py_DECREF(fModuleBuiltin);; 241 if (fPickleDumps) Py_DECREF(fPickleDumps);; 242 if (fPickleLoads) Py_DECREF(fPickleLoads);; 243 if(fMain) Py_DECREF(fMain);//objects fGlobalNS and fLocalNS will be free here; 244 if (fGlobalNS) Py_DECREF(fGlobalNS);; 245 Py_Finalize();; 246}; 247 ; 248///////////////////////////////////////////////////////////////////////////////; 249/// Check Python interpreter initialization status; 250///; 251/// \return Boolean whether interpreter is initialized; 252 ; 253int PyMethodBase::PyIsInitialized(); 254{; 255 if (!Py_IsInitialized()) return kFALSE;; 256 if (!fEval) return kFALSE;; 257 if (!fModuleBuiltin) return kFALSE;; 258 if (!fPickleDumps) return kFALSE;; 259 if (!fPickleLoads) return kFALSE;; 260 return kTRUE;; 261}; 262 ; 263///////////////////////////////////////////////////////////////////////////////; 264/// Serialize Python object; 265///; 266/// \param[in] path Path where object is written to file; 267/// \param[in] obj Python object; 268///; 269/// The input Python object is serialized and written to a file. The Python; 270/// module `pickle` is used to do so.; ",MatchSource.WIKI,doc/master/PyMethodBase_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html
Safety,avoid,avoid,". ROOT: tmva/pymva/src/PyMethodBase.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. PyMethodBase.cxx. Go to the documentation of this file. 1// @(#)root/tmva/pymva $Id$; 2// Authors: Omar Zapata, Lorenzo Moneta, Sergei Gleyzer 2015, Stefan Wunsch 2017; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : PyMethodBase *; 8 * *; 9 * Description: *; 10 * Virtual base class for all MVA method based on python *; 11 * *; 12 **********************************************************************************/; 13 ; 14#include <Python.h> // Needs to be included first to avoid redefinition of _POSIX_C_SOURCE; 15#include <TMVA/PyMethodBase.h>; 16 ; 17#include ""TMVA/DataSet.h""; 18#include ""TMVA/DataSetInfo.h""; 19#include ""TMVA/MsgLogger.h""; 20#include ""TMVA/Results.h""; 21#include ""TMVA/Timer.h""; 22#include ""TMVA/Tools.h""; 23 ; 24#include ""TSystem.h""; 25 ; 26#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; 27#include <numpy/arrayobject.h>; 28 ; 29using namespace TMVA;; 30 ; 31namespace TMVA {; 32namespace Internal {; 33class PyGILRAII {; 34 PyGILState_STATE m_GILState;; 35 ; 36public:; 37 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 38 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 39};; 40} // namespace Internal; 41 ; 42/// get current Python executable used by ROOT; 43TString Python_Executable() {; 44 TString python_version = gSystem->GetFromPipe(""root-config --python-version"");; 45 if (python_version.IsNull()) {; 46 TMVA::gTools().Log() << kFATAL << ""Can't find a valid Python version used to build ROOT"" << Endl;; 47 return nullptr;; 48 }; 49#ifdef _MSC_VER; 50 // on Windows there is a space before the version and the executable is python.exe; 51 // for both versions of Python; 52 python_version.ReplaceAll("" "", """");; 53 if (python_version[0] == '2' || python_version[0] == ",MatchSource.WIKI,doc/master/PyMethodBase_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html
Integrability,inject,injecting,"No Matches. Namespaces ; pyroot002_pythonizationDecorator.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; import ROOT; from ROOT import pythonization; ; # Let's first define a new C++ class. In this tutorial, we will see how we can; # ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; # make it more pythonic or easier to use from Python.; #; # Note: In this example, the class is defined dynamically for demonstration; # purposes, but it could also be a C++ class defined in some library or header.; # For more information about loading C++ user code to be used from Python with; # PyROOT, please see:; # https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; ROOT.gInterpreter.Declare('''; class MyClass {};; '''); ; # Next, we define a pythonizor function: the function that will be responsible; # for injecting new behaviour in our C++ class `MyClass`.; #; # To convert a given Python function into a pythonizor, we need to decorate it; # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object). For that purpose, I can define the following; # pythonizor function. There are two important things to be noted here:; # - The @pythonization de",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html
Performance,load,loading,". ROOT: tutorials/pyroot/pyroot002_pythonizationDecorator.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot002_pythonizationDecorator.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; import ROOT; from ROOT import pythonization; ; # Let's first define a new C++ class. In this tutorial, we will see how we can; # ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; # make it more pythonic or easier to use from Python.; #; # Note: In this example, the class is defined dynamically for demonstration; # purposes, but it could also be a C++ class defined in some library or header.; # For more information about loading C++ user code to be used from Python with; # PyROOT, please see:; # https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; ROOT.gInterpreter.Declare('''; class MyClass {};; '''); ; # Next, we define a pythonizor function: the function that will be responsible; # for injecting new behaviour in our C++ class `MyClass`.; #; # To convert a given Python function into a pythonizor, we need to decorate it; # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object)",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html
Security,inject,injecting,"No Matches. Namespaces ; pyroot002_pythonizationDecorator.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; import ROOT; from ROOT import pythonization; ; # Let's first define a new C++ class. In this tutorial, we will see how we can; # ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; # make it more pythonic or easier to use from Python.; #; # Note: In this example, the class is defined dynamically for demonstration; # purposes, but it could also be a C++ class defined in some library or header.; # For more information about loading C++ user code to be used from Python with; # PyROOT, please see:; # https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; ROOT.gInterpreter.Declare('''; class MyClass {};; '''); ; # Next, we define a pythonizor function: the function that will be responsible; # for injecting new behaviour in our C++ class `MyClass`.; #; # To convert a given Python function into a pythonizor, we need to decorate it; # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object). For that purpose, I can define the following; # pythonizor function. There are two important things to be noted here:; # - The @pythonization de",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html
Usability,simpl,simple," header.; # For more information about loading C++ user code to be used from Python with; # PyROOT, please see:; # https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; ROOT.gInterpreter.Declare('''; class MyClass {};; '''); ; # Next, we define a pythonizor function: the function that will be responsible; # for injecting new behaviour in our C++ class `MyClass`.; #; # To convert a given Python function into a pythonizor, we need to decorate it; # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object). For that purpose, I can define the following; # pythonizor function. There are two important things to be noted here:; # - The @pythonization decorator has one argument that specifies our target; # class is `MyClass`.; # - The pythonizor function `pythonizor_of_myclass` provides and injects a new; # implementation for `__str__`, the mechanism that Python provides to define; # how to represent objects as strings. This new implementation; # always returns the string ""This is a MyClass object"".; @pythonization('MyClass'); def pythonizor_of_myclass(klass):; klass.__str__ = lambda o : 'This is a MyClass object'; ; # Once we have defined our pythonizor function, let's see it in action.; # We will now use the `MyClass` class for the first time from Python: we will; # create a new instance of that class. At this moment, t",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html
Integrability,inject,injecting,"hows how to use the `@pythonization` decorator to add extra; 5## behaviour to C++ user classes that are used from Python via PyROOT.; 6##; 7## \macro_code; 8## \macro_output; 9##; 10## \date November 2021; 11## \author Enric Tejedor; 12 ; 13import ROOT; 14from ROOT import pythonization; 15 ; 16# Let's first define a new C++ class. In this tutorial, we will see how we can; 17# ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; 18# make it more pythonic or easier to use from Python.; 19#; 20# Note: In this example, the class is defined dynamically for demonstration; 21# purposes, but it could also be a C++ class defined in some library or header.; 22# For more information about loading C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to b",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html
Performance,load,loading,"rator.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pyroot002_pythonizationDecorator.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -nodraw; 4## This tutorial shows how to use the `@pythonization` decorator to add extra; 5## behaviour to C++ user classes that are used from Python via PyROOT.; 6##; 7## \macro_code; 8## \macro_output; 9##; 10## \date November 2021; 11## \author Enric Tejedor; 12 ; 13import ROOT; 14from ROOT import pythonization; 15 ; 16# Let's first define a new C++ class. In this tutorial, we will see how we can; 17# ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; 18# make it more pythonic or easier to use from Python.; 19#; 20# Note: In this example, the class is defined dynamically for demonstration; 21# purposes, but it could also be a C++ class defined in some library or header.; 22# For more information about loading C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example.",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html
Security,inject,injecting,"hows how to use the `@pythonization` decorator to add extra; 5## behaviour to C++ user classes that are used from Python via PyROOT.; 6##; 7## \macro_code; 8## \macro_output; 9##; 10## \date November 2021; 11## \author Enric Tejedor; 12 ; 13import ROOT; 14from ROOT import pythonization; 15 ; 16# Let's first define a new C++ class. In this tutorial, we will see how we can; 17# ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; 18# make it more pythonic or easier to use from Python.; 19#; 20# Note: In this example, the class is defined dynamically for demonstration; 21# purposes, but it could also be a C++ class defined in some library or header.; 22# For more information about loading C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to b",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html
Usability,simpl,simple,"ing C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to be noted here:; 48# - The @pythonization decorator has one argument that specifies our target; 49# class is `MyClass`.; 50# - The pythonizor function `pythonizor_of_myclass` provides and injects a new; 51# implementation for `__str__`, the mechanism that Python provides to define; 52# how to represent objects as strings. This new implementation; 53# always returns the string ""This is a MyClass object"".; 54@pythonization('MyClass'); 55def pythonizor_of_myclass(klass):; 56 klass.__str__ = lambda o : 'This is a MyClass object'; 57 ; 58# Once we have defined our pythonizor function, let's see it in action.; 59# We will now use the `MyClass` class for the first time from Python: we will; 60# create a new insta",MatchSource.WIKI,doc/master/pyroot002__pythonizationDecorator_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html
Energy Efficiency,power,powered,". ROOT: tutorials/pyroot/pyroot003_prettyPrinting.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot003_prettyPrinting.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ; The printing behaves similar to the ROOT prompt powered by the C++ interpreter cling.; ; import ROOT; ; # Create an object with PyROOT; obj = ROOT.std.vector(""int"")(3); for i in range(obj.size()):; obj[i] = i; ; # Print the object, which reveals the content. Note that `print` calls the special; # method `__str__` of the object internally.; print(obj); ; # The output can be retrieved as string by any function that triggers the `__str__`; # special method of the object, e.g., `str` or `format`.; print(str(obj)); print(""{}"".format(obj)); ; # Note that the interactive Python prompt does not call `__str__`, it calls; # `__repr__`, which implements a formal and unique string representation of; # the object.; print(repr(obj)); obj; ; # The print output behaves similar to the ROOT prompt, e.g., here for a ROOT histogram.; hist = ROOT.TH1F(""name"", ""title"", 10, 0, 1); print(hist); ; # If cling cannot produce any nice representation for the class, we fall back to a; # ""<ClassName at address>"" format, which is what `__repr__` returns; ROOT.gInterpreter.Declare('class MyClass {};'); m = ROOT.MyClass(); print(m); print(str(m) == repr(m)); ; formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyNam",MatchSource.WIKI,doc/master/pyroot003__prettyPrinting_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot003__prettyPrinting_8py.html
Availability,avail,available,". ROOT: tutorials/pyroot/pyroot004_NumbaDeclare.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot004_NumbaDeclare.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ; The feature uses the numba Python package for just-in-time compilation of the Python callable and supports fundamental types and ROOT::RVec thereof.; ; import ROOT; ; # To mark a Python callable to be used from C++, you have to use the decorator; # provided by PyROOT passing the C++ types of the input arguments and the return; # value.; @ROOT.Numba.Declare(['float', 'int'], 'float'); def pypow(x, y):; return x**y; ; # The Python callable is now available from C++ in the Numba namespace.; # For example, we can use it from the interpreter.; ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); ; # Or we can use the callable as well within a RDataFrame workflow.; data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; .Define('x_pow3', 'Numba::pypow(x, 3)')\; .AsNumpy(); ; print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); ; # ROOT uses the numba Python package to create C++ functions from python ones.; # We support as input and return types of the callable fundamental types and; # ROOT::RVec thereof. See the following callable computing the power of the; # elements in an array.; @ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); def pypowarray(x, y):; return x**y; ; ROOT.gInterpreter.ProcessLine('''; ROOT::RVecF x = {0, 1, 2, 3};; cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; '''); ; # and now with RDataFrame; s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; .Define('x2', 'Numba::pypowarray(x, 2)')\; .Sum('x2') # 1 + 4 + 9 == 14; print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html
Energy Efficiency,power,power,"nd supports fundamental types and ROOT::RVec thereof.; ; import ROOT; ; # To mark a Python callable to be used from C++, you have to use the decorator; # provided by PyROOT passing the C++ types of the input arguments and the return; # value.; @ROOT.Numba.Declare(['float', 'int'], 'float'); def pypow(x, y):; return x**y; ; # The Python callable is now available from C++ in the Numba namespace.; # For example, we can use it from the interpreter.; ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); ; # Or we can use the callable as well within a RDataFrame workflow.; data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; .Define('x_pow3', 'Numba::pypow(x, 3)')\; .AsNumpy(); ; print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); ; # ROOT uses the numba Python package to create C++ functions from python ones.; # We support as input and return types of the callable fundamental types and; # ROOT::RVec thereof. See the following callable computing the power of the; # elements in an array.; @ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); def pypowarray(x, y):; return x**y; ; ROOT.gInterpreter.ProcessLine('''; ROOT::RVecF x = {0, 1, 2, 3};; cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; '''); ; # and now with RDataFrame; s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; .Define('x2', 'Numba::pypowarray(x, 2)')\; .Sum('x2') # 1 + 4 + 9 == 14; print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Poin",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html
Integrability,interface,interface,"m python ones.; # We support as input and return types of the callable fundamental types and; # ROOT::RVec thereof. See the following callable computing the power of the; # elements in an array.; @ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); def pypowarray(x, y):; return x**y; ; ROOT.gInterpreter.ProcessLine('''; ROOT::RVecF x = {0, 1, 2, 3};; cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; '''); ; # and now with RDataFrame; s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; .Define('x2', 'Numba::pypowarray(x, 2)')\; .Sum('x2') # 1 + 4 + 9 == 14; print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; 2^3 = 8; pypowarray({ 0, 1, 2, 3 }, 3) = { 0, 1, 8, 27 }; pypow([0. 1. 2. 3.], 3) = [ 0. 1. 8. 27.]; sum(pypowarray({ 1, 2, 3 }, 2)) = 14.0; DateMarch 2020 ; AuthorStefan Wunsch ; Definition in file pyroot004_NumbaDeclare.py. tutorialspyrootpyroot004_NumbaDeclare.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html
Usability,usab,usable,". ROOT: tutorials/pyroot/pyroot004_NumbaDeclare.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot004_NumbaDeclare.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ; The feature uses the numba Python package for just-in-time compilation of the Python callable and supports fundamental types and ROOT::RVec thereof.; ; import ROOT; ; # To mark a Python callable to be used from C++, you have to use the decorator; # provided by PyROOT passing the C++ types of the input arguments and the return; # value.; @ROOT.Numba.Declare(['float', 'int'], 'float'); def pypow(x, y):; return x**y; ; # The Python callable is now available from C++ in the Numba namespace.; # For example, we can use it from the interpreter.; ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); ; # Or we can use the callable as well within a RDataFrame workflow.; data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; .Define('x_pow3', 'Numba::pypow(x, 3)')\; .AsNumpy(); ; print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); ; # ROOT uses the numba Python package to create C++ functions from python ones.; # We support as input and return types of the callable fundamental types and; # ROOT::RVec thereof. See the following callable computing the power of the; # elements in an array.; @ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); def pypowarray(x, y):; return x**y; ; ROOT.gInterpreter.ProcessLine('''; ROOT::RVecF x = {0, 1, 2, 3};; cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; '''); ; # and now with RDataFrame; s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; .Define('x2', 'Numba::pypowarray(x, 2)')\; .Sum('x2') # 1 + 4 + 9 == 14; print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html
Availability,avail,available,". ROOT: tutorials/pyroot/pyroot004_NumbaDeclare.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pyroot004_NumbaDeclare.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -nodraw; 4## This tutorial illustrates how PyROOT supports declaring C++ callables from; 5## Python callables making them, for example, usable with RDataFrame. The feature; 6## uses the numba Python package for just-in-time compilation of the Python callable; 7## and supports fundamental types and ROOT::RVec thereof.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date March 2020; 13## \author Stefan Wunsch; 14 ; 15import ROOT; 16 ; 17# To mark a Python callable to be used from C++, you have to use the decorator; 18# provided by PyROOT passing the C++ types of the input arguments and the return; 19# value.; 20@ROOT.Numba.Declare(['float', 'int'], 'float'); 21def pypow(x, y):; 22 return x**y; 23 ; 24# The Python callable is now available from C++ in the Numba namespace.; 25# For example, we can use it from the interpreter.; 26ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); 27 ; 28# Or we can use the callable as well within a RDataFrame workflow.; 29data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; 30 .Define('x_pow3', 'Numba::pypow(x, 3)')\; 31 .AsNumpy(); 32 ; 33print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); 34 ; 35# ROOT uses the numba Python package to create C++ functions from python ones.; 36# We support as input and return types of the callable fundamental types and; 37# ROOT::RVec thereof. See the following callable computing the power of the; 38# elements in an array.; 39@ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); 40def pypowarray(x, y):; 41 return x**y; 42 ; 43ROOT.gInterpreter.ProcessLine('''; 44ROOT::RVecF x = {0, 1, 2, 3};; 45cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; 46'''); 47 ; 48# and now w",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html
Energy Efficiency,power,power,"; 15import ROOT; 16 ; 17# To mark a Python callable to be used from C++, you have to use the decorator; 18# provided by PyROOT passing the C++ types of the input arguments and the return; 19# value.; 20@ROOT.Numba.Declare(['float', 'int'], 'float'); 21def pypow(x, y):; 22 return x**y; 23 ; 24# The Python callable is now available from C++ in the Numba namespace.; 25# For example, we can use it from the interpreter.; 26ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); 27 ; 28# Or we can use the callable as well within a RDataFrame workflow.; 29data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; 30 .Define('x_pow3', 'Numba::pypow(x, 3)')\; 31 .AsNumpy(); 32 ; 33print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); 34 ; 35# ROOT uses the numba Python package to create C++ functions from python ones.; 36# We support as input and return types of the callable fundamental types and; 37# ROOT::RVec thereof. See the following callable computing the power of the; 38# elements in an array.; 39@ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); 40def pypowarray(x, y):; 41 return x**y; 42 ; 43ROOT.gInterpreter.ProcessLine('''; 44ROOT::RVecF x = {0, 1, 2, 3};; 45cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; 46'''); 47 ; 48# and now with RDataFrame; 49s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; 50 .Define('x2', 'Numba::pypowarray(x, 2)')\; 51 .Sum('x2') # 1 + 4 + 9 == 14; 52print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg co",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html
Integrability,interface,interface,"_pow3', 'Numba::pypow(x, 3)')\; 31 .AsNumpy(); 32 ; 33print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); 34 ; 35# ROOT uses the numba Python package to create C++ functions from python ones.; 36# We support as input and return types of the callable fundamental types and; 37# ROOT::RVec thereof. See the following callable computing the power of the; 38# elements in an array.; 39@ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); 40def pypowarray(x, y):; 41 return x**y; 42 ; 43ROOT.gInterpreter.ProcessLine('''; 44ROOT::RVecF x = {0, 1, 2, 3};; 45cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; 46'''); 47 ; 48# and now with RDataFrame; 49s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; 50 .Define('x2', 'Numba::pypowarray(x, 2)')\; 51 .Sum('x2') # 1 + 4 + 9 == 14; 52print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41. tutorialspyrootpyroot004_NumbaDeclare.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html
Usability,usab,usable,". ROOT: tutorials/pyroot/pyroot004_NumbaDeclare.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pyroot004_NumbaDeclare.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -nodraw; 4## This tutorial illustrates how PyROOT supports declaring C++ callables from; 5## Python callables making them, for example, usable with RDataFrame. The feature; 6## uses the numba Python package for just-in-time compilation of the Python callable; 7## and supports fundamental types and ROOT::RVec thereof.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date March 2020; 13## \author Stefan Wunsch; 14 ; 15import ROOT; 16 ; 17# To mark a Python callable to be used from C++, you have to use the decorator; 18# provided by PyROOT passing the C++ types of the input arguments and the return; 19# value.; 20@ROOT.Numba.Declare(['float', 'int'], 'float'); 21def pypow(x, y):; 22 return x**y; 23 ; 24# The Python callable is now available from C++ in the Numba namespace.; 25# For example, we can use it from the interpreter.; 26ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); 27 ; 28# Or we can use the callable as well within a RDataFrame workflow.; 29data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; 30 .Define('x_pow3', 'Numba::pypow(x, 3)')\; 31 .AsNumpy(); 32 ; 33print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); 34 ; 35# ROOT uses the numba Python package to create C++ functions from python ones.; 36# We support as input and return types of the callable fundamental types and; 37# ROOT::RVec thereof. See the following callable computing the power of the; 38# elements in an array.; 39@ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); 40def pypowarray(x, y):; 41 return x**y; 42 ; 43ROOT.gInterpreter.ProcessLine('''; 44ROOT::RVecF x = {0, 1, 2, 3};; 45cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; 46'''); 47 ; 48# and now w",MatchSource.WIKI,doc/master/pyroot004__NumbaDeclare_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html
Availability,alive,alive,"e file; print(""Histogram '{}' is attached to: '{}'.\n"".format(histo_2.GetName(), histo_2.GetDirectory().GetName())); # Before exiting the context, objects can be written to the file; f.WriteObject(histo_2, ""my_histogram""); ; # When the TFile.Close method is called, the current directory is automatically; # set again to ROOT.gROOT. Objects that were attached to the file inside the; # context are automatically deleted and made 'None' when the file is closed.; print(""Status after the first TFile context manager:""); print("" Current directory: '{}'."".format(ROOT.gDirectory.GetName())); print("" Accessing 'histo_2' gives: '{}'.\n"".format(histo_2)); ; # Also reading data from a TFile can be done in a context manager. Information; # stored in the objects of the file can be queried and used inside the context.; # After the context, the objects are not usable anymore because the file is; # automatically closed. This means you should use this pattern as a quick way; # to get information or modify objects from a certain file, without needing to; # keep the histograms alive afterwards.; with TFile.Open(""pyroot005_file_1.root"", ""read"") as f:; # Retrieve histogram using the name given to f.WriteObject in the previous; # with statement; histo_2_fromfile = f[""my_histogram""]; print(""Retrieved '{}' histogram from file '{}'.\n"".format(histo_2_fromfile.GetName(), f.GetName())); ; # Cleanup the file created for this tutorial; os.remove(""pyroot005_file_1.root""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char d",MatchSource.WIKI,doc/master/pyroot005__tfile__context__manager_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html
Usability,usab,usable,"n file; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # And the created histogram is automatically attached to the file; print(""Histogram '{}' is attached to: '{}'.\n"".format(histo_2.GetName(), histo_2.GetDirectory().GetName())); # Before exiting the context, objects can be written to the file; f.WriteObject(histo_2, ""my_histogram""); ; # When the TFile.Close method is called, the current directory is automatically; # set again to ROOT.gROOT. Objects that were attached to the file inside the; # context are automatically deleted and made 'None' when the file is closed.; print(""Status after the first TFile context manager:""); print("" Current directory: '{}'."".format(ROOT.gDirectory.GetName())); print("" Accessing 'histo_2' gives: '{}'.\n"".format(histo_2)); ; # Also reading data from a TFile can be done in a context manager. Information; # stored in the objects of the file can be queried and used inside the context.; # After the context, the objects are not usable anymore because the file is; # automatically closed. This means you should use this pattern as a quick way; # to get information or modify objects from a certain file, without needing to; # keep the histograms alive afterwards.; with TFile.Open(""pyroot005_file_1.root"", ""read"") as f:; # Retrieve histogram using the name given to f.WriteObject in the previous; # with statement; histo_2_fromfile = f[""my_histogram""]; print(""Retrieved '{}' histogram from file '{}'.\n"".format(histo_2_fromfile.GetName(), f.GetName())); ; # Cleanup the file created for this tutorial; os.remove(""pyroot005_file_1.root""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char ",MatchSource.WIKI,doc/master/pyroot005__tfile__context__manager_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html
Availability,avail,available," with how TFile works, so it is suggested to also take a look at the pyroot005 tutorial.; import os; ; import ROOT; from ROOT import TDirectory, TFile; ; # Sometimes it is useful to have multiple open files at once. In such cases,; # the current directory will always be the file that was open last.; file_1 = TFile(""pyroot006_file_1.root"", ""recreate""); file_2 = TFile(""pyroot006_file_2.root"", ""recreate""); print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # Changing directory into another file can be safely done through a TContext; # context manager.; with TDirectory.TContext(file_1):; # Inside the statement, the current directory is file_1; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_1 = ROOT.TH1F(""histo_1"", ""histo_1"", 10, 0, 10); file_1.WriteObject(histo_1, ""my_histogram""); ; # After the context, the current directory is restored back to file_2. Also, the; # two files are kept open. This means that objects read, written or modified; # inside the context are still available afterwards.; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); if file_1.IsOpen() and file_2.IsOpen():; print(""'{}' and '{}' are open.\n"".format(file_1.GetName(), file_2.GetName())); ; # TContext and TFile context managers can also be used in conjunction, allowing; # for safely:; # - Opening a file, creating, modifying, writing and reading objects in it.; # - Closing the file, storing it on disk.; # - Restoring the previous value of gDirectory to the latest file opened before; # this context, rather than to the global ROOT.gROOT; # Remember that the TContext must be initialized before the TFile, otherwise the; # current directory would already be set to the file opened for this context.; with TDirectory.TContext(), TFile(""pyroot006_file_3.root"", ""recreate"") as f:; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_2 = ROOT.TH1F(""histo_2"", ""histo_2"", 10, 0, 10); f.WriteObject(histo_2, ""another_histog",MatchSource.WIKI,doc/master/pyroot006__tcontext__context__manager_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html
Safety,safe,safely,". ROOT: tutorials/pyroot/pyroot006_tcontext_context_manager.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot006_tcontext_context_manager.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial demonstrates the usage of the TContext class as a Python context manager. ; This functionality is related with how TFile works, so it is suggested to also take a look at the pyroot005 tutorial.; import os; ; import ROOT; from ROOT import TDirectory, TFile; ; # Sometimes it is useful to have multiple open files at once. In such cases,; # the current directory will always be the file that was open last.; file_1 = TFile(""pyroot006_file_1.root"", ""recreate""); file_2 = TFile(""pyroot006_file_2.root"", ""recreate""); print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # Changing directory into another file can be safely done through a TContext; # context manager.; with TDirectory.TContext(file_1):; # Inside the statement, the current directory is file_1; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_1 = ROOT.TH1F(""histo_1"", ""histo_1"", 10, 0, 10); file_1.WriteObject(histo_1, ""my_histogram""); ; # After the context, the current directory is restored back to file_2. Also, the; # two files are kept open. This means that objects read, written or modified; # inside the context are still available afterwards.; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); if file_1.IsOpen() and file_2.IsOpen():; print(""'{}' and '{}' are open.\n"".format(file_1.GetName(), file_2.GetName())); ; # TContext and TFile context managers can also be used in conjunction, allowing; # for safely:; # - Opening a file, creating, modifying, writing and reading objects in it.; # - Closing the file, storing it on disk.; # - Restoring the previous value of gDirectory to the latest file opened before; # this context, rather than to the global ROOT.gROOT; # Remem",MatchSource.WIKI,doc/master/pyroot006__tcontext__context__manager_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html
Deployability,update,update,"; 11 * of the License, or (at your option) any later version. *; 12 * *; 13 * This library is distributed in the hope that it will be useful, *; 14 * but WITHOUT ANY WARRANTY; without even the implied warranty of *; 15 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; 16 * General Public License for more details. *; 17 * *; 18 * You should have received a copy of the GNU General Public License *; 19 * along with this library (see file COPYING); if not, write *; 20 * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; 21 * 330, Boston, MA 02111-1307 USA, or contact the author. *; 22 * *; 23 **********************************************************************/; 24 ; 25// Header file for class GSLRandom; 26//; 27// Created by: moneta at Sun Nov 21 16:26:03 2004; 28//; 29// Last update: Sun Nov 21 16:26:03 2004; 30//; 31#ifndef ROOT_Math_QuasiRandom; 32#define ROOT_Math_QuasiRandom; 33 ; 34#include <string>; 35 ; 36/**; 37 @defgroup QuasiRandom QuasiRandom number generators and distributions; 38 Classes for generating QuasiRandom numbers and based on GSL ; 39 @ingroup Random; 40 @ingroup MathMore; 41*/; 42 ; 43 ; 44 ; 45namespace ROOT {; 46namespace Math {; 47 ; 48 ; 49//_____________________________________________________________________________________; 50/**; 51 User class for MathMore random numbers template on the Engine type.; 52 The API of this class followed that of the class ROOT::Math::Random; 53 It must be implemented using as Engine one of the derived classes of; 54 ROOT::Math::GSLQuasiRandomEngine, like ROOT::Math::GSLQrngSobol; 55 ; 56 @ingroup QuasiRandom; 57 ; 58*/; 59template < class Engine>; 60class QuasiRandom {; 61 ; 62public:; 63 ; 64 ; 65 /**; 66 Create a QuasiRandom generator. Use default engine constructor.; 67 Engine will be initialized via Initialize() function in order to; 68 allocate resources; 69 */; 70 QuasiRandom(unsigned int dimension = 1) {; 71 fEngine.Initialize(dimension);; 72 }; 73 ; 74 ; 75 /**; 76",MatchSource.WIKI,doc/master/QuasiRandom_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/QuasiRandom_8h_source.html
Energy Efficiency,allocate,allocate,"ROOT_Math_QuasiRandom; 32#define ROOT_Math_QuasiRandom; 33 ; 34#include <string>; 35 ; 36/**; 37 @defgroup QuasiRandom QuasiRandom number generators and distributions; 38 Classes for generating QuasiRandom numbers and based on GSL ; 39 @ingroup Random; 40 @ingroup MathMore; 41*/; 42 ; 43 ; 44 ; 45namespace ROOT {; 46namespace Math {; 47 ; 48 ; 49//_____________________________________________________________________________________; 50/**; 51 User class for MathMore random numbers template on the Engine type.; 52 The API of this class followed that of the class ROOT::Math::Random; 53 It must be implemented using as Engine one of the derived classes of; 54 ROOT::Math::GSLQuasiRandomEngine, like ROOT::Math::GSLQrngSobol; 55 ; 56 @ingroup QuasiRandom; 57 ; 58*/; 59template < class Engine>; 60class QuasiRandom {; 61 ; 62public:; 63 ; 64 ; 65 /**; 66 Create a QuasiRandom generator. Use default engine constructor.; 67 Engine will be initialized via Initialize() function in order to; 68 allocate resources; 69 */; 70 QuasiRandom(unsigned int dimension = 1) {; 71 fEngine.Initialize(dimension);; 72 }; 73 ; 74 ; 75 /**; 76 Create a QuasiRandom generator based on a provided generic engine.; 77 Engine will be initialized via Initialize() function in order to; 78 allocate resources; 79 */; 80 explicit QuasiRandom(const Engine & e, unsigned int dimension = 1) : fEngine(e) {; 81 fEngine.Initialize(dimension);; 82 }; 83 ; 84 /**; 85 Destructor: call Terminate() function of engine to free any; 86 allocated resource; 87 */; 88 ~QuasiRandom() {; 89 fEngine.Terminate();; 90 }; 91 ; 92 /**; 93 Generate next quasi random numbers points; 94 */; 95 bool Next(double * x) {; 96 return fEngine(x);; 97 }; 98 ; 99 /**; 100 Generate next quasi random numbers point (1 - dimension); 101 */; 102 double Next() {; 103 return fEngine();; 104 }; 105 ; 106 /**; 107 Generate quasi random numbers between ]0,1[; 108 0 and 1 are excluded; 109 Function to be compatible with ROOT TRandom compatibility; 110 */;",MatchSource.WIKI,doc/master/QuasiRandom_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/QuasiRandom_8h_source.html
Deployability,update,update,". ROOT: math/genvector/src/QuaternionXaxial.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. QuaternionXaxial.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for quaternion times other non-axial rotations.; 12// Decoupled from main Quaternion implementations.; 13//; 14// Created by: Mark Fischler Tues July 19, 2005; 15//; 16// Last update: $Id$; 17//; 18#include ""Math/GenVector/Quaternion.h""; 19 ; 20namespace ROOT {; 21 ; 22namespace Math {; 23 ; 24 ; 25// Although the same technique would work with axial rotations,; 26// we know that two of the four quaternion components will be zero,; 27// and we exploit that knowledge:; 28 ; 29Quaternion Quaternion::operator * (const RotationX & rx) const {; 30 // combination with a RotationX; 31 Quaternion q(rx);; 32 return Quaternion (; 33 U()*q.U() - I()*q.I(); 34 , I()*q.U() + U()*q.I(); 35 , J()*q.U() + K()*q.I(); 36 , K()*q.U() - J()*q.I(); 37 );; 38}; 39 ; 40Quaternion Quaternion::operator * (const RotationY & ry) const {; 41 // combination with a RotationY; 42 Quaternion q(ry);; 43 return Quaternion (; 44 U()*q.U() - J()*q.J(); 45 , I()*q.U() - K()*q.J(); 46 , J()*q.U() + U()*q.J(); 47 , K()*q.U() + I()*q.J(); 48 );; 49}; 50 ; 51Quaternion Quaternion::operator * (const RotationZ & rz) const {; 52 // combination with a RotationZ; 53 Quaternion q(rz);; 54 return Quaternion (; 55 U()*q.U() - K()*q.K(); 56 , I()*q.U() + J()*q.K(); 57 , J()*q.U() - I()*q.K(); 58 , K()*q.U() + U()*q.K(); 59 );; 60}; 61 ; 62Quaternion; 63operator * ( RotationX const & r, Quaternion const & q ) {; 64 return Quaternion(r) * q; // TODO: improve performance; 65}; 66 ; 67Qua",MatchSource.WIKI,doc/master/QuaternionXaxial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/QuaternionXaxial_8cxx_source.html
Performance,perform,performance," 30 // combination with a RotationX; 31 Quaternion q(rx);; 32 return Quaternion (; 33 U()*q.U() - I()*q.I(); 34 , I()*q.U() + U()*q.I(); 35 , J()*q.U() + K()*q.I(); 36 , K()*q.U() - J()*q.I(); 37 );; 38}; 39 ; 40Quaternion Quaternion::operator * (const RotationY & ry) const {; 41 // combination with a RotationY; 42 Quaternion q(ry);; 43 return Quaternion (; 44 U()*q.U() - J()*q.J(); 45 , I()*q.U() - K()*q.J(); 46 , J()*q.U() + U()*q.J(); 47 , K()*q.U() + I()*q.J(); 48 );; 49}; 50 ; 51Quaternion Quaternion::operator * (const RotationZ & rz) const {; 52 // combination with a RotationZ; 53 Quaternion q(rz);; 54 return Quaternion (; 55 U()*q.U() - K()*q.K(); 56 , I()*q.U() + J()*q.K(); 57 , J()*q.U() - I()*q.K(); 58 , K()*q.U() + U()*q.K(); 59 );; 60}; 61 ; 62Quaternion; 63operator * ( RotationX const & r, Quaternion const & q ) {; 64 return Quaternion(r) * q; // TODO: improve performance; 65}; 66 ; 67Quaternion; 68operator * ( RotationY const & r, Quaternion const & q ) {; 69 return Quaternion(r) * q; // TODO: improve performance; 70}; 71 ; 72Quaternion; 73operator * ( RotationZ const & r, Quaternion const & q ) {; 74 return Quaternion(r) * q; // TODO: improve performance; 75}; 76 ; 77 ; 78} //namespace Math; 79} //namespace ROOT; Quaternion.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::QuaternionRotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k).Definition Quaternion.h:49; ROOT::Math::Quaternion::QuaternionQuaternion()Default constructor (identity rotation)Definition Quaternion.h:60; ROOT::Math::Quaternion::UScalar U() constAccess to the four quaternion components: U() is the coefficient of the identity Pauli matrix,...Definition Quaternion.h:167; ROOT::Math::Quaternion::operator*",MatchSource.WIKI,doc/master/QuaternionXaxial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/QuaternionXaxial_8cxx_source.html
Deployability,update,update,". ROOT: math/genvector/src/Quaternion.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Quaternion.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for rotation in 3 dimensions, represented by quaternion; 12//; 13// Created by: Mark Fischler Thurs June 9 2005; 14//; 15// Last update: $Id$; 16//; 17#include ""Math/GenVector/Quaternion.h""; 18 ; 19#include <cmath>; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23 ; 24#include ""Math/GenVector/Rotation3Dfwd.h""; 25#include ""Math/GenVector/AxisAnglefwd.h""; 26#include ""Math/GenVector/EulerAnglesfwd.h""; 27 ; 28namespace ROOT {; 29 ; 30namespace Math {; 31 ; 32// ========== Constructors and Assignment =====================; 33 ; 34void Quaternion::Rectify(); 35{; 36 ; 37 // The vector should be a unit vector, and the first element should be; 38 // non-negative (though negative fU quaternions would work just fine,; 39 // being isomorphic to a quaternion with positive fU).; 40 ; 41 if ( fU < 0 ) {; 42 fU = - fU; fI = - fI; fJ = - fJ; fK = - fK;; 43 }; 44 ; 45 Scalar a = 1.0 / std::sqrt(fU*fU + fI*fI + fJ*fJ + fK*fK);; 46 fU *= a;; 47 fI *= a;; 48 fJ *= a;; 49 fK *= a;; 50 ; 51} // Rectify(); 52 ; 53 ; 54// ========== Operations =====================; 55 ; 56// DisplacementVector3D< Cartesian3D<double> >; 57// Quaternion::operator() (const DisplacementVector3D< Cartesian3D<double> > & v) const; 58// {; 59// // apply to a 3D Vector; 60// }; 61 ; 62// Quaternion Quaternion::operator * (const Quaternion & q) const {; 63// // combination of rotations; 64// return Quaternion (; 65// fU*q.fU - fI*q.fI - fJ*q.",MatchSource.WIKI,doc/master/Quaternion_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Quaternion_8cxx_source.html
Integrability,depend,depending,"d an element to the mixture using fraction by weight Check if the element is already definedDefinition TGeoMaterial.cxx:869; Once defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the 2 methods:; void TGeoMaterial::FillMaterialEvolution(TObjArray *population,; Double_t precision=0.001); TGeoMaterial::FillMaterialEvolutionvirtual void FillMaterialEvolution(TObjArray *population, Double_t precision=0.001)Fills a user array with all the elements deriving from the possible decay of the top element composin...Definition TGeoMaterial.cxx:742; TObjArrayAn array of TObjects.Definition TObjArray.h:31; To use this method, one has to provide an empty TObjArray object that will be filled with all elements coming from the decay chain of the initial radionuclides contained by the material/mixture. The precision represent the cumulative branching ratio for which decay products are still considered. The POPULATION list may contain stable elements as well as radionuclides, depending on the initial elements. To test if an element is a radionuclide:; Bool_t TGeoElement::IsRadioNuclide() const; Bool_tbool Bool_tDefinition RtypesCore.h:63; TGeoElement::IsRadioNuclidevirtual Bool_t IsRadioNuclide() constDefinition TGeoElement.h:82; All radionuclides in the output population list have attached objects that represent the time evolution of their fraction of nuclei with respect to the top radionuclide in the decay chain. These objects (Bateman solutions) can be retrieved and drawn:; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoBatemanSol::Drawvoid Draw(Option_t *option="""") overrideDraw the solution of Bateman equation versus time.Definition TGeoElement.cxx:1612; TGeoElementRN::RatioTGeoBatemanSol * Ratio() constDefinition TGeoElement.h:188; Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:; TGeoMaterial::Deca",MatchSource.WIKI,doc/master/RadioNuclides_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RadioNuclides_8C.html
Performance,load,loaded,". ROOT: tutorials/geom/RadioNuclides.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RadioNuclides.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Macro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package. ; A radionuclide (TGeoElementRN) derives from the class TGeoElement and provides additional information related to its radioactive properties and decay modes.; The radionuclides table is loaded on demand by any call:; TGeoElementRN *TGeoElementTable::GetElementRN(Int_t atomic_number,; Int_t atomic_charge,; Int_t isomeric_number); Int_tint Int_tDefinition RtypesCore.h:45; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementTable::GetElementRNTGeoElementRN * GetElementRN(Int_t ENDFcode) constRetrieve a radionuclide by ENDF code.Definition TGeoElement.cxx:1368; The isomeric number is optional and the default value is 0.; To create a radioactive material based on a radionuclide, one should use the constructor:; TGeoMaterial(const char *name, TGeoElement *elem, Double_t density); Double_tdouble Double_tDefinition RtypesCore.h:59; namechar name[80]Definition TGX11.cxx:110; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; To create a radioactive mixture, one can use radionuclides as well as stable elements:; TGeoMixture(const char *name, Int_t nelements, Double_t density);; TGeoMixture::AddElement(TGeoElement *elem, Double_t weight_fraction);; TGeoMixtureMixtures of elements.Definition TGeoMaterial.h:159; TGeoMixture::AddElementvoid AddElement(Double_t a, Double_t z, Double_t weight)add an element to the mixture using fraction by weight Check if the element is already definedDefinition TGeoMaterial.cxx:869; Once defined, one can retrieve the time evolution for the rad",MatchSource.WIKI,doc/master/RadioNuclides_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RadioNuclides_8C.html
Testability,test,test,"x:869; Once defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the 2 methods:; void TGeoMaterial::FillMaterialEvolution(TObjArray *population,; Double_t precision=0.001); TGeoMaterial::FillMaterialEvolutionvirtual void FillMaterialEvolution(TObjArray *population, Double_t precision=0.001)Fills a user array with all the elements deriving from the possible decay of the top element composin...Definition TGeoMaterial.cxx:742; TObjArrayAn array of TObjects.Definition TObjArray.h:31; To use this method, one has to provide an empty TObjArray object that will be filled with all elements coming from the decay chain of the initial radionuclides contained by the material/mixture. The precision represent the cumulative branching ratio for which decay products are still considered. The POPULATION list may contain stable elements as well as radionuclides, depending on the initial elements. To test if an element is a radionuclide:; Bool_t TGeoElement::IsRadioNuclide() const; Bool_tbool Bool_tDefinition RtypesCore.h:63; TGeoElement::IsRadioNuclidevirtual Bool_t IsRadioNuclide() constDefinition TGeoElement.h:82; All radionuclides in the output population list have attached objects that represent the time evolution of their fraction of nuclei with respect to the top radionuclide in the decay chain. These objects (Bateman solutions) can be retrieved and drawn:; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoBatemanSol::Drawvoid Draw(Option_t *option="""") overrideDraw the solution of Bateman equation versus time.Definition TGeoElement.cxx:1612; TGeoElementRN::RatioTGeoBatemanSol * Ratio() constDefinition TGeoElement.h:188; Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); TGeoMaterial::DecayMaterialvirtual TGeoMaterial * DecayMaterial(D",MatchSource.WIKI,doc/master/RadioNuclides_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RadioNuclides_8C.html
Integrability,interface,interface,"nst char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; ROOT::Internal::RDF::TValueGetterHelper class which keeps track for each slot where to get the entry.Definition RArrowDS.cxx:204; ROOT::RDF::RArrowDSRDataFrame data source class to interface with Apache Arrow.Definition RArrowDS.hxx:30; ROOT::RDF::RArrowDS::GetEntryRangesstd::vector< std::pair< ULong64_t, ULong64_t > > GetEntryRanges() finalReturn ranges of entries to distribute to tasks.Definition RArrowDS.cxx:469; ROOT::RDF::RArrowDS::SetNSlotsvoid SetNSlots(unsigned int nSlots) finalInform RDataSource of the number of processing slots (i.e.Definition RArrowDS.cxx:554; ROOT::RDF::RArrowDS::~RArrowDS~RArrowDS()Destructor.Definition RArrowDS.cxx:460; ROOT::RDF::RArrowDS::fNSlotssize_t fNSlotsDefinition RArrowDS.hxx:35; ROOT::RDF::RArrowDS::HasColumnbool HasColumn(std::string_view colName) const finalChecks if the dataset has a certain column.Definition RArrowDS.cxx:493; ROOT::RDF::RArrowDS::InitSlotvoid InitSlot(unsigned int slot, ULong64_t firstEntry) finalConvenience method called at the start of the data processing associated to a slot.Definition RArrowDS.cxx:511; ROOT::RDF::RArrowDS::GetLabelstd::string GetLabel() finalReturn a string represen",MatchSource.WIKI,doc/master/RArrowDS_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RArrowDS_8hxx_source.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot1.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example creating a simple ratio plot of two histograms using the pois division option. ; Two histograms are set up and filled with random numbers. The constructor of TRatioPlot takes the two histograms, name and title for the object, drawing options for the histograms (hist and E in this case) and a drawing option for the output graph. The histograms drawing options can be changed with SetH1DrawOpt and SetH2DrawOpt. ; void ratioplot1() {; gStyle->SetOptStat(0);; auto C = new TCanvas(""C"", ""A ratio example"");; auto h1 = new TH1D(""h1"", ""TRatioPlot Example; x; y"", 50, 0, 10);; auto h2 = new TH1D(""h2"", ""h2"", 50, 0, 10);; auto f1 = new TF1(""f1"", ""exp(- x/[0] )"");; f1->SetParameter(0, 3);; h1->FillRandom(""f1"", 1900);; h2->FillRandom(""f1"", 2000);; h1->Sumw2();; h2->Scale(1.9 / 2.);; h2->SetLineColor(kRed);; ; // Create and draw the ratio plot; auto rp = new TRatioPlot(h1, h2);; C->SetTicks(0, 1);; rp->Draw();; rp->GetLowYaxis()->SetNdivisions(505);; ; // Add a legend to the ratio plot; rp->GetUpperPad()->cd();; TLegend *legend = new TLegend(0.3,0.7,0.7,0.85);; legend->AddEntry(""h1"",""First histogram"",""l"");; legend->AddEntry(""h2"",""Second histogram"",""le"");; legend->Draw();; }; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create s",MatchSource.WIKI,doc/master/ratioplot1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot1_8C.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot1.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot1.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example creating a simple ratio plot of two histograms using the pois division option. ; Two histograms are set up and filled with random numbers. The constructor of TRatioPlot takes the to histograms, name and title for the object, drawing options for the histograms (hist and E in this case) and a drawing option for the output graph. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""A ratio example""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, 0, 10); h2 = ROOT.TH1D(""h2"", ""h2"", 50, 0, 10); f1 = ROOT.TF1(""f1"", ""exp(- x/[0] )""); f1.SetParameter(0,3); ; h1.FillRandom(""f1"",1900); h2.FillRandom(""f1"", 2000); h1.Sumw2(); h2.Scale(1.9/2.); ; h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp = ROOT.TRatioPlot(h1,h2); ; c1.SetTicks(0,1); rp.GetLowYaxis().SetNdivisions(505); c1.Update(); c1.Draw(); rp.Draw(); ; AuthorAlberto Ferro ; Definition in file ratioplot1.py. tutorialshistratioplot1.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ratioplot1_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot1_8py.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot2.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of a fit residual plot. ; Creates a histogram filled with random numbers from a gaussian distribution and fits it with a standard gaussian function. The result is passed to the TRatioPlot constructor. Additionally, after calling TRatioPlot::Draw the upper and lower y axis titles are modified. Confidence interval bands are automatically drawn on the bottom (but can be disabled by draw option nobands). ; void ratioplot2() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->GetXaxis()->SetTitle(""x"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefYaxis()->SetTitle(""ratio"");; rp1->GetUpperRefYaxis()->SetTitle(""entries"");; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:16",MatchSource.WIKI,doc/master/ratioplot2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot2_8C.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot2.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot2.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of a fit residual plot. ; Creates a histogram filled with random numbers from a gaussian distribution and fits it with a standard gaussian function. The result is passed to the TRatioPlot constructor. Additionally, after calling TRatioPlot::Draw the upper and lower y axis titles are modified. Confidence interval bands are automatically drawn on the bottom (but can be disabled by draw option nobands). Inspired by the tutorial of Paul Gessinger. . ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); ; h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.GetXaxis().SetTitle(""x""); ; rp1 = ROOT.TRatioPlot(h1); rp1.Draw(); rp1.GetLowerRefYaxis().SetTitle(""ratio""); rp1.GetUpperRefYaxis().SetTitle(""entries""); ; c1.Update(); ; AuthorAlberto Ferro ; Definition in file ratioplot2.py. tutorialshistratioplot2.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ratioplot2_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot2_8py.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot3.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; Since the lower plot is not created until TRatioPlot::Draw is called, you can only use the method afterwards. ; void ratioplot3() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; c1->SetLogy();; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->SetMinimum(0.001);; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-2);; rp1->GetLowerRefGraph()->SetMaximum(2);; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640;",MatchSource.WIKI,doc/master/ratioplot3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot3_8C.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot3.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot3.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; Since the lower plot is not created until TRatioPlot::Draw is called, you can only use the method afterwards. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); c1.SetLogy(); ; h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.SetMinimum(0.001); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1); rp1.Draw(); rp1.GetLowerRefGraph().SetMinimum(-2); rp1.GetLowerRefGraph().SetMaximum(2); ; c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot3.py. tutorialshistratioplot3.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ratioplot3_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot3_8py.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot4.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; By default, dashed lines are drawn at certain points. You can either disable them, or specify where you want them to appear. ; void ratioplot4() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; std::vector<double> lines = {-3, -2, -1, 0, 1, 2, 3};; rp1->SetGridlines(lines);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-4);; rp1->GetLowerRefGraph()->SetMaximum(4);; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:",MatchSource.WIKI,doc/master/ratioplot4_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot4_8C.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot4.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot4.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; By default, dashed lines are drawn at certain points. You can either disable them, or specify where you want them to appear. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1); ; lines = ROOT.std.vector('double')(); for i in range(-3,4):lines.push_back(i); rp1.SetGridlines(lines); ; rp1.Draw(); rp1.GetLowerRefGraph().SetMinimum(-4); rp1.GetLowerRefGraph().SetMaximum(4); ; c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot4.py. tutorialshistratioplot4.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ratioplot4_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot4_8py.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot5.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot5.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. . ; void ratioplot5() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"",""0"");; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; rp1->SetConfidenceIntervalColors(kBlue, kRed);; rp1->Draw();; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; ratioplot5Definition ratioplot5.py:1; AuthorPaul Gessinger ; Definition in file ratio",MatchSource.WIKI,doc/master/ratioplot5_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot5_8C.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot5.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot5.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1); rp1.SetConfidenceIntervalColors(ROOT.kBlue, ROOT.kRed); rp1.Draw(); c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot5.py. tutorialshistratioplot5.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ratioplot5_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot5_8py.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot6.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot6.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing a fit residual plot, where the separation margin has been set to 0. ; The last label of the lower plot's y axis is hidden automatically. ; void ratioplot6() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; gPad->SetFrameFillStyle(0);; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 5000);; TFitResultPtr fitres = h1->Fit(""gaus"", ""S0"");; h1->Sumw2();; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1, ""errfunc"");; rp1->SetGraphDrawOpt(""L"");; rp1->SetSeparationMargin(0.0);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-2);; rp1->GetLowerRefGraph()->SetMaximum(2);; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164;",MatchSource.WIKI,doc/master/ratioplot6_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot6_8C.html
Usability,simpl,simple,". ROOT: tutorials/hist/ratioplot6.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot6.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing a fit residual plot, where the separation margin has been set to 0. ; The last label of the lower plot's y axis is hidden automatically. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); ROOT.gPad.SetFrameFillStyle(0); ; h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 5000); h1.Fit(""gaus"", ""S""); ; h1.Sumw2(); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1, ""errfunc""); rp1.SetGraphDrawOpt(""L""); rp1.SetSeparationMargin(0.0); rp1.Draw(); rp1.GetLowerRefGraph().SetMinimum(-2); rp1.GetLowerRefGraph().SetMaximum(2); ; c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot6.py. tutorialshistratioplot6.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ratioplot6_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot6_8py.html
Safety,avoid,avoid,"booking time using the convention ""Hist_title ; X_title ; Y_title""; TH1F *h1 = new TH1F(""h1"", ""Two gaussian plots and their ratio;x title; h1 and h2 gaussian histograms"", 100, -5, 5);; TH1F *h2 = new TH1F(""h2"", ""h2"", 100, -5, 5);; h1->FillRandom(""gaus"");; h2->FillRandom(""gaus"");; ; // Define the Canvas; TCanvas *c = new TCanvas(""c"", ""canvas"", 800, 800);; ; // Upper plot will be in pad1; TPad *pad1 = new TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0);; pad1->SetBottomMargin(0); // Upper and lower plot are joined; pad1->SetGridx(); // Vertical grid; pad1->Draw(); // Draw the upper pad: pad1; pad1->cd(); // pad1 becomes the current pad; h1->SetStats(0); // No statistics on upper plot; h1->Draw(); // Draw h1; h2->Draw(""same""); // Draw h2 on top of h1; ; #if ROOT_VERSION_CODE >= ROOT_VERSION(6,8,0); // Avoid the first label (0) to be clipped.; TAxis *axis = h1->GetYaxis();; axis->ChangeLabel(1, -1, -1, -1, -1, -1, "" "");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; #else; // Do not draw the Y axis label on the upper plot and redraw a small; // axis instead, in order to avoid the first label (0) to be clipped.; h1->GetYaxis()->SetLabelSize(0.);; TGaxis *axis = new TGaxis( -5, 20, -5, 220, 20,220,510,"""");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; axis->Draw();; #endif; ; // lower plot will be in pad; c->cd(); // Go back to the main canvas before defining pad2; TPad *pad2 = new TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3);; pad2->SetTopMargin(0);; pad2->SetBottomMargin(0.2);; pad2->SetGridx(); // vertical grid; pad2->Draw();; pad2->cd(); // pad2 becomes the current pad; ; // Define the ratio plot; TH1F *h3 = (TH1F*)h1->Clone(""h3"");; h3->SetLineColor(kBlack);; h3->SetMinimum(0.8); // Define Y ..; h3->SetMaximum(1.35); // .. range; h3->Sumw2();; h3->SetStats(0); // No statistics on lower plot; h3->Divide(h2);; h3->SetMarkerStyle(21);; h3->Draw(""ep""); // Draw the ratio plot; ; // h1 settings",MatchSource.WIKI,doc/master/ratioplotOld_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplotOld_8C.html
Availability,error,errors,"hing...; No Matches. Namespaces ; ratioplot.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Display two histograms and their ratio. ; This program illustrates how to plot two histograms and their ratio on the same canvas. Original macro by Olivier Couet.; ; from ROOT import TCanvas, TColor, TGaxis, TH1F, TPad; from ROOT import kBlack, kBlue, kRed; ; ; def createH1():; h1 = TH1F(""h1"", (""Two gaussian plots and their ratio; x title; h1 and h2""; "" histograms""), 100, -5, 5); h1.SetLineColor(kBlue+1); h1.SetLineWidth(2); h1.FillRandom(""gaus""); h1.GetYaxis().SetTitleSize(20); h1.GetYaxis().SetTitleFont(43); h1.GetYaxis().SetTitleOffset(1.55); h1.SetStats(0); return h1; ; ; def createH2():; h2 = TH1F(""h2"", ""h2"", 100, -5, 5); h2.FillRandom(""gaus""); h2.SetLineColor(kRed); h2.SetLineWidth(2); return h2; ; ; def createRatio(h1, h2):; h3 = h1.Clone(""h3""); h3.SetLineColor(kBlack); h3.SetMarkerStyle(21); h3.SetTitle(""""); h3.SetMinimum(0.8); h3.SetMaximum(1.35); # Set up plot for markers and errors; h3.Sumw2(); h3.SetStats(0); h3.Divide(h2); ; # Adjust y-axis settings; y = h3.GetYaxis(); y.SetTitle(""ratio h1/h2 ""); y.SetNdivisions(505); y.SetTitleSize(20); y.SetTitleFont(43); y.SetTitleOffset(1.55); y.SetLabelFont(43); y.SetLabelSize(15); ; # Adjust x-axis settings; x = h3.GetXaxis(); x.SetTitleSize(20); x.SetTitleFont(43); x.SetTitleOffset(4.0); x.SetLabelFont(43); x.SetLabelSize(15); ; return h3; ; ; def createCanvasPads():; c = TCanvas(""c"", ""canvas"", 800, 800); # Upper histogram plot is pad1; pad1 = TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0); pad1.SetBottomMargin(0) # joins upper and lower plot; pad1.SetGridx(); pad1.Draw(); # Lower ratio plot is pad2; c.cd() # returns to main canvas before defining pad2; pad2 = TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3); pad2.SetTopMargin(0) # joins upper and lower plot; pad2.SetBottomMargin(0.2); pad2.SetGridx(); pad2.Draw(); ; return c, pad1, pad2; ; ; def ratioplot():; # create required parts; h1 = createH1(); h2 = createH2(); h3 =",MatchSource.WIKI,doc/master/ratioplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot_8py.html
Safety,avoid,avoid," h3.SetMaximum(1.35); # Set up plot for markers and errors; h3.Sumw2(); h3.SetStats(0); h3.Divide(h2); ; # Adjust y-axis settings; y = h3.GetYaxis(); y.SetTitle(""ratio h1/h2 ""); y.SetNdivisions(505); y.SetTitleSize(20); y.SetTitleFont(43); y.SetTitleOffset(1.55); y.SetLabelFont(43); y.SetLabelSize(15); ; # Adjust x-axis settings; x = h3.GetXaxis(); x.SetTitleSize(20); x.SetTitleFont(43); x.SetTitleOffset(4.0); x.SetLabelFont(43); x.SetLabelSize(15); ; return h3; ; ; def createCanvasPads():; c = TCanvas(""c"", ""canvas"", 800, 800); # Upper histogram plot is pad1; pad1 = TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0); pad1.SetBottomMargin(0) # joins upper and lower plot; pad1.SetGridx(); pad1.Draw(); # Lower ratio plot is pad2; c.cd() # returns to main canvas before defining pad2; pad2 = TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3); pad2.SetTopMargin(0) # joins upper and lower plot; pad2.SetBottomMargin(0.2); pad2.SetGridx(); pad2.Draw(); ; return c, pad1, pad2; ; ; def ratioplot():; # create required parts; h1 = createH1(); h2 = createH2(); h3 = createRatio(h1, h2); c, pad1, pad2 = createCanvasPads(); ; # draw everything; pad1.cd(); h1.Draw(); h2.Draw(""same""); # to avoid clipping the bottom zero, redraw a small axis; h1.GetYaxis().SetLabelSize(0.0); axis = TGaxis(-5, 20, -5, 220, 20, 220, 510, """"); axis.SetLabelFont(43); axis.SetLabelSize(15); axis.Draw(); pad2.cd(); h3.Draw(""ep""); ; # To hold window open when running from command line; # text = raw_input(); ; ; if __name__ == ""__main__"":; ratioplot(); TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; ratioplotDefinition ratioplot.py:1; AuthorMichael Moran ; Definition in file ratioplot.py. tutorialspyrootratioplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ratioplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ratioplot_8py.html
Performance,optimiz,optimizer,"ROOT dataset into a basic PyTorch workflow. ; ; import torch; import ROOT; ; tree_name = ""sig_tree""; file_name = ""http://root.cern/files/Higgs_data.root""; ; batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two generators that return training and validation batches; # as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name,; file_name,; batch_size,; chunk_size,; target=target,; validation_split=0.3,; ); ; # Get a list of the columns used for training; input_columns = gen_train.train_columns; num_features = len(input_columns); ; ; def calc_accuracy(targets, pred):; return torch.sum(targets == pred.round()) / pred.size(0); ; ; # Initialize PyTorch model; model = torch.nn.Sequential(; torch.nn.Linear(num_features, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 1),; torch.nn.Sigmoid(),; ); loss_fn = torch.nn.MSELoss(reduction=""mean""); optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9); ; ; # Loop through the training set and train model; for i, (x_train, y_train) in enumerate(gen_train):; # Make prediction and calculate loss; pred = model(x_train).view(-1); loss = loss_fn(pred, y_train); ; # improve model; model.zero_grad(); loss.backward(); optimizer.step(); ; # Calculate accuracy; accuracy = calc_accuracy(y_train, pred); ; print(f""Training => accuracy: {accuracy}""); ; #################################################################; # Validation; #################################################################; ; # Evaluate the model on the validation set; for i, (x_train, y_train) in enumerate(gen_validation):; # Make prediction and calculate accuracy; pred = model(x_train).view(-1); accuracy = calc_accuracy(y_train, pred); ; print(f""Validation => accuracy: {accuracy}""); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle G",MatchSource.WIKI,doc/master/RBatchGenerator__PyTorch_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html
Safety,predict,prediction,"batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two generators that return training and validation batches; # as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name,; file_name,; batch_size,; chunk_size,; target=target,; validation_split=0.3,; ); ; # Get a list of the columns used for training; input_columns = gen_train.train_columns; num_features = len(input_columns); ; ; def calc_accuracy(targets, pred):; return torch.sum(targets == pred.round()) / pred.size(0); ; ; # Initialize PyTorch model; model = torch.nn.Sequential(; torch.nn.Linear(num_features, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 1),; torch.nn.Sigmoid(),; ); loss_fn = torch.nn.MSELoss(reduction=""mean""); optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9); ; ; # Loop through the training set and train model; for i, (x_train, y_train) in enumerate(gen_train):; # Make prediction and calculate loss; pred = model(x_train).view(-1); loss = loss_fn(pred, y_train); ; # improve model; model.zero_grad(); loss.backward(); optimizer.step(); ; # Calculate accuracy; accuracy = calc_accuracy(y_train, pred); ; print(f""Training => accuracy: {accuracy}""); ; #################################################################; # Validation; #################################################################; ; # Evaluate the model on the validation set; for i, (x_train, y_train) in enumerate(gen_validation):; # Make prediction and calculate accuracy; pred = model(x_train).view(-1); accuracy = calc_accuracy(y_train, pred); ; print(f""Validation => accuracy: {accuracy}""); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int",MatchSource.WIKI,doc/master/RBatchGenerator__PyTorch_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html
Security,validat,validation,". ROOT: tutorials/tmva/RBatchGenerator_PyTorch.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; RBatchGenerator_PyTorch.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ; ; import torch; import ROOT; ; tree_name = ""sig_tree""; file_name = ""http://root.cern/files/Higgs_data.root""; ; batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two generators that return training and validation batches; # as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name,; file_name,; batch_size,; chunk_size,; target=target,; validation_split=0.3,; ); ; # Get a list of the columns used for training; input_columns = gen_train.train_columns; num_features = len(input_columns); ; ; def calc_accuracy(targets, pred):; return torch.sum(targets == pred.round()) / pred.size(0); ; ; # Initialize PyTorch model; model = torch.nn.Sequential(; torch.nn.Linear(num_features, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 1),; torch.nn.Sigmoid(),; ); loss_fn = torch.nn.MSELoss(reduction=""mean""); optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9); ; ; # Loop through the training set and train model; for i, (x_train, y_train) in enumerate(gen_train):; # Make prediction and calculate loss; pred = model(x_train).view(-1); loss = loss_fn(pred, y_train); ; # improve model; model.zero_grad(); loss.backward(); optimizer.step(); ; # Calculate accuracy; accuracy = calc_accuracy(y_train, pred); ; print(f""Training => accuracy: {accuracy}""); ; #################################################################; # Validation; #################################################################; ; # Evaluate the model on the validation set; for i, (x_train, y_train) in enumerate(gen_",MatchSource.WIKI,doc/master/RBatchGenerator__PyTorch_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html
Modifiability,layers,layers," Searching...; No Matches. Namespaces ; RBatchGenerator_TensorFlow.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; import tensorflow as tf; import ROOT; ; tree_name = ""sig_tree""; file_name = ""http://root.cern/files/Higgs_data.root""; ; batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two TF.Dataset for training and validation batches.; ds_train, ds_valid = ROOT.TMVA.Experimental.CreateTFDatasets(; tree_name,; file_name,; batch_size,; chunk_size,; validation_split=0.3,; target=target,; ); ; # Get a list of the columns used for training; input_columns = ds_train.train_columns; num_features = len(input_columns); ; ##############################################################################; # AI example; ##############################################################################; ; # Define TensorFlow model; model = tf.keras.Sequential(; [; tf.keras.layers.Dense(; 300, activation=tf.nn.tanh, input_shape=(num_features,); ), # input shape required; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(1, activation=tf.nn.sigmoid),; ]; ); loss_fn = tf.keras.losses.BinaryCrossentropy(); model.compile(optimizer=""adam"", loss=loss_fn, metrics=[""accuracy""]); ; # Train model; model.fit(ds_train, validation_data=ds_valid, epochs=2); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const ",MatchSource.WIKI,doc/master/RBatchGenerator__TensorFlow_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBatchGenerator__TensorFlow_8py.html
Performance,optimiz,optimizer,"ize = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two TF.Dataset for training and validation batches.; ds_train, ds_valid = ROOT.TMVA.Experimental.CreateTFDatasets(; tree_name,; file_name,; batch_size,; chunk_size,; validation_split=0.3,; target=target,; ); ; # Get a list of the columns used for training; input_columns = ds_train.train_columns; num_features = len(input_columns); ; ##############################################################################; # AI example; ##############################################################################; ; # Define TensorFlow model; model = tf.keras.Sequential(; [; tf.keras.layers.Dense(; 300, activation=tf.nn.tanh, input_shape=(num_features,); ), # input shape required; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(1, activation=tf.nn.sigmoid),; ]; ); loss_fn = tf.keras.losses.BinaryCrossentropy(); model.compile(optimizer=""adam"", loss=loss_fn, metrics=[""accuracy""]); ; # Train model; model.fit(ds_train, validation_data=ds_valid, epochs=2); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; Epoch 1/2; ; 1/Unknown - 9s 9s/step - loss: 0.5945 - accuracy: 0.7656␈",MatchSource.WIKI,doc/master/RBatchGenerator__TensorFlow_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBatchGenerator__TensorFlow_8py.html
Security,validat,validation,". ROOT: tutorials/tmva/RBatchGenerator_TensorFlow.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; RBatchGenerator_TensorFlow.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; import tensorflow as tf; import ROOT; ; tree_name = ""sig_tree""; file_name = ""http://root.cern/files/Higgs_data.root""; ; batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two TF.Dataset for training and validation batches.; ds_train, ds_valid = ROOT.TMVA.Experimental.CreateTFDatasets(; tree_name,; file_name,; batch_size,; chunk_size,; validation_split=0.3,; target=target,; ); ; # Get a list of the columns used for training; input_columns = ds_train.train_columns; num_features = len(input_columns); ; ##############################################################################; # AI example; ##############################################################################; ; # Define TensorFlow model; model = tf.keras.Sequential(; [; tf.keras.layers.Dense(; 300, activation=tf.nn.tanh, input_shape=(num_features,); ), # input shape required; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(1, activation=tf.nn.sigmoid),; ]; ); loss_fn = tf.keras.losses.BinaryCrossentropy(); model.compile(optimizer=""adam"", loss=loss_fn, metrics=[""accuracy""]); ; # Train model; model.fit(ds_train, validation_data=ds_valid, epochs=2); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window co",MatchSource.WIKI,doc/master/RBatchGenerator__TensorFlow_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBatchGenerator__TensorFlow_8py.html
Availability,error,error,"ue);; 124 comp->Add(files);; 125 // if there are any open files, make them visible by default; 126 if (elem_files->GetNumChilds() > 0); 127 seldir = {};; 128 }; 129 ; 130 SetTopElement(comp);; 131 ; 132 SetWorkingPath(seldir);; 133}; 134 ; 135/////////////////////////////////////////////////////////////////////; 136/// Reset all data correspondent to last request; 137 ; 138void RBrowserData::ResetLastRequestData(bool with_element); 139{; 140 fLastAllChilds = false;; 141 fLastSortedItems.clear();; 142 fLastSortMethod.clear();; 143 fLastItems.clear();; 144 if (with_element) {; 145 fLastPath.clear();; 146 fLastElement.reset();; 147 }; 148}; 149 ; 150/////////////////////////////////////////////////////////////////////////; 151/// Decompose path to elements; 152/// Returns array of names for each element in the path, first element either ""/"" or "".""; 153/// If returned array empty - it is error; 154 ; 155Browsable::RElementPath_t RBrowserData::DecomposePath(const std::string &strpath, bool relative_to_work_element); 156{; 157 Browsable::RElementPath_t arr;; 158 if (relative_to_work_element) arr = fWorkingPath;; 159 ; 160 if (strpath.empty()); 161 return arr;; 162 ; 163 auto arr2 = Browsable::RElement::ParsePath(strpath);; 164 arr.insert(arr.end(), arr2.begin(), arr2.end());; 165 return arr;; 166}; 167 ; 168/////////////////////////////////////////////////////////////////////////; 169/// Process browser request; 170 ; 171bool RBrowserData::ProcessBrowserRequest(const RBrowserRequest &request, RBrowserReply &reply); 172{; 173 auto path = fWorkingPath;; 174 path.insert(path.end(), request.path.begin(), request.path.end());; 175 ; 176 if ((path != fLastPath) || !fLastElement) {; 177 ; 178 auto elem = GetSubElement(path);; 179 if (!elem) return false;; 180 ; 181 ResetLastRequestData(true);; 182 ; 183 fLastPath = path;; 184 fLastElement = std::move(elem);; 185 ; 186 fLastElement->cd(); // set element active; 187 } else if (request.reload) {; 188 // only reload items from elemen",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Deployability,configurat,configuration,"lementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Browsable::RItemRepresentation of single item in the browser.Definition RItem.hxx:23; ROOT::Browsable::RProvider::Browsestatic std::shared_ptr< RElement > Browse(std::unique_ptr< RHolder > &obj)Create browsable element for the object Created element may take ownership over the object.Definition RProvider.cxx:273; ROOT::Browsable::RSysFile::ProvideTopEntriesstatic RElementPath_t ProvideTopEntries(std::shared_ptr< RGroup > &comp, const std::string &workdir="""")Provide top entries for file system On windows it is list of existing drivers, on Linux it is ""File s...Definition RSysFile.cxx:533; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RBrowserDataCleanupDefinition RBrowserData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::RBrowserDataCleanupRBrowserDataCleanup(RBrowserData &_data)Definition RBrowserData.cxx:48; ROOT::RBrowserDataCleanup::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from a list.Definition RBrowserData.cxx:50; ROOT::RBrowserDataWay to browse (hopefully) everything in ROOT.Definition RBrowserData.hxx:37; ROOT::RBrowserData::SetTopElementvoid SetTopElement(std::shared_ptr< Browsable::RElement > elem)set top element for browsingDefinition RBrowserData.cxx:88; ROOT::RBrowserData::fLastSortedItemsstd::vector< const Browsable::RItem * > fLastSortedItems! sorted child items, used in requestsDefinition RBrowserData.hxx:51; ROOT::RBrowserData::fWorkingPathBrowsable::RElementPath_t fWorkingPath! path showed in BreadcrumbDef",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Modifiability,config,configuration,"lementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Browsable::RItemRepresentation of single item in the browser.Definition RItem.hxx:23; ROOT::Browsable::RProvider::Browsestatic std::shared_ptr< RElement > Browse(std::unique_ptr< RHolder > &obj)Create browsable element for the object Created element may take ownership over the object.Definition RProvider.cxx:273; ROOT::Browsable::RSysFile::ProvideTopEntriesstatic RElementPath_t ProvideTopEntries(std::shared_ptr< RGroup > &comp, const std::string &workdir="""")Provide top entries for file system On windows it is list of existing drivers, on Linux it is ""File s...Definition RSysFile.cxx:533; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RBrowserDataCleanupDefinition RBrowserData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::RBrowserDataCleanupRBrowserDataCleanup(RBrowserData &_data)Definition RBrowserData.cxx:48; ROOT::RBrowserDataCleanup::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from a list.Definition RBrowserData.cxx:50; ROOT::RBrowserDataWay to browse (hopefully) everything in ROOT.Definition RBrowserData.hxx:37; ROOT::RBrowserData::SetTopElementvoid SetTopElement(std::shared_ptr< Browsable::RElement > elem)set top element for browsingDefinition RBrowserData.cxx:88; ROOT::RBrowserData::fLastSortedItemsstd::vector< const Browsable::RItem * > fLastSortedItems! sorted child items, used in requestsDefinition RBrowserData.hxx:51; ROOT::RBrowserData::fWorkingPathBrowsable::RElementPath_t fWorkingPath! path showed in BreadcrumbDef",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Performance,cache,cached,"ply data; 268 ; 269std::string RBrowserData::ProcessRequest(const RBrowserRequest &request); 270{; 271 if (request.lastcycle < 0); 272 gEnv->SetValue(""WebGui.LastCycle"", ""no"");; 273 else if (request.lastcycle > 0); 274 gEnv->SetValue(""WebGui.LastCycle"", ""yes"");; 275 ; 276 RBrowserReply reply;; 277 ; 278 reply.path = request.path;; 279 reply.first = 0;; 280 reply.nchilds = 0;; 281 ; 282 ProcessBrowserRequest(request, reply);; 283 ; 284 return TBufferJSON::ToJSON(&reply, TBufferJSON::kSkipTypeInfo + TBufferJSON::kNoSpaces).Data();; 285}; 286 ; 287/////////////////////////////////////////////////////////////////////////; 288/// Returns element with path, specified as string; 289 ; 290std::shared_ptr<Browsable::RElement> RBrowserData::GetElement(const std::string &str); 291{; 292 auto path = DecomposePath(str, true);; 293 ; 294 return GetSubElement(path);; 295}; 296 ; 297/////////////////////////////////////////////////////////////////////////; 298/// Returns element with path, specified as Browsable::RElementPath_t; 299 ; 300std::shared_ptr<Browsable::RElement> RBrowserData::GetElementFromTop(const Browsable::RElementPath_t &path); 301{; 302 return GetSubElement(path);; 303}; 304 ; 305/////////////////////////////////////////////////////////////////////////; 306/// Returns sub-element starting from top, using cached data; 307 ; 308std::shared_ptr<Browsable::RElement> RBrowserData::GetSubElement(const Browsable::RElementPath_t &path); 309{; 310 if (path.empty()); 311 return fTopElement;; 312 ; 313 // validate cache - removes no longer actual elements; 314 RemoveFromCache(nullptr);; 315 ; 316 // first check direct match in cache; 317 for (auto &entry : fCache); 318 if (entry.first == path); 319 return entry.second;; 320 ; 321 // find best possible entry in cache; 322 int pos = 0;; 323 auto elem = fTopElement;; 324 ; 325 for (auto &entry : fCache) {; 326 if (entry.first.size() >= path.size()); 327 continue;; 328 ; 329 auto comp = Browsable::RElement::ComparePaths(path, ent",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Safety,avoid,avoid,"v.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TFolder.h; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; TObjectHolder.hxx; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; ROOT::Browsable::RElement::ExtractItemIndexstatic int ExtractItemIndex(std::string &name)Extract index from name Index coded by client with ###<indx>$$$ suffix Such coding used by browser to...Definition RElement.cxx:178; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Browsable::RItemRepresentation of single item in the browser.Definition RItem.hxx:23; ROOT::Browsable::RProvider::Browsestatic std::shared_ptr< RElement > Browse(std::unique_ptr< RHolder > &obj)Create browsable element for the object Created element may take ownership over the object.Definition RProvider.cxx:273; ROOT::Browsable::RSysFile::ProvideTopEntriesstatic RElementPath_t ProvideTopEntries(std::shared_ptr< RGroup > &comp, const std::string &workdir="""")Provide top entries for file system On windows it is list of existing drivers, on Linux it is ""File s...Definition RSysFile.cxx:533; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RBrowserDataCleanupDefinition RBrowserData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::R",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Security,validat,validate,"//////////////////////////////////////; 288/// Returns element with path, specified as string; 289 ; 290std::shared_ptr<Browsable::RElement> RBrowserData::GetElement(const std::string &str); 291{; 292 auto path = DecomposePath(str, true);; 293 ; 294 return GetSubElement(path);; 295}; 296 ; 297/////////////////////////////////////////////////////////////////////////; 298/// Returns element with path, specified as Browsable::RElementPath_t; 299 ; 300std::shared_ptr<Browsable::RElement> RBrowserData::GetElementFromTop(const Browsable::RElementPath_t &path); 301{; 302 return GetSubElement(path);; 303}; 304 ; 305/////////////////////////////////////////////////////////////////////////; 306/// Returns sub-element starting from top, using cached data; 307 ; 308std::shared_ptr<Browsable::RElement> RBrowserData::GetSubElement(const Browsable::RElementPath_t &path); 309{; 310 if (path.empty()); 311 return fTopElement;; 312 ; 313 // validate cache - removes no longer actual elements; 314 RemoveFromCache(nullptr);; 315 ; 316 // first check direct match in cache; 317 for (auto &entry : fCache); 318 if (entry.first == path); 319 return entry.second;; 320 ; 321 // find best possible entry in cache; 322 int pos = 0;; 323 auto elem = fTopElement;; 324 ; 325 for (auto &entry : fCache) {; 326 if (entry.first.size() >= path.size()); 327 continue;; 328 ; 329 auto comp = Browsable::RElement::ComparePaths(path, entry.first);; 330 ; 331 if ((comp > pos) && (comp == (int) entry.first.size())) {; 332 pos = comp;; 333 elem = entry.second;; 334 }; 335 }; 336 ; 337 while (pos < (int) path.size()) {; 338 std::string subname = path[pos];; 339 int indx = Browsable::RElement::ExtractItemIndex(subname);; 340 ; 341 auto iter = elem->GetChildsIter();; 342 if (!iter); 343 return nullptr;; 344 ; 345 if (!iter->Find(subname, indx)) {; 346 if (indx < 0); 347 return nullptr;; 348 iter = elem->GetChildsIter();; 349 if (!iter || !iter->Find(subname)); 350 return nullptr;; 351 }; 352 ; 353 elem = iter->GetElem",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Testability,log,log,"lementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Browsable::RItemRepresentation of single item in the browser.Definition RItem.hxx:23; ROOT::Browsable::RProvider::Browsestatic std::shared_ptr< RElement > Browse(std::unique_ptr< RHolder > &obj)Create browsable element for the object Created element may take ownership over the object.Definition RProvider.cxx:273; ROOT::Browsable::RSysFile::ProvideTopEntriesstatic RElementPath_t ProvideTopEntries(std::shared_ptr< RGroup > &comp, const std::string &workdir="""")Provide top entries for file system On windows it is list of existing drivers, on Linux it is ""File s...Definition RSysFile.cxx:533; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RBrowserDataCleanupDefinition RBrowserData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::RBrowserDataCleanupRBrowserDataCleanup(RBrowserData &_data)Definition RBrowserData.cxx:48; ROOT::RBrowserDataCleanup::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from a list.Definition RBrowserData.cxx:50; ROOT::RBrowserDataWay to browse (hopefully) everything in ROOT.Definition RBrowserData.hxx:37; ROOT::RBrowserData::SetTopElementvoid SetTopElement(std::shared_ptr< Browsable::RElement > elem)set top element for browsingDefinition RBrowserData.cxx:88; ROOT::RBrowserData::fLastSortedItemsstd::vector< const Browsable::RItem * > fLastSortedItems! sorted child items, used in requestsDefinition RBrowserData.hxx:51; ROOT::RBrowserData::fWorkingPathBrowsable::RElementPath_t fWorkingPath! path showed in BreadcrumbDef",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Usability,clear,clear,"15 auto elem_root = Browsable::RProvider::Browse(rootfold);; 116 if (elem_root); 117 comp->Add(std::make_shared<Browsable::RWrapper>(""root"", elem_root));; 118 ; 119 std::unique_ptr<Browsable::RHolder> rootfiles = std::make_unique<Browsable::TObjectHolder>(gROOT->GetListOfFiles(), kFALSE);; 120 auto elem_files = Browsable::RProvider::Browse(rootfiles);; 121 if (elem_files) {; 122 auto files = std::make_shared<Browsable::RWrapper>(""ROOT Files"", elem_files);; 123 files->SetExpandByDefault(true);; 124 comp->Add(files);; 125 // if there are any open files, make them visible by default; 126 if (elem_files->GetNumChilds() > 0); 127 seldir = {};; 128 }; 129 ; 130 SetTopElement(comp);; 131 ; 132 SetWorkingPath(seldir);; 133}; 134 ; 135/////////////////////////////////////////////////////////////////////; 136/// Reset all data correspondent to last request; 137 ; 138void RBrowserData::ResetLastRequestData(bool with_element); 139{; 140 fLastAllChilds = false;; 141 fLastSortedItems.clear();; 142 fLastSortMethod.clear();; 143 fLastItems.clear();; 144 if (with_element) {; 145 fLastPath.clear();; 146 fLastElement.reset();; 147 }; 148}; 149 ; 150/////////////////////////////////////////////////////////////////////////; 151/// Decompose path to elements; 152/// Returns array of names for each element in the path, first element either ""/"" or "".""; 153/// If returned array empty - it is error; 154 ; 155Browsable::RElementPath_t RBrowserData::DecomposePath(const std::string &strpath, bool relative_to_work_element); 156{; 157 Browsable::RElementPath_t arr;; 158 if (relative_to_work_element) arr = fWorkingPath;; 159 ; 160 if (strpath.empty()); 161 return arr;; 162 ; 163 auto arr2 = Browsable::RElement::ParsePath(strpath);; 164 arr.insert(arr.end(), arr2.begin(), arr2.end());; 165 return arr;; 166}; 167 ; 168/////////////////////////////////////////////////////////////////////////; 169/// Process browser request; 170 ; 171bool RBrowserData::ProcessBrowserRequest(const RBrowserRequest &requ",MatchSource.WIKI,doc/master/RBrowserData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html
Availability,avail,available,"/////////////////////////////////////////////////////////////; 87/// Create new canvas instance; 88 ; 89std::shared_ptr<ROOT::Experimental::RCanvas> ROOT::Experimental::RCanvas::Create(const std::string &title); 90{; 91 auto pCanvas = std::make_shared<RCanvas>();; 92 pCanvas->SetTitle(title);; 93 {; 94 std::lock_guard<std::mutex> grd(GetHeldCanvasesMutex());; 95 GetHeldCanvases().emplace_back(pCanvas);; 96 }; 97 ; 98 return pCanvas;; 99}; 100 ; 101//////////////////////////////////////////////////////////////////////////; 102/// Create new display for the canvas; 103/// The parameter `where` specifies which program could be used for display creation; 104/// Possible values:; 105///; 106/// - `cef` Chromium Embeded Framework, local display, local communication; 107/// - `qt5` Qt5 WebEngine (when running via rootqt5), local display, local communication; 108/// - `browser` default system web-browser, communication via random http port from range 8800 - 9800; 109/// - `<prog>` any program name which will be started instead of default browser, like firefox or /usr/bin/opera; 110/// one could also specify $url in program name, which will be replaced with canvas URL; 111/// - `native` either any available local display or default browser; 112///; 113/// Canvas can be displayed in several different places; 114 ; 115void ROOT::Experimental::RCanvas::Show(const std::string &where); 116{; 117 fShown = true;; 118 ; 119 // Do not display canvas in batch mode; 120 if (gROOT->IsWebDisplayBatch()); 121 return;; 122 ; 123 if (fPainter) {; 124 bool isany = (fPainter->NumDisplays() > 0);; 125 ; 126 if (!where.empty()); 127 fPainter->NewDisplay(where);; 128 ; 129 if (isany) return;; 130 }; 131 ; 132 if (!fModified); 133 fModified = 1; // 0 is special value, means no changes and no drawings; 134 ; 135 if (!fPainter); 136 fPainter = Internal::RVirtualCanvasPainter::Create(*this);; 137 ; 138 if (fPainter) {; 139 fPainter->NewDisplay(where);; 140 fPainter->CanvasUpdated(fModified, true, nul",MatchSource.WIKI,doc/master/RCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html
Deployability,update,update,"; 328{; 329 // suppress all changes coming from non-main connection; 330 if (!GetContext().IsMainConn()); 331 return nullptr;; 332 ; 333 auto canv = const_cast<ROOT::Experimental::RCanvas *>(GetContext().GetCanvas());; 334 if (!canv) return nullptr;; 335 ; 336 if ((ids.size() != names.size()) || (ids.size() != values.size())) {; 337 R__LOG_ERROR(GPadLog()) << ""Mismatch of arrays size in RChangeAttrRequest"";; 338 return nullptr;; 339 }; 340 ; 341 Version_t vers = 0;; 342 ; 343 for(int indx = 0; indx < (int) ids.size(); indx++) {; 344 if (ids[indx] == ""canvas"") {; 345 if (canv->GetAttrMap().Change(names[indx], values[indx].get())) {; 346 if (!vers) vers = canv->IncModified();; 347 canv->SetDrawableVersion(vers);; 348 }; 349 } else {; 350 auto drawable = canv->FindPrimitiveByDisplayId(ids[indx]);; 351 if (drawable && drawable->GetAttrMap().Change(names[indx], values[indx].get())) {; 352 if (!vers) vers = canv->IncModified();; 353 drawable->SetDrawableVersion(vers);; 354 }; 355 }; 356 }; 357 ; 358 fNeedUpdate = (vers > 0) && update;; 359 ; 360 return nullptr; // no need for any reply; 361}; 362 ; RCanvas.hxx; RLogger.hxx; R__LOG_ERROR#define R__LOG_ERROR(...)Definition RLogger.hxx:362; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; Version_tshort Version_tDefinition RtypesCore.h:65; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text",MatchSource.WIKI,doc/master/RCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html
Modifiability,plugin,plugin,"GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TList.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; ROOT::Experimental::Internal::RVirtualCanvasPainter::Createstatic std::unique_ptr< RVirtualCanvasPainter > Create(RCanvas &canv)Loads the plugin that implements this class.Definition RVirtualCanvasPainter.cxx:42; ROOT::Experimental::RCanvasA window's topmost RPad.Definition RCanvas.hxx:47; ROOT::Experimental::RCanvas::GetCanvasesstatic const std::vector< std::shared_ptr< RCanvas > > GetCanvases()Returns list of created canvases.Definition RCanvas.cxx:45; ROOT::Experimental::RCanvas::ReleaseHeldCanvasesstatic void ReleaseHeldCanvases()Release list of held canvases pointers If no other shared pointers exists on the canvas,...Definition RCanvas.cxx:56; ROOT::Experimental::RCanvas::SaveAsbool SaveAs(const std::string &filename)Save canvas in image file.Definition RCanvas.cxx:181; ROOT::Experimental::RCanvas::GetWindowUrlstd::string GetWindowUrl(bool remote)Returns window URL which can be used for connection.Definition RCanvas.cxx:159; ROOT::Experimental::RCanvas::IsModifiedbool IsModified() constReturns true is canvas was modified since last painting.Definition RCanvas.cxx",MatchSource.WIKI,doc/master/RCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html
Performance,perform,performed,"Experimental::RCanvas::Remove(); 226{; 227 std::lock_guard<std::mutex> grd(GetHeldCanvasesMutex());; 228 auto &held = GetHeldCanvases();; 229 auto indx = held.size();; 230 while (indx-- > 0) {; 231 if (held[indx].get() == this); 232 held.erase(held.begin() + indx);; 233 }; 234}; 235 ; 236//////////////////////////////////////////////////////////////////////////////////////////////; 237/// Set handle which will be cleared when connection is closed; 238 ; 239void ROOT::Experimental::RCanvas::ClearOnClose(const std::shared_ptr<void> &handle); 240{; 241 if (fPainter); 242 fPainter->SetClearOnClose(handle);; 243}; 244 ; 245//////////////////////////////////////////////////////////////////////////; 246/// Run canvas functionality for the given time (in seconds); 247/// Used to process canvas-related actions in the appropriate thread context.; 248/// Must be regularly called when canvas created and used in extra thread.; 249/// Time parameter specifies minimal execution time in seconds - if default value 0 is used,; 250/// just all pending actions will be performed.; 251/// When canvas is not yet displayed - just performs sleep for given time interval.; 252///; 253/// Example of usage:; 254///; 255/// ~~~ {.cpp}; 256/// void draw_canvas(bool &run_loop, std::make_shared<RH1D> hist); 257/// {; 258/// auto canvas = RCanvas::Create(""Canvas title"");; 259/// canvas->Draw(hist)->SetLineColor(RColor::kBlue);; 260/// canvas->Show();; 261/// while (run_loop) {; 262/// pHist->Fill(1);; 263/// canvas->Modified();; 264/// canvas->Update();; 265/// canvas->Run(0.1); // process canvas events; 266/// }; 267///; 268/// canvas->Remove();; 269/// }; 270///; 271/// int main(); 272/// {; 273/// RAxisConfig xaxis(100, -10., 10.);; 274/// auto pHist = std::make_shared<RH1D>(xaxis);; 275/// bool run_loop = true;; 276///; 277/// std::thread thrd(draw_canvas, run_loop, pHist);; 278/// std::this_thread::sleep_for(std::chrono::seconds(100));; 279/// run_loop = false;; 280/// thrd.join();; 281/// retur",MatchSource.WIKI,doc/master/RCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html
Security,hash,hash,"::RCanvas::GetWindowUrl(bool remote); 160{; 161 if (fPainter); 162 return fPainter->GetWindowUrl(remote);; 163 ; 164 return """";; 165}; 166 ; 167 ; 168//////////////////////////////////////////////////////////////////////////; 169/// Hide all canvas displays; 170 ; 171void ROOT::Experimental::RCanvas::Hide(); 172{; 173 if (fPainter); 174 fPainter = nullptr;; 175}; 176 ; 177//////////////////////////////////////////////////////////////////////////; 178/// Create image file for the canvas; 179/// Supported SVG (extension .svg), JPEG (extension .jpg or .jpeg), PNG (extension .png) or JSON (extension .json); 180 ; 181bool ROOT::Experimental::RCanvas::SaveAs(const std::string &filename); 182{; 183 if (!fPainter); 184 fPainter = Internal::RVirtualCanvasPainter::Create(*this);; 185 ; 186 if (!fPainter); 187 return false;; 188 ; 189 int width = GetWidth();; 190 int height = GetHeight();; 191 ; 192 return fPainter->ProduceBatchOutput(filename, width > 1 ? width : 800, height > 1 ? height : 600);; 193}; 194 ; 195//////////////////////////////////////////////////////////////////////////; 196/// Return unique identifier for the canvas; 197/// Used in iPython display; 198 ; 199std::string ROOT::Experimental::RCanvas::GetUID() const; 200{; 201 const void *ptr = this;; 202 auto hash = TString::Hash(&ptr, sizeof(void*));; 203 TString fmt = TString::Format(""rcanv_%x"", hash);; 204 return fmt.Data();; 205}; 206 ; 207//////////////////////////////////////////////////////////////////////////; 208/// Create JSON data for the canvas; 209/// Can be used of offline display with JSROOT; 210 ; 211std::string ROOT::Experimental::RCanvas::CreateJSON(); 212{; 213 if (!fPainter); 214 fPainter = Internal::RVirtualCanvasPainter::Create(*this);; 215 ; 216 if (!fPainter); 217 return """";; 218 ; 219 return fPainter->ProduceJSON();; 220}; 221 ; 222//////////////////////////////////////////////////////////////////////////; 223/// Remove canvas from global canvas lists, will be destroyed once last shared_p",MatchSource.WIKI,doc/master/RCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html
Usability,clear,cleared,"; 210 ; 211std::string ROOT::Experimental::RCanvas::CreateJSON(); 212{; 213 if (!fPainter); 214 fPainter = Internal::RVirtualCanvasPainter::Create(*this);; 215 ; 216 if (!fPainter); 217 return """";; 218 ; 219 return fPainter->ProduceJSON();; 220}; 221 ; 222//////////////////////////////////////////////////////////////////////////; 223/// Remove canvas from global canvas lists, will be destroyed once last shared_ptr is disappear; 224 ; 225void ROOT::Experimental::RCanvas::Remove(); 226{; 227 std::lock_guard<std::mutex> grd(GetHeldCanvasesMutex());; 228 auto &held = GetHeldCanvases();; 229 auto indx = held.size();; 230 while (indx-- > 0) {; 231 if (held[indx].get() == this); 232 held.erase(held.begin() + indx);; 233 }; 234}; 235 ; 236//////////////////////////////////////////////////////////////////////////////////////////////; 237/// Set handle which will be cleared when connection is closed; 238 ; 239void ROOT::Experimental::RCanvas::ClearOnClose(const std::shared_ptr<void> &handle); 240{; 241 if (fPainter); 242 fPainter->SetClearOnClose(handle);; 243}; 244 ; 245//////////////////////////////////////////////////////////////////////////; 246/// Run canvas functionality for the given time (in seconds); 247/// Used to process canvas-related actions in the appropriate thread context.; 248/// Must be regularly called when canvas created and used in extra thread.; 249/// Time parameter specifies minimal execution time in seconds - if default value 0 is used,; 250/// just all pending actions will be performed.; 251/// When canvas is not yet displayed - just performs sleep for given time interval.; 252///; 253/// Example of usage:; 254///; 255/// ~~~ {.cpp}; 256/// void draw_canvas(bool &run_loop, std::make_shared<RH1D> hist); 257/// {; 258/// auto canvas = RCanvas::Create(""Canvas title"");; 259/// canvas->Draw(hist)->SetLineColor(RColor::kBlue);; 260/// canvas->Show();; 261/// while (run_loop) {; 262/// pHist->Fill(1);; 263/// canvas->Modified();; 264/// canvas->Update();; 2",MatchSource.WIKI,doc/master/RCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html
Availability,mask,mask,"RCanvas.hxx:27; ROOT::Experimental::RChangeAttrRequest::namesstd::vector< std::string > namesarray of attribute namesDefinition RCanvas.hxx:26; ROOT::Experimental::RChangeAttrRequest::idsstd::vector< std::string > idsarray of idsDefinition RCanvas.hxx:25; ROOT::Experimental::RChangeAttrRequest::~RChangeAttrRequest~RChangeAttrRequest() override=default; ROOT::Experimental::RChangeAttrRequest::NeedCanvasUpdatebool NeedCanvasUpdate() const overrideDefinition RCanvas.hxx:36; ROOT::Experimental::RChangeAttrRequest::RChangeAttrRequestRChangeAttrRequest()=default; ROOT::Experimental::RChangeAttrRequest::fNeedUpdatebool fNeedUpdate! is canvas update requiredDefinition RCanvas.hxx:29; ROOT::Experimental::RChangeAttrRequest::operator=RChangeAttrRequest & operator=(const RChangeAttrRequest &)=delete; ROOT::Experimental::RChangeAttrRequest::updatebool updateupdate canvas at the endDefinition RCanvas.hxx:28; ROOT::Experimental::RChangeAttrRequest::Processstd::unique_ptr< RDrawableReply > Process() overrideApply attributes changes to the drawable Return mask with actions which were really applied.Definition RCanvas.cxx:327; ROOT::Experimental::RChangeAttrRequest::RChangeAttrRequestRChangeAttrRequest(const RChangeAttrRequest &)=delete; ROOT::Experimental::RDrawableRequestBase class for requests which can be submitted from the clients.Definition RDrawableRequest.hxx:50; ROOT::Experimental::RDrawable::Version_tuint64_t Version_tDefinition RDrawable.hxx:123; ROOT::Experimental::RPadBaseBase class for graphic containers for RDrawable-s.Definition RPadBase.hxx:37; ROOT::Experimental::RPadBase::SetDrawableVersionvoid SetDrawableVersion(Version_t vers) overrideAssign drawable version - for pad itself and all primitives.Definition RPadBase.cxx:238; ROOT::Experimental::CanvasCallback_tstd::function< void(bool)> CanvasCallback_tDefinition RVirtualCanvasPainter.hxx:22; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecu",MatchSource.WIKI,doc/master/RCanvas_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html
Deployability,update,update,"**************************************************; 2 * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; 3 * All rights reserved. *; 4 * *; 5 * For the licensing terms see $ROOTSYS/LICENSE. *; 6 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 7 *************************************************************************/; 8 ; 9#ifndef ROOT7_RCanvas; 10#define ROOT7_RCanvas; 11 ; 12#include ""ROOT/RPadBase.hxx""; 13#include ""ROOT/RVirtualCanvasPainter.hxx""; 14#include ""ROOT/RDrawableRequest.hxx""; 15 ; 16#include <memory>; 17#include <string>; 18#include <vector>; 19#include <list>; 20 ; 21namespace ROOT {; 22namespace Experimental {; 23 ; 24class RChangeAttrRequest : public RDrawableRequest {; 25 std::vector<std::string> ids; ///< array of ids; 26 std::vector<std::string> names; ///< array of attribute names; 27 std::vector<std::unique_ptr<RAttrMap::Value_t>> values; ///< array of values; 28 bool update{true}; ///< update canvas at the end; 29 bool fNeedUpdate{false}; ///<! is canvas update required; 30 RChangeAttrRequest(const RChangeAttrRequest &) = delete;; 31 RChangeAttrRequest& operator=(const RChangeAttrRequest &) = delete;; 32public:; 33 RChangeAttrRequest() = default; // for I/O; 34 ~RChangeAttrRequest() override = default;; 35 std::unique_ptr<RDrawableReply> Process() override;; 36 bool NeedCanvasUpdate() const override { return fNeedUpdate; }; 37};; 38 ; 39/** \class RCanvas; 40\ingroup GpadROOT7; 41\brief A window's topmost `RPad`.; 42\author Axel Naumann <axel@cern.ch>; 43\date 2015-07-08; 44\warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; 45*/; 46 ; 47class RCanvas: public RPadBase {; 48friend class RPadBase; /// use for ID generation; 49friend class RCanvasPainter; /// used for primitives drawing; 50friend class RChangeAttrRequest; /// to apply attributes changes; 51private:; 52 /// Title of the canvas.; 53 std::string fTitle;; 54 ; 55 /// Width of the c",MatchSource.WIKI,doc/master/RCanvas_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html
Usability,clear,clear,"eight; 114 int GetHeight() const { return fHeight; }; 115 ; 116 /// Display the canvas.; 117 void Show(const std::string &where = """");; 118 ; 119 /// returns true if Show() method was called; 120 bool IsShown() const { return fShown; }; 121 ; 122 /// clear IsShown() flag; 123 void ClearShown() { fShown = false; }; 124 ; 125 /// Returns window name used to display canvas; 126 std::string GetWindowAddr() const;; 127 ; 128 /// Returns window URL which can be used for connection; 129 std::string GetWindowUrl(bool remote);; 130 ; 131 /// Hide all canvas displays; 132 void Hide();; 133 ; 134 /// Remove canvas from global canvas lists, will be destroyed when shared_ptr will be removed; 135 void Remove();; 136 ; 137 /// Insert panel into the canvas, canvas should be shown at this moment; 138 template <class PANEL>; 139 bool AddPanel(std::shared_ptr<PANEL> &panel); 140 {; 141 if (!fPainter) return false;; 142 return fPainter->AddPanel(panel->GetWindow());; 143 }; 144 ; 145 /// Get modify counter; 146 uint64_t GetModified() const { return fModified; }; 147 ; 148 // Set newest version to all primitives; 149 void Modified() { SetDrawableVersion(IncModified()); }; 150 ; 151 /// Set newest version to specified drawable; 152 void Modified(std::shared_ptr<RDrawable> drawable); 153 {; 154 // TODO: may be check that drawable belong to the canvas; 155 if (drawable); 156 drawable->SetDrawableVersion(IncModified());; 157 }; 158 ; 159 // Return if canvas was modified and not yet updated; 160 bool IsModified() const;; 161 ; 162 /// update drawing; 163 void Update(bool async = false, CanvasCallback_t callback = nullptr);; 164 ; 165 /// returns true if Update() method was called; 166 bool IsUpdated() const { return fUpdated; }; 167 ; 168 /// clear IsUpdated() flag; 169 void ClearUpdated() { fUpdated = false; }; 170 ; 171 /// Run canvas functionality for given time (in seconds); 172 void Run(double tm = 0.);; 173 ; 174 /// Save canvas in image file; 175 bool SaveAs(const std::string &filenam",MatchSource.WIKI,doc/master/RCanvas_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html
Energy Efficiency,green,green," rgb[2]); }; 81 ; 82 /** Set r/g/b components of color */; 83 void SetRGB(uint8_t r, uint8_t g, uint8_t b);; 84 ; 85 /** Set r/g/b/a components of color, a is integer between 0..255 */; 86 void SetRGBA(uint8_t r, uint8_t g, uint8_t b, uint8_t alpha);; 87 ; 88 /** Set alpha as value from range 0..255 */; 89 void SetAlpha(uint8_t alpha);; 90 ; 91 /** Set alpha as float value from range 0..1 */; 92 void SetAlphaFloat(float alpha); 93 {; 94 if (alpha <= 0.); 95 SetAlpha(0);; 96 else if (alpha >= 1.); 97 SetAlpha(255);; 98 else; 99 SetAlpha((uint8_t)(alpha * 255));; 100 }; 101 ; 102 /** Returns true if color alpha (opacity) was specified */; 103 bool HasAlpha() const { return IsRGBA(); }; 104 ; 105 /** Returns color as RGBA array, trying also convert color name into RGBA value */; 106 std::vector<uint8_t> AsRGBA() const;; 107 ; 108 /** Returns red color component 0..255 */; 109 uint8_t GetRed() const; 110 {; 111 auto rgba = AsRGBA();; 112 return rgba.size() > 2 ? rgba[0] : 0;; 113 }; 114 ; 115 /** Returns green color component 0..255 */; 116 uint8_t GetGreen() const; 117 {; 118 auto rgba = AsRGBA();; 119 return rgba.size() > 2 ? rgba[1] : 0;; 120 }; 121 ; 122 /** Returns blue color component 0..255 */; 123 uint8_t GetBlue() const; 124 {; 125 auto rgba = AsRGBA();; 126 return rgba.size() > 2 ? rgba[2] : 0;; 127 }; 128 ; 129 /** Returns color alpha (opacity) as uint8_t 0..255 */; 130 uint8_t GetAlpha() const; 131 {; 132 auto rgba = AsRGBA();; 133 return rgba.size() > 3 ? rgba[3] : 0xFF;; 134 }; 135 ; 136 /** Returns color alpha (opacity) as float from 0..1 */; 137 float GetAlphaFloat() const; 138 {; 139 return GetAlpha() / 255.;; 140 }; 141 ; 142 /** Set color as plain SVG name like ""white"" or ""lightblue"" */; 143 bool SetName(const std::string &name); 144 {; 145 fColor = name;; 146 if (!IsName()) {; 147 Clear();; 148 return false;; 149 }; 150 return true;; 151 }; 152 ; 153 void SetOrdinal(float val);; 154 float GetOrdinal() const;; 155 ; 156 /** Returns color as it stored ",MatchSource.WIKI,doc/master/RColor_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RColor_8hxx_source.html
Integrability,interface,interface,". ROOT: graf2d/gpadv7/inc/ROOT/RColor.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RColor.hxx. Go to the documentation of this file. 1/*************************************************************************; 2 * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; 3 * All rights reserved. *; 4 * *; 5 * For the licensing terms see $ROOTSYS/LICENSE. *; 6 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 7 *************************************************************************/; 8 ; 9#ifndef ROOT7_RColor; 10#define ROOT7_RColor; 11 ; 12#include <cstdint>; 13#include <vector>; 14#include <string>; 15#include <array>; 16#include <DllImport.h>; 17 ; 18namespace ROOT {; 19namespace Experimental {; 20 ; 21// TODO: see also imagemagick's C++ interface for RColor operations!; 22// https://www.imagemagick.org/api/magick++-classes.php; 23 ; 24/** \class RColor; 25\ingroup GpadROOT7; 26\brief The color class; 27\author Axel Naumann <axel@cern.ch>; 28\author Sergey Linev <S.Linev@gsi.de>; 29\date 2017-09-26; 30\warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; 31*/; 32 ; 33class RColor {; 34 ; 35 using RGB_t = std::array<uint8_t, 3>;; 36 ; 37private:; 38 ; 39 std::string fColor; ///< string representation of color; 40 ; 41 static std::string toHex(uint8_t v);; 42 ; 43 static std::vector<uint8_t> ConvertNameToRGB(const std::string &name);; 44 ; 45 bool SetRGBHex(const std::string &hex);; 46 bool SetAlphaHex(const std::string &hex);; 47 ; 48public:; 49 ; 50 RColor() = default;; 51 ; 52 /** Construct color with provided r,g,b values */; 53 RColor(uint8_t r, uint8_t g, uint8_t b) { SetRGB(r, g, b); }; 54 ; 55 /** Construct color with provided r,g,b and alpha values */; 56 RColor(uint8_t r, uint8_t g, uint8_t b, float alpha); 57 {; 58 SetRGBA(r, g, b, alpha);; 59 }; 60 ; 61 /** Construct color with provided RGB_t value */; 62 RColor(",MatchSource.WIKI,doc/master/RColor_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RColor_8hxx_source.html
Usability,clear,clear,"turn the Hue, Light, Saturation (HLS) definition of this RColor */; 163 bool GetHLS(float &hue, float &light, float &satur) const;; 164 ; 165 /** Set the Red Green and Blue (RGB) values from the Hue, Light, Saturation (HLS). */; 166 void SetHLS(float hue, float light, float satur);; 167 ; 168 std::string AsHex(bool with_alpha = false) const;; 169 std::string AsSVG() const;; 170 ; 171 void Clear(); 172 {; 173 fColor.clear();; 174 }; 175 ; 176 static const RColor &AutoColor();; 177 ; 178 R__DLLEXPORT static constexpr RGB_t kBlack{{0, 0, 0}};; 179 R__DLLEXPORT static constexpr RGB_t kGreen{{0, 0x80, 0}};; 180 R__DLLEXPORT static constexpr RGB_t kLime{{0, 0xFF, 0}};; 181 R__DLLEXPORT static constexpr RGB_t kAqua{{0, 0xFF, 0xFF}};; 182 R__DLLEXPORT static constexpr RGB_t kPurple{{0x80, 0, 0x80}};; 183 R__DLLEXPORT static constexpr RGB_t kGrey{{0x80, 0x80, 0x80}};; 184 R__DLLEXPORT static constexpr RGB_t kFuchsia{{0xFF, 0, 0xFF}};; 185 R__DLLEXPORT static constexpr RGB_t kNavy{{0, 0, 0x80}};; 186 R__DLLEXPORT static constexpr RGB_t kBlue{{0, 0, 0xff}};; 187 R__DLLEXPORT static constexpr RGB_t kTeal{{0, 0x80, 0x80}};; 188 R__DLLEXPORT static constexpr RGB_t kOlive{{0x80, 0x80, 0}};; 189 R__DLLEXPORT static constexpr RGB_t kSilver{{0xc0, 0xc0, 0xc0}};; 190 R__DLLEXPORT static constexpr RGB_t kMaroon{{0x80, 0, 0}};; 191 R__DLLEXPORT static constexpr RGB_t kRed{{0xff, 0, 0}};; 192 R__DLLEXPORT static constexpr RGB_t kYellow{{0xff, 0xff, 0}};; 193 R__DLLEXPORT static constexpr RGB_t kWhite{{0xff, 0xff, 0xff}};; 194 R__DLLEXPORT static constexpr float kTransparent{0.};; 195 R__DLLEXPORT static constexpr float kSemiTransparent{0.5};; 196 R__DLLEXPORT static constexpr float kOpaque{1.};; 197 ; 198 friend bool operator==(const RColor &lhs, const RColor &rhs); 199 {; 200 if (lhs.fColor == rhs.fColor) return true;; 201 ; 202 auto l = lhs.AsRGBA();; 203 auto r = rhs.AsRGBA();; 204 ; 205 return !l.empty() && (l == r);; 206 }; 207};; 208 ; 209} // namespace Experimental; 210} // namesp",MatchSource.WIKI,doc/master/RColor_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RColor_8hxx_source.html
Integrability,depend,dependency,". ROOT: core/foundation/inc/ROOT/RConfig.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RConfig.hxx File Reference. #include ""../RVersion.h""; #include ""RConfigure.h"". Include dependency graph for RConfig.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define _NAME1_(name)   name;  ; #define _NAME2_(name1, name2)   _NAME1_(name1)name2;  ; #define _NAME3_(name1, name2, name3)   _NAME2_(name1,name2)name3;  ; #define _QUOTE_(name)   ""name"";  ; #define _R__DEPRECATED_634(REASON)   _R__DEPRECATED_LATER(REASON);  ; #define _R__DEPRECATED_636(REASON)   _R__DEPRECATED_LATER(REASON);  ; #define _R__DEPRECATED_700(REASON)   _R__DEPRECATED_LATER(REASON);  ; #define _R__DEPRECATED_LATER(REASON);  ; #define _R__JOIN3_(F, X, Y)   _NAME3_(F,X,Y);  ; #define _R__JOIN_(X, Y)   _NAME2_(X,Y);  ; #define _R__UNIQUE_(X)   _R__JOIN_(X,__LINE__);  ; #define _R__UNIQUE_DICT_(X)   _R__JOIN3_(R__DICTIONARY_FILENAME,X,__LINE__);  ; #define _R_DEPRECATED_REMOVE_NOW(REASON)   __attribute__((REMOVE_THIS_NOW));  ; #define R__ALWAYS_INLINE   inline;  ; #define R__ALWAYS_SUGGEST_ALTERNATIVE(ALTERNATIVE)    _R__DEPRECATED_LATER(""There is a superior alternative: "" ALTERNATIVE);  ; #define R__ANSISTREAM   /* ANSI C++ Standard Library conformant */;  ; #define R__DEPRECATED(MAJOR, MINOR, REASON)    _R__JOIN3_(_R__DEPRECATED_,MAJOR,MINOR)(""will be removed in ROOT v"" #MAJOR ""."" #MINOR "": "" REASON);  ; #define R__HIDDEN;  ; #define R__INTENTIONALLY_UNINIT_BEGIN;  ; #define R__INTENTIONALLY_UNINIT_END;  ; #define R__likely(expr)   expr;  ; #define R__NEVER_INLINE   inline;  ; #define R__SIZEDDELETE;  ; #define R__SSTREAM   /* use sstream or strstream header */;  ; #define R__SUGGEST_ALTERNATIVE(ALTERNATIVE);  ; #define R__unlikely(expr)   ex",MatchSource.WIKI,doc/master/RConfig_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConfig_8hxx.html
Availability,error,error,"/; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_RConfig; 12#define ROOT_RConfig; 13 ; 14/*************************************************************************; 15 * *; 16 * RConfig *; 17 * *; 18 * Defines used by ROOT. *; 19 * *; 20 *************************************************************************/; 21 ; 22#include ""../RVersion.h""; 23#include ""RConfigure.h""; 24 ; 25 ; 26/*---- new C++ features ------------------------------------------------------*/; 27 ; 28#if defined __has_feature; 29# if __has_feature(modules); 30# define R__CXXMODULES; 31# endif; 32#endif; 33 ; 34#define R__USE_SHADOW_CLASS; 35 ; 36/* Now required, thus defined by default for backward compatibility */; 37#define R__ANSISTREAM /* ANSI C++ Standard Library conformant */; 38#define R__SSTREAM /* use sstream or strstream header */; 39 ; 40#if defined(_MSC_VER); 41# if (_MSC_VER < 1910); 42# error ""ROOT requires Visual Studio 2017 or higher.""; 43# else; 44# define R__NULLPTR; 45# endif; 46#else; 47#if defined(__cplusplus) && (__cplusplus < 201703L); 48#error ""ROOT requires support for C++17 or higher.""; 49# if defined(__GNUC__) || defined(__clang__); 50#error ""Pass `-std=c++17` as compiler argument.""; 51# endif; 52# endif; 53#endif; 54 ; 55/*---- machines --------------------------------------------------------------*/; 56 ; 57#ifdef __hpux; 58 /* R__HPUX10 or R__HPUX11 is determined in the Makefile */; 59# define R__HPUX; 60# define R__UNIX; 61# define ANSICPP; 62# ifdef __LP64__; 63# define R__B64; 64# endif; 65# ifdef R__HPUX10; 66# define NEED_SNPRINTF; 67# endif; 68#endif; 69 ; 70#ifdef _AIX; 71# define R__AIX; 72# define R__UNIX; 73# define",MatchSource.WIKI,doc/master/RConfig_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html
Performance,perform,performance-critical,"UNINIT_END \; 539 R__DO_PRAGMA(GCC diagnostic pop); 540#else; 541# define R__INTENTIONALLY_UNINIT_BEGIN; 542# define R__INTENTIONALLY_UNINIT_END; 543 ; 544#endif; 545 ; 546#ifdef R__HAS_ATTRIBUTE_ALWAYS_INLINE; 547#define R__ALWAYS_INLINE inline __attribute__((always_inline)); 548#else; 549#if defined(_MSC_VER); 550#define R__ALWAYS_INLINE __forceinline; 551#else; 552#define R__ALWAYS_INLINE inline; 553#endif; 554#endif; 555 ; 556// See also https://nemequ.github.io/hedley/api-reference.html#HEDLEY_NEVER_INLINE; 557// for other platforms.; 558#ifdef R__HAS_ATTRIBUTE_NOINLINE; 559#define R__NEVER_INLINE inline __attribute__((noinline)); 560#else; 561#if defined(_MSC_VER); 562#define R__NEVER_INLINE inline __declspec(noinline); 563#else; 564#define R__NEVER_INLINE inline; 565#endif; 566#endif; 567 ; 568/*---- unlikely / likely expressions -----------------------------------------*/; 569// These are meant to use in cases like:; 570// if (R__unlikely(expression)) { ... }; 571// in performance-critical sections. R__unlikely / R__likely provide hints to; 572// the compiler code generation to heavily optimize one side of a conditional,; 573// causing the other branch to have a heavy performance cost.; 574//; 575// It is best to use this for conditionals that test for rare error cases or; 576// backward compatibility code.; 577 ; 578#if (__GNUC__ >= 3) || defined(__INTEL_COMPILER); 579#if !defined(R__unlikely); 580 #define R__unlikely(expr) __builtin_expect(!!(expr), 0); 581#endif; 582#if !defined(R__likely); 583 #define R__likely(expr) __builtin_expect(!!(expr), 1); 584#endif; 585#else; 586 #define R__unlikely(expr) expr; 587 #define R__likely(expr) expr; 588#endif; 589 ; 590// Setting this define causes ROOT to keep statistics about memory buffer allocation; 591// time within the TTree. Given that this is a ""hot-path"", we provide a mechanism; 592// for enabling / disabling this at compile time by developers; default is disabled.; 593#ifndef R__TRACK_BASKET_ALLOC_TIME; 594/",MatchSource.WIKI,doc/master/RConfig_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html
Safety,avoid,avoid,"as R__DEPRECATED(6,04, ""Not threadsafe; use TFoo::Bar()."") */; 504#define R__DEPRECATED(MAJOR, MINOR, REASON) \; 505 _R__JOIN3_(_R__DEPRECATED_,MAJOR,MINOR)(""will be removed in ROOT v"" #MAJOR ""."" #MINOR "": "" REASON); 506 ; 507/* Mechanisms to advise users to avoid legacy functions and classes that will not be removed */; 508#if defined R__SUGGEST_NEW_INTERFACE; 509# define R__SUGGEST_ALTERNATIVE(ALTERNATIVE) \; 510 _R__DEPRECATED_LATER(""There is a superior alternative: "" ALTERNATIVE); 511#else; 512# define R__SUGGEST_ALTERNATIVE(ALTERNATIVE); 513#endif; 514 ; 515#define R__ALWAYS_SUGGEST_ALTERNATIVE(ALTERNATIVE) \; 516 _R__DEPRECATED_LATER(""There is a superior alternative: "" ALTERNATIVE); 517 ; 518 ; 519 ; 520/*---- misc ------------------------------------------------------------------*/; 521 ; 522#ifdef R__GNU; 523# define SafeDelete(p) { if (p) { delete p; p = nullptr; } }; 524#else; 525# define SafeDelete(p) { delete p; p = nullptr; }; 526#endif; 527 ; 528#ifdef __FAST_MATH__; 529#define R__FAST_MATH; 530#endif; 531 ; 532#if (__GNUC__ >= 7); 533#define R__DO_PRAGMA(x) _Pragma (#x); 534# define R__INTENTIONALLY_UNINIT_BEGIN \; 535 R__DO_PRAGMA(GCC diagnostic push) \; 536 R__DO_PRAGMA(GCC diagnostic ignored ""-Wmaybe-uninitialized"") \; 537 R__DO_PRAGMA(GCC diagnostic ignored ""-Wuninitialized""); 538# define R__INTENTIONALLY_UNINIT_END \; 539 R__DO_PRAGMA(GCC diagnostic pop); 540#else; 541# define R__INTENTIONALLY_UNINIT_BEGIN; 542# define R__INTENTIONALLY_UNINIT_END; 543 ; 544#endif; 545 ; 546#ifdef R__HAS_ATTRIBUTE_ALWAYS_INLINE; 547#define R__ALWAYS_INLINE inline __attribute__((always_inline)); 548#else; 549#if defined(_MSC_VER); 550#define R__ALWAYS_INLINE __forceinline; 551#else; 552#define R__ALWAYS_INLINE inline; 553#endif; 554#endif; 555 ; 556// See also https://nemequ.github.io/hedley/api-reference.html#HEDLEY_NEVER_INLINE; 557// for other platforms.; 558#ifdef R__HAS_ATTRIBUTE_NOINLINE; 559#define R__NEVER_INLINE inline __attribute__((noinline)); 560#else; 5",MatchSource.WIKI,doc/master/RConfig_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html
Testability,test,test,"INE; 547#define R__ALWAYS_INLINE inline __attribute__((always_inline)); 548#else; 549#if defined(_MSC_VER); 550#define R__ALWAYS_INLINE __forceinline; 551#else; 552#define R__ALWAYS_INLINE inline; 553#endif; 554#endif; 555 ; 556// See also https://nemequ.github.io/hedley/api-reference.html#HEDLEY_NEVER_INLINE; 557// for other platforms.; 558#ifdef R__HAS_ATTRIBUTE_NOINLINE; 559#define R__NEVER_INLINE inline __attribute__((noinline)); 560#else; 561#if defined(_MSC_VER); 562#define R__NEVER_INLINE inline __declspec(noinline); 563#else; 564#define R__NEVER_INLINE inline; 565#endif; 566#endif; 567 ; 568/*---- unlikely / likely expressions -----------------------------------------*/; 569// These are meant to use in cases like:; 570// if (R__unlikely(expression)) { ... }; 571// in performance-critical sections. R__unlikely / R__likely provide hints to; 572// the compiler code generation to heavily optimize one side of a conditional,; 573// causing the other branch to have a heavy performance cost.; 574//; 575// It is best to use this for conditionals that test for rare error cases or; 576// backward compatibility code.; 577 ; 578#if (__GNUC__ >= 3) || defined(__INTEL_COMPILER); 579#if !defined(R__unlikely); 580 #define R__unlikely(expr) __builtin_expect(!!(expr), 0); 581#endif; 582#if !defined(R__likely); 583 #define R__likely(expr) __builtin_expect(!!(expr), 1); 584#endif; 585#else; 586 #define R__unlikely(expr) expr; 587 #define R__likely(expr) expr; 588#endif; 589 ; 590// Setting this define causes ROOT to keep statistics about memory buffer allocation; 591// time within the TTree. Given that this is a ""hot-path"", we provide a mechanism; 592// for enabling / disabling this at compile time by developers; default is disabled.; 593#ifndef R__TRACK_BASKET_ALLOC_TIME; 594//#define R__TRACK_BASKET_ALLOC_TIME 1; 595#endif; 596 ; 597#endif. corefoundationincROOTRConfig.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RConfig_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html
Availability,error,error,"ommand.substr( 0, endsymbol ) );; 148 result[""source""] = membervalue;; 149 result[""target""] = membervalue;; 150 command = TSchemaRuleProcessor::Trim( command.substr( endsymbol+1 ) );; 151 }; 152 }; 153 }; 154 ; 155 //-----------------------------------------------------------------------; 156 // Process the input until there are no characters left; 157 //////////////////////////////////////////////////////////////////////////; 158 ; 159 while( !command.empty() ) {; 160 //--------------------------------------------------------------------; 161 // Find key token; 162 ///////////////////////////////////////////////////////////////////////; 163 ; 164 std::string::size_type pos = command.find( '=' );; 165 ; 166 //--------------------------------------------------------------------; 167 // No equality sign found - no keys left; 168 ///////////////////////////////////////////////////////////////////////; 169 ; 170 if( pos == std::string::npos ) {; 171 error_string = ""Parsing error, no key found!"";; 172 return false;; 173 }; 174 ; 175 //--------------------------------------------------------------------; 176 // The key was found - process the arguments; 177 ///////////////////////////////////////////////////////////////////////; 178 ; 179 std::string key = TSchemaRuleProcessor::Trim( command.substr( 0, pos ) );; 180 command = TSchemaRuleProcessor::Trim( command.substr( pos+1 ) );; 181 ; 182 //--------------------------------------------------------------------; 183 // Nothing left to be processed; 184 ///////////////////////////////////////////////////////////////////////; 185 ; 186 if( command.size() < 1 ) {; 187 error_string = ""Parsing error, wrond or no value specified for key: "" + key;; 188 return false;; 189 }; 190 ; 191 Bool_t hasquote = command[0] == '""';; 192 ; 193 //--------------------------------------------------------------------; 194 // Processing code tag: ""{ code }""; 195 ///////////////////////////////////////////////////////////////////////; 196 ; 197 if(",MatchSource.WIKI,doc/master/RConversionRuleParser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html
Integrability,message,message,"; 661 //-----------------------------------------------------------------------; 662 // Create the function name; 663 //////////////////////////////////////////////////////////////////////////; 664 ; 665 std::ostringstream func;; 666 func << ""read_"" << mappedName << ""_"" << index;; 667 rule[""funcname""] = func.str();; 668 ; 669 //-----------------------------------------------------------------------; 670 // Write the header; 671 //////////////////////////////////////////////////////////////////////////; 672 ; 673 output << "" static void "" << func.str();; 674 output << ""( char* target, TVirtualObject *oldObj )"" << std::endl;; 675 output << "" {"" << std::endl;; 676 output << "" //--- Automatically generated variables ---"" << std::endl;; 677 ; 678 //-----------------------------------------------------------------------; 679 // Write the automatically generated variables; 680 //////////////////////////////////////////////////////////////////////////; 681 ; 682 std::list<std::pair<ROOT::Internal::TSchemaType,std::string> > source;; 683 std::list<std::string> target;; 684 TSchemaRuleProcessor::SplitDeclaration( rule[""source""], source );; 685 TSchemaRuleProcessor::SplitList( rule[""target""], target );; 686 ; 687 WriteAutoVariables( target, source, members, className, mappedName, output );; 688 output << "" "" << className << ""* newObj = ("" << className;; 689 output << ""*)target;"" << std::endl;; 690 output << "" // Supress warning message.\n"";; 691 output << "" "" << ""(void)oldObj;\n\n"";; 692 output << "" "" << ""(void)newObj;\n\n"";; 693 ; 694 //-----------------------------------------------------------------------; 695 // Write the user's code; 696 //////////////////////////////////////////////////////////////////////////; 697 ; 698 output << "" //--- User's code ---"" << std::endl;; 699 output << "" "" << rule[""code""] << std::endl;; 700 output << "" }"" << std::endl;; 701 }; 702 ; 703 ; 704 /////////////////////////////////////////////////////////////////////////////; 705 /// Write the co",MatchSource.WIKI,doc/master/RConversionRuleParser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html
Modifiability,variab,variables,"lgorithm>; 21#include <iostream>; 22#include <map>; 23#include <sstream>; 24#include <string>; 25#include <utility>; 26#include <vector>; 27 ; 28namespace {; 29 static void RemoveEscapeSequences(std::string& rawString); 30 {; 31 const std::vector<std::pair<std::string, std::string>> subPairs { {""\\\\"",""\\""},; 32 {""\\\"""",""\""""},; 33 {""\\\'"",""\'""}};; 34 size_t start_pos = 0;; 35 for (auto const & subPair : subPairs){; 36 start_pos = 0;; 37 auto from = subPair.first;; 38 auto to = subPair.second;; 39 while((start_pos = rawString.find(from, start_pos)) != std::string::npos) {; 40 rawString.replace(start_pos, from.length(), to);; 41 start_pos += to.length();; 42 }; 43 }; 44 }; 45}; 46 ; 47namespace ROOT; 48{; 49 using namespace Internal;; 50 ; 51 typedef std::list<std::pair<ROOT::Internal::TSchemaType,std::string> > SourceTypeList_t;; 52 ; 53 //--------------------------------------------------------------------------; 54 // Allocate global variables; 55 /////////////////////////////////////////////////////////////////////////////; 56 ; 57 SchemaRuleClassMap_t gReadRules;; 58 SchemaRuleClassMap_t gReadRawRules;; 59 ; 60 static Bool_t ValidateRule( const std::map<std::string, std::string>& rule, std::string &error_string );; 61 ; 62 static std::string::size_type FindEndSymbol(std::string &command); 63 {; 64 // Find the end of a symbol.; 65 ; 66 if (command.length() == 0) return std::string::npos;; 67 std::string::size_type cursor;; 68 unsigned int level = 0;; 69 for (cursor = 0 ; cursor < command.length(); ++cursor); 70 {; 71 switch( command[cursor] ) {; 72 case ' ':; 73 case '\t':; 74 case '\r':; 75 case '=': if (level==0) {; 76 std::string::size_type sub_cursor = cursor;; 77 while( isspace(command[sub_cursor]) ) {; 78 ++sub_cursor;; 79 }; 80 if ( command[sub_cursor] == '=' ) {; 81 return sub_cursor;; 82 } else {; 83 return cursor;; 84 }; 85 } else {; 86 break;; 87 }; 88 case '<': ++level; break;; 89 case '>': if (level==0) { return std::string::npos; }; 90 --level; break;",MatchSource.WIKI,doc/master/RConversionRuleParser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html
Security,checksum,checksum,"ssing key: \"""" + key + ""\""\n"";; 237 error_string += ""Expected \"" at the end of the value."";; 238 return false;; 239 }; 240 result[key] = command.substr( 1, l-1 );; 241 } else {; 242 l = command.find(' ', 1);; 243 if (l == std::string::npos) l = command.size();; 244 result[key] = command.substr( 0, l );; 245 }; 246 }; 247 ; 248 //--------------------------------------------------------------------; 249 // Everything went ok; 250 ///////////////////////////////////////////////////////////////////////; 251 ; 252 if( l == command.size() ); 253 break;; 254 command = command.substr( l+1 );; 255 }; 256 std::map<std::string, std::string>::const_iterator it1;; 257 it1 = result.find(""oldtype"");; 258 if ( it1 != result.end() ) {; 259 std::map<std::string, std::string>::const_iterator it2;; 260 it2 = result.find(""source"");; 261 if ( it2 != result.end() ) {; 262 result[""source""] = it1->second + "" "" + it2->second;; 263 }; 264 }; 265 if ( result.find(""version"") == result.end() && result.find(""checksum"") == result.end() ) {; 266 result[""version""] = ""[1-]"";; 267 }; 268 ; 269 //------------------------------------------------------------------------; 270 // ""include"" tag. Replace "";"" with "","" for backwards compatibility with; 271 // ROOT5; 272 //////////////////////////////////////////////////////////////////////////; 273 ; 274 auto const includeKeyName = ""include"";; 275 auto includeTag = result.find(includeKeyName);; 276 if (includeTag != result.end()){; 277 auto & includeTagValue = includeTag->second;; 278 std::replace_if (includeTagValue.begin(),; 279 includeTagValue.end(),; 280 [](char c){ return c == ';';},; 281 ',');; 282 result[includeKeyName] = includeTagValue;; 283 }; 284 ; 285 return ValidateRule( result, error_string);; 286 }; 287 ; 288 /////////////////////////////////////////////////////////////////////////////; 289 /// Validate if the user specified rules are correct; 290 ; 291 static Bool_t ValidateRule( const std::map<std::string, std::string>& rule, std::string &error",MatchSource.WIKI,doc/master/RConversionRuleParser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html
Usability,clear,clear,"-------------------------------------------; 118 // If the first symbol does not end is not followed by equal then it; 119 // defaults to being the sourceClass.; 120 //////////////////////////////////////////////////////////////////////////; 121 ; 122 {; 123 std::string::size_type endsymbol = FindEndSymbol( command );; 124 if ( endsymbol == command.length() || command[endsymbol] == ' ' || command[endsymbol] == '\t' ) {; 125 ; 126// std::string::size_type space_pos = command.find( ' ' );; 127// std::string::size_type equal_pos = command.find( '=' );; 128// if ( space_pos < equal_pos) {; 129 std::string value = TSchemaRuleProcessor::Trim( command.substr( 0, endsymbol ) );; 130 result[""sourceClass""] = value;; 131 result[""targetClass""] = value;; 132 if (endsymbol < command.length()) {; 133 command = TSchemaRuleProcessor::Trim( command.substr( endsymbol+1 ) );; 134 } else {; 135 command.clear();; 136 }; 137 ; 138 //-----------------------------------------------------------------------; 139 // If the first symbol is the targetClass then the 2nd symbol can be; 140 // the source data member name.; 141 //-----------------------------------------------------------------------; 142// space_pos = command.find( ' ' );; 143// equal_pos = command.find( '=' );; 144// if ( space_pos < equal_pos ) {; 145 endsymbol = FindEndSymbol( command );; 146 if ( endsymbol == command.length() || command[endsymbol] == ' ' || command[endsymbol] == '\t' ) {; 147 std::string membervalue = TSchemaRuleProcessor::Trim( command.substr( 0, endsymbol ) );; 148 result[""source""] = membervalue;; 149 result[""target""] = membervalue;; 150 command = TSchemaRuleProcessor::Trim( command.substr( endsymbol+1 ) );; 151 }; 152 }; 153 }; 154 ; 155 //-----------------------------------------------------------------------; 156 // Process the input until there are no characters left; 157 //////////////////////////////////////////////////////////////////////////; 158 ; 159 while( !command.empty() ) {; 160 //---------------",MatchSource.WIKI,doc/master/RConversionRuleParser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html
Modifiability,variab,variables,"h""; 16 ; 17namespace ROOT; 18{; 19 //---------------------------------------------------------------------------; 20 // Global variables; 21 //---------------------------------------------------------------------------; 22 typedef std::map<std::string, std::string> SchemaRuleMap_t;; 23 typedef std::map<std::string, std::list<SchemaRuleMap_t> > SchemaRuleClassMap_t;; 24 R__EXTERN SchemaRuleClassMap_t gReadRules;; 25 R__EXTERN SchemaRuleClassMap_t gReadRawRules;; 26 ; 27 typedef std::map<std::string, ROOT::Internal::TSchemaType> MembersTypeMap_t;; 28 ; 29 //---------------------------------------------------------------------------; 30 // Create the data member name-type map; 31 //---------------------------------------------------------------------------; 32 // void CreateNameTypeMap( const clang::CXXRecordDecl &cl, MembersTypeMap_t& members );; 33 ; 34 //---------------------------------------------------------------------------; 35 // Check if given rule contains references to valid data members; 36 //---------------------------------------------------------------------------; 37 bool HasValidDataMembers( SchemaRuleMap_t& rule, MembersTypeMap_t& members,; 38 std::string& error_string);; 39 ; 40 //---------------------------------------------------------------------------; 41 // Write the conversion function for Read rule; 42 //---------------------------------------------------------------------------; 43 void WriteReadRuleFunc( SchemaRuleMap_t& rule",MatchSource.WIKI,doc/master/RConversionRuleParser_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8h_source.html
Availability,avail,available," comma) must be quoted.; 43~~~; 44 1997,Ford,E350,""Super, luxurious truck""; 45~~~; 46- Fields with double-quote characters must be quoted, and each of the embedded; 47double-quote characters must be represented by a pair of double-quote characters.; 48~~~; 49 1997,Ford,E350,""Super, """"luxurious"""" truck""; 50~~~; 51- Fields with embedded line breaks are not supported, even when quoted.; 52~~~; 53 1997,Ford,E350,""Go get one now; 54 they are going fast""; 55~~~; 56- Spaces are considered part of a field and are not ignored.; 57~~~; 58 1997, Ford , E350; 59 not same as; 60 1997,Ford,E350; 61 but same as; 62 1997, ""Ford"" , E350; 63~~~; 64- If a header row is provided, it must contain column names for each of the fields.; 65~~~; 66 Year,Make,Model; 67 1997,Ford,E350; 68 2000,Mercury,Cougar; 69~~~; 70 ; 71The current implementation of RCsvDS reads the entire CSV file content into memory before; 72RDataFrame starts processing it. Therefore, before creating a CSV RDataFrame, it is; 73important to check both how much memory is available and the size of the CSV file.; 74 ; 75RCsvDS can handle empty cells and also allows the usage of the special keywords ""NaN"" and ""nan"" to; 76indicate `nan` values. If the column is of type double, these cells are stored internally as `nan`.; 77Empty cells and explicit `nan`-s inside columns of type Long64_t/bool are stored as zeros.; 78*/; 79// clang-format on; 80 ; 81#include <ROOT/TSeq.hxx>; 82#include <ROOT/RCsvDS.hxx>; 83#include <ROOT/RRawFile.hxx>; 84#include <TError.h>; 85 ; 86#include <algorithm>; 87#include <memory>; 88#include <sstream>; 89#include <string>; 90 ; 91namespace ROOT {; 92 ; 93namespace RDF {; 94 ; 95std::string RCsvDS::AsString(); 96{; 97 return ""CSV data source"";; 98}; 99 ; 100// Regular expressions for type inference; 101const TRegexp RCsvDS::fgIntRegex(""^[-+]?[0-9]+$"");; 102const TRegexp RCsvDS::fgDoubleRegex1(""^[-+]?[0-9]+\\.[0-9]*$"");; 103const TRegexp RCsvDS::fgDoubleRegex2(""^[-+]?[0-9]*\\.[0-9]+$"");; 104const TRegexp ",MatchSource.WIKI,doc/master/RCsvDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html
Integrability,message,messages,"es.resize(nColumns, std::vector<Long64_t>(fNSlots));; 549 fStringEvtValues.resize(nColumns, std::vector<std::string>(fNSlots));; 550 fBoolEvtValues.resize(nColumns, std::deque<bool>(fNSlots));; 551}; 552 ; 553std::string RCsvDS::GetLabel(); 554{; 555 return ""RCsv"";; 556}; 557 ; 558RDataFrame FromCSV(std::string_view fileName, bool readHeaders, char delimiter, Long64_t linesChunkSize,; 559 std::unordered_map<std::string, char> &&colTypes); 560{; 561 ROOT::RDataFrame rdf(; 562 std::make_unique<RCsvDS>(fileName, readHeaders, delimiter, linesChunkSize, std::move(colTypes)));; 563 return rdf;; 564}; 565 ; 566} // ns RDF; 567 ; 568} // ns ROOT; RCsvDS.hxx; RRawFile.hxx; b#define b(i)Definition RSha256.hxx:100; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32Vi",MatchSource.WIKI,doc/master/RCsvDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html
Performance,load,loaded,"ng::npos) {; 215 std::string msg = ""Type alias '"" + std::string(1, col.second) + ""' is not supported.\n"";; 216 msg += ""Supported type aliases are 'O' for boolean, 'D' for double, 'L' for Long64_t, 'T' for std::string."";; 217 throw std::runtime_error(msg);; 218 }; 219 }; 220}; 221 ; 222void RCsvDS::InferColTypes(std::vector<std::string> &columns); 223{; 224 const auto second_line = fCsvFile->GetFilePos();; 225 ; 226 for (auto i = 0u; i < columns.size(); ++i) {; 227 const auto userSpecifiedType = fColTypes.find(fHeaders[i]);; 228 if (userSpecifiedType != fColTypes.end()) {; 229 fColTypesList.push_back(userSpecifiedType->second);; 230 continue;; 231 }; 232 ; 233 // read <=10 extra lines until a non-empty cell on this column is found, so that type is determined; 234 for (auto extraRowsRead = 0u; extraRowsRead < 10u && columns[i] == ""nan""; ++extraRowsRead) {; 235 std::string line;; 236 if (!fCsvFile->Readln(line)); 237 break; // EOF; 238 const auto temp_columns = ParseColumns(line);; 239 if (temp_columns[i] != ""nan""); 240 columns[i] = temp_columns[i]; // will break the loop in the next iteration; 241 }; 242 // reset the reading from the second line, because the first line is already loaded in `columns`; 243 fCsvFile->Seek(second_line);; 244 ; 245 if (columns[i] == ""nan"") {; 246 // could not find a non-empty value, default to double; 247 fColTypes[fHeaders[i]] = 'D';; 248 fColTypesList.push_back('D');; 249 } else {; 250 InferType(columns[i], i);; 251 }; 252 }; 253}; 254 ; 255void RCsvDS::InferType(const std::string &col, unsigned int idxCol); 256{; 257 ColType_t type;; 258 int dummy;; 259 ; 260 if (fgIntRegex.Index(col, &dummy) != -1) {; 261 type = 'L'; // Long64_t; 262 } else if (fgDoubleRegex1.Index(col, &dummy) != -1 || fgDoubleRegex2.Index(col, &dummy) != -1 ||; 263 fgDoubleRegex3.Index(col, &dummy) != -1) {; 264 type = 'D'; // double; 265 } else if (fgTrueRegex.Index(col, &dummy) != -1 || fgFalseRegex.Index(col, &dummy) != -1) {; 266 type = 'O'; // bool; 267 } else {",MatchSource.WIKI,doc/master/RCsvDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html
Security,access,access,"tangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; gDebugInt_t gDebugDefinition TROOT.cxx:597; TSeq.hxx; ROOT::Internal::RRawFileThe RRawFile provides read-only access to local and remote files.Definition RRawFile.hxx:43; ROOT::RDF::RCsvDS::GetTypeNamestd::string GetTypeName(std::string_view colName) const finalType of a column as a string, e.g.Definition RCsvDS.cxx:495; ROOT::RDF::RCsvDS::FillRecordvoid FillRecord(const std::string &, Record_t &)Definition RCsvDS.cxx:120; ROOT::RDF::RCsvDS::GetTypeColType_t GetType(std::string_view colName) constDefinition RCsvDS.cxx:484; ROOT::RDF::RCsvDS::fDoubleEvtValuesstd::vector< std::vector< double > > fDoubleEvtValuesDefinition RCsvDS.hxx:59; ROOT::RDF::RCsvDS::InferTypevoid InferType(const std::string &, unsigned int)Definition RCsvDS.cxx:255; ROOT::RDF::RCsvDS::fDataPosstd::uint64_t fDataPosDefinition RCsvDS.hxx:45; ROOT::RDF::RCsvDS::fgColTypeMapstatic const std::unordered_map< ColType_t, std::string > fgColTypeMapDefinition RCsvDS.hxx:40; ROOT::RDF::RCsvDS::ParseValuesize_t ParseValue(const std::string &, std::vector< std::string > &, size_t)Definition RCsvDS.cxx:287; ROOT::RDF::RCsv",MatchSource.WIKI,doc/master/RCsvDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html
Testability,assert,assert,"d::runtime_error(msg);; 490 }; 491 ; 492 return fColTypes.at(colName.data());; 493}; 494 ; 495std::string RCsvDS::GetTypeName(std::string_view colName) const; 496{; 497 return fgColTypeMap.at(GetType(colName));; 498}; 499 ; 500bool RCsvDS::HasColumn(std::string_view colName) const; 501{; 502 return fHeaders.end() != std::find(fHeaders.begin(), fHeaders.end(), colName);; 503}; 504 ; 505bool RCsvDS::SetEntry(unsigned int slot, ULong64_t entry); 506{; 507 // Here we need to normalise the entry to the number of lines we already processed.; 508 const auto offset = (fEntryRangesRequested - 1) * fLinesChunkSize;; 509 const auto recordPos = entry - offset;; 510 int colIndex = 0;; 511 for (auto &colType : fColTypesList) {; 512 auto dataPtr = fRecords[recordPos][colIndex];; 513 switch (colType) {; 514 case 'D': {; 515 fDoubleEvtValues[colIndex][slot] = *static_cast<double *>(dataPtr);; 516 break;; 517 }; 518 case 'L': {; 519 fLong64EvtValues[colIndex][slot] = *static_cast<Long64_t *>(dataPtr);; 520 break;; 521 }; 522 case 'O': {; 523 fBoolEvtValues[colIndex][slot] = *static_cast<bool *>(dataPtr);; 524 break;; 525 }; 526 case 'T': {; 527 fStringEvtValues[colIndex][slot] = *static_cast<std::string *>(dataPtr);; 528 break;; 529 }; 530 }; 531 colIndex++;; 532 }; 533 return true;; 534}; 535 ; 536void RCsvDS::SetNSlots(unsigned int nSlots); 537{; 538 assert(0U == fNSlots && ""Setting the number of slots even if the number of slots is different from zero."");; 539 ; 540 fNSlots = nSlots;; 541 ; 542 const auto nColumns = fHeaders.size();; 543 // Initialize the entire set of addresses; 544 fColAddresses.resize(nColumns, std::vector<void *>(fNSlots, nullptr));; 545 ; 546 // Initialize the per event data holders; 547 fDoubleEvtValues.resize(nColumns, std::vector<double>(fNSlots));; 548 fLong64EvtValues.resize(nColumns, std::vector<Long64_t>(fNSlots));; 549 fStringEvtValues.resize(nColumns, std::vector<std::string>(fNSlots));; 550 fBoolEvtValues.resize(nColumns, std::deque<bool>(fNSlots));;",MatchSource.WIKI,doc/master/RCsvDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html
Usability,clear,clear,"e user is trying to set types only of existing columns; 363 ValidateColTypes(columns);; 364 ; 365 // Infer types of columns with first record; 366 InferColTypes(columns);; 367 ; 368 // rewind; 369 fCsvFile->Seek(fDataPos);; 370 } else {; 371 std::string msg = ""Could not infer column types of CSV file "";; 372 msg += fileName;; 373 throw std::runtime_error(msg);; 374 }; 375}; 376 ; 377void RCsvDS::FreeRecords(); 378{; 379 for (auto &record : fRecords) {; 380 for (size_t i = 0; i < record.size(); ++i) {; 381 void *p = record[i];; 382 const auto colType = fColTypes[fHeaders[i]];; 383 switch (colType) {; 384 case 'D': {; 385 delete static_cast<double *>(p);; 386 break;; 387 }; 388 case 'L': {; 389 delete static_cast<Long64_t *>(p);; 390 break;; 391 }; 392 case 'O': {; 393 delete static_cast<bool *>(p);; 394 break;; 395 }; 396 case 'T': {; 397 delete static_cast<std::string *>(p);; 398 break;; 399 }; 400 }; 401 }; 402 }; 403 fRecords.clear();; 404}; 405 ; 406////////////////////////////////////////////////////////////////////////; 407/// Destructor.; 408RCsvDS::~RCsvDS(); 409{; 410 FreeRecords();; 411}; 412 ; 413void RCsvDS::Finalize(); 414{; 415 fCsvFile->Seek(fDataPos);; 416 fProcessedLines = 0ULL;; 417 fEntryRangesRequested = 0ULL;; 418 FreeRecords();; 419}; 420 ; 421const std::vector<std::string> &RCsvDS::GetColumnNames() const; 422{; 423 return fHeaders;; 424}; 425 ; 426std::vector<std::pair<ULong64_t, ULong64_t>> RCsvDS::GetEntryRanges(); 427{; 428 // Read records and store them in memory; 429 auto linesToRead = fLinesChunkSize;; 430 FreeRecords();; 431 ; 432 std::string line;; 433 while ((-1LL == fLinesChunkSize || 0 != linesToRead) && fCsvFile->Readln(line)) {; 434 if (line.empty()) continue; // skip empty lines; 435 fRecords.emplace_back();; 436 FillRecord(line, fRecords.back());; 437 --linesToRead;; 438 }; 439 ; 440 if (!fColContainingEmpty.empty()) {; 441 std::string msg = """";; 442 for (const auto &col : fColContainingEmpty) {; 443 const auto colT = GetTypeName(",MatchSource.WIKI,doc/master/RCsvDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html
Availability,avail,available,"10 ; 11#include ""ROOT/InternalTreeUtils.hxx""; 12#include ""ROOT/RDataFrame.hxx""; 13#include ""ROOT/RDataSource.hxx""; 14#include ""ROOT/RDF/RDatasetSpec.hxx""; 15#include ""ROOT/RDF/RInterface.hxx""; 16#include ""ROOT/RDF/RLoopManager.hxx""; 17#include ""ROOT/RDF/Utils.hxx""; 18#include <string_view>; 19#include ""TChain.h""; 20#include ""TDirectory.h""; 21#include ""RtypesCore.h"" // for ULong64_t; 22#include ""TTree.h""; 23 ; 24#include <fstream> // std::ifstream; 25#include <nlohmann/json.hpp> // nlohmann::json::parse; 26#include <memory> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Deployability,toggle,toggleInherit,"ecial helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); 78 - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); 79 - [User-defined custom actions](\ref generic-actions); 80 - [Dataset joins with friend trees](\ref friends); 81 - [Reading data formats other than ROOT trees](\ref other-file-formats); 82 - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); 83 - [Visualizing the computation graph](\ref representgraph); 84 - [Activating RDataFrame execution logs](\ref rdf-logging); 85 - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); 86 - [Adding a progress bar](\ref progressbar); 87 - [Working with missing values in the dataset](\ref missing-values); 88- [Efficient analysis in Python](\ref python); 89- <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>; 90 ; 91\anchor cheatsheet; 92## Cheat sheet; 93These are the operations which can be performed with RDataFrame.; 94 ; 95### Transformations; 96Transformations are a way to manipulate the data.; 97 ; 98| **Transformation** | **Description** |; 99|------------------|--------------------|; 100| Alias() | Introduce an alias for a particular column name. |; 101| DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; 102| Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; 103| DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; 104| DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Energy Efficiency,efficient,efficient,"first 10 entries *that pass the; 583preceding filter*.; 584 ; 585Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; 586processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations.; 587 ; 588\anchor custom-columns; 589### Custom columns; 590Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; 591(function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; 592strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be; 593assigned to the temporary column.; 594 ; 595A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; 596transformations/actions.; 597 ; 598Use cases include:; 599- caching the results of complex calculations for easy and efficient multiple access; 600- extraction of quantities of interest from complex objects; 601- branch aliasing, i.e. changing the name of a branch; 602 ; 603An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree.; 604 ; 605It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; 606`Define(name, expression)`. For example this invocation; 607 ; 608~~~{.cpp}; 609df.Define(""pt"", ""sqrt(px*px + py*py)"");; 610~~~; 611 ; 612will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; 613builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; 614from the names of the variables specified by the user.; 615 ; 616#### Custom columns as function of slot and entry number; 617 ; 618It is possible to create custom columns also as a function of the processing slot and en",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Integrability,interface,interface,"*******; 4 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include ""ROOT/InternalTreeUtils.hxx""; 12#include ""ROOT/RDataFrame.hxx""; 13#include ""ROOT/RDataSource.hxx""; 14#include ""ROOT/RDF/RDatasetSpec.hxx""; 15#include ""ROOT/RDF/RInterface.hxx""; 16#include ""ROOT/RDF/RLoopManager.hxx""; 17#include ""ROOT/RDF/Utils.hxx""; 18#include <string_view>; 19#include ""TChain.h""; 20#include ""TDirectory.h""; 21#include ""RtypesCore.h"" // for ULong64_t; 22#include ""TTree.h""; 23 ; 24#include <fstream> // std::ifstream; 25#include <nlohmann/json.hpp> // nlohmann::json::parse; 26#include <memory> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementat",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Modifiability,flexible,flexible,") | Return the number of event loops run by this RDataFrame instance so far. |; 168| GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; 169| SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |; 170 ; 171\anchor introduction; 172## Introduction; 173Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; 174takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; 175RDataFrame provides methods to perform most common operations required by ROOT analyses;; 176at the same time, users can just as easily specify custom code that will be executed in the event loop.; 177 ; 178RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:; 179 ; 1801. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well.; 181 ; 1822. Transform the dataframe by:; 183 ; 184 - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset.; 185 ; 186 - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every ",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Performance,multi-thread,multi-threading,"10 ; 11#include ""ROOT/InternalTreeUtils.hxx""; 12#include ""ROOT/RDataFrame.hxx""; 13#include ""ROOT/RDataSource.hxx""; 14#include ""ROOT/RDF/RDatasetSpec.hxx""; 15#include ""ROOT/RDF/RInterface.hxx""; 16#include ""ROOT/RDF/RLoopManager.hxx""; 17#include ""ROOT/RDF/Utils.hxx""; 18#include <string_view>; 19#include ""TChain.h""; 20#include ""TDirectory.h""; 21#include ""RtypesCore.h"" // for ULong64_t; 22#include ""TTree.h""; 23 ; 24#include <fstream> // std::ifstream; 25#include <nlohmann/json.hpp> // nlohmann::json::parse; 26#include <memory> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Safety,safe,safe,"> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python.; 61 ; 62## Table of Contents; 63- [Cheat sheet](\ref cheatsheet); 64- [Introduction](\ref introduction); 65- [Crash course](\ref crash-course); 66- [Working with collections](\ref collections); 67- [Transformations: manipulating data](\ref transformations); 68- [Actions: getting results](\ref actions); 69- [Distributed execution in Python](\ref distrdf); 70- [Perf",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Security,access,access,"> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python.; 61 ; 62## Table of Contents; 63- [Cheat sheet](\ref cheatsheet); 64- [Introduction](\ref introduction); 65- [Crash course](\ref crash-course); 66- [Working with collections](\ref collections); 67- [Transformations: manipulating data](\ref transformations); 68- [Actions: getting results](\ref actions); 69- [Distributed execution in Python](\ref distrdf); 70- [Perf",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Testability,log,logs,"the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python.; 61 ; 62## Table of Contents; 63- [Cheat sheet](\ref cheatsheet); 64- [Introduction](\ref introduction); 65- [Crash course](\ref crash-course); 66- [Working with collections](\ref collections); 67- [Transformations: manipulating data](\ref transformations); 68- [Actions: getting results](\ref actions); 69- [Distributed execution in Python](\ref distrdf); 70- [Performance tips and parallel execution](\ref parallel-execution); 71- [More features](\ref more-features); 72 - [Systematic variations](\ref systematics); 73 - [RDataFrame objects as function arguments and return values](\ref rnode); 74 - [Storing RDataFrame objects in collections](\ref RDFCollections); 75 - [Executing callbacks every N events](\ref callbacks); 76 - [Default column lists](\ref default-branches); 77 - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); 78 - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); 79 - [User-defined custom actions](\ref generic-actions); 80 - [Dataset joins with friend trees](\ref friends); 81 - [Reading data formats other than ROOT trees](\ref other-file-formats); 82 - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); 83 - [Visualizing the computation graph](\ref representgraph); 84 - [Activating RDataFrame execution logs](\ref rdf-logging); 85 - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); 86 - [Adding a progress bar](\ref progressbar); 87 - [Working with missing values in the dataset](\ref missing-values); 88- [Efficient analysis in Python](\ref python); 89- <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>; 90 ; 91\anchor cheatsheet; 92## Cheat sheet; ",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Usability,guid,guide,"ROOT/RDF/RDatasetSpec.hxx""; 15#include ""ROOT/RDF/RInterface.hxx""; 16#include ""ROOT/RDF/RLoopManager.hxx""; 17#include ""ROOT/RDF/Utils.hxx""; 18#include <string_view>; 19#include ""TChain.h""; 20#include ""TDirectory.h""; 21#include ""RtypesCore.h"" // for ULong64_t; 22#include ""TTree.h""; 23 ; 24#include <fstream> // std::ifstream; 25#include <nlohmann/json.hpp> // nlohmann::json::parse; 26#include <memory> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__d",MatchSource.WIKI,doc/master/RDataFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/dataframe/inc/ROOT/RDataFrame.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; RDataFrame.hxx File Reference. #include ""TROOT.h""; #include ""ROOT/RDF/RDatasetSpec.hxx""; #include ""ROOT/RDF/RInterface.hxx""; #include ""ROOT/RDF/Utils.hxx""; #include <string_view>; #include ""RtypesCore.h""; #include <initializer_list>; #include <memory>; #include <string>; #include <vector>. Include dependency graph for RDataFrame.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::RDF;  ; namespace  ROOT::RDF::Experimental;  . Functions; ROOT::RDataFrame ROOT::RDF::Experimental::FromSpec (const std::string &jsonFile);  Factory method to create an RDataFrame from a JSON specification file. ;  . treedataframeincROOTRDataFrame.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RDataFrame_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8hxx.html
Integrability,interface,interface,". ROOT: tree/dataframe/inc/ROOT/RDataFrame.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RDataFrame.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Danilo Piparo CERN 12/2016; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11/**; 12 \defgroup dataframe Dataframe; 13ROOT's RDataFrame allows to analyse data stored in TTrees with a high level interface.; 14*/; 15 ; 16#ifndef ROOT_RDATAFRAME; 17#define ROOT_RDATAFRAME; 18 ; 19#include ""TROOT.h"" // To allow ROOT::EnableImplicitMT without including ROOT.h; 20#include ""ROOT/RDF/RDatasetSpec.hxx""; 21#include ""ROOT/RDF/RInterface.hxx""; 22#include ""ROOT/RDF/Utils.hxx""; 23#include <string_view>; 24#include ""RtypesCore.h""; 25 ; 26#include <initializer_list>; 27#include <memory>; 28#include <string>; 29#include <vector>; 30 ; 31class TDirectory;; 32class TTree;; 33 ; 34namespace ROOT {; 35namespace RDF {; 36class RDataSource;; 37}; 38 ; 39namespace RDFDetail = ROOT::Detail::RDF;; 40 ; 41class RDataFrame : public ROOT::RDF::RInterface<RDFDetail::RLoopManager> {; 42public:; 43 using ColumnNames_t = ROOT::RDF::ColumnNames_t;; 44 RDataFrame(std::string_view treeName, std::string_view filenameglob, const ColumnNames_t &defaultColumns = {});; 45 RDataFrame(std::string_view treename, const std::vector<std::string> &filenames,; 46 const ColumnNames_t &defaultColumns = {});; 47 RDataFrame(std::string_view treename, std::initializer_list<std::string> filenames,; 48 const ColumnNames_t &defaultColumns = {}):; 49 RDataFrame(treename, std::vector<std::string>(filenames), defaultColumns) {}; 50 RDataFrame(std::string_view treeName, ::TDirector",MatchSource.WIKI,doc/master/RDataFrame_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDataFrame_8hxx_source.html
Availability,avail,available,"9 *************************************************************************/; 10 ; 11#ifndef ROOT_RDF_RDATASETSPEC; 12#define ROOT_RDF_RDATASETSPEC; 13 ; 14#include <limits>; 15#include <string>; 16#include <utility> // std::pair; 17#include <vector>; 18 ; 19#include <ROOT/RDF/RSample.hxx>; 20#include <ROOT/RFriendInfo.hxx>; 21#include <RtypesCore.h> // Long64_t; 22 ; 23namespace ROOT {; 24namespace Detail {; 25namespace RDF {; 26class RLoopManager;; 27}; 28} // namespace Detail; 29namespace RDF {; 30namespace Experimental {; 31 ; 32// clang-format off; 33/**; 34\class ROOT::RDF::Experimental::RDatasetSpec; 35\ingroup dataframe; 36\brief The dataset specification for RDataFrame.; 37 ; 38This class allows users to create the dataset specification for RDataFrame ; 39to which they add samples (using the RSample class object) with tree names and file names, ; 40and, optionally, the metadata information (using the RMetaData class objects). ; 41Adding global friend trees and/or setting the range of events to be processed; 42are also available.; 43 ; 44Note, there exists yet another method to build RDataFrame from the dataset information using the JSON file format: \ref FromSpec(const std::string &jsonFile) ""FromSpec()"". ; 45*/; 46 ; 47class RDatasetSpec {; 48 // clang-format on ; 49 friend class ::ROOT::Detail::RDF::RLoopManager; // for MoveOutSamples; 50 ; 51public:; 52 struct REntryRange {; 53 Long64_t fBegin{0};; 54 Long64_t fEnd{std::numeric_limits<Long64_t>::max()};; 55 REntryRange();; 56 REntryRange(Long64_t endEntry);; 57 REntryRange(Long64_t startEntry, Long64_t endEntry);; 58 };; 59 ; 60private:; 61 std::vector<RSample> fSamples; ///< List of samples; 62 ROOT::TreeUtils::RFriendInfo fFriendInfo; ///< List of friends; 63 REntryRange fEntryRange; ///< Start (inclusive) and end (exclusive) entry for the dataset processing; 64 ; 65 std::vector<RSample> MoveOutSamples();; 66 ; 67public:; 68 RDatasetSpec() = default;; 69 ; 70 const std::vector<std::string> GetSampleName",MatchSource.WIKI,doc/master/RDatasetSpec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDatasetSpec_8hxx_source.html
Availability,robust,robust,"ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::Foreachvoid Foreach(F func, unsigned nTimes, unsigned nChunks=0)Execute a function without arguments several times in parallel, dividing the execution in nChunks.Definition TThreadExecutor.hxx:146; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::RealTimeDouble_t RealTime()Stop the stopwatch (if it is running) and return the realtime (in seconds) passed between the start a...Definition TStopwatch.cxx:110; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::CpuTimeDouble_t CpuTime()Stop the stopwatch (if it is running) and return the cputime (in seconds) passed between the start an...Definition TStopwatch.cxx:125; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; int; ROOT::Detail::RDF::RDFLogChannelROOT::Experimental::RLogChannel & RDFLogChannel()Definition RDFUtils.cxx:37; ROOT::Experimental::Internal::GetChannelOrManagerRLogChannel & GetChannelOrManager()Definition RLogger.hxx:302; ROOT::Experimental::ELogLevel::kDebug@ kDebugDebug information; only useful for developers; can have added verbosity up to 255-kDebug.; ROOT::Experimental::ELogLevel::kError@ kErrorAn error.; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RD",MatchSource.WIKI,doc/master/RDFHelpers_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html
Integrability,interface,interface,"lpers.cxx:145; ROOT::RDF::Experimental::ProgressHelper::fLastPrintTimestd::chrono::time_point< std::chrono::system_clock > fLastPrintTimeDefinition RDFHelpers.hxx:330; ROOT::RDF::Experimental::ProgressHelper::fBeginTimestd::chrono::time_point< std::chrono::system_clock > fBeginTimeDefinition RDFHelpers.hxx:329; ROOT::RDF::Experimental::ProgressHelper::PrintStatsFinalvoid PrintStatsFinal(std::ostream &stream, std::chrono::seconds totalElapsedSeconds) constDefinition RDFHelpers.cxx:273; ROOT::RDF::Experimental::ProgressHelper::fBarWidthunsigned int fBarWidthDefinition RDFHelpers.hxx:343; ROOT::RDF::Experimental::ProgressHelper::fEventsPerSecondStatisticsIndexstd::size_t fEventsPerSecondStatisticsIndexDefinition RDFHelpers.hxx:341; ROOT::RDF::Experimental::ProgressHelper::ComputeNEventsSoFarstd::size_t ComputeNEventsSoFar() constDefinition RDFHelpers.hxx:435; ROOT::RDF::RInterfaceBase::GetNFilesunsigned int GetNFiles()Definition RInterfaceBase.cxx:27; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::BookRResultPtr< typename std::decay_t< Helper >::Result_t > Book(Helper &&helper, const ColumnNames_t &columns={})Book execution of a custom action using a user-defined helper object.Definition RInterface.hxx:2984; ROOT::RDF::RResultHandleA type-erased version of RResultPtr and RResultMap.Definition RResultHandle.hxx:33; ROOT::RDF::RResultPtrSmart pointer for the return type of actions.Definition RResultPtr.hxx:119; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::",MatchSource.WIKI,doc/master/RDFHelpers_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html
Performance,load,load,"Compute a running mean of events/s.; 162double ProgressHelper::EvtPerSec() const; 163{; 164 if (fEventsPerSecondStatisticsIndex < fEventsPerSecondStatistics.size()); 165 return std::accumulate(fEventsPerSecondStatistics.begin(),; 166 fEventsPerSecondStatistics.begin() + fEventsPerSecondStatisticsIndex, 0.) /; 167 fEventsPerSecondStatisticsIndex;; 168 else; 169 return std::accumulate(fEventsPerSecondStatistics.begin(), fEventsPerSecondStatistics.end(), 0.) /; 170 fEventsPerSecondStatistics.size();; 171}; 172 ; 173/// Record current event counts and time stamp, populate evts/s statistics array.; 174std::pair<std::size_t, std::chrono::seconds> ProgressHelper::RecordEvtCountAndTime(); 175{; 176 using namespace std::chrono;; 177 ; 178 auto currentEventCount = fProcessedEvents.load();; 179 auto eventsPerTimeInterval = currentEventCount - fLastProcessedEvents;; 180 fLastProcessedEvents = currentEventCount;; 181 ; 182 auto oldPrintTime = fLastPrintTime;; 183 auto newPrintTime = system_clock::now();; 184 fLastPrintTime = newPrintTime;; 185 ; 186 duration<double> secondsCurrentInterval = newPrintTime - oldPrintTime;; 187 fEventsPerSecondStatistics[fEventsPerSecondStatisticsIndex++ % fEventsPerSecondStatistics.size()] =; 188 eventsPerTimeInterval / secondsCurrentInterval.count();; 189 ; 190 return {currentEventCount, duration_cast<seconds>(newPrintTime - fBeginTime)};; 191}; 192 ; 193namespace {; 194 ; 195struct RestoreStreamState {; 196 RestoreStreamState(std::ostream &stream) : fStream(stream), fFlags(stream.flags()), fFillChar(stream.fill()) {}; 197 ~RestoreStreamState(); 198 {; 199 fStream.flags(fFlags);; 200 fStream.fill(fFillChar);; 201 }; 202 ; 203 std::ostream &fStream;; 204 std::ios_base::fmtflags fFlags;; 205 std::ostream::char_type fFillChar;; 206};; 207 ; 208/// Format std::chrono::seconds as `1:30m`.; 209std::ostream &operator<<(std::ostream &stream, std::chrono::seconds elapsedSeconds); 210{; 211 RestoreStreamState restore(stream);; 212 auto h = std::chrono::durat",MatchSource.WIKI,doc/master/RDFHelpers_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html
Testability,log,logs,";; 79 }; 80 if (nToRun == 0u); 81 return 0u;; 82 ; 83 // Find the unique event loops; 84 auto sameGraph = [](const RResultHandle &a, const RResultHandle &b) { return a.fLoopManager < b.fLoopManager; };; 85 std::set<RResultHandle, decltype(sameGraph)> s(handles.begin(), handles.end(), sameGraph);; 86 std::vector<RResultHandle> uniqueLoops(s.begin(), s.end());; 87 ; 88 // Trigger jitting. One call is enough to jit the code required by all computation graphs.; 89 TStopwatch sw;; 90 sw.Start();; 91 {; 92 const auto effectiveVerbosity =; 93 ROOT::Experimental::Internal::GetChannelOrManager(ROOT::Detail::RDF::RDFLogChannel()); 94 .GetEffectiveVerbosity(ROOT::Experimental::RLogManager::Get());; 95 if (effectiveVerbosity >= ROOT::Experimental::ELogLevel::kDebug + 10) {; 96 // a very high verbosity was requested, let's not silence anything; 97 uniqueLoops[0].fLoopManager->Jit();; 98 } else {; 99 // silence logs from RLoopManager::Jit: RunGraphs does its own logging; 100 auto silenceRDFLogs = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(),; 101 ROOT::Experimental::ELogLevel::kError);; 102 uniqueLoops[0].fLoopManager->Jit();; 103 }; 104 }; 105 sw.Stop();; 106 R__LOG_INFO(ROOT::Detail::RDF::RDFLogChannel()); 107 << ""Just-in-time compilation phase for RunGraphs ("" << uniqueLoops.size(); 108 << "" unique computation graphs) completed""; 109 << (sw.RealTime() > 1e-3 ? "" in "" + std::to_string(sw.RealTime()) + "" seconds."" : "" in less than 1ms."");; 110 ; 111 // Trigger the unique event loops; 112 auto run = [](RResultHandle &h) {; 113 if (h.fLoopManager); 114 h.fLoopManager->Run(/*jit=*/false);; 115 };; 116 ; 117 sw.Start();; 118#ifdef R__USE_IMT; 119 if (ROOT::IsImplicitMTEnabled()) {; 120 ROOT::TThreadExecutor{}.Foreach(run, uniqueLoops);; 121 } else {; 122#endif; 123 std::for_each(uniqueLoops.begin(), uniqueLoops.end(), run);; 124#ifdef R__USE_IMT; 125 }; 126#endif; 127 sw.Stop();; 128 R__LOG_INFO(ROOT::Detail::RDF::RDFLogChannel()); 129 << ""Finished RunGr",MatchSource.WIKI,doc/master/RDFHelpers_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html
Usability,progress bar,progress bar,"IsImplicitMTEnabled; 13#include ""TError.h"" // Warning; 14#include ""TStopwatch.h""; 15#include ""RConfigure.h"" // R__USE_IMT; 16#include ""ROOT/RLogger.hxx""; 17#include ""ROOT/RDF/RLoopManager.hxx"" // for RLoopManager; 18#include ""ROOT/RDF/Utils.hxx""; 19#include ""ROOT/RResultHandle.hxx"" // for RResultHandle, RunGraphs; 20#ifdef R__USE_IMT; 21#include ""ROOT/TThreadExecutor.hxx""; 22#endif // R__USE_IMT; 23 ; 24#include <algorithm>; 25#include <iostream>; 26#include <set>; 27#include <cstdio>; 28 ; 29// TODO, this function should be part of core libraries; 30#include <numeric>; 31#if (!defined(_WIN32)) && (!defined(_WIN64)); 32#include <unistd.h>; 33#endif; 34 ; 35#if defined(_WIN32) || defined(_WIN64); 36#define WIN32_LEAN_AND_MEAN; 37#define VC_EXTRALEAN; 38#include <io.h>; 39#include <Windows.h>; 40#else; 41#include <sys/ioctl.h>; 42#endif; 43 ; 44// Get terminal size for progress bar; 45int get_tty_size(); 46{; 47#if defined(_WIN32) || defined(_WIN64); 48 if (!_isatty(_fileno(stdout))); 49 return 0;; 50 int width = 0;; 51 CONSOLE_SCREEN_BUFFER_INFO csbi;; 52 if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)); 53 width = (int)(csbi.srWindow.Right - csbi.srWindow.Left + 1);; 54 return width;; 55#else; 56 int width = 0;; 57 struct winsize w;; 58 ioctl(fileno(stdout), TIOCGWINSZ, &w);; 59 width = (int)(w.ws_col);; 60 return width;; 61#endif; 62}; 63 ; 64using ROOT::RDF::RResultHandle;; 65 ; 66unsigned int ROOT::RDF::RunGraphs(std::vector<RResultHandle> handles); 67{; 68 if (handles.empty()) {; 69 Warning(""RunGraphs"", ""Got an empty list of handles, now quitting."");; 70 return 0u;; 71 }; 72 ; 73 // Check that there are results which have not yet been run; 74 const unsigned int nToRun =; 75 std::count_if(handles.begin(), handles.end(), [](const auto &h) { return !h.IsReady(); });; 76 if (nToRun < handles.size()) {; 77 Warning(""RunGraphs"", ""Got %zu handles from which %zu link to results which are already ready."", handles.size(),; 78 handles.size() - nToRun)",MatchSource.WIKI,doc/master/RDFHelpers_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/dataframe/inc/ROOT/RDFHelpers.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions ; RDFHelpers.hxx File Reference. #include <ROOT/RDF/GraphUtils.hxx>; #include <ROOT/RDF/RActionBase.hxx>; #include <ROOT/RDF/RResultMap.hxx>; #include <ROOT/RResultHandle.hxx>; #include <ROOT/TypeTraits.hxx>; #include <array>; #include <chrono>; #include <fstream>; #include <functional>; #include <map>; #include <memory>; #include <mutex>; #include <type_traits>; #include <utility>; #include <vector>. Include dependency graph for RDFHelpers.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::RDF::Experimental::ProgressHelper;  RDF progress helper. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  ; namespace  ROOT::Internal::RDF;  ; namespace  ROOT::RDF;  ; namespace  ROOT::RDF::Experimental;  . Typedefs; using ROOT::RDF::Experimental::SnapshotPtr_t = ROOT::RDF::RResultPtr< ROOT::RDF::RInterface< ROOT::Detail::RDF::RLoopManager, void > >;  . Functions; void ROOT::RDF::Experimental::AddProgressBar (ROOT::RDataFrame df);  Add ProgressBar to an RDataFrame. ;  ; void ROOT::RDF::Experimental::AddProgressBar (ROOT::RDF::RNode df);  Add ProgressBar to a ROOT::RDF::RNode. ;  ; template<typename NodeType > ; RNode ROOT::RDF::AsRNode (NodeType node);  Cast a RDataFrame node to the common type ROOT::RDF::RNode. ;  ; template<typename F , typename Args = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::arg_types_nodecay, typename Ret = typename ROOT::TypeTraits::CallableTraits<std::decay_",MatchSource.WIKI,doc/master/RDFHelpers_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx.html
Modifiability,variab,variables,"template<typename F , typename Args = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::arg_types_nodecay, typename Ret = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::ret_type> ; auto ROOT::RDF::Not (F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward< F >(f)));  Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result. ;  ; template<typename... ArgTypes, typename F > ; std::function< bool(ArgTypes...)> ROOT::Internal::RDF::NotHelper (ROOT::TypeTraits::TypeList< ArgTypes... >, F &&f);  ; template<typename... ArgTypes, typename Ret , typename... Args> ; std::function< bool(ArgTypes...)> ROOT::Internal::RDF::NotHelper (ROOT::TypeTraits::TypeList< ArgTypes... >, Ret(*f)(Args...));  ; template<std::size_t N, typename T , typename F > ; auto ROOT::Internal::RDF::PassAsVec (F &&f) -> PassAsVecHelper< std::make_index_sequence< N >, T, F >;  ; template<std::size_t N, typename T , typename F > ; auto ROOT::RDF::PassAsVec (F &&f) -> RDFInternal::PassAsVecHelper< std::make_index_sequence< N >, T, F >;  PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection. ;  ; unsigned int ROOT::RDF::RunGraphs (std::vector< RResultHandle > handles);  Trigger the event loop of multiple RDataFrames concurrently. ;  ; template<typename NodeType > ; std::string ROOT::RDF::SaveGraph (NodeType node);  Create a graphviz representation of the dataframe computation graph, return it as a string. ;  ; template<typename NodeType > ; void ROOT::RDF::SaveGraph (NodeType node, const std::string &outputFile);  Create a graphviz representation of the dataframe computation graph, write it to the specified file. ;  ; template<typename T > ; RResultMap< T > ROOT::RDF::Experimental::VariationsFor (RResultPtr< T > resPtr);  Produce all required systematic variations for the given result. ;  ; SnapshotPtr_t ROOT::RDF::Experimental::VariationsFor (SnapshotPtr_t ",MatchSource.WIKI,doc/master/RDFHelpers_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx.html
Performance,concurren,concurrently,"aits::CallableTraits<std::decay_t<F>>::ret_type> ; auto ROOT::RDF::Not (F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward< F >(f)));  Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result. ;  ; template<typename... ArgTypes, typename F > ; std::function< bool(ArgTypes...)> ROOT::Internal::RDF::NotHelper (ROOT::TypeTraits::TypeList< ArgTypes... >, F &&f);  ; template<typename... ArgTypes, typename Ret , typename... Args> ; std::function< bool(ArgTypes...)> ROOT::Internal::RDF::NotHelper (ROOT::TypeTraits::TypeList< ArgTypes... >, Ret(*f)(Args...));  ; template<std::size_t N, typename T , typename F > ; auto ROOT::Internal::RDF::PassAsVec (F &&f) -> PassAsVecHelper< std::make_index_sequence< N >, T, F >;  ; template<std::size_t N, typename T , typename F > ; auto ROOT::RDF::PassAsVec (F &&f) -> RDFInternal::PassAsVecHelper< std::make_index_sequence< N >, T, F >;  PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection. ;  ; unsigned int ROOT::RDF::RunGraphs (std::vector< RResultHandle > handles);  Trigger the event loop of multiple RDataFrames concurrently. ;  ; template<typename NodeType > ; std::string ROOT::RDF::SaveGraph (NodeType node);  Create a graphviz representation of the dataframe computation graph, return it as a string. ;  ; template<typename NodeType > ; void ROOT::RDF::SaveGraph (NodeType node, const std::string &outputFile);  Create a graphviz representation of the dataframe computation graph, write it to the specified file. ;  ; template<typename T > ; RResultMap< T > ROOT::RDF::Experimental::VariationsFor (RResultPtr< T > resPtr);  Produce all required systematic variations for the given result. ;  ; SnapshotPtr_t ROOT::RDF::Experimental::VariationsFor (SnapshotPtr_t resPtr);  . treedataframeincROOTRDFHelpers.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RDFHelpers_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx.html
Availability,down,down,". ROOT: tree/dataframe/inc/ROOT/RDFHelpers.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RDFHelpers.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Danilo Piparo CERN 02/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11// This header contains helper free functions that slim down RDataFrame's programming model; 12 ; 13#ifndef ROOT_RDF_HELPERS; 14#define ROOT_RDF_HELPERS; 15 ; 16#include <ROOT/RDF/GraphUtils.hxx>; 17#include <ROOT/RDF/RActionBase.hxx>; 18#include <ROOT/RDF/RResultMap.hxx>; 19#include <ROOT/RResultHandle.hxx> // users of RunGraphs might rely on this transitive include; 20#include <ROOT/TypeTraits.hxx>; 21 ; 22#include <array>; 23#include <chrono>; 24#include <fstream>; 25#include <functional>; 26#include <map>; 27#include <memory>; 28#include <mutex>; 29#include <type_traits>; 30#include <utility> // std::index_sequence; 31#include <vector>; 32 ; 33namespace ROOT {; 34namespace Internal {; 35namespace RDF {; 36template <typename... ArgTypes, typename F>; 37std::function<bool(ArgTypes...)> NotHelper(ROOT::TypeTraits::TypeList<ArgTypes...>, F &&f); 38{; 39 return std::function<bool(ArgTypes...)>([=](ArgTypes... args) mutable { return !f(args...); });; 40}; 41 ; 42template <typename... ArgTypes, typename Ret, typename... Args>; 43std::function<bool(ArgTypes...)> NotHelper(ROOT::TypeTraits::TypeList<ArgTypes...>, Ret (*f)(Args...)); 44{; 45 return std::function<bool(ArgTypes...)>([=](ArgTypes... args) mutable { return !f(args...); });; 46}; 47 ; 48template <typename I, typename T, typename F>; 49class PassAsVecHelper;; 50 ; 51template <std::size_t... ",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Energy Efficiency,efficient,efficient,"45 if (!out.is_open()) {; 146 throw std::runtime_error(""Could not open output file \"""" + outputFile + ""\""for reading"");; 147 }; 148 ; 149 out << dotGraph;; 150 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct computation graphs that have been processed; 167///; 168/// This function triggers the event loop of all computation graphs which relate to the; 169/// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; 170/// RResultPtr is that the event loops will run concurrently. Therefore, the overall; 171/// computation of all results is generally more efficient.; 172/// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; 173///; 174/// ~~~{.cpp}; 175/// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; 176/// auto r1 = df1.Histo1D(""var1"");; 177///; 178/// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; 179/// auto r2 = df2.Sum(""var2"");; 180///; 181/// // RResultPtr -> RResultHandle conversion is automatic; 182/// ROOT::RDF::RunGraphs({r1, r2});; 183/// ~~~; 184// clang-format on; 185unsigned int RunGraphs(std::vector<RResultHandle> handles);; 186 ; 187namespace Experimental {; 188 ; 189/// \brief Produce all required systematic variations for the given result.; 190/// \param[in] resPtr The result for which variations should be produced.; 191/// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; 192/// (e.g. ""pt:down"") and the corresponding varied",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Integrability,interoperab,interoperability,"t... N, typename T, typename F>; 52class PassAsVecHelper<std::index_sequence<N...>, T, F> {; 53 template <std::size_t Idx>; 54 using AlwaysT = T;; 55 std::decay_t<F> fFunc;; 56 ; 57public:; 58 PassAsVecHelper(F &&f) : fFunc(std::forward<F>(f)) {}; 59 auto operator()(AlwaysT<N>... args) -> decltype(fFunc({args...})) { return fFunc({args...}); }; 60};; 61 ; 62template <std::size_t N, typename T, typename F>; 63auto PassAsVec(F &&f) -> PassAsVecHelper<std::make_index_sequence<N>, T, F>; 64{; 65 return PassAsVecHelper<std::make_index_sequence<N>, T, F>(std::forward<F>(f));; 66}; 67 ; 68} // namespace RDF; 69} // namespace Internal; 70 ; 71namespace RDF {; 72namespace RDFInternal = ROOT::Internal::RDF;; 73 ; 74// clang-format off; 75/// Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result; 76///; 77/// The callable must have one single non-template definition of operator(). This is a limitation with respect to; 78/// std::not_fn, required for interoperability with RDataFrame.; 79// clang-format on; 80template <typename F,; 81 typename Args = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::arg_types_nodecay,; 82 typename Ret = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::ret_type>; 83auto Not(F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward<F>(f))); 84{; 85 static_assert(std::is_same<Ret, bool>::value, ""RDF::Not requires a callable that returns a bool."");; 86 return RDFInternal::NotHelper(Args(), std::forward<F>(f));; 87}; 88 ; 89// clang-format off; 90/// PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection.; 91///; 92/// PassAsVec<N, T>(func) returns a callable that takes N arguments of type T, passes them down to function `func` as; 93/// an initializer list `{t1, t2, t3,..., tN}` and returns whatever f({t1, t2, t3, ..., tN}) returns.; 94///; 95/// Note that for this to work with RDataFrame the type of a",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Modifiability,variab,variables," 68} // namespace RDF; 69} // namespace Internal; 70 ; 71namespace RDF {; 72namespace RDFInternal = ROOT::Internal::RDF;; 73 ; 74// clang-format off; 75/// Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result; 76///; 77/// The callable must have one single non-template definition of operator(). This is a limitation with respect to; 78/// std::not_fn, required for interoperability with RDataFrame.; 79// clang-format on; 80template <typename F,; 81 typename Args = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::arg_types_nodecay,; 82 typename Ret = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::ret_type>; 83auto Not(F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward<F>(f))); 84{; 85 static_assert(std::is_same<Ret, bool>::value, ""RDF::Not requires a callable that returns a bool."");; 86 return RDFInternal::NotHelper(Args(), std::forward<F>(f));; 87}; 88 ; 89// clang-format off; 90/// PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection.; 91///; 92/// PassAsVec<N, T>(func) returns a callable that takes N arguments of type T, passes them down to function `func` as; 93/// an initializer list `{t1, t2, t3,..., tN}` and returns whatever f({t1, t2, t3, ..., tN}) returns.; 94///; 95/// Note that for this to work with RDataFrame the type of all columns that the callable is applied to must be exactly T.; 96/// Example usage together with RDataFrame (""varX"" columns must all be `float` variables):; 97/// \code; 98/// bool myVecFunc(std::vector<float> args);; 99/// df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});; 100/// \endcode; 101// clang-format on; 102template <std::size_t N, typename T, typename F>; 103auto PassAsVec(F &&f) -> RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>; 104{; 105 return RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>(std::forward<F>(f));; 106",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Performance,optimiz,optimized,"lumns must all be `float` variables):; 97/// \code; 98/// bool myVecFunc(std::vector<float> args);; 99/// df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});; 100/// \endcode; 101// clang-format on; 102template <std::size_t N, typename T, typename F>; 103auto PassAsVec(F &&f) -> RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>; 104{; 105 return RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>(std::forward<F>(f));; 106}; 107 ; 108// clang-format off; 109/// Create a graphviz representation of the dataframe computation graph, return it as a string.; 110/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 111///; 112/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 113///; 114/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 115/// effectively optimized away from the computation graph.; 116///; 117/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 118// clang-format on; 119template <typename NodeType>; 120std::string SaveGraph(NodeType node); 121{; 122 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 123 return helper.RepresentGraph(node);; 124}; 125 ; 126// clang-format off; 127/// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; 128/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 129/// \param[in] outputFile file where to save the representation.; 130///; 131/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 132///; 133/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Safety,safe,safe,"float>(myVecFunc), {""var1"", ""var2"", ""var3""});; 100/// \endcode; 101// clang-format on; 102template <std::size_t N, typename T, typename F>; 103auto PassAsVec(F &&f) -> RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>; 104{; 105 return RDFInternal::PassAsVecHelper<std::make_index_sequence<N>, T, F>(std::forward<F>(f));; 106}; 107 ; 108// clang-format off; 109/// Create a graphviz representation of the dataframe computation graph, return it as a string.; 110/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 111///; 112/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 113///; 114/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 115/// effectively optimized away from the computation graph.; 116///; 117/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 118// clang-format on; 119template <typename NodeType>; 120std::string SaveGraph(NodeType node); 121{; 122 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 123 return helper.RepresentGraph(node);; 124}; 125 ; 126// clang-format off; 127/// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; 128/// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; 129/// \param[in] outputFile file where to save the representation.; 130///; 131/// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; 132///; 133/// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; 134/// effectively optimized away from the computation graph.; 135///; 136/// Note that SaveGraph is not t",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Security,access,accessing,"elper helper;; 142 std::string dotGraph = helper.RepresentGraph(node);; 143 ; 144 std::ofstream out(outputFile);; 145 if (!out.is_open()) {; 146 throw std::runtime_error(""Could not open output file \"""" + outputFile + ""\""for reading"");; 147 }; 148 ; 149 out << dotGraph;; 150 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct computation graphs that have been processed; 167///; 168/// This function triggers the event loop of all computation graphs which relate to the; 169/// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; 170/// RResultPtr is that the event loops will run concurrently. Therefore, the overall; 171/// computation of all results is generally more efficient.; 172/// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; 173///; 174/// ~~~{.cpp}; 175/// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; 176/// auto r1 = df1.Histo1D(""var1"");; 177///; 178/// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; 179/// auto r2 = df2.Sum(""var2"");; 180///; 181/// // RResultPtr -> RResultHandle conversion is automatic; 182/// ROOT::RDF::RunGraphs({r1, r2});; 183/// ~~~; 184// clang-format on; 185unsigned int RunGraphs(std::vector<RResultHandle> handles);; 186 ; 187namespace Experimental {; 188 ; 189/// \brief Produce all required systematic variations for the given result.; 190/// \param[in] resPtr The result for which variations should be produced.; 191/// \return A \ref ROOT::RDF::Experimental::RResul",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Usability,progress bar,progress bar,":system_clock::now();; 330 std::chrono::time_point<std::chrono::system_clock> fLastPrintTime = fBeginTime;; 331 std::chrono::seconds fPrintInterval{1};; 332 ; 333 std::atomic<std::size_t> fProcessedEvents{0};; 334 std::size_t fLastProcessedEvents{0};; 335 std::size_t fIncrement;; 336 ; 337 mutable std::mutex fSampleNameToEventEntriesMutex;; 338 std::map<std::string, ULong64_t> fSampleNameToEventEntries; // Filename, events in the file; 339 ; 340 std::array<double, 20> fEventsPerSecondStatistics;; 341 std::size_t fEventsPerSecondStatisticsIndex{0};; 342 ; 343 unsigned int fBarWidth;; 344 unsigned int fTotalFiles;; 345 ; 346 std::mutex fPrintMutex;; 347 bool fIsTTY;; 348 bool fUseShellColours;; 349 ; 350 std::shared_ptr<TTree> fTree{nullptr};; 351 ; 352public:; 353 /// Create a progress helper.; 354 /// \param increment RDF callbacks are called every `n` events. Pass this `n` here.; 355 /// \param totalFiles read total number of files in the RDF.; 356 /// \param progressBarWidth Number of characters the progress bar will occupy.; 357 /// \param printInterval Update every stats every `n` seconds.; 358 /// \param useColors Use shell colour codes to colour the output. Automatically disabled when; 359 /// we are not writing to a tty.; 360 ProgressHelper(std::size_t increment, unsigned int totalFiles = 1, unsigned int progressBarWidth = 40,; 361 unsigned int printInterval = 1, bool useColors = true);; 362 ; 363 ~ProgressHelper() = default;; 364 ; 365 friend class ProgressBarAction;; 366 ; 367 /// Register a new sample for completion statistics.; 368 /// \see ROOT::RDF::RInterface::DefinePerSample().; 369 /// The *id.AsString()* refers to the name of the currently processed file.; 370 /// The idea is to populate the event entries in the *fSampleNameToEventEntries* map; 371 /// by selecting the greater of the two values:; 372 /// *id.EntryRange().second* which is the upper event entry range of the processed sample; 373 /// and the current value of the event entries in the *f",MatchSource.WIKI,doc/master/RDFHelpers_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html
Availability,failure,failure,"},; 87 {""double"", typeid(double)},; 88 {""Double_t"", typeid(double)},; 89 {""float"", typeid(float)},; 90 {""Float_t"", typeid(float)},; 91 {""long long"", typeid(long long)},; 92 {""long long int"", typeid(long long)},; 93 {""Long64_t"", typeid(long long)},; 94 {""unsigned long long"", typeid(unsigned long long)},; 95 {""unsigned long long int"", typeid(unsigned long long)},; 96 {""ULong64_t"", typeid(unsigned long long)},; 97 {""bool"", typeid(bool)},; 98 {""Bool_t"", typeid(bool)}};; 99 ; 100 if (auto it = typeName2TypeIDMap.find(name); it != typeName2TypeIDMap.end()); 101 return it->second.get();; 102 ; 103 if (auto c = TClass::GetClass(name.c_str())) {; 104 if (!c->GetTypeInfo()) {; 105 throw std::runtime_error(""Cannot extract type_info of type "" + name + ""."");; 106 }; 107 return *c->GetTypeInfo();; 108 }; 109 ; 110 throw std::runtime_error(""Cannot extract type_info of type "" + name + ""."");; 111}; 112 ; 113/// Returns the name of a type starting from its type_info; 114/// An empty string is returned in case of failure; 115/// References and pointers are not supported since those cannot be stored in; 116/// columns.; 117/// Note that this function will take a lock and may be a potential source of; 118/// contention in multithreaded execution.; 119std::string TypeID2TypeName(const std::type_info &id); 120{; 121 const static std::unordered_map<TypeInfoRef, std::string, TypeInfoRefHash, TypeInfoRefEqualComp> typeID2TypeNameMap{; 122 {typeid(char), ""char""}, {typeid(unsigned char), ""unsigned char""},; 123 {typeid(int), ""int""}, {typeid(unsigned int), ""unsigned int""},; 124 {typeid(short), ""short""}, {typeid(unsigned short), ""unsigned short""},; 125 {typeid(long), ""long""}, {typeid(unsigned long), ""unsigned long""},; 126 {typeid(double), ""double""}, {typeid(float), ""float""},; 127 {typeid(Long64_t), ""Long64_t""}, {typeid(ULong64_t), ""ULong64_t""},; 128 {typeid(bool), ""bool""}};; 129 ; 130 if (auto it = typeID2TypeNameMap.find(id); it != typeID2TypeNameMap.end()); 131 return it->second;; 132 ; 133 if ",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Deployability,upgrade,upgrade,": column \"""" + colName + ""\"" is being used as "";; 421 if (tName.empty()) {; 422 errMsg += requestedType.name();; 423 errMsg += "" (extracted from type info)"";; 424 } else {; 425 errMsg += tName;; 426 }; 427 errMsg += "" but the Define or Vary node advertises it as "";; 428 if (colTypeName.empty()) {; 429 auto &id = colType;; 430 errMsg += id.name();; 431 errMsg += "" (extracted from type info)"";; 432 } else {; 433 errMsg += colTypeName;; 434 }; 435 throw std::runtime_error(errMsg);; 436 }; 437}; 438 ; 439bool IsStrInVec(const std::string &str, const std::vector<std::string> &vec); 440{; 441 return std::find(vec.cbegin(), vec.cend(), str) != vec.cend();; 442}; 443 ; 444auto RStringCache::Insert(const std::string &string) -> decltype(fStrings)::const_iterator; 445{; 446 {; 447 std::shared_lock l{fMutex};; 448 if (auto it = fStrings.find(string); it != fStrings.end()); 449 return it;; 450 }; 451 ; 452 // TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; 453 // but that is unfortunately not usable outside the already available ROOT mutexes; 454 std::unique_lock l{fMutex};; 455 if (auto it = fStrings.find(string); it != fStrings.end()); 456 return it;; 457 ; 458 return fStrings.insert(string).first;; 459}; 460} // end NS RDF; 461} // end NS Internal; 462} // end NS ROOT; RDataSource.hxx; RDefineBase.hxx; RLogger.hxx; R__LOG_DEBUG#define R__LOG_DEBUG(DEBUGLEVEL,...)Definition RLogger.hxx:365; RLoopManager.hxx; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; RtypesCore.h; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TBranchElement.h; TBranch.h; TClassEdit.h; TClassRef.h; TClass.h; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; lengthOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAli",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Integrability,message,message,"274 {""unsigned short int"", 's'},; 275 {""UShort_t"", 's'},; 276 {""long"", 'G'},; 277 {""long int"", 'G'},; 278 {""Long_t"", 'G'},; 279 {""unsigned long"", 'g'},; 280 {""unsigned long int"", 'g'},; 281 {""ULong_t"", 'g'},; 282 {""double"", 'D'},; 283 {""Double_t"", 'D'},; 284 {""float"", 'F'},; 285 {""Float_t"", 'F'},; 286 {""long long"", 'L'},; 287 {""long long int"", 'L'},; 288 {""Long64_t"", 'L'},; 289 {""unsigned long long"", 'l'},; 290 {""unsigned long long int"", 'l'},; 291 {""ULong64_t"", 'l'},; 292 {""bool"", 'O'},; 293 {""Bool_t"", 'O'}};; 294 ; 295 if (auto it = typeName2ROOTTypeNameMap.find(b); it != typeName2ROOTTypeNameMap.end()); 296 return it->second;; 297 ; 298 return ' ';; 299}; 300 ; 301unsigned int GetNSlots(); 302{; 303 unsigned int nSlots = 1;; 304#ifdef R__USE_IMT; 305 if (ROOT::IsImplicitMTEnabled()); 306 nSlots = ROOT::GetThreadPoolSize();; 307#endif // R__USE_IMT; 308 return nSlots;; 309}; 310 ; 311/// Replace occurrences of '.' with '_' in each string passed as argument.; 312/// An Info message is printed when this happens. Dots at the end of the string are not replaced.; 313/// An exception is thrown in case the resulting set of strings would contain duplicates.; 314std::vector<std::string> ReplaceDotWithUnderscore(const std::vector<std::string> &columnNames); 315{; 316 auto newColNames = columnNames;; 317 for (auto &col : newColNames) {; 318 const auto dotPos = col.find('.');; 319 if (dotPos != std::string::npos && dotPos != col.size() - 1 && dotPos != 0u) {; 320 auto oldName = col;; 321 std::replace(col.begin(), col.end(), '.', '_');; 322 if (std::find(columnNames.begin(), columnNames.end(), col) != columnNames.end()); 323 throw std::runtime_error(""Column "" + oldName + "" would be written as "" + col +; 324 "" but this column already exists. Please use Alias to select a new name for "" +; 325 oldName);; 326 Info(""Snapshot"", ""Column %s will be saved as %s"", oldName.c_str(), col.c_str());; 327 }; 328 }; 329 ; 330 return newColNames;; 331}; 332 ; 333void InterpreterDeclare(const st",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Modifiability,variab,variable-sized,"""}, {typeid(ULong64_t), ""ULong64_t""},; 128 {typeid(bool), ""bool""}};; 129 ; 130 if (auto it = typeID2TypeNameMap.find(id); it != typeID2TypeNameMap.end()); 131 return it->second;; 132 ; 133 if (auto c = TClass::GetClass(id)) {; 134 return c->GetName();; 135 }; 136 ; 137 return """";; 138}; 139 ; 140std::string ComposeRVecTypeName(const std::string &valueType); 141{; 142 return ""ROOT::VecOps::RVec<"" + valueType + "">"";; 143}; 144 ; 145std::string GetLeafTypeName(TLeaf *leaf, const std::string &colName); 146{; 147 const char *colTypeCStr = leaf->GetTypeName();; 148 std::string colType = colTypeCStr == nullptr ? """" : colTypeCStr;; 149 if (colType.empty()); 150 throw std::runtime_error(""Could not deduce type of leaf "" + colName);; 151 if (leaf->GetLeafCount() != nullptr && leaf->GetLenStatic() == 1) {; 152 // this is a variable-sized array; 153 colType = ComposeRVecTypeName(colType);; 154 } else if (leaf->GetLeafCount() == nullptr && leaf->GetLenStatic() > 1) {; 155 // this is a fixed-sized array (we do not differentiate between variable- and fixed-sized arrays); 156 colType = ComposeRVecTypeName(colType);; 157 } else if (leaf->GetLeafCount() != nullptr && leaf->GetLenStatic() > 1) {; 158 // we do not know how to deal with this branch; 159 throw std::runtime_error(""TTree leaf "" + colName +; 160 "" has both a leaf count and a static length. This is not supported."");; 161 }; 162 ; 163 return colType;; 164}; 165 ; 166/// Return the typename of object colName stored in t, if any. Return an empty string if colName is not in t.; 167/// Supported cases:; 168/// - leaves corresponding to single values, variable- and fixed-length arrays, with following syntax:; 169/// - ""leafname"", as long as TTree::GetLeaf resolves it; 170/// - ""b1.b2...leafname"", as long as TTree::GetLeaf(""b1.b2...."", ""leafname"") resolves it; 171/// - TBranchElements, as long as TTree::GetBranch resolves their names; 172std::string GetBranchOrLeafTypeName(TTree &t, const std::string &colName); 173{; 174 // look for",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Performance,cache,cache,"etColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h lengthDefinition TGWin32VirtualXProxy.cxx:245; namechar name[80]Definition TGX11.cxx:110; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TLeaf.h; operator()TRObject operator()(const T1 &t1) constDefinition TRFunctionImport__oprtr.h:14; TROOT.h; TTree.h; Utils.hxx; ROOT::Detail::RDF::RDefineBaseDefinition RDefineBase.hxx:39; ROOT::Detail::RDF::RDefineBase::GetTypeNamestd::string GetTypeName() constDefinition RDefineBase.cxx:47; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::Internal::RDF::RStringCache::Insertauto Insert(const std::string &string) -> decltype(fStrings)::const_iteratorInserts the input string in the cache and returns an iterator to the cached string.Definition RDFUtils.cxx:444; ROOT::RDF::RDataSourceRDataSource defines an API that RDataFrame can use to read arbitrary data formats.Definition RDataSource.hxx:109; ROOT::RDF::RDataSource::HasColumnvirtual bool HasColumn(std::string_view colName) const =0Checks if the dataset has a certain column.; ROOT::RDF::RDataSource::GetTypeNamevirtual std::string GetTypeName(std::string_view colName) const =0Type of a column as a string, e.g.; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranch::Classstatic TClass * Class(); TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass ",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Safety,avoid,avoid,"d be considered in an invalid state.\n"";; 341 throw std::runtime_error(msg);; 342 }; 343}; 344 ; 345Long64_t InterpreterCalc(const std::string &code, const std::string &context); 346{; 347 R__LOG_DEBUG(10, RDFLogChannel()) << ""Jitting and executing the following code:\n\n"" << code << '\n';; 348 ; 349 TInterpreter::EErrorCode errorCode(TInterpreter::kNoError); // storage for cling errors; 350 ; 351 auto callCalc = [&errorCode, &context](const std::string &codeSlice) {; 352 gInterpreter->Calc(codeSlice.c_str(), &errorCode);; 353 if (errorCode != TInterpreter::EErrorCode::kNoError) {; 354 std::string msg = ""\nAn error occurred during just-in-time compilation"";; 355 if (!context.empty()); 356 msg += "" in "" + context;; 357 msg +=; 358 "". The lines above might indicate the cause of the crash\nAll RDF objects that have not run their event ""; 359 ""loop yet should be considered in an invalid state.\n"";; 360 throw std::runtime_error(msg);; 361 }; 362 };; 363 ; 364 // Call Calc every 1000 newlines in order to avoid jitting a very large function body, which is slow:; 365 // see https://github.com/root-project/root/issues/9312 and https://github.com/root-project/root/issues/7604; 366 std::size_t substr_start = 0;; 367 std::size_t substr_end = 0;; 368 while (substr_end != std::string::npos && substr_start != code.size() - 1) {; 369 for (std::size_t i = 0u; i < 1000u && substr_end != std::string::npos; ++i) {; 370 substr_end = code.find('\n', substr_end + 1);; 371 }; 372 const std::string subs = code.substr(substr_start, substr_end - substr_start);; 373 substr_start = substr_end;; 374 ; 375 callCalc(subs);; 376 }; 377 ; 378 return 0; // we used to forward the return value of Calc, but that's not possible anymore.; 379}; 380 ; 381bool IsInternalColumn(std::string_view colName); 382{; 383 const auto str = colName.data();; 384 const auto goodPrefix = colName.size() > 3 && // has at least more characters than {r,t}df; 385 ('r' == str[0] || 't' == str[0]) && // starts with r or t; 386 ",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Testability,log,log,"butes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h lengthDefinition TGWin32VirtualXProxy.cxx:245; namechar name[80]Definition TGX11.cxx:110; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TLeaf.h; operator()TRObject operator()(const T1 &t1) constDefinition TRFunctionImport__oprtr.h:14; TROOT.h; TTree.h; Utils.hxx; ROOT::Detail::RDF::RDefineBaseDefinition RDefineBase.hxx:39; ROOT::Detail::RDF::RDefineBase::GetTypeNamestd::string GetTypeName() constDefinition RDefineBase.cxx:47; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::Internal::RDF::RStringCache::Insertauto Insert(const std::string &string) -> decltype(fStrings)::const_iteratorInserts the input string in the cache and returns an iterator to the cached string.Definition RDFUtils.cxx:444; ROOT::RDF::RDataSourceRDataSource defines an API that RDataFrame can use to read arbitrary data formats.Definition RDataSource.hxx:109; ROOT::RDF::RDataSource::HasColumnvirtual bool HasColumn(std::string_view colName) const =0Checks if the dataset has a certain column.; ROOT::RDF::RDataSource::GetTypeNamevirtual std::string GetTypeName(std::string_view colName) const =0Type of a column as a string, e.g.; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranch::Classstatic TClass * Class(); TClassRefTClassRef is used to implement a permanent reference to a TClass object.Defi",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Usability,usab,usable,": column \"""" + colName + ""\"" is being used as "";; 421 if (tName.empty()) {; 422 errMsg += requestedType.name();; 423 errMsg += "" (extracted from type info)"";; 424 } else {; 425 errMsg += tName;; 426 }; 427 errMsg += "" but the Define or Vary node advertises it as "";; 428 if (colTypeName.empty()) {; 429 auto &id = colType;; 430 errMsg += id.name();; 431 errMsg += "" (extracted from type info)"";; 432 } else {; 433 errMsg += colTypeName;; 434 }; 435 throw std::runtime_error(errMsg);; 436 }; 437}; 438 ; 439bool IsStrInVec(const std::string &str, const std::vector<std::string> &vec); 440{; 441 return std::find(vec.cbegin(), vec.cend(), str) != vec.cend();; 442}; 443 ; 444auto RStringCache::Insert(const std::string &string) -> decltype(fStrings)::const_iterator; 445{; 446 {; 447 std::shared_lock l{fMutex};; 448 if (auto it = fStrings.find(string); it != fStrings.end()); 449 return it;; 450 }; 451 ; 452 // TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; 453 // but that is unfortunately not usable outside the already available ROOT mutexes; 454 std::unique_lock l{fMutex};; 455 if (auto it = fStrings.find(string); it != fStrings.end()); 456 return it;; 457 ; 458 return fStrings.insert(string).first;; 459}; 460} // end NS RDF; 461} // end NS Internal; 462} // end NS ROOT; RDataSource.hxx; RDefineBase.hxx; RLogger.hxx; R__LOG_DEBUG#define R__LOG_DEBUG(DEBUGLEVEL,...)Definition RLogger.hxx:365; RLoopManager.hxx; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; RtypesCore.h; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TBranchElement.h; TBranch.h; TClassEdit.h; TClassRef.h; TClass.h; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; lengthOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAli",MatchSource.WIKI,doc/master/RDFUtils_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RDFUtils_8cxx_source.html
Availability,error,errors,"245 fMvaEventErrorUpper( 0 ),; 246 fLogger ( 0 ); 247{; 248 fDataSetManager = new DataSetManager( fDataInputHandler );; 249 fDataSetManager->AddDataSetInfo(fDataSetInfo);; 250 fLogger = new MsgLogger(this);; 251 SetConfigName( GetName() );; 252 DeclareOptions();; 253 ParseOptions();; 254 ; 255 // arguments: names of input variables given in form: ""name1:name2:name3""; 256 // verbose flag; 257 DecodeVarNames(varNames);; 258 Init();; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// declaration of configuration options; 263 ; 264void TMVA::Reader::DeclareOptions(); 265{; 266 if (gTools().CheckForSilentOption( GetOptions() )) Log().InhibitOutput(); // make sure is silent if wanted to; 267 ; 268 DeclareOptionRef( fVerbose, ""V"", ""Verbose flag"" );; 269 DeclareOptionRef( fColor, ""Color"", ""Color flag (default True)"" );; 270 DeclareOptionRef( fSilent, ""Silent"", ""Boolean silent flag (default False)"" );; 271 DeclareOptionRef( fCalculateError, ""Error"", ""Calculates errors (default False)"" );; 272}; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// destructor; 276 ; 277TMVA::Reader::~Reader( void ); 278{; 279 delete fDataSetManager; // DSMTEST; 280 ; 281 delete fLogger;; 282 ; 283 for (auto it=fMethodMap.begin(); it!=fMethodMap.end(); it++){; 284 MethodBase * kl = dynamic_cast<TMVA::MethodBase*>(it->second);; 285 delete kl;; 286 }; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// default initialisation (no member variables); 291 ; 292void TMVA::Reader::Init( void ); 293{; 294 if (Verbose()) fLogger->SetMinType( kVERBOSE );; 295 ; 296 gConfig().SetUseColor( fColor );; 297 gConfig().SetSilent ( fSilent );; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Add a float variable or expression to the reader; 302 ; 303void TMVA::Reader::AddVariable( const TString& expression, Float",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Deployability,integrat,integrated,". ROOT: tmva/tmva/src/Reader.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Reader.cxx. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Eckhard von Toerne, Jan Therhaag; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : Reader *; 8 * *; 9 * *; 10 * Description: *; 11 * Reader class to be used in the user application to interpret the trained *; 12 * MVAs in an analysis context *; 13 * *; 14 * Authors (alphabetical order): *; 15 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 16 * Peter Speckmayer <peter.speckmayer@cern.ch> - CERN, Switzerland *; 17 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 18 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 19 * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; 20 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 21 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 22 * *; 23 * Copyright (c) 2005-2011: *; 24 * CERN, Switzerland *; 25 * U. of Victoria, Canada *; 26 * MPI-K Heidelberg, Germany *; 27 * U. of Bonn, Germany *; 28 * *; 29 * Redistribution and use in source and binary forms, with or without *; 30 * modification, are permitted according to the terms listed in LICENSE *; 31 * (see tmva/doc/LICENSE) *; 32 **********************************************************************************/; 33 ; 34/*! \class TMVA::Reader; 35\ingroup TMVA; 36 ; 37 The Reader class serves to use the MVAs in a specific analysis context.; 38 Within an event loop, a vector is filled that corresponds to the variables; 39 that were used to train the MVA(s) during the training stage. This vector; 40 is transfered to the Reader, who takes care of interpreting the weight; 41 file of the MVA of choice, an",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Energy Efficiency,allocate,allocated,"Reader.h:161; TMVA::Reader::DataInfoconst DataSetInfo & DataInfo() constDefinition Reader.h:117; TMVA::Tools::xmlengineTXMLEngine & xmlengine()Definition Tools.h:262; TMVA::Tools::ReadAttrvoid ReadAttr(void *node, const char *, T &value)read attribute from xmlDefinition Tools.h:329; TMVA::Types::Instancestatic Types & Instance()The single instance of ""Types"" if existing already, or create it (Singleton)Definition Types.cxx:70; TMVA::Types::EMVAEMVADefinition Types.h:76; TMVA::Types::kCategory@ kCategoryDefinition Types.h:97; TMVA::Types::kCuts@ kCutsDefinition Types.h:78; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TXMLEngine::FreeDocvoid FreeDoc(XMLDocPointer_t xmldoc)frees allocated document data and deletes document itselfDefinition TXMLEngine.cxx:1288; TXMLEngine::DocGetRootElementXMLNodePointer_t DocGetRootElement(XMLDocPointer_t xmldoc)returns root node of documentDefinition TXMLEngine.cxx:1339; TXMLEngine::ParseFileXMLDocPointer_t ParseFile(const char *filename, Int_t maxbuf=100000)Parses content of file and tries to produce xml structures.Definition TXMLEngine.cxx:1356; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TMVA::gConfigConfig & gConfig(); TMVA::gToolsTools & gTools(); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; Config.h; Types.h. tmvatmvasrcReader.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Integrability,integrat,integrated,". ROOT: tmva/tmva/src/Reader.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Reader.cxx. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Eckhard von Toerne, Jan Therhaag; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : Reader *; 8 * *; 9 * *; 10 * Description: *; 11 * Reader class to be used in the user application to interpret the trained *; 12 * MVAs in an analysis context *; 13 * *; 14 * Authors (alphabetical order): *; 15 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 16 * Peter Speckmayer <peter.speckmayer@cern.ch> - CERN, Switzerland *; 17 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 18 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 19 * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; 20 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 21 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 22 * *; 23 * Copyright (c) 2005-2011: *; 24 * CERN, Switzerland *; 25 * U. of Victoria, Canada *; 26 * MPI-K Heidelberg, Germany *; 27 * U. of Bonn, Germany *; 28 * *; 29 * Redistribution and use in source and binary forms, with or without *; 30 * modification, are permitted according to the terms listed in LICENSE *; 31 * (see tmva/doc/LICENSE) *; 32 **********************************************************************************/; 33 ; 34/*! \class TMVA::Reader; 35\ingroup TMVA; 36 ; 37 The Reader class serves to use the MVAs in a specific analysis context.; 38 Within an event loop, a vector is filled that corresponds to the variables; 39 that were used to train the MVA(s) during the training stage. This vector; 40 is transfered to the Reader, who takes care of interpreting the weight; 41 file of the MVA of choice, an",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Modifiability,variab,variables,"yer@cern.ch> - CERN, Switzerland *; 17 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 18 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 19 * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; 20 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 21 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 22 * *; 23 * Copyright (c) 2005-2011: *; 24 * CERN, Switzerland *; 25 * U. of Victoria, Canada *; 26 * MPI-K Heidelberg, Germany *; 27 * U. of Bonn, Germany *; 28 * *; 29 * Redistribution and use in source and binary forms, with or without *; 30 * modification, are permitted according to the terms listed in LICENSE *; 31 * (see tmva/doc/LICENSE) *; 32 **********************************************************************************/; 33 ; 34/*! \class TMVA::Reader; 35\ingroup TMVA; 36 ; 37 The Reader class serves to use the MVAs in a specific analysis context.; 38 Within an event loop, a vector is filled that corresponds to the variables; 39 that were used to train the MVA(s) during the training stage. This vector; 40 is transfered to the Reader, who takes care of interpreting the weight; 41 file of the MVA of choice, and to return the MVA's output. This is then; 42 used by the user for further analysis.; 43 ; 44 Usage:; 45 ; 46~~~ {.cpp}; 47 // ------ before starting the event loop (eg, in the initialisation step); 48 ; 49 //; 50 // create TMVA::Reader object; 51 //; 52 TMVA::Reader *reader = new TMVA::Reader();; 53 ; 54 // create a set of variables and declare them to the reader; 55 // - the variable names must corresponds in name and type to; 56 // those given in the weight file(s) that you use; 57 Float_t var1, var2, var3, var4;; 58 reader->AddVariable( ""var1"", &var1 );; 59 reader->AddVariable( ""var2"", &var2 );; 60 reader->AddVariable( ""var3"", &var3 );; 61 reader->AddVariable( ""var4"", &var4 );; 62 ; 63 // book the MVA of your choice (prior training of these methods, ie,; 64 // existence of the weight files i",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Performance,perform,performs," the vector.; 471 IMethod* imeth = FindMVA( methodTag );; 472 MethodBase* meth = dynamic_cast<TMVA::MethodBase*>(imeth);; 473 if(meth==0) return 0;; 474 ; 475 // Event* tmpEvent=new Event(inputVec, 2); // ToDo resolve magic 2 issue; 476 Event* tmpEvent=new Event(inputVec, DataInfo().GetNVariables()); // is this the solution?; 477 for (UInt_t i=0; i<inputVec.size(); i++){; 478 if (TMath::IsNaN(inputVec[i])) {; 479 Log() << kERROR << i << ""-th variable of the event is NaN --> return MVA value -999, \n that's all I can do, please fix or remove this event."" << Endl;; 480 delete tmpEvent;; 481 return -999;; 482 }; 483 }; 484 ; 485 if (meth->GetMethodType() == TMVA::Types::kCuts) {; 486 TMVA::MethodCuts* mc = dynamic_cast<TMVA::MethodCuts*>(meth);; 487 if(mc); 488 mc->SetTestSignalEfficiency( aux );; 489 }; 490 Double_t val = meth->GetMvaValue( tmpEvent, (fCalculateError?&fMvaEventError:0));; 491 delete tmpEvent;; 492 return val;; 493}; 494 ; 495////////////////////////////////////////////////////////////////////////////////; 496/// Evaluate a std::vector<double> of input data for a given method; 497/// The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff; 498 ; 499Double_t TMVA::Reader::EvaluateMVA( const std::vector<Double_t>& inputVec, const TString& methodTag, Double_t aux ); 500{; 501 // performs a copy to float values which are internally used by all methods; 502 if(fTmpEvalVec.size() != inputVec.size()); 503 fTmpEvalVec.resize(inputVec.size());; 504 ; 505 for (UInt_t idx=0; idx!=inputVec.size(); idx++ ); 506 fTmpEvalVec[idx]=inputVec[idx];; 507 ; 508 return EvaluateMVA( fTmpEvalVec, methodTag, aux );; 509}; 510 ; 511////////////////////////////////////////////////////////////////////////////////; 512/// evaluates MVA for given set of input variables; 513 ; 514Double_t TMVA::Reader::EvaluateMVA( const TString& methodTag, Double_t aux ); 515{; 516 IMethod* method = 0;; 517 ; 518 std::map<TString, IMethod*>::iterator it = fMeth",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Security,access,access,"indow_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TH1D.h; TLeaf.h; TMath.h; TString.h; TVector.h; TXMLEngine.h; Tools.h; TMVA::ClassifierFactory::CreateIMethod * Create(const std::string &name, const TString &job, const TString &title, DataSetInfo &dsi, const TString &option)creates the method if needed based on the method name using the creator function the factory has stor...Definition ClassifierFactory.cxx:89; TMVA::ClassifierFactory::Instancestatic ClassifierFactory & Instance()access to the ClassifierFactory singleton creates the instance if neededDefinition ClassifierFactory.cxx:48; TMVA::Config::SetUseColorvoid SetUseColor(Bool_t uc)Definition Config.h:60; TMVA::Config::SetSilentvoid SetSilent(Bool_t s)Definition Config.h:63; TMVA::ConfigurableDefinition Configurable.h:45; TMVA::Configurable::SetConfigNamevoid SetConfigName(const char *n)Definition Configurable.h:63; TMVA::Configurable::ParseOptionsvirtual void ParseOptions()options parserDefinition Configurable.cxx:124; TMVA::DataSetInfo::AddVariableVariableInfo & AddVariable(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0, char varType='F', Bool_t normalized=kTRUE, void *external=nullptr)add a variable (can be a complex expression) to the set of variables used in the MV analysisDefinition DataSetInfo.cxx:207; TMVA::DataSetManagerClass that contains all the data information.Definition DataSetManager.h:51; TMVA::DataSetManager::AddDataSetInfoDataSetInfo & AddD",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Testability,assert,assert,"void* doc = gTools().xmlengine().ParseFile(filename,gTools().xmlenginebuffersize());// the default buffer size in TXMLEngine::ParseFile is 100k. Starting with ROOT 5.29 one can set the buffer size, see: http://savannah.cern.ch/bugs/?78864. This might be necessary for large XML files; 349 void* rootnode = gTools().xmlengine().DocGetRootElement(doc); // node ""MethodSetup""; 350 gTools().ReadAttr(rootnode, ""Method"", fullMethodName);; 351 gTools().xmlengine().FreeDoc(doc);; 352 }; 353 else {; 354 char buf[512];; 355 fin.getline(buf,512);; 356 while (!TString(buf).BeginsWith(""Method"")) fin.getline(buf,512);; 357 fullMethodName = TString(buf);; 358 fin.close();; 359 }; 360 TString methodType = fullMethodName(0,fullMethodName.Index(""::""));; 361 if (methodType.Contains("" "")) methodType = methodType(methodType.Last(' ')+1,methodType.Length());; 362 return methodType;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// read method name from weight file; 367 ; 368TMVA::IMethod* TMVA::Reader::BookMVA( const TString& methodTag, const TString& weightfile ); 369{; 370 // assert non-existence; 371 if (fMethodMap.find( methodTag ) != fMethodMap.end()); 372 Log() << kFATAL << ""<BookMVA> method tag \"""" << methodTag << ""\"" already exists!"" << Endl;; 373 ; 374 TString methodType(GetMethodTypeFromFile(weightfile));; 375 ; 376 Log() << kINFO << ""Booking \"""" << methodTag << ""\"" of type \"""" << methodType << ""\"" from "" << weightfile << ""."" << Endl;; 377 ; 378 MethodBase* method = dynamic_cast<MethodBase*>(this->BookMVA( Types::Instance().GetMethodType(methodType),; 379 weightfile ) );; 380 if( method && method->GetMethodType() == Types::kCategory ){; 381 MethodCategory *methCat = (dynamic_cast<MethodCategory*>(method));; 382 if( !methCat ); 383 Log() << kFATAL << ""Method with type kCategory cannot be casted to MethodCategory. /Reader"" << Endl;; 384 methCat->fDataSetManager = fDataSetManager;; 385 }; 386 ; 387 return fMethodMap[methodTag] = m",MatchSource.WIKI,doc/master/Reader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html
Integrability,depend,dependency,". ROOT: tmva/tmva/inc/TMVA/Reader.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces ; Reader.h File Reference. #include ""TMVA/Configurable.h""; #include ""TMVA/Types.h""; #include ""TMVA/DataSetInfo.h""; #include ""TMVA/DataInputHandler.h""; #include ""TMVA/DataSetManager.h""; #include <vector>; #include <map>; #include <stdexcept>; #include <string>. Include dependency graph for Reader.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TMVA::Reader;  The Reader class serves to use the MVAs in a specific analysis context. More...;  . Namespaces; namespace  TMVA;  create variable transformations ;  . tmvatmvaincTMVAReader.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Reader_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h.html
Modifiability,variab,variable,". ROOT: tmva/tmva/inc/TMVA/Reader.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces ; Reader.h File Reference. #include ""TMVA/Configurable.h""; #include ""TMVA/Types.h""; #include ""TMVA/DataSetInfo.h""; #include ""TMVA/DataInputHandler.h""; #include ""TMVA/DataSetManager.h""; #include <vector>; #include <map>; #include <stdexcept>; #include <string>. Include dependency graph for Reader.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TMVA::Reader;  The Reader class serves to use the MVAs in a specific analysis context. More...;  . Namespaces; namespace  TMVA;  create variable transformations ;  . tmvatmvaincTMVAReader.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Reader_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h.html
Availability,error,error,"able {; 65 ; 66 public:; 67 ; 68 // without prior specification of variables; 69 Reader( const TString& theOption="""", Bool_t verbose = 0 );; 70 ; 71 // STL types; 72 Reader( std::vector<std::string>& varNames, const TString& theOption = """", Bool_t verbose = 0 );; 73 Reader( const std::string& varNames, const TString& theOption, Bool_t verbose = 0 ); // format: ""var1:var2:...""; 74 ; 75 // Root types; 76 Reader( std::vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0 );; 77 Reader( const TString& varNames, const TString& theOption, Bool_t verbose = 0 ); // format: ""var1:var2:...""; 78 ; 79 virtual ~Reader( void );; 80 ; 81 // book MVA method via weight file; 82 IMethod* BookMVA( const TString& methodTag, const TString& weightfile );; 83 IMethod* BookMVA( TMVA::Types::EMVA methodType, const char* xmlstr );; 84 IMethod* FindMVA( const TString& methodTag );; 85 ; 86 // returns the MVA response for given event; 87 Double_t EvaluateMVA( const std::vector<Float_t> &, const TString& methodTag, Double_t aux = 0 );; 88 Double_t EvaluateMVA( const std::vector<Double_t>&, const TString& methodTag, Double_t aux = 0 );; 89 Double_t EvaluateMVA( MethodBase* method, Double_t aux = 0 );; 90 Double_t EvaluateMVA( const TString& methodTag, Double_t aux = 0 );; 91 ; 92 // returns error on MVA response for given event; 93 // NOTE: must be called AFTER ""EvaluateMVA(...)"" call !; 94 Double_t GetMVAError() const { return fMvaEventError; }; 95 Double_t GetMVAErrorLower() const { return fMvaEventError; }; 96 Double_t GetMVAErrorUpper() const { return fMvaEventErrorUpper; }; 97 ; 98 // regression response; 99 const std::vector< Float_t >& EvaluateRegression( const TString& methodTag, Double_t aux = 0 );; 100 const std::vector< Float_t >& EvaluateRegression( MethodBase* method, Double_t aux = 0 );; 101 Float_t EvaluateRegression( UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0 );; 102 ; 103 // multiclass response; 104 const std::vector< Float_t >& EvaluateM",MatchSource.WIKI,doc/master/Reader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html
Deployability,integrat,integrated,". ROOT: tmva/tmva/inc/TMVA/Reader.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Reader.h. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : Reader *; 8 * *; 9 * *; 10 * Description: *; 11 * Reader class to be used in the user application to interpret the trained *; 12 * MVAs in an analysis context *; 13 * *; 14 * Authors (alphabetical order): *; 15 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 16 * Peter Speckmayer <peter.speckmayer@cern.ch> - CERN, Switzerland *; 17 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 18 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 19 * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; 20 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 21 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 22 * *; 23 * Copyright (c) 2005-2011: *; 24 * CERN, Switzerland *; 25 * U. of Victoria, Canada *; 26 * MPI-K Heidelberg, Germany *; 27 * U. of Bonn, Germany *; 28 * *; 29 * Redistribution and use in source and binary forms, with or without *; 30 * modification, are permitted according to the terms listed in LICENSE *; 31 * (see tmva/doc/LICENSE) *; 32 **********************************************************************************/; 33 ; 34#ifndef ROOT_TMVA_Reader; 35#define ROOT_TMVA_Reader; 36 ; 37//////////////////////////////////////////////////////////////////////////; 38// //; 39// Reader //; 40// //; 41// Reader class to be used in the user application to interpret the //; 42// trained MVAs in an analysis context //; 43// //; 44/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/Reader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html
Integrability,integrat,integrated,". ROOT: tmva/tmva/inc/TMVA/Reader.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Reader.h. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : Reader *; 8 * *; 9 * *; 10 * Description: *; 11 * Reader class to be used in the user application to interpret the trained *; 12 * MVAs in an analysis context *; 13 * *; 14 * Authors (alphabetical order): *; 15 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 16 * Peter Speckmayer <peter.speckmayer@cern.ch> - CERN, Switzerland *; 17 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 18 * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; 19 * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; 20 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 21 * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; 22 * *; 23 * Copyright (c) 2005-2011: *; 24 * CERN, Switzerland *; 25 * U. of Victoria, Canada *; 26 * MPI-K Heidelberg, Germany *; 27 * U. of Bonn, Germany *; 28 * *; 29 * Redistribution and use in source and binary forms, with or without *; 30 * modification, are permitted according to the terms listed in LICENSE *; 31 * (see tmva/doc/LICENSE) *; 32 **********************************************************************************/; 33 ; 34#ifndef ROOT_TMVA_Reader; 35#define ROOT_TMVA_Reader; 36 ; 37//////////////////////////////////////////////////////////////////////////; 38// //; 39// Reader //; 40// //; 41// Reader class to be used in the user application to interpret the //; 42// trained MVAs in an analysis context //; 43// //; 44/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/Reader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html
Modifiability,variab,variables,"ed in LICENSE *; 31 * (see tmva/doc/LICENSE) *; 32 **********************************************************************************/; 33 ; 34#ifndef ROOT_TMVA_Reader; 35#define ROOT_TMVA_Reader; 36 ; 37//////////////////////////////////////////////////////////////////////////; 38// //; 39// Reader //; 40// //; 41// Reader class to be used in the user application to interpret the //; 42// trained MVAs in an analysis context //; 43// //; 44//////////////////////////////////////////////////////////////////////////; 45 ; 46#include ""TMVA/Configurable.h""; 47#include ""TMVA/Types.h""; 48#include ""TMVA/DataSetInfo.h""; 49#include ""TMVA/DataInputHandler.h""; 50#include ""TMVA/DataSetManager.h""; 51 ; 52#include <vector>; 53#include <map>; 54#include <stdexcept>; 55#include <string>; 56 ; 57namespace TMVA {; 58 ; 59 class IMethod;; 60 class MethodBase;; 61 class DataSetInfo;; 62 class MethodCuts;; 63 ; 64 class Reader : public Configurable {; 65 ; 66 public:; 67 ; 68 // without prior specification of variables; 69 Reader( const TString& theOption="""", Bool_t verbose = 0 );; 70 ; 71 // STL types; 72 Reader( std::vector<std::string>& varNames, const TString& theOption = """", Bool_t verbose = 0 );; 73 Reader( const std::string& varNames, const TString& theOption, Bool_t verbose = 0 ); // format: ""var1:var2:...""; 74 ; 75 // Root types; 76 Reader( std::vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0 );; 77 Reader( const TString& varNames, const TString& theOption, Bool_t verbose = 0 ); // format: ""var1:var2:...""; 78 ; 79 virtual ~Reader( void );; 80 ; 81 // book MVA method via weight file; 82 IMethod* BookMVA( const TString& methodTag, const TString& weightfile );; 83 IMethod* BookMVA( TMVA::Types::EMVA methodType, const char* xmlstr );; 84 IMethod* FindMVA( const TString& methodTag );; 85 ; 86 // returns the MVA response for given event; 87 Double_t EvaluateMVA( const std::vector<Float_t> &, const TString& methodTag, Double_t aux = 0 );; 88 Double_t Evalua",MatchSource.WIKI,doc/master/Reader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html
Security,access,accessors,"/ returns the MVA response for given event; 87 Double_t EvaluateMVA( const std::vector<Float_t> &, const TString& methodTag, Double_t aux = 0 );; 88 Double_t EvaluateMVA( const std::vector<Double_t>&, const TString& methodTag, Double_t aux = 0 );; 89 Double_t EvaluateMVA( MethodBase* method, Double_t aux = 0 );; 90 Double_t EvaluateMVA( const TString& methodTag, Double_t aux = 0 );; 91 ; 92 // returns error on MVA response for given event; 93 // NOTE: must be called AFTER ""EvaluateMVA(...)"" call !; 94 Double_t GetMVAError() const { return fMvaEventError; }; 95 Double_t GetMVAErrorLower() const { return fMvaEventError; }; 96 Double_t GetMVAErrorUpper() const { return fMvaEventErrorUpper; }; 97 ; 98 // regression response; 99 const std::vector< Float_t >& EvaluateRegression( const TString& methodTag, Double_t aux = 0 );; 100 const std::vector< Float_t >& EvaluateRegression( MethodBase* method, Double_t aux = 0 );; 101 Float_t EvaluateRegression( UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0 );; 102 ; 103 // multiclass response; 104 const std::vector< Float_t >& EvaluateMulticlass( const TString& methodTag, Double_t aux = 0 );; 105 const std::vector< Float_t >& EvaluateMulticlass( MethodBase* method, Double_t aux = 0 );; 106 Float_t EvaluateMulticlass( UInt_t clsNumber, const TString& methodTag, Double_t aux = 0 );; 107 ; 108 // probability and rarity accessors (see Users Guide for definition of Rarity); 109 Double_t GetProba ( const TString& methodTag, Double_t ap_sig=0.5, Double_t mvaVal=-9999999 );; 110 Double_t GetRarity( const TString& methodTag, Double_t mvaVal=-9999999 );; 111 ; 112 // accessors; 113 virtual const char* GetName() const { return ""Reader""; }; 114 Bool_t Verbose( void ) const { return fVerbose; }; 115 void SetVerbose( Bool_t v ) { fVerbose = v; }; 116 ; 117 const DataSetInfo& DataInfo() const { return fDataSetInfo; }; 118 DataSetInfo& DataInfo() { return fDataSetInfo; }; 119 ; 120 void AddVariable( const TString& expression, Float_t* ",MatchSource.WIKI,doc/master/Reader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html
Testability,log,logger,"Double_t mvaVal=-9999999 );; 111 ; 112 // accessors; 113 virtual const char* GetName() const { return ""Reader""; }; 114 Bool_t Verbose( void ) const { return fVerbose; }; 115 void SetVerbose( Bool_t v ) { fVerbose = v; }; 116 ; 117 const DataSetInfo& DataInfo() const { return fDataSetInfo; }; 118 DataSetInfo& DataInfo() { return fDataSetInfo; }; 119 ; 120 void AddVariable( const TString& expression, Float_t* );; 121 void AddVariable( const TString& expression, Int_t* );; 122 ; 123 void AddSpectator( const TString& expression, Float_t* );; 124 void AddSpectator( const TString& expression, Int_t* );; 125 ; 126 private:; 127 ; 128 DataSetManager* fDataSetManager; // DSMTEST; 129 ; 130 ; 131 TString GetMethodTypeFromFile( const TString& filename );; 132 ; 133 // this booking method is internal; 134 IMethod* BookMVA( Types::EMVA method, const TString& weightfile );; 135 ; 136 DataSetInfo fDataSetInfo; // the data set; 137 ; 138 DataInputHandler fDataInputHandler;; 139 ; 140 // Init Reader class; 141 void Init( void );; 142 ; 143 // Decode Constructor string (or TString) and fill variable name std::vector; 144 void DecodeVarNames( const std::string& varNames );; 145 void DecodeVarNames( const TString& varNames );; 146 ; 147 void DeclareOptions();; 148 ; 149 Bool_t fVerbose; ///< verbosity; 150 Bool_t fSilent; ///< silent mode; 151 Bool_t fColor; ///< color mode; 152 Bool_t fCalculateError; ///< error calculation mode; 153 ; 154 Double_t fMvaEventError; ///< per-event error returned by MVA; 155 Double_t fMvaEventErrorUpper; ///< per-event error returned by MVA; 156 ; 157 std::map<TString, IMethod*> fMethodMap; ///< map of methods; 158 ; 159 std::vector<Float_t> fTmpEvalVec; ///< temporary evaluation vector (if user input is v<double>); 160 ; 161 mutable MsgLogger* fLogger; ///<! message logger; 162 MsgLogger& Log() const { return *fLogger; }; 163 ; 164 ClassDef(Reader,0); // Interpret the trained MVAs in an analysis context; 165 };; 166 ; 167}; 168 ; 169#endif; Configurable.",MatchSource.WIKI,doc/master/Reader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html
Modifiability,variab,variable,". ROOT: tutorials/hist/rebin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rebin.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Rebin a variable bin-width histogram. ; This tutorial illustrates how to:; create a variable bin-width histogram with a binning such that the population per bin is about the same.; rebin a variable bin-width histogram into another one. ; #include ""TH1.h""; #include ""TCanvas.h""; void rebin() {; //create a fix bin histogram; TH1F *h = new TH1F(""h"",""test rebin"",100,-3,3);; Int_t nentries = 1000;; h->FillRandom(""gaus"",nentries);; Double_t xbins[1001];; Int_t k=0;; TAxis *axis = h->GetXaxis();; for (Int_t i=1;i<=100;i++) {; Int_t y = (Int_t)h->GetBinContent(i);; if (y <=0) continue;; Double_t dx = axis->GetBinWidth(i)/y;; Double_t xmin = axis->GetBinLowEdge(i);; for (Int_t j=0;j<y;j++) {; xbins[k] = xmin +j*dx;; k++;; }; }; xbins[k] = axis->GetXmax();; //create a variable bin-width histogram out of fix bin histogram; //new rebinned histogram should have about 10 entries per bin; TH1F *hnew = new TH1F(""hnew"",""rebinned"",k,xbins);; hnew->FillRandom(""gaus"",10*nentries);; ; //rebin hnew keeping only 50% of the bins; Double_t xbins2[501];; Int_t kk=0;; for (Int_t j=0;j<k;j+=2) {; xbins2[kk] = xbins[j];; kk++;; }; xbins2[kk] = xbins[k];; TH1F *hnew2 = (TH1F*)hnew->Rebin(kk,""hnew2"",xbins2);; ; //draw the 3 histograms; TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; c1->Divide(1,3);; c1->cd(1);; h->Draw();; c1->cd(2);; hnew->Draw();; c1->cd(3);; hnew2->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; nentriesint nentriesDefinition THbookFile.cxx:91; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t",MatchSource.WIKI,doc/master/rebin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rebin_8C.html
Testability,test,test,". ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rebin.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Rebin a variable bin-width histogram. ; This tutorial illustrates how to:; create a variable bin-width histogram with a binning such that the population per bin is about the same.; rebin a variable bin-width histogram into another one. ; #include ""TH1.h""; #include ""TCanvas.h""; void rebin() {; //create a fix bin histogram; TH1F *h = new TH1F(""h"",""test rebin"",100,-3,3);; Int_t nentries = 1000;; h->FillRandom(""gaus"",nentries);; Double_t xbins[1001];; Int_t k=0;; TAxis *axis = h->GetXaxis();; for (Int_t i=1;i<=100;i++) {; Int_t y = (Int_t)h->GetBinContent(i);; if (y <=0) continue;; Double_t dx = axis->GetBinWidth(i)/y;; Double_t xmin = axis->GetBinLowEdge(i);; for (Int_t j=0;j<y;j++) {; xbins[k] = xmin +j*dx;; k++;; }; }; xbins[k] = axis->GetXmax();; //create a variable bin-width histogram out of fix bin histogram; //new rebinned histogram should have about 10 entries per bin; TH1F *hnew = new TH1F(""hnew"",""rebinned"",k,xbins);; hnew->FillRandom(""gaus"",10*nentries);; ; //rebin hnew keeping only 50% of the bins; Double_t xbins2[501];; Int_t kk=0;; for (Int_t j=0;j<k;j+=2) {; xbins2[kk] = xbins[j];; kk++;; }; xbins2[kk] = xbins[k];; TH1F *hnew2 = (TH1F*)hnew->Rebin(kk,""hnew2"",xbins2);; ; //draw the 3 histograms; TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; c1->Divide(1,3);; c1->cd(1);; h->Draw();; c1->cd(2);; hnew->Draw();; c1->cd(3);; hnew2->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; nentriesint nentriesDefinition THbookFile.cxx:91; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn low edge of bin.Definition",MatchSource.WIKI,doc/master/rebin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rebin_8C.html
Modifiability,variab,variable,". ROOT: tutorials/hist/rebin.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rebin.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_hist; 3/// \notebook -js; 4/// Rebin a variable bin-width histogram.; 5///; 6/// This tutorial illustrates how to:; 7/// - create a variable bin-width histogram with a binning such; 8/// that the population per bin is about the same.; 9/// - rebin a variable bin-width histogram into another one.; 10///; 11/// \macro_image; 12/// \macro_code; 13///; 14/// \author Rene Brun; 15 ; 16#include ""TH1.h""; 17#include ""TCanvas.h""; 18void rebin() {; 19 //create a fix bin histogram; 20 TH1F *h = new TH1F(""h"",""test rebin"",100,-3,3);; 21 Int_t nentries = 1000;; 22 h->FillRandom(""gaus"",nentries);; 23 Double_t xbins[1001];; 24 Int_t k=0;; 25 TAxis *axis = h->GetXaxis();; 26 for (Int_t i=1;i<=100;i++) {; 27 Int_t y = (Int_t)h->GetBinContent(i);; 28 if (y <=0) continue;; 29 Double_t dx = axis->GetBinWidth(i)/y;; 30 Double_t xmin = axis->GetBinLowEdge(i);; 31 for (Int_t j=0;j<y;j++) {; 32 xbins[k] = xmin +j*dx;; 33 k++;; 34 }; 35 }; 36 xbins[k] = axis->GetXmax();; 37 //create a variable bin-width histogram out of fix bin histogram; 38 //new rebinned histogram should have about 10 entries per bin; 39 TH1F *hnew = new TH1F(""hnew"",""rebinned"",k,xbins);; 40 hnew->FillRandom(""gaus"",10*nentries);; 41 ; 42 //rebin hnew keeping only 50% of the bins; 43 Double_t xbins2[501];; 44 Int_t kk=0;; 45 for (Int_t j=0;j<k;j+=2) {; 46 xbins2[kk] = xbins[j];; 47 kk++;; 48 }; 49 xbins2[kk] = xbins[k];; 50 TH1F *hnew2 = (TH1F*)hnew->Rebin(kk,""hnew2"",xbins2);; 51 ; 52 //draw the 3 histograms; 53 TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; 54 c1->Divide(1,3);; 55 c1->cd(1);; 56 h->Draw();; 57 c1->cd(2);; 58 hnew->Draw();; 59 c1->cd(3);; 60 hnew2->Draw();; 61}; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; ",MatchSource.WIKI,doc/master/rebin_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rebin_8C_source.html
Testability,test,test,"-width histogram.; 5///; 6/// This tutorial illustrates how to:; 7/// - create a variable bin-width histogram with a binning such; 8/// that the population per bin is about the same.; 9/// - rebin a variable bin-width histogram into another one.; 10///; 11/// \macro_image; 12/// \macro_code; 13///; 14/// \author Rene Brun; 15 ; 16#include ""TH1.h""; 17#include ""TCanvas.h""; 18void rebin() {; 19 //create a fix bin histogram; 20 TH1F *h = new TH1F(""h"",""test rebin"",100,-3,3);; 21 Int_t nentries = 1000;; 22 h->FillRandom(""gaus"",nentries);; 23 Double_t xbins[1001];; 24 Int_t k=0;; 25 TAxis *axis = h->GetXaxis();; 26 for (Int_t i=1;i<=100;i++) {; 27 Int_t y = (Int_t)h->GetBinContent(i);; 28 if (y <=0) continue;; 29 Double_t dx = axis->GetBinWidth(i)/y;; 30 Double_t xmin = axis->GetBinLowEdge(i);; 31 for (Int_t j=0;j<y;j++) {; 32 xbins[k] = xmin +j*dx;; 33 k++;; 34 }; 35 }; 36 xbins[k] = axis->GetXmax();; 37 //create a variable bin-width histogram out of fix bin histogram; 38 //new rebinned histogram should have about 10 entries per bin; 39 TH1F *hnew = new TH1F(""hnew"",""rebinned"",k,xbins);; 40 hnew->FillRandom(""gaus"",10*nentries);; 41 ; 42 //rebin hnew keeping only 50% of the bins; 43 Double_t xbins2[501];; 44 Int_t kk=0;; 45 for (Int_t j=0;j<k;j+=2) {; 46 xbins2[kk] = xbins[j];; 47 kk++;; 48 }; 49 xbins2[kk] = xbins[k];; 50 TH1F *hnew2 = (TH1F*)hnew->Rebin(kk,""hnew2"",xbins2);; 51 ; 52 //draw the 3 histograms; 53 TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; 54 c1->Divide(1,3);; 55 c1->cd(1);; 56 h->Draw();; 57 c1->cd(2);; 58 hnew->Draw();; 59 c1->cd(3);; 60 hnew2->Draw();; 61}; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; nentriesint nentriesDefinition THbookFile.cxx:91; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::GetBinLowEdgevirtual Double_",MatchSource.WIKI,doc/master/rebin_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rebin_8C_source.html
Deployability,configurat,configuration,"e::RElement::GetTitlevirtual std::string GetTitle() constTitle of browsable (optional)Definition RElement.hxx:71; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::GetPathAsStringstatic std::string GetPathAsString(const RElementPath_t &path)Converts element path back to string.Definition RElement.cxx:160; ROOT::Browsable::RElement::GetSubElementstatic std::shared_ptr< RElement > GetSubElement(std::shared_ptr< RElement > &elem, const RElementPath_t &path)Returns sub element.Definition RElement.cxx:69; ROOT::Browsable::RElement::CreateItemvirtual std::unique_ptr< RItem > CreateItem() constReturns item with element description.Definition RElement.cxx:105; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; TBufferJSON::ConvertToJSONstatic TString ConvertToJSON(const TObject *obj, Int_t compact=0, const char *member_name=nullptr)Converts object, inherited from TObject class, to JSON string Lower digit of compact parameter define...Definition TBufferJSON.cxx:522; TString::Dataconst char * Data() constDefinition TString.h:376; nconst Int_t nDefinition legend1.C:16; ROOT::BrowsableDefinition RAnyObjectHolder.hxx:15; ROOT::Browsable::RElementPath_tstd::vector< std::string > RElementPath_tDefinition RElement.hxx:20; ROOT::BrowsableLogROOT::Experimental::RLogChannel & BrowsableLog()Log channel for Browsable diagnostics.Definition RElement.cxx:20; slashTCanvas * slash()Definition slash.C:1. guibrowsablesrcRElement.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RElement_8cxx_source.html
Integrability,depend,depends,"tract index from name; 175/// Index coded by client with `###<indx>$$$` suffix; 176/// Such coding used by browser to identify element by index; 177 ; 178int RElement::ExtractItemIndex(std::string &name); 179{; 180 auto p1 = name.rfind(""###""), p2 = name.rfind(""$$$"");; 181 if ((p1 == std::string::npos) || (p2 == std::string::npos) || (p1 >= p2) || (p2 != name.length()-3)) return -1;; 182 ; 183 int indx = std::stoi(name.substr(p1+3,p2-p1-3));; 184 name.resize(p1);; 185 return indx;; 186}; RElement.hxx; RItem.hxx; RLevelIter.hxx; RLogger.hxx; TBufferJSON.h; namechar name[80]Definition TGX11.cxx:110; ROOT::Browsable::RElement::GetNamevirtual std::string GetName() const =0Name of browsable, must be provided in derived classes.; ROOT::Browsable::RElement::GetContentKindstatic EContentKind GetContentKind(const std::string &kind)Find item with specified name Default implementation, should work for all.Definition RElement.cxx:52; ROOT::Browsable::RElement::GetContentvirtual std::string GetContent(const std::string &=""text"")Returns element content, depends from kind.Definition RElement.cxx:90; ROOT::Browsable::RElement::EContentKindEContentKindDefinition RElement.hxx:37; ROOT::Browsable::RElement::kFileName@ kFileName""filename"" - file name if applicableDefinition RElement.hxx:44; ROOT::Browsable::RElement::kNone@ kNonenot recognizedDefinition RElement.hxx:38; ROOT::Browsable::RElement::kJpeg@ kJpeg""jpg"" or ""jpeg"" - plain jpg binary code, returned inside std::stringDefinition RElement.hxx:42; ROOT::Browsable::RElement::kPng@ kPng""png"" - plain png binary code, returned inside std::stringDefinition RElement.hxx:41; ROOT::Browsable::RElement::kJson@ kJson""json"" representation of object, can be used in code editorDefinition RElement.hxx:43; ROOT::Browsable::RElement::kText@ kText""text"" - plain text for code editorDefinition RElement.hxx:39; ROOT::Browsable::RElement::kImage@ kImage""image64"" - base64 for supported image formats (png/gif/gpeg)Definition RElement.hxx:40; ROOT::Browsa",MatchSource.WIKI,doc/master/RElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RElement_8cxx_source.html
Modifiability,config,configuration,"e::RElement::GetTitlevirtual std::string GetTitle() constTitle of browsable (optional)Definition RElement.hxx:71; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::GetPathAsStringstatic std::string GetPathAsString(const RElementPath_t &path)Converts element path back to string.Definition RElement.cxx:160; ROOT::Browsable::RElement::GetSubElementstatic std::shared_ptr< RElement > GetSubElement(std::shared_ptr< RElement > &elem, const RElementPath_t &path)Returns sub element.Definition RElement.cxx:69; ROOT::Browsable::RElement::CreateItemvirtual std::unique_ptr< RItem > CreateItem() constReturns item with element description.Definition RElement.cxx:105; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; TBufferJSON::ConvertToJSONstatic TString ConvertToJSON(const TObject *obj, Int_t compact=0, const char *member_name=nullptr)Converts object, inherited from TObject class, to JSON string Lower digit of compact parameter define...Definition TBufferJSON.cxx:522; TString::Dataconst char * Data() constDefinition TString.h:376; nconst Int_t nDefinition legend1.C:16; ROOT::BrowsableDefinition RAnyObjectHolder.hxx:15; ROOT::Browsable::RElementPath_tstd::vector< std::string > RElementPath_tDefinition RElement.hxx:20; ROOT::BrowsableLogROOT::Experimental::RLogChannel & BrowsableLog()Log channel for Browsable diagnostics.Definition RElement.cxx:20; slashTCanvas * slash()Definition slash.C:1. guibrowsablesrcRElement.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RElement_8cxx_source.html
Safety,avoid,avoid,"th_t &path); 70{; 71 auto curr = elem;; 72 ; 73 for (auto &itemname : path) {; 74 if (!curr); 75 return nullptr;; 76 ; 77 auto iter = curr->GetChildsIter();; 78 if (!iter || !iter->Find(itemname)); 79 return nullptr;; 80 ; 81 curr = iter->GetElement();; 82 }; 83 ; 84 return curr;; 85}; 86 ; 87/////////////////////////////////////////////////////////////////////; 88/// Returns string content like text file content or json representation; 89 ; 90std::string RElement::GetContent(const std::string &kind); 91{; 92 if (GetContentKind(kind) == kJson) {; 93 auto obj = GetObject();; 94 if (obj); 95 return TBufferJSON::ConvertToJSON(obj->GetObject(), obj->GetClass()).Data();; 96 }; 97 ; 98 return """"s;; 99}; 100 ; 101 ; 102/////////////////////////////////////////////////////////////////////; 103/// Returns item with element description; 104 ; 105std::unique_ptr<RItem> RElement::CreateItem() const; 106{; 107 auto item = std::make_unique<RItem>(GetName());; 108 item->SetTitle(GetTitle());; 109 return item;; 110}; 111 ; 112/////////////////////////////////////////////////////////////////////; 113/// Parse string path to produce RElementPath_t; 114/// One should avoid to use string pathes as much as possible; 115 ; 116RElementPath_t RElement::ParsePath(const std::string &strpath); 117{; 118 RElementPath_t arr;; 119 if (strpath.empty()); 120 return arr;; 121 ; 122 std::string slash = ""/"";; 123 ; 124 std::string::size_type previous = 0;; 125 if (strpath[0] == slash[0]) previous++;; 126 ; 127 auto current = strpath.find(slash, previous);; 128 while (current != std::string::npos) {; 129 if (current > previous); 130 arr.emplace_back(strpath.substr(previous, current - previous));; 131 previous = current + 1;; 132 current = strpath.find(slash, previous);; 133 }; 134 ; 135 if (previous < strpath.length()); 136 arr.emplace_back(strpath.substr(previous));; 137 ; 138 return arr;; 139}; 140 ; 141/////////////////////////////////////////////////////////////////////; 142/// Compare two paths,; ",MatchSource.WIKI,doc/master/RElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RElement_8cxx_source.html
Testability,log,log,"e::RElement::GetTitlevirtual std::string GetTitle() constTitle of browsable (optional)Definition RElement.hxx:71; ROOT::Browsable::RElement::ComparePathsstatic int ComparePaths(const RElementPath_t &path1, const RElementPath_t &path2)Compare two paths, Returns number of elements matches in both paths.Definition RElement.cxx:145; ROOT::Browsable::RElement::GetPathAsStringstatic std::string GetPathAsString(const RElementPath_t &path)Converts element path back to string.Definition RElement.cxx:160; ROOT::Browsable::RElement::GetSubElementstatic std::shared_ptr< RElement > GetSubElement(std::shared_ptr< RElement > &elem, const RElementPath_t &path)Returns sub element.Definition RElement.cxx:69; ROOT::Browsable::RElement::CreateItemvirtual std::unique_ptr< RItem > CreateItem() constReturns item with element description.Definition RElement.cxx:105; ROOT::Browsable::RElement::ParsePathstatic RElementPath_t ParsePath(const std::string &str)Parse string path to produce RElementPath_t One should avoid to use string pathes as much as possible...Definition RElement.cxx:116; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; TBufferJSON::ConvertToJSONstatic TString ConvertToJSON(const TObject *obj, Int_t compact=0, const char *member_name=nullptr)Converts object, inherited from TObject class, to JSON string Lower digit of compact parameter define...Definition TBufferJSON.cxx:522; TString::Dataconst char * Data() constDefinition TString.h:376; nconst Int_t nDefinition legend1.C:16; ROOT::BrowsableDefinition RAnyObjectHolder.hxx:15; ROOT::Browsable::RElementPath_tstd::vector< std::string > RElementPath_tDefinition RElement.hxx:20; ROOT::BrowsableLogROOT::Experimental::RLogChannel & BrowsableLog()Log channel for Browsable diagnostics.Definition RElement.cxx:20; slashTCanvas * slash()Definition slash.C:1. guibrowsablesrcRElement.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RElement_8cxx_source.html
Availability,error,errors,"ma);; ; // Construct plot frame in 'x'; RooPlot *xframe = x.frame(Title(""Gaussian pdf.""));; ; // P l o t m o d e l a n d c h a n g e p a r a m e t e r v a l u e s; // ---------------------------------------------------------------------------; ; // Plot gauss in frame (i.e. in x); gauss.plotOn(xframe);; ; // Change the value of sigma to 3; sigma.setVal(3);; ; // Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor(kRed));; ; // G e n e r a t e e v e n t s; // -----------------------------; ; // Generate a dataset of 1000 events in x from gauss; std::unique_ptr<RooDataSet> data{gauss.generate(x, 10000)};; ; // Make a second plot frame in x and draw both the; // data and the pdf in the frame; RooPlot *xframe2 = x.frame(Title(""Gaussian pdf with data""));; data->plotOn(xframe2);; gauss.plotOn(xframe2);; ; // F i t m o d e l t o d a t a; // -----------------------------; ; // Fit pdf to data; gauss.fitTo(*data, PrintLevel(-1));; ; // Print values of mean and sigma (that now reflect fitted values and errors); mean.Print();; sigma.Print();; ; // Draw all frames on a canvas; TCanvas *c = new TCanvas(""rf101_basics"", ""rf101_basics"", 800, 400); c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; xframe->GetYaxis()->SetTitleOffset(1.6);; xframe->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; xframe2->GetYaxis()->SetTitleOffset(1.6);; xframe2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(c",MatchSource.WIKI,doc/master/rf101__basics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf101__basics_8C.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf101_basics.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf101_basics.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: fitting, plotting, toy data generation on one-dimensional PDFs. ; pdf = gauss(x,m,s). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""RooPlot.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf101_basics(); {; // S e t u p m o d e l; // ---------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar mean(""mean"", ""mean of gaussian"", 1, -10, 10);; RooRealVar sigma(""sigma"", ""width of gaussian"", 1, 0.1, 10);; ; // Build gaussian pdf in terms of x,mean and sigma; RooGaussian gauss(""gauss"", ""gaussian PDF"", x, mean, sigma);; ; // Construct plot frame in 'x'; RooPlot *xframe = x.frame(Title(""Gaussian pdf.""));; ; // P l o t m o d e l a n d c h a n g e p a r a m e t e r v a l u e s; // ---------------------------------------------------------------------------; ; // Plot gauss in frame (i.e. in x); gauss.plotOn(xframe);; ; // Change the value of sigma to 3; sigma.setVal(3);; ; // Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor(kRed));; ; // G e n e r a t e e v e n t s; // -----------------------------; ; // Generate a dataset of 1000 events in x from gauss; std::unique_ptr<RooDataSet> data{gauss.generate(x, 10000)};; ; // Make a second plot frame in x and draw both the; // data and the pdf in the frame; RooPlot *xframe2 = x.frame(Title(""Gaussian pdf with data""));; data->plotOn(xframe2);; gauss.plotOn(xframe2);; ; // F i t m o d e l t o d a t a; // -----------------------------; ; // Fit pdf to data; gauss.fitTo(*data, PrintLevel(-1));; ; // Print values of mean and sigma (that now reflect fitted values and errors); mean.Print();; sigm",MatchSource.WIKI,doc/master/rf101__basics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf101__basics_8C.html
Performance,optimiz,optimization,"efinition TVirtualPad.h:308; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf101_basicsDefinition rf101_basics.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::mean = 1.01746 +/- 0.0300144 L(-10 - 10) ; RooRealVar::sigma = 2.9787 +/- 0.0219217 L(0.1 - 10) ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf101_basics.C. tutorialsroofitrf101_basics.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf101__basics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf101__basics_8C.html
Availability,error,errors,"terms of x,mean and sigma; gauss = ROOT.RooGaussian(""gauss"", ""gaussian PDF"", x, mean, sigma); ; # Construct plot frame in 'x'; xframe = x.frame(Title=""Gaussian pdf"") # RooPlot; ; # Plot model and change parameter values; # ---------------------------------------------------------------------------; # Plot gauss in frame (i.e. in x); gauss.plotOn(xframe); ; # Change the value of sigma to 3; sigma.setVal(3); ; # Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor=""r""); ; # Generate events; # -----------------------------; # Generate a dataset of 1000 events in x from gauss; data = gauss.generate({x}, 10000) # ROOT.RooDataSet; ; # Make a second plot frame in x and draw both the; # data and the pdf in the frame; xframe2 = x.frame(Title=""Gaussian pdf with data"") # RooPlot; data.plotOn(xframe2); gauss.plotOn(xframe2); ; # Fit model to data; # -----------------------------; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Print values of mean and sigma (that now reflect fitted values and; # errors); mean.Print(); sigma.Print(); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf101_basics"", ""rf101_basics"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.6); xframe2.Draw(); ; c.SaveAs(""rf101_basics.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::mean = 1.01746 +/- 0.0300",MatchSource.WIKI,doc/master/rf101__basics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf101__basics_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf101_basics.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf101_basics.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial illustrates the basic features of RooFit. . ; import ROOT; ; # Set up model; # ---------------------; # Declare variables x,mean,sigma with associated name, title, initial; # value and allowed range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); mean = ROOT.RooRealVar(""mean"", ""mean of gaussian"", 1, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 1, 0.1, 10); ; # Build gaussian pdf in terms of x,mean and sigma; gauss = ROOT.RooGaussian(""gauss"", ""gaussian PDF"", x, mean, sigma); ; # Construct plot frame in 'x'; xframe = x.frame(Title=""Gaussian pdf"") # RooPlot; ; # Plot model and change parameter values; # ---------------------------------------------------------------------------; # Plot gauss in frame (i.e. in x); gauss.plotOn(xframe); ; # Change the value of sigma to 3; sigma.setVal(3); ; # Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor=""r""); ; # Generate events; # -----------------------------; # Generate a dataset of 1000 events in x from gauss; data = gauss.generate({x}, 10000) # ROOT.RooDataSet; ; # Make a second plot frame in x and draw both the; # data and the pdf in the frame; xframe2 = x.frame(Title=""Gaussian pdf with data"") # RooPlot; data.plotOn(xframe2); gauss.plotOn(xframe2); ; # Fit model to data; # -----------------------------; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Print values of mean and sigma (that now reflect fitted values and; # errors); mean.Print(); sigma.Print(); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf101_basics"", ""rf101_basics"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1",MatchSource.WIKI,doc/master/rf101__basics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf101__basics_8py.html
Performance,optimiz,optimization,"me (i.e. in x); gauss.plotOn(xframe); ; # Change the value of sigma to 3; sigma.setVal(3); ; # Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor=""r""); ; # Generate events; # -----------------------------; # Generate a dataset of 1000 events in x from gauss; data = gauss.generate({x}, 10000) # ROOT.RooDataSet; ; # Make a second plot frame in x and draw both the; # data and the pdf in the frame; xframe2 = x.frame(Title=""Gaussian pdf with data"") # RooPlot; data.plotOn(xframe2); gauss.plotOn(xframe2); ; # Fit model to data; # -----------------------------; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Print values of mean and sigma (that now reflect fitted values and; # errors); mean.Print(); sigma.Print(); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf101_basics"", ""rf101_basics"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.6); xframe2.Draw(); ; c.SaveAs(""rf101_basics.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::mean = 1.01746 +/- 0.0300144 L(-10 - 10) ; RooRealVar::sigma = 2.9787 +/- 0.0219217 L(0.1 - 10) ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf101_basics.py. tutorialsroofitrf101_basics.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf101__basics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf101__basics_8py.html
Availability,error,error,". ROOT: tutorials/roofit/rf102_dataimport.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf102_dataimport.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: importing data from ROOT TTrees and THx histograms. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""RooPlot.h""; #include ""TTree.h""; #include ""TH1D.h""; #include ""TRandom.h""; using namespace RooFit;; ; TH1 *makeTH1();; TTree *makeTTree();; ; void rf102_dataimport(); {; // ---------------------------------------------------; // I m p o r t i n g R O O T h i s t o g r a m s; // ===================================================; ; // I m p o r t T H 1 i n t o a R o o D a t a H i s t; // ---------------------------------------------------------; ; // Create a ROOT TH1 histogram; TH1 *hh = makeTH1();; ; // Declare observable x; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create a binned dataset that imports contents of TH1 and associates its contents to observable 'x'; RooDataHist dh(""dh"", ""dh"", x, Import(*hh));; ; // P l o t a n d f i t a R o o D a t a H i s t; // ---------------------------------------------------; ; // Make plot of binned dataset showing Poisson error bars (RooFit default); RooPlot *frame = x.frame(Title(""Imported TH1 with Poisson error bars""));; dh.plotOn(frame);; ; // Fit a Gaussian pdf to the data; RooRealVar mean(""mean"", ""mean"", 0, -10, 10);; RooRealVar sigma(""sigma"", ""sigma"", 3, 0.1, 10);; RooGaussian gauss(""gauss"", ""gauss"", x, mean, sigma);; gauss.fitTo(dh, PrintLevel(-1));; gauss.plotOn(frame);; ; // P l o t a n d f i t a R o o D a t a H i s t w i t h i n t e r n a l e r r o r s; // ---------------------------------------------------------------------------------------------; ; // If histogram has custom error (i.e. its contents is does not originate from a Poisson process; // but e.g. is a sum of weighted events) you c",MatchSource.WIKI,doc/master/rf102__dataimport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html
Integrability,message,message,"mported. Since the y values in the import tree are in the range [-15,15]; // and RRV y defines a range [-10,10] this means that the RooDataSet below will have less entries than the TTree; // 'tree'; ; RooDataSet ds(""ds"", ""ds"", RooArgSet(x, y), Import(*tree));; ; // U s e a s c i i i m p o r t / e x p o r t f o r d a t a s e t s; // ------------------------------------------------------------------------------------; {; // Write data to output stream; std::ofstream outstream(""rf102_testData.txt"");; // Optionally, adjust the stream here (e.g. std::setprecision); ds.write(outstream);; outstream.close();; }; ; // Read data from input stream. The variables of the dataset need to be supplied; // to the RooDataSet::read() function.; std::cout << ""\n-----------------------\nReading data from ASCII\n"";; RooDataSet *dataReadBack =; RooDataSet::read(""rf102_testData.txt"",; RooArgList(x, y), // variables to be read. If the file has more fields, these are ignored.; ""D""); // Prints if a RooFit message stream listens for debug messages. Use Q for quiet.; ; dataReadBack->Print(""V"");; ; std::cout << ""\nOriginal data, line 20:\n"";; ds.get(20)->Print(""V"");; ; std::cout << ""\nRead-back data, line 20:\n"";; dataReadBack->get(20)->Print(""V"");; ; // P l o t d a t a s e t s w i t h m u l t i p l e b i n n i n g c h o i c e s; // ------------------------------------------------------------------------------------; ; // Print number of events in dataset; ds.Print();; ; // Print unbinned dataset with default frame binning (100 bins); RooPlot *frame3 = y.frame(Title(""Unbinned data shown in default frame binning""));; ds.plotOn(frame3);; ; // Print unbinned dataset with custom binning choice (20 bins); RooPlot *frame4 = y.frame(Title(""Unbinned data shown with custom binning""));; ds.plotOn(frame4, Binning(20));; ; RooPlot *frame5 = y.frame(Title(""Unbinned data read back from ASCII file""));; ds.plotOn(frame5, Binning(20));; dataReadBack->plotOn(frame5, Binning(20), MarkerColor(kRed), MarkerStyle(5))",MatchSource.WIKI,doc/master/rf102__dataimport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html
Modifiability,variab,variables,"le y; RooRealVar y(""y"", ""y"", -10, 10);; ; // Construct unbinned dataset importing tree branches x and y matching between branches and RooRealVars; // is done by name of the branch/RRV; //; // Note that ONLY entries for which x,y have values within their allowed ranges as defined in; // RooRealVar x and y are imported. Since the y values in the import tree are in the range [-15,15]; // and RRV y defines a range [-10,10] this means that the RooDataSet below will have less entries than the TTree; // 'tree'; ; RooDataSet ds(""ds"", ""ds"", RooArgSet(x, y), Import(*tree));; ; // U s e a s c i i i m p o r t / e x p o r t f o r d a t a s e t s; // ------------------------------------------------------------------------------------; {; // Write data to output stream; std::ofstream outstream(""rf102_testData.txt"");; // Optionally, adjust the stream here (e.g. std::setprecision); ds.write(outstream);; outstream.close();; }; ; // Read data from input stream. The variables of the dataset need to be supplied; // to the RooDataSet::read() function.; std::cout << ""\n-----------------------\nReading data from ASCII\n"";; RooDataSet *dataReadBack =; RooDataSet::read(""rf102_testData.txt"",; RooArgList(x, y), // variables to be read. If the file has more fields, these are ignored.; ""D""); // Prints if a RooFit message stream listens for debug messages. Use Q for quiet.; ; dataReadBack->Print(""V"");; ; std::cout << ""\nOriginal data, line 20:\n"";; ds.get(20)->Print(""V"");; ; std::cout << ""\nRead-back data, line 20:\n"";; dataReadBack->get(20)->Print(""V"");; ; // P l o t d a t a s e t s w i t h m u l t i p l e b i n n i n g c h o i c e s; // ------------------------------------------------------------------------------------; ; // Print number of events in dataset; ds.Print();; ; // Print unbinned dataset with default frame binning (100 bins); RooPlot *frame3 = y.frame(Title(""Unbinned data shown in default frame binning""));; ds.plotOn(frame3);; ; // Print unbinned dataset with custom binning choice (",MatchSource.WIKI,doc/master/rf102__dataimport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html
Performance,optimiz,optimization,"Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf102_dataimportDefinition rf102_dataimport.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; ; -----------------------; Reading data from ASCII; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_",MatchSource.WIKI,doc/master/rf102__dataimport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html
Availability,error,error,"25, -10, 10); for i in range(100):; hh.Fill(ROOT.gRandom.Gaus(0, 3)); return hh; ; ; def makeTTree():; # Create ROOT ROOT.TTree filled with a Gaussian distribution in x and a; # uniform distribution in y; ; tree = ROOT.TTree(""tree"", ""tree""); px = array(""d"", [0]); py = array(""d"", [0]); tree.Branch(""x"", px, ""x/D""); tree.Branch(""y"", py, ""y/D""); for i in range(100):; px[0] = ROOT.gRandom.Gaus(0, 3); py[0] = ROOT.gRandom.Uniform() * 30 - 15; tree.Fill(); return tree; ; ; ############################; # Importing ROOT histograms; ############################; # Import ROOT TH1 into a RooDataHist; # ---------------------------------------------------------; # Create a ROOT TH1 histogram; hh = makeTH1(); ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create a binned dataset that imports contents of ROOT.TH1 and associates; # its contents to observable 'x'; dh = ROOT.RooDataHist(""dh"", ""dh"", [x], Import=hh); ; # Plot and fit a RooDataHist; # ---------------------------------------------------; # Make plot of binned dataset showing Poisson error bars (RooFit default); frame = x.frame(Title=""Imported ROOT.TH1 with Poisson error bars""); dh.plotOn(frame); ; # Fit a Gaussian p.d.f to the data; mean = ROOT.RooRealVar(""mean"", ""mean"", 0, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 3, 0.1, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mean, sigma); gauss.fitTo(dh, PrintLevel=-1); gauss.plotOn(frame); ; # Plot and fit a RooDataHist with internal errors; # ---------------------------------------------------------------------------------------------; ; # If histogram has custom error (i.e. its contents is does not originate from a Poisson process; # but e.g. is a sum of weighted events) you can data with symmetric 'sum-of-weights' error instead; # (same error bars as shown by ROOT); frame2 = x.frame(Title=""Imported ROOT.TH1 with internal errors""); dh.plotOn(frame2, DataError=""SumW2""); gauss.plotOn(frame2); ; # Please note that error bars shown (Poisson ",MatchSource.WIKI,doc/master/rf102__dataimport_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html
Integrability,message,message,"ince the y values in the import tree are in the range [-15,15]; # and RRV y defines a range [-10,10] this means that the ROOT.RooDataSet; # below will have less entries than the ROOT.TTree 'tree'; ; ds = ROOT.RooDataSet(""ds"", ""ds"", {x, y}, Import=tree); ; # Use ascii import/export for datasets; # ------------------------------------------------------------------------------------; ; ; def write_dataset(ds, filename):; # Write data to output stream; outstream = ROOT.std.ofstream(filename); # Optionally, adjust the stream here (e.g. std::setprecision); ds.write(outstream); outstream.close(); ; ; write_dataset(ds, ""rf102_testData.txt""); ; # Read data from input stream. The variables of the dataset need to be supplied; # to the RooDataSet::read() function.; print(""\n-----------------------\nReading data from ASCII""); dataReadBack = ROOT.RooDataSet.read(; ""rf102_testData.txt"",; [x, y], # variables to be read. If the file has more fields, these are ignored.; ""D"", # Prints if a RooFit message stream listens for debug messages. Use Q for quiet.; ); ; dataReadBack.Print(""V""); ; print(""\nOriginal data, line 20:""); ds.get(20).Print(""V""); ; print(""\nRead-back data, line 20:""); dataReadBack.get(20).Print(""V""); ; ; # Plot data set with multiple binning choices; # ------------------------------------------------------------------------------------; # Print number of events in dataset; ds.Print(); ; # Print unbinned dataset with default frame binning (100 bins); frame3 = y.frame(Title=""Unbinned data shown in default frame binning""); ds.plotOn(frame3); ; # Print unbinned dataset with custom binning choice (20 bins); frame4 = y.frame(Title=""Unbinned data shown with custom binning""); ds.plotOn(frame4, Binning=20); ; frame5 = y.frame(Title=""Unbinned data read back from ASCII file""); ds.plotOn(frame5, Binning=20); dataReadBack.plotOn(frame5, Binning=20, MarkerColor=""r"", MarkerStyle=5); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf102_dataimport"", ""rf102_dataimport"", 800, 800); c",MatchSource.WIKI,doc/master/rf102__dataimport_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html
Modifiability,variab,variables,"Construct unbinned dataset importing tree branches x and y matching between branches and ROOT.RooRealVars; # is done by name of the branch/RRV; #; # Note that ONLY entries for which x,y have values within their allowed ranges as defined in; # ROOT.RooRealVar x and y are imported. Since the y values in the import tree are in the range [-15,15]; # and RRV y defines a range [-10,10] this means that the ROOT.RooDataSet; # below will have less entries than the ROOT.TTree 'tree'; ; ds = ROOT.RooDataSet(""ds"", ""ds"", {x, y}, Import=tree); ; # Use ascii import/export for datasets; # ------------------------------------------------------------------------------------; ; ; def write_dataset(ds, filename):; # Write data to output stream; outstream = ROOT.std.ofstream(filename); # Optionally, adjust the stream here (e.g. std::setprecision); ds.write(outstream); outstream.close(); ; ; write_dataset(ds, ""rf102_testData.txt""); ; # Read data from input stream. The variables of the dataset need to be supplied; # to the RooDataSet::read() function.; print(""\n-----------------------\nReading data from ASCII""); dataReadBack = ROOT.RooDataSet.read(; ""rf102_testData.txt"",; [x, y], # variables to be read. If the file has more fields, these are ignored.; ""D"", # Prints if a RooFit message stream listens for debug messages. Use Q for quiet.; ); ; dataReadBack.Print(""V""); ; print(""\nOriginal data, line 20:""); ds.get(20).Print(""V""); ; print(""\nRead-back data, line 20:""); dataReadBack.get(20).Print(""V""); ; ; # Plot data set with multiple binning choices; # ------------------------------------------------------------------------------------; # Print number of events in dataset; ds.Print(); ; # Print unbinned dataset with default frame binning (100 bins); frame3 = y.frame(Title=""Unbinned data shown in default frame binning""); ds.plotOn(frame3); ; # Print unbinned dataset with custom binning choice (20 bins); frame4 = y.frame(Title=""Unbinned data shown with custom binning""); ds.plotOn(frame4, Binnin",MatchSource.WIKI,doc/master/rf102__dataimport_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html
Performance,optimiz,optimization,"TCanvas(""rf102_dataimport"", ""rf102_dataimport"", 800, 800); c.Divide(3, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(5); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame4.Draw(); c.cd(6); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame5.Draw(); ; c.SaveAs(""rf102_dataimport.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::r",MatchSource.WIKI,doc/master/rf102__dataimport_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html
Availability,error,error,"stly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf103_interprfuncsDefinition rf103_interprfuncs.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; ------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html
Deployability,integrat,integrator,"stly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf103_interprfuncsDefinition rf103_interprfuncs.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; ------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html
Integrability,integrat,integrator,"stly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf103_interprfuncsDefinition rf103_interprfuncs.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; ------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html
Modifiability,variab,variable,":101; RooDataSet.h; RooFitResult.h; RooGaussian.h; RooGenericPdf.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooGenericPdfImplementation of a probability density function that takes a RooArgList of servers and a C++ express...Definition RooGenericPdf.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf103_interprfunc",MatchSource.WIKI,doc/master/rf103__interprfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html
Performance,optimiz,optimization,"stly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf103_interprfuncsDefinition rf103_interprfuncs.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; ------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html
Availability,error,error,"SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf103_interprfuncs.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8py.html
Deployability,integrat,integrator,"SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf103_interprfuncs.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8py.html
Integrability,integrat,integrator,"SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf103_interprfuncs.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8py.html
Performance,optimiz,optimization,"SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf103_interprfuncs.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------",MatchSource.WIKI,doc/master/rf103__interprfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8py.html
Availability,error,error,"itThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[y]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(GenPdf_over_GenPdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_GenPdf_over_GenPdf_Int[x]_GenPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf104_classfactory.C. tutorialsroofitrf104_classfactory.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf104__classfactory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html
Deployability,integrat,integrator,"itThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[y]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(GenPdf_over_GenPdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_GenPdf_over_GenPdf_Int[x]_GenPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf104_classfactory.C. tutorialsroofitrf104_classfactory.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf104__classfactory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html
Integrability,interface,interface,"sion of pdf of rf103""));; data2->plotOn(frame2);; genpdf->plotOn(frame2);; ; // Draw all frames on a canvas; TCanvas *c = new TCanvas(""rf104_classfactory"", ""rf104_classfactory"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooClassFactory.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooArgSetRooArgSet is a ",MatchSource.WIKI,doc/master/rf104__classfactory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html
Modifiability,variab,variable,". ROOT: tutorials/roofit/rf104_classfactory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf104_classfactory.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: The class factory for functions and pdfs ; NOTE: This demo uses code that is generated by the macro, therefore it cannot be compiled in one step by ACliC. To run this macro compiled with ACliC do; root>.x rf104_classfactory.C // run interpreted to generate code; root>.L MyPdfV3.cxx+ // Compile and load created class; root>.x rf104_classfactory.C+ // run compiled code; rf104_classfactoryDefinition rf104_classfactory.py:1. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooClassFactory.h""; #include ""TROOT.h""; ; using namespace RooFit;; ; void rf104_classfactory(); {; // W r i t e c l a s s s k e l e t o n c o d e; // --------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b; // To use this class,; // - Edit the file MyPdfV1.cxx and implement the evaluate() method in terms of x,a and b; // - Compile and link class with '.x MyPdfV1.cxx+'; //; RooClassFactory::makePdf(""MyPdfV1"", ""x,A,B"");; ; // W i t h a d d e d i n i t i a l v a l u e e x p r e s s i o n; // ---------------------------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b and given formula expression; // To use this class,; // - Compile and link class with '.x MyPdfV2.cxx+'; //; RooClassFactory::makePdf(""MyPdfV2"", ""x,A,B"", """", ""A*fabs(x)+pow(x-B,2)"");; ; // W i t h a d d e d a n a l y t i c a l i n t e g r a l e x p r e s s i o n; // ---------------------------------------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b, given formula expression _and_; // given expression for analytical integral over x; // To use this class,; // -",MatchSource.WIKI,doc/master/rf104__classfactory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html
Performance,load,load,". ROOT: tutorials/roofit/rf104_classfactory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf104_classfactory.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: The class factory for functions and pdfs ; NOTE: This demo uses code that is generated by the macro, therefore it cannot be compiled in one step by ACliC. To run this macro compiled with ACliC do; root>.x rf104_classfactory.C // run interpreted to generate code; root>.L MyPdfV3.cxx+ // Compile and load created class; root>.x rf104_classfactory.C+ // run compiled code; rf104_classfactoryDefinition rf104_classfactory.py:1. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooClassFactory.h""; #include ""TROOT.h""; ; using namespace RooFit;; ; void rf104_classfactory(); {; // W r i t e c l a s s s k e l e t o n c o d e; // --------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b; // To use this class,; // - Edit the file MyPdfV1.cxx and implement the evaluate() method in terms of x,a and b; // - Compile and link class with '.x MyPdfV1.cxx+'; //; RooClassFactory::makePdf(""MyPdfV1"", ""x,A,B"");; ; // W i t h a d d e d i n i t i a l v a l u e e x p r e s s i o n; // ---------------------------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b and given formula expression; // To use this class,; // - Compile and link class with '.x MyPdfV2.cxx+'; //; RooClassFactory::makePdf(""MyPdfV2"", ""x,A,B"", """", ""A*fabs(x)+pow(x-B,2)"");; ; // W i t h a d d e d a n a l y t i c a l i n t e g r a l e x p r e s s i o n; // ---------------------------------------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b, given formula expression _and_; // given expression for analytical integral over x; // To use this class,; // -",MatchSource.WIKI,doc/master/rf104__classfactory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html
Availability,error,error,"t(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf104_classfactory.png""); (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[y]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(GenPdf_over_GenPdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_GenPdf_over_GenPdf_Int[x]_GenPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf104_classfactory.py. tutorialsroofitrf104_classfactory.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf104__classfactory_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html
Deployability,integrat,integrator,"t(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf104_classfactory.png""); (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[y]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(GenPdf_over_GenPdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_GenPdf_over_GenPdf_Int[x]_GenPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf104_classfactory.py. tutorialsroofitrf104_classfactory.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf104__classfactory_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html
Integrability,integrat,integrator,"t(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf104_classfactory.png""); (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[y]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(GenPdf_over_GenPdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_GenPdf_over_GenPdf_Int[x]_GenPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf104_classfactory.py. tutorialsroofitrf104_classfactory.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf104__classfactory_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html
Modifiability,variab,variable,". ROOT: tutorials/roofit/rf104_classfactory.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf104_classfactory.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: the class factory for functions and pdfs ; NOTE: This demo uses code that is generated by the macro, which can be compiled on the fly (set to MyPdfV3 below). To use MyPdfV1 or MyPdfV2, adjust lines below accordingly. ; import ROOT; ; # Write class skeleton code; # --------------------------------------------------; ; # Write skeleton pdf class with variable x,a,b; # To use this class,; # - Edit the file MyPdfV1.cxx and implement the evaluate() method in terms of x,a and b; # - Compile and link class with '.x MyPdfV1.cxx+'; #; ROOT.RooClassFactory.makePdf(""MyPdfV1"", ""x,A,B""); ; # With added initial value expression; # ---------------------------------------------------------------------; ; # Write skeleton pdf class with variable x,a,b and given formula expression; # To use this class,; # - Compile and link class with '.x MyPdfV2.cxx+'; #; ROOT.RooClassFactory.makePdf(""MyPdfV2"", ""x,A,B"", """", ""A*fabs(x)+pow(x-B,2)""); ; # With added analytical integral expression; # ---------------------------------------------------------------------------------; ; # Write skeleton pdf class with variable x,a,b, given formula expression _and_; # given expression for analytical integral over x; # To use this class,; # - Compile and link class with '.x MyPdfV3.cxx+'; #; ROOT.RooClassFactory.makePdf(; ""MyPdfV3"",; ""x,A,B"",; """",; ""A*fabs(x)+pow(x-B,2)"",; True,; False,; ""x:(A/2)*(pow(x.max(rangeName),2)+pow(x.min(rangeName),2))+(1./3)*(pow(x.max(rangeName)-B,3)-pow(x.min(rangeName)-B,3))"",; ); ; # Use instance of created class; # ---------------------------------------------------------; ; # Compile MyPdfV3 class; ROOT.gROOT.ProcessLineSync("".x MyPdfV3.cxx+""); ; # Creat instance of MyPdfV3 class; a = ROOT.RooRealVar(""a"", ""a"", 1); ",MatchSource.WIKI,doc/master/rf104__classfactory_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html
Performance,perform,performs,"""A*fabs(x)+pow(x-B,2)"",; True,; False,; ""x:(A/2)*(pow(x.max(rangeName),2)+pow(x.min(rangeName),2))+(1./3)*(pow(x.max(rangeName)-B,3)-pow(x.min(rangeName)-B,3))"",; ); ; # Use instance of created class; # ---------------------------------------------------------; ; # Compile MyPdfV3 class; ROOT.gROOT.ProcessLineSync("".x MyPdfV3.cxx+""); ; # Creat instance of MyPdfV3 class; a = ROOT.RooRealVar(""a"", ""a"", 1); b = ROOT.RooRealVar(""b"", ""b"", 2, -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); pdf = ROOT.MyPdfV3(""pdf"", ""pdf"", y, a, b); ; # Generate toy data from pdf and plot data and pdf on frame; frame1 = y.frame(Title=""Compiled class MyPdfV3""); data = pdf.generate({y}, 1000); pdf.fitTo(data, PrintLevel=-1); data.plotOn(frame1); pdf.plotOn(frame1); ; # /; # C o m p i l e d v e r s i o n o f e x a m p l e r f 1 0 3 #; # /; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # The ROOT.RooClassFactory.makePdfInstance() function performs code writing, compiling, linking; # and object instantiation in one go and can serve as a straight; # replacement of ROOT.RooGenericPdf; ; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 5, 0.1, 10); genpdf = ROOT.RooClassFactory.makePdfInstance(""GenPdf"", ""(1+0.1*fabs(x)+sin(sqrt(fabs(x*alpha+0.1))))"", [x, alpha]); ; # Generate a toy dataset from the interpreted pdf; data2 = genpdf.generate({x}, 50000); ; # Fit the interpreted pdf to the generated data; genpdf.fitTo(data2, PrintLevel=-1); ; # Make a plot of the data and the pdf overlaid; frame2 = x.frame(Title=""Compiled version of pdf of rf103""); data2.plotOn(frame2); genpdf.plotOn(frame2); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf104_classfactory"", ""rf104_classfactory"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf104_classfactory.png""); (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- ",MatchSource.WIKI,doc/master/rf104__classfactory_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html
Availability,error,errorFunc,". ROOT: tutorials/roofit/rf105_funcbinding.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf105_funcbinding.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: binding ROOT math functions as RooFit functions and pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TMath.h""; #include ""TF1.h""; #include ""Math/DistFunc.h""; #include ""RooTFnBinding.h""; ; using namespace RooFit;; ; void rf105_funcbinding(); {; ; // B i n d T M a t h : : E r f C f u n c t i o n; // ---------------------------------------------------; ; // Bind one-dimensional TMath::Erf function as RooAbsReal function; RooRealVar x(""x"", ""x"", -3, 3);; RooAbsReal *errorFunc = bindFunction(""erf"", TMath::Erf, x);; ; // Print erf definition; errorFunc->Print();; ; // Plot erf on frame; RooPlot *frame1 = x.frame(Title(""TMath::Erf bound as RooFit function""));; errorFunc->plotOn(frame1);; ; // B i n d R O O T : : M a t h : : b e t a _ p d f C f u n c t i o n; // -----------------------------------------------------------------------; ; // Bind pdf ROOT::Math::Beta with three variables as RooAbsPdf function; RooRealVar x2(""x2"", ""x2"", 0, 0.999);; RooRealVar a(""a"", ""a"", 5, 0, 10);; RooRealVar b(""b"", ""b"", 2, 0, 10);; RooAbsPdf *beta = bindPdf(""beta"", ROOT::Math::beta_pdf, x2, a, b);; ; // Perf beta definition; beta->Print();; ; // Generate some events and fit; std::unique_ptr<RooDataSet> data{beta->generate(x2, 10000)};; beta->fitTo(*data, PrintLevel(-1));; ; // Plot data and pdf on frame; RooPlot *frame2 = x2.frame(Title(""ROOT::Math::Beta bound as RooFit pdf""));; data->plotOn(frame2);; beta->plotOn(frame2);; ; // B i n d R O O T T F 1 a s R o o F i t f u n c t i o n; // ---------------------------------------------------------------; ; // Create a ROOT TF1 function; TF1 *fa1 = new TF1(""fa1"", ""sin(x)/x"", 0, 10);; ; // Create an ",MatchSource.WIKI,doc/master/rf105__funcbinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8C.html
Deployability,integrat,integrator,"le beta_pdf(double x, double a, double b)Probability density function of the beta distribution.Definition PdfFuncMathCore.h:82; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; rf105_funcbindingDefinition rf105_funcbinding.py:1; ; RooCFunction1Binding<double,double>::erf[ function=TMath::Erf x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=(0x7fb320797e70) x=x2 y=a z=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf105_funcbinding.C. tutorialsroofitrf105_funcbinding.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf105__funcbinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8C.html
Integrability,interface,interface,"GetYaxis()->SetTitleOffset(1.6);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.6);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.6);; frame3->Draw();; }; DistFunc.h; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooTFnBinding.h; TAxis.h; TCanvas.h; TF1.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; TMath.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overr",MatchSource.WIKI,doc/master/rf105__funcbinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8C.html
Modifiability,variab,variables,"Matches. rf105_funcbinding.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: binding ROOT math functions as RooFit functions and pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TMath.h""; #include ""TF1.h""; #include ""Math/DistFunc.h""; #include ""RooTFnBinding.h""; ; using namespace RooFit;; ; void rf105_funcbinding(); {; ; // B i n d T M a t h : : E r f C f u n c t i o n; // ---------------------------------------------------; ; // Bind one-dimensional TMath::Erf function as RooAbsReal function; RooRealVar x(""x"", ""x"", -3, 3);; RooAbsReal *errorFunc = bindFunction(""erf"", TMath::Erf, x);; ; // Print erf definition; errorFunc->Print();; ; // Plot erf on frame; RooPlot *frame1 = x.frame(Title(""TMath::Erf bound as RooFit function""));; errorFunc->plotOn(frame1);; ; // B i n d R O O T : : M a t h : : b e t a _ p d f C f u n c t i o n; // -----------------------------------------------------------------------; ; // Bind pdf ROOT::Math::Beta with three variables as RooAbsPdf function; RooRealVar x2(""x2"", ""x2"", 0, 0.999);; RooRealVar a(""a"", ""a"", 5, 0, 10);; RooRealVar b(""b"", ""b"", 2, 0, 10);; RooAbsPdf *beta = bindPdf(""beta"", ROOT::Math::beta_pdf, x2, a, b);; ; // Perf beta definition; beta->Print();; ; // Generate some events and fit; std::unique_ptr<RooDataSet> data{beta->generate(x2, 10000)};; beta->fitTo(*data, PrintLevel(-1));; ; // Plot data and pdf on frame; RooPlot *frame2 = x2.frame(Title(""ROOT::Math::Beta bound as RooFit pdf""));; data->plotOn(frame2);; beta->plotOn(frame2);; ; // B i n d R O O T T F 1 a s R o o F i t f u n c t i o n; // ---------------------------------------------------------------; ; // Create a ROOT TF1 function; TF1 *fa1 = new TF1(""fa1"", ""sin(x)/x"", 0, 10);; ; // Create an observable; RooRealVar x3(""x3"", ""x3"", 0.01, 20);; ; // Create binding of TF1 object to above observable; RooAbsReal *rfa1 = bindFunc",MatchSource.WIKI,doc/master/rf105__funcbinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8C.html
Performance,optimiz,optimization,"le beta_pdf(double x, double a, double b)Probability density function of the beta distribution.Definition PdfFuncMathCore.h:82; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; rf105_funcbindingDefinition rf105_funcbinding.py:1; ; RooCFunction1Binding<double,double>::erf[ function=TMath::Erf x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=(0x7fb320797e70) x=x2 y=a z=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf105_funcbinding.C. tutorialsroofitrf105_funcbinding.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf105__funcbinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8C.html
Availability,error,error,"ame3); ; c = ROOT.TCanvas(""rf105_funcbinding"", ""rf105_funcbinding"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf105_funcbinding.png""); RooCFunction1Binding<double,double>::erf[ function=(0x7f013b501000) x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=ROOT::Math::beta_pdf x=x2 a=a b=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf105_funcbinding.py. tutorialsroofitrf105_funcbinding.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf105__funcbinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html
Deployability,integrat,integrator,"ame3); ; c = ROOT.TCanvas(""rf105_funcbinding"", ""rf105_funcbinding"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf105_funcbinding.png""); RooCFunction1Binding<double,double>::erf[ function=(0x7f013b501000) x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=ROOT::Math::beta_pdf x=x2 a=a b=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf105_funcbinding.py. tutorialsroofitrf105_funcbinding.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf105__funcbinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html
Integrability,integrat,integrator,"ame3); ; c = ROOT.TCanvas(""rf105_funcbinding"", ""rf105_funcbinding"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf105_funcbinding.png""); RooCFunction1Binding<double,double>::erf[ function=(0x7f013b501000) x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=ROOT::Math::beta_pdf x=x2 a=a b=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf105_funcbinding.py. tutorialsroofitrf105_funcbinding.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf105__funcbinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf105_funcbinding.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf105_funcbinding.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'BASIC FUNCTIONALITY' RooFit tutorial macro #105 Demonstration of binding ROOT Math functions as RooFit functions and pdfs . ; import ROOT; ; # Bind ROOT TMath::Erf C function; # ---------------------------------------------------; ; # Bind one-dimensional ROOT.TMath.Erf function as ROOT.RooAbsReal function; x = ROOT.RooRealVar(""x"", ""x"", -3, 3); erf = ROOT.RooFit.bindFunction(""erf"", ROOT.TMath.Erf, x); ; # Print erf definition; erf.Print(); ; # Plot erf on frame; frame1 = x.frame(Title=""TMath.Erf bound as ROOT.RooFit function""); erf.plotOn(frame1); ; # Bind ROOT::Math::beta_pdf C function; # -----------------------------------------------------------------------; ; # Bind pdf ROOT.Math.Beta with three variables as ROOT.RooAbsPdf function; x2 = ROOT.RooRealVar(""x2"", ""x2"", 0, 0.999); a = ROOT.RooRealVar(""a"", ""a"", 5, 0, 10); b = ROOT.RooRealVar(""b"", ""b"", 2, 0, 10); beta = ROOT.RooFit.bindPdf(""beta"", ROOT.Math.beta_pdf, x2, a, b); ; # Perf beta definition; beta.Print(); ; # Generate some events and fit; data = beta.generate({x2}, 10000); beta.fitTo(data, PrintLevel=-1); ; # Plot data and pdf on frame; frame2 = x2.frame(Title=""ROOT.Math.Beta bound as ROOT.RooFit pdf""); data.plotOn(frame2); beta.plotOn(frame2); ; # Bind ROOT TF1 as RooFit function; # ---------------------------------------------------------------; ; # Create a ROOT TF1 function; fa1 = ROOT.TF1(""fa1"", ""sin(x)/x"", 0, 10); ; # Create an observable; x3 = ROOT.RooRealVar(""x3"", ""x3"", 0.01, 20); ; # Create binding of TF1 object to above observable; rfa1 = ROOT.RooFit.bindFunction(fa1, x3); ; # Print rfa1 definition; rfa1.Print(); ; # Make plot frame in observable, TF1 binding function; frame3 = x3.frame(Title=""TF1 bound as ROOT.RooFit function""); rfa1.plotOn(frame3); ; c = R",MatchSource.WIKI,doc/master/rf105__funcbinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html
Performance,optimiz,optimization,"ame3); ; c = ROOT.TCanvas(""rf105_funcbinding"", ""rf105_funcbinding"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf105_funcbinding.png""); RooCFunction1Binding<double,double>::erf[ function=(0x7f013b501000) x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=ROOT::Math::beta_pdf x=x2 a=a b=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf105_funcbinding.py. tutorialsroofitrf105_funcbinding.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf105__funcbinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html
Availability,error,error,"iable that can be changed from the outside.Definition RooRealVar.h:37; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TTextBase class for several text objects.Definition TText.h:22; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; arrowDefinition RArrowDS.hxx:17; rf106_plotdecorationDefinition rf106_plotdecoration.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf106_plotdecoration.C. tutorialsroofitrf106_plotdecoration.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf106__plotdecoration_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8C.html
Modifiability,variab,variable,">Write();; f.Close();; ; // To read back and plot frame with all decorations in clean root session do; // root> TFile f(""rf106_plotdecoration.root"") ;; // root> xframe->Draw() ;; ; new TCanvas(""rf106_plotdecoration"", ""rf106_plotdecoration"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; f#define f(i)Definition RSha256.hxx:104; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TArrow.h; TAxis.h; TCanvas.h; TFile.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TText.h; gPad#define gPadDefinition TVirtualPad.h:308; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::addObjectvoid addObject(TObject *obj, Option_t *drawOptions="""", bool invisible=false)Add a generic object to this plot.Definition RooPlot.cxx:366; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Defini",MatchSource.WIKI,doc/master/rf106__plotdecoration_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8C.html
Performance,optimiz,optimization,"iable that can be changed from the outside.Definition RooRealVar.h:37; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TTextBase class for several text objects.Definition TText.h:22; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; arrowDefinition RArrowDS.hxx:17; rf106_plotdecorationDefinition rf106_plotdecoration.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf106_plotdecoration.C. tutorialsroofitrf106_plotdecoration.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf106__plotdecoration_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8C.html
Availability,error,error,"t=0.55); ; # Add box with data statistics; # -------------------------------------------------------; ; # X size of box is from 55% to 99% of Xaxis range, of box is at 80% of; # Yaxis range); data.statOn(frame, Layout=(0.55, 0.99, 0.8)); ; # Add text and arrow; # -----------------------------------; ; # Add text to frame; txt = ROOT.TText(2, 100, ""Signal""); txt.SetTextSize(0.04); txt.SetTextColor(ROOT.kRed); frame.addObject(txt); ; # Add arrow to frame; arrow = ROOT.TArrow(2, 100, -1, 50, 0.01, ""|>""); arrow.SetLineColor(ROOT.kRed); arrow.SetFillColor(ROOT.kRed); arrow.SetLineWidth(3); frame.addObject(arrow); ; # Persist frame with all decorations in ROOT file; # ---------------------------------------------------------------------------------------------; ; f = ROOT.TFile(""rf106_plotdecoration.root"", ""RECREATE""); frame.Write(); f.Close(); ; # To read back and plot frame with all decorations in clean root session do; # root> ROOT.TFile f(""rf106_plotdecoration.root""); # root> xframe.Draw(); ; c = ROOT.TCanvas(""rf106_plotdecoration"", ""rf106_plotdecoration"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf106_plotdecoration.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf106_plotdecoration.py. tutorialsroofitrf106_plotdecoration.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf106__plotdecoration_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8py.html
Performance,optimiz,optimization,"t=0.55); ; # Add box with data statistics; # -------------------------------------------------------; ; # X size of box is from 55% to 99% of Xaxis range, of box is at 80% of; # Yaxis range); data.statOn(frame, Layout=(0.55, 0.99, 0.8)); ; # Add text and arrow; # -----------------------------------; ; # Add text to frame; txt = ROOT.TText(2, 100, ""Signal""); txt.SetTextSize(0.04); txt.SetTextColor(ROOT.kRed); frame.addObject(txt); ; # Add arrow to frame; arrow = ROOT.TArrow(2, 100, -1, 50, 0.01, ""|>""); arrow.SetLineColor(ROOT.kRed); arrow.SetFillColor(ROOT.kRed); arrow.SetLineWidth(3); frame.addObject(arrow); ; # Persist frame with all decorations in ROOT file; # ---------------------------------------------------------------------------------------------; ; f = ROOT.TFile(""rf106_plotdecoration.root"", ""RECREATE""); frame.Write(); f.Close(); ; # To read back and plot frame with all decorations in clean root session do; # root> ROOT.TFile f(""rf106_plotdecoration.root""); # root> xframe.Draw(); ; c = ROOT.TCanvas(""rf106_plotdecoration"", ""rf106_plotdecoration"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf106_plotdecoration.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf106_plotdecoration.py. tutorialsroofitrf106_plotdecoration.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf106__plotdecoration_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8py.html
Availability,error,errors,"File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: various plotting styles of data, functions in a RooPlot . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf107_plotstyles(); {; ; // S e t u p m o d e l; // ---------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create Gaussian; RooRealVar sigma(""sigma"", ""sigma"", 3, 0.1, 10);; RooRealVar mean(""mean"", ""mean"", -3, -10, 10);; RooGaussian gauss(""gauss"", ""gauss"", x, mean, sigma);; ; // Generate a sample of 100 events with sigma=3; std::unique_ptr<RooDataSet> data{gauss.generate(x, 100)};; ; // Fit pdf to data; gauss.fitTo(*data, PrintLevel(-1));; ; // M a k e p l o t f r a m e s; // -------------------------------; ; // Make four plot frames to demonstrate various plotting features; RooPlot *frame1 = x.frame(Name(""xframe""), Title(""Red Curve / SumW2 Histo errors""), Bins(20));; RooPlot *frame2 = x.frame(Name(""xframe""), Title(""Dashed Curve / No XError bars""), Bins(20));; RooPlot *frame3 = x.frame(Name(""xframe""), Title(""Filled Curve / Blue Histo""), Bins(20));; RooPlot *frame4 = x.frame(Name(""xframe""), Title(""Partial Range / Filled Bar chart""), Bins(20));; ; // D a t a p l o t t i n g s t y l e s; // ---------------------------------------; ; // Use sqrt(sum(weights^2)) error instead of Poisson errors; data->plotOn(frame1, DataError(RooAbsData::SumW2));; ; // Remove horizontal error bars; data->plotOn(frame2, XErrorSize(0));; ; // Blue markers and error bors; data->plotOn(frame3, MarkerColor(kBlue), LineColor(kBlue));; ; // Filled bar chart; data->plotOn(frame4, DrawOption(""B""), DataError(RooAbsData::None), XErrorSize(0), FillColor(kGray));; ; // F u n c t i o n p l o t t i n g s t y l e s; // -----------------------------------------------; ; // Change line color to red; gauss.plotOn(frame1, LineColor(kRed));; ; // Change line style t",MatchSource.WIKI,doc/master/rf107__plotstyles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8C.html
Energy Efficiency,green,green,"me(""xframe""), Title(""Dashed Curve / No XError bars""), Bins(20));; RooPlot *frame3 = x.frame(Name(""xframe""), Title(""Filled Curve / Blue Histo""), Bins(20));; RooPlot *frame4 = x.frame(Name(""xframe""), Title(""Partial Range / Filled Bar chart""), Bins(20));; ; // D a t a p l o t t i n g s t y l e s; // ---------------------------------------; ; // Use sqrt(sum(weights^2)) error instead of Poisson errors; data->plotOn(frame1, DataError(RooAbsData::SumW2));; ; // Remove horizontal error bars; data->plotOn(frame2, XErrorSize(0));; ; // Blue markers and error bors; data->plotOn(frame3, MarkerColor(kBlue), LineColor(kBlue));; ; // Filled bar chart; data->plotOn(frame4, DrawOption(""B""), DataError(RooAbsData::None), XErrorSize(0), FillColor(kGray));; ; // F u n c t i o n p l o t t i n g s t y l e s; // -----------------------------------------------; ; // Change line color to red; gauss.plotOn(frame1, LineColor(kRed));; ; // Change line style to dashed; gauss.plotOn(frame2, LineStyle(kDashed));; ; // Filled shapes in green color; gauss.plotOn(frame3, DrawOption(""F""), FillColor(kOrange), MoveToBack());; ; //; gauss.plotOn(frame4, Range(-8, 3), LineColor(kMagenta));; ; TCanvas *c = new TCanvas(""rf107_plotstyles"", ""rf107_plotstyles"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.6);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.6);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.6);; frame3->Draw();; c->cd(4);; gPad->SetLeftMargin(0.15);; frame4->GetYaxis()->SetTitleOffset(1.6);; frame4->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kGray@ kGrayDefinition Rtypes.h:65; kRed@ kRedDefinition Rtypes.h:66; kOrange@ kOrangeDefinition Rtypes.h:67; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCa",MatchSource.WIKI,doc/master/rf107__plotstyles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8C.html
Modifiability,variab,variable,".15);; frame4->GetYaxis()->SetTitleOffset(1.6);; frame4->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kGray@ kGrayDefinition Rtypes.h:65; kRed@ kRedDefinition Rtypes.h:66; kOrange@ kOrangeDefinition Rtypes.h:67; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsData::None@ NoneDefinition RooAbsData.h:108; RooAbsData::SumW2@ SumW2Definition RooAbsData.h:108; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf107_plotstylesDefinition rf107_plotstyles.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coeffi",MatchSource.WIKI,doc/master/rf107__plotstyles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8C.html
Performance,optimiz,optimization,"n that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf107_plotstylesDefinition rf107_plotstyles.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(gauss) only plotting range [-8,3], curve is normalized to data in given range; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'plotRange' created with bounds [-8,3]; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf107_plotstyles.C. tutorialsroofitrf107_plotstyles.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf107__plotstyles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8C.html
Availability,error,errors,". ROOT: tutorials/roofit/rf107_plotstyles.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf107_plotstyles.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: demonstration of various plotting styles of data, functions in a RooPlot . ; import ROOT; ; ; # Set up model; # ---------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create Gaussian; sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 3, 0.1, 10); mean = ROOT.RooRealVar(""mean"", ""mean"", -3, -10, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mean, sigma); ; # Generate a sample of 100 events with sigma=3; data = gauss.generate({x}, 100); ; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Make plot frames; # -------------------------------; ; # Make four plot frames to demonstrate various plotting features; frame1 = x.frame(Name=""xframe"", Title=""Red Curve / SumW2 Histo errors"", Bins=20); frame2 = x.frame(Name=""xframe"", Title=""Dashed Curve / No XError bars"", Bins=20); frame3 = x.frame(Name=""xframe"", Title=""Filled Curve / Blue Histo"", Bins=20); frame4 = x.frame(Name=""xframe"", Title=""Partial Range / Filled Bar chart"", Bins=20); ; # Data plotting styles; # ---------------------------------------; ; # Use sqrt(sum(weights^2)) error instead of Poisson errors; data.plotOn(frame1, DataError=""SumW2""); ; # Remove horizontal error bars; data.plotOn(frame2, XErrorSize=0); ; # Blue markers and error bors; data.plotOn(frame3, MarkerColor=""b"", LineColor=""b""); ; # Filled bar chart; data.plotOn(frame4, DrawOption=""B"", DataError=None, XErrorSize=0, FillColor=""kGray""); ; # Function plotting styles; # -----------------------------------------------; ; # Change line color to red; gauss.plotOn(frame1, LineColor=""r""); ; # Change line style to dashed; gauss.plotOn(frame2, LineStyle=""--""); ; # Filled shapes in green color; gauss.plotOn(frame3, MoveToBack=True, DrawOption=""F"", FillColor=""kOrange""); ;",MatchSource.WIKI,doc/master/rf107__plotstyles_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8py.html
Energy Efficiency,green,green,"plotting features; frame1 = x.frame(Name=""xframe"", Title=""Red Curve / SumW2 Histo errors"", Bins=20); frame2 = x.frame(Name=""xframe"", Title=""Dashed Curve / No XError bars"", Bins=20); frame3 = x.frame(Name=""xframe"", Title=""Filled Curve / Blue Histo"", Bins=20); frame4 = x.frame(Name=""xframe"", Title=""Partial Range / Filled Bar chart"", Bins=20); ; # Data plotting styles; # ---------------------------------------; ; # Use sqrt(sum(weights^2)) error instead of Poisson errors; data.plotOn(frame1, DataError=""SumW2""); ; # Remove horizontal error bars; data.plotOn(frame2, XErrorSize=0); ; # Blue markers and error bors; data.plotOn(frame3, MarkerColor=""b"", LineColor=""b""); ; # Filled bar chart; data.plotOn(frame4, DrawOption=""B"", DataError=None, XErrorSize=0, FillColor=""kGray""); ; # Function plotting styles; # -----------------------------------------------; ; # Change line color to red; gauss.plotOn(frame1, LineColor=""r""); ; # Change line style to dashed; gauss.plotOn(frame2, LineStyle=""--""); ; # Filled shapes in green color; gauss.plotOn(frame3, MoveToBack=True, DrawOption=""F"", FillColor=""kOrange""); ; #; gauss.plotOn(frame4, Range=(-8, 3), LineColor=""m""); ; c = ROOT.TCanvas(""rf107_plotstyles"", ""rf107_plotstyles"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf107_plotstyles.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, u",MatchSource.WIKI,doc/master/rf107__plotstyles_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8py.html
Performance,optimiz,optimization,"hart; data.plotOn(frame4, DrawOption=""B"", DataError=None, XErrorSize=0, FillColor=""kGray""); ; # Function plotting styles; # -----------------------------------------------; ; # Change line color to red; gauss.plotOn(frame1, LineColor=""r""); ; # Change line style to dashed; gauss.plotOn(frame2, LineStyle=""--""); ; # Filled shapes in green color; gauss.plotOn(frame3, MoveToBack=True, DrawOption=""F"", FillColor=""kOrange""); ; #; gauss.plotOn(frame4, Range=(-8, 3), LineColor=""m""); ; c = ROOT.TCanvas(""rf107_plotstyles"", ""rf107_plotstyles"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf107_plotstyles.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(gauss) only plotting range [-8,3], curve is normalized to data in given range; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'plotRange' created with bounds [-8,3]; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf107_plotstyles.py. tutorialsroofitrf107_plotstyles.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf107__plotstyles_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8py.html
Deployability,integrat,integrates,"is a RooAbsAnaConvPdf implementation that describes the decay of B mesons with the...Definition RooBMixDecay.h:23; RooBMixDecay::DoubleSided@ DoubleSidedDefinition RooBMixDecay.h:26; RooBinningImplements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choi...Definition RooBinning.h:27; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMaximumSetMaximum(ymax); RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf108_plotbinningDefinition rf108_plotbinning.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt integrates over variables (mixState,tagFlav); [#1] INFO:Plotting -- RooAbsReal::plotAsymOn(bmix) plot on dt projects variables (tagFlav); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf108_plotbinning.C. tutorialsroofitrf108_plotbinning.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf108__plotbinning_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8C.html
Integrability,integrat,integrates,"is a RooAbsAnaConvPdf implementation that describes the decay of B mesons with the...Definition RooBMixDecay.h:23; RooBMixDecay::DoubleSided@ DoubleSidedDefinition RooBMixDecay.h:26; RooBinningImplements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choi...Definition RooBinning.h:27; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMaximumSetMaximum(ymax); RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf108_plotbinningDefinition rf108_plotbinning.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt integrates over variables (mixState,tagFlav); [#1] INFO:Plotting -- RooAbsReal::plotAsymOn(bmix) plot on dt projects variables (tagFlav); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf108_plotbinning.C. tutorialsroofitrf108_plotbinning.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf108__plotbinning_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8C.html
Modifiability,variab,variable,". ROOT: tutorials/roofit/rf108_plotbinning.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf108_plotbinning.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: plotting unbinned data with alternate and variable binnings . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussModel.h""; #include ""RooDecay.h""; #include ""RooBMixDecay.h""; #include ""RooCategory.h""; #include ""RooBinning.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf108_plotbinning(); {; ; // S e t u p m o d e l; // ---------------------; ; // Build a B decay pdf with mixing; RooRealVar dt(""dt"", ""dt"", -20, 20);; RooRealVar dm(""dm"", ""dm"", 0.472);; RooRealVar tau(""tau"", ""tau"", 1.547);; RooRealVar w(""w"", ""mistag rate"", 0.1);; RooRealVar dw(""dw"", ""delta mistag rate"", 0.);; ; RooCategory mixState(""mixState"", ""B0/B0bar mixing state"");; mixState.defineType(""mixed"", -1);; mixState.defineType(""unmixed"", 1);; RooCategory tagFlav(""tagFlav"", ""Flavour of the tagged B0"");; tagFlav.defineType(""B0"", 1);; tagFlav.defineType(""B0bar"", -1);; ; // Build a gaussian resolution model; RooRealVar bias1(""bias1"", ""bias1"", 0);; RooRealVar sigma1(""sigma1"", ""sigma1"", 0.1);; RooGaussModel gm1(""gm1"", ""gauss model 1"", dt, bias1, sigma1);; ; // Construct Bdecay (x) gauss; RooBMixDecay bmix(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, RooBMixDecay::DoubleSided);; ; // S a m p l e d a t a f r o m m o d e l; // --------------------------------------------; ; // Sample 2000 events in (dt,mixState,tagFlav) from bmix; std::unique_ptr<RooDataSet> data{bmix.generate(RooArgSet(dt, mixState, tagFlav), 2000)};; ; // S h o w d t d i s t r i b u t i o n w i t h c u s t o m b i n n i n g; // -------------------------------------------------------------------------------; ; // Make plot of dt distribution of data in range (-15,15) with fine binning for dt>0 and coa",MatchSource.WIKI,doc/master/rf108__plotbinning_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8C.html
Deployability,integrat,integrates,"nning as shown; # in Y axis label (100 bins -. Events/0.4*Xaxis-dim) so that all bins; # represent a consistent density distribution; ; # Show mixstate asymmetry with custom binning; # ------------------------------------------------------------------------------------; ; # Make plot of dt distribution of data asymmetry in 'mixState' with; # variable binning; ; # Create binning object with range (-10,10); abins = ROOT.RooBinning(-10, 10); ; # Add boundaries at 0, (-1,1), (-2,2), (-3,3), (-4,4) and (-6,6); abins.addBoundary(0); abins.addBoundaryPair(1); abins.addBoundaryPair(2); abins.addBoundaryPair(3); abins.addBoundaryPair(4); abins.addBoundaryPair(6); ; # Create plot frame in dt; aframe = dt.frame(Range=(-10, 10), Title=""mixState asymmetry distribution with custom binning""); ; # Plot mixState asymmetry of data with specified customg binning; data.plotOn(aframe, Asymmetry=mixState, Binning=abins); ; # Plot corresponding property of pdf; bmix.plotOn(aframe, Asymmetry=mixState); ; # Adjust vertical range of plot to sensible values for an asymmetry; aframe.SetMinimum(-1.1); aframe.SetMaximum(1.1); ; # NB: For asymmetry distributions no density corrects are needed (and are; # thus not applied); ; # Draw plots on canvas; c = ROOT.TCanvas(""rf108_plotbinning"", ""rf108_plotbinning"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); dtframe.GetYaxis().SetTitleOffset(1.6); dtframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); aframe.GetYaxis().SetTitleOffset(1.6); aframe.Draw(); ; c.SaveAs(""rf108_plotbinning.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt integrates over variables (tagFlav,mixState); [#1] INFO:Plotting -- RooAbsReal::plotAsymOn(bmix) plot on dt projects variables (tagFlav); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf108_plotbinning.py. tutorialsroofitrf108_plotbinning.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf108__plotbinning_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8py.html
Integrability,integrat,integrates,"nning as shown; # in Y axis label (100 bins -. Events/0.4*Xaxis-dim) so that all bins; # represent a consistent density distribution; ; # Show mixstate asymmetry with custom binning; # ------------------------------------------------------------------------------------; ; # Make plot of dt distribution of data asymmetry in 'mixState' with; # variable binning; ; # Create binning object with range (-10,10); abins = ROOT.RooBinning(-10, 10); ; # Add boundaries at 0, (-1,1), (-2,2), (-3,3), (-4,4) and (-6,6); abins.addBoundary(0); abins.addBoundaryPair(1); abins.addBoundaryPair(2); abins.addBoundaryPair(3); abins.addBoundaryPair(4); abins.addBoundaryPair(6); ; # Create plot frame in dt; aframe = dt.frame(Range=(-10, 10), Title=""mixState asymmetry distribution with custom binning""); ; # Plot mixState asymmetry of data with specified customg binning; data.plotOn(aframe, Asymmetry=mixState, Binning=abins); ; # Plot corresponding property of pdf; bmix.plotOn(aframe, Asymmetry=mixState); ; # Adjust vertical range of plot to sensible values for an asymmetry; aframe.SetMinimum(-1.1); aframe.SetMaximum(1.1); ; # NB: For asymmetry distributions no density corrects are needed (and are; # thus not applied); ; # Draw plots on canvas; c = ROOT.TCanvas(""rf108_plotbinning"", ""rf108_plotbinning"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); dtframe.GetYaxis().SetTitleOffset(1.6); dtframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); aframe.GetYaxis().SetTitleOffset(1.6); aframe.Draw(); ; c.SaveAs(""rf108_plotbinning.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt integrates over variables (tagFlav,mixState); [#1] INFO:Plotting -- RooAbsReal::plotAsymOn(bmix) plot on dt projects variables (tagFlav); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf108_plotbinning.py. tutorialsroofitrf108_plotbinning.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf108__plotbinning_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8py.html
Modifiability,variab,variable,". ROOT: tutorials/roofit/rf108_plotbinning.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf108_plotbinning.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: plotting unbinned data with alternate and variable binnings . ; import ROOT; ; # Set up model; # ---------------------; ; # Build a B decay pdf with mixing; dt = ROOT.RooRealVar(""dt"", ""dt"", -20, 20); dm = ROOT.RooRealVar(""dm"", ""dm"", 0.472); tau = ROOT.RooRealVar(""tau"", ""tau"", 1.547); w = ROOT.RooRealVar(""w"", ""mistag rate"", 0.1); dw = ROOT.RooRealVar(""dw"", ""delta mistag rate"", 0.0); ; mixState = ROOT.RooCategory(""mixState"", ""B0/B0bar mixing state"", {""mixed"": -1, ""unmixed"": 1}); tagFlav = ROOT.RooCategory(""tagFlav"", ""Flavour of the tagged B0"", {""B0"": 1, ""B0bar"": -1}); ; # Build a gaussian resolution model; dterr = ROOT.RooRealVar(""dterr"", ""dterr"", 0.1, 1.0); bias1 = ROOT.RooRealVar(""bias1"", ""bias1"", 0); sigma1 = ROOT.RooRealVar(""sigma1"", ""sigma1"", 0.1); gm1 = ROOT.RooGaussModel(""gm1"", ""gauss model 1"", dt, bias1, sigma1); ; # Construct Bdecay (x) gauss; bmix = ROOT.RooBMixDecay(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, type=""DoubleSided""); ; # Sample data from model; # --------------------------------------------; ; # Sample 2000 events in (dt,mixState,tagFlav) from bmix; data = bmix.generate({dt, mixState, tagFlav}, 2000); ; # Show dt distribution with custom binning; # -------------------------------------------------------------------------------; ; # Make plot of dt distribution of data in range (-15,15) with fine binning; # for dt>0 and coarse binning for dt<0; ; # Create binning object with range (-15,15); tbins = ROOT.RooBinning(-15, 15); ; # Add 60 bins with uniform spacing in range (-15,0); tbins.addUniform(60, -15, 0); ; # Add 15 bins with uniform spacing in range (0,15); tbins.addUniform(15, 0, 15); ; # Make plot with specified binning; dtframe = dt.frame(Range=(-15, 15), Title=""dt",MatchSource.WIKI,doc/master/rf108__plotbinning_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8py.html
Modifiability,variab,variable,"Offset(1.6);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.6);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.6);; frame3->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooHist.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsData::SumW2@ SumW2Definition RooAbsData.h:108; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooHistGraphical representation of binned data based on the TGraphAsymmErrors class.Definition RooHist.h:29; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::chiSquaredouble chiSquare(int nFitParam=0) constShortcut for RooPlot::chiSquare(const char* pdfname, const char* histname, int nFitParam=nullptr)Definition RooPlot.h:180; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::residHistRooHist * residHist(const char *histname=nullptr, const char *pdfname=nullptr, bool normalize=false, bool useAverage=true) constReturn a RooHist (derives from TGraphAsymErrors) containing the residuals of a histogram.Definition RooPlot.cxx:1101; RooPlot::pullHistRooHist * pullHist(const char *histname=nullptr, const char *pdfname=nullptr, bool useAverage=true) constUses residHist() and sets normalize=true.Definition RooPlot.h:185; RooPlot::addPlotablevoid addPlotable(RooPlotable *plota",MatchSource.WIKI,doc/master/rf109__chi2residpull_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf109__chi2residpull_8C.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf110_normintegration.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf110_normintegration.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: normalization and integration of pdfs, construction of cumulative distribution monodimensional functions . ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooAbsReal.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf110_normintegration(); {; // S e t u p m o d e l; // ---------------------; ; // Create observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create pdf gaussx(x,-2,3); RooGaussian gx(""gx"", ""gx"", x, -2.0, 3.0);; ; // R e t r i e v e r a w & n o r m a l i z e d v a l u e s o f R o o F i t p . d . f . s; // --------------------------------------------------------------------------------------------------; ; // Return 'raw' unnormalized value of gx; cout << ""gx = "" << gx.getVal() << endl;; ; // Return value of gx normalized over x in range [-10,10]; RooArgSet nset(x);; cout << ""gx_Norm[x] = "" << gx.getVal(&nset) << endl;; ; // Create object representing integral over gx; // which is used to calculate gx_Norm[x] == gx / gx_Int[x]; std::unique_ptr<RooAbsReal> igx{gx.createIntegral(x)};; cout << ""gx_Int[x] = "" << igx->getVal() << endl;; ; // I n t e g r a t e n o r m a l i z e d p d f o v e r s u b r a n g e; // ----------------------------------------------------------------------------; ; // Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5);; ; // Create an integral of gx_Norm[x] over x in range ""signal""; // This is the fraction of of pdf gx_Norm[x] which is in the; // range named ""signal""; std::unique_ptr<RooAbsReal> igx_sig{gx.createIntegral(x, NormSet(x), Range(""signal""))};; cout << ""gx_Int[x|signal]_Norm[x] = "" << igx_sig->getVal() << endl;; ; // C o n s t r u c t c u m u l a t i v e d i s t r i b u t i o n f u ",MatchSource.WIKI,doc/master/rf110__normintegration_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf110__normintegration_8C.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf110_normintegration.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf110_normintegration.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: normalization and integration of pdfs, construction of cumulative distribution monodimensional functions . ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooAbsReal.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf110_normintegration(); {; // S e t u p m o d e l; // ---------------------; ; // Create observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create pdf gaussx(x,-2,3); RooGaussian gx(""gx"", ""gx"", x, -2.0, 3.0);; ; // R e t r i e v e r a w & n o r m a l i z e d v a l u e s o f R o o F i t p . d . f . s; // --------------------------------------------------------------------------------------------------; ; // Return 'raw' unnormalized value of gx; cout << ""gx = "" << gx.getVal() << endl;; ; // Return value of gx normalized over x in range [-10,10]; RooArgSet nset(x);; cout << ""gx_Norm[x] = "" << gx.getVal(&nset) << endl;; ; // Create object representing integral over gx; // which is used to calculate gx_Norm[x] == gx / gx_Int[x]; std::unique_ptr<RooAbsReal> igx{gx.createIntegral(x)};; cout << ""gx_Int[x] = "" << igx->getVal() << endl;; ; // I n t e g r a t e n o r m a l i z e d p d f o v e r s u b r a n g e; // ----------------------------------------------------------------------------; ; // Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5);; ; // Create an integral of gx_Norm[x] over x in range ""signal""; // This is the fraction of of pdf gx_Norm[x] which is in the; // range named ""signal""; std::unique_ptr<RooAbsReal> igx_sig{gx.createIntegral(x, NormSet(x), Range(""signal""))};; cout << ""gx_Int[x|signal]_Norm[x] = "" << igx_sig->getVal() << endl;; ; // C o n s t r u c t c u m u l a t i v e d i s t r i b u t i o n f u ",MatchSource.WIKI,doc/master/rf110__normintegration_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf110__normintegration_8C.html
Modifiability,variab,variable,"-----------------------------------------------------------------------------------------; ; // Create the cumulative distribution function of gx; // i.e. calculate Int[-10,x] gx(x') dx'; std::unique_ptr<RooAbsReal> gx_cdf{gx.createCdf(x)};; ; // Plot cdf of gx versus x; RooPlot *frame = x.frame(Title(""cdf of Gaussian pdf""));; gx_cdf->plotOn(frame);; ; // Draw plot on canvas; new TCanvas(""rf110_normintegration"", ""rf110_normintegration"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAbsReal.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf110_normintegrationDefinition rf110_normintegration.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; gx = 0.800737; gx_Norm[x] = 0.106896; gx_Int[x] = 7.49084; [#1] INFO:Eval -- RooRealVar",MatchSource.WIKI,doc/master/rf110__normintegration_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf110__normintegration_8C.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf110_normintegration.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf110_normintegration.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: examples on normalization and integration of pdfs, construction of cumulative distribution functions from monodimensional pdfs . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Create observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create pdf gaussx(x,-2,3); gx = ROOT.RooGaussian(""gx"", ""gx"", x, -2, 3); ; # Retrieve raw & normalized values of RooFit pdfs; # --------------------------------------------------------------------------------------------------; ; # Return 'raw' unnormalized value of gx; print(""gx = "", gx.getVal()); ; # Return value of gx normalized over x in range [-10,10]; nset = {x}; print(""gx_Norm[x] = "", gx.getVal(nset)); ; # Create object representing integral over gx; # which is used to calculate gx_Norm[x] == gx / gx_Int[x]; igx = gx.createIntegral({x}); print(""gx_Int[x] = "", igx.getVal()); ; # Integrate normalized pdf over subrange; # ----------------------------------------------------------------------------; ; # Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5); ; # Create an integral of gx_Norm[x] over x in range ""signal""; # ROOT.This is the fraction of of pdf gx_Norm[x] which is in the; # range named ""signal""; xset = {x}; igx_sig = gx.createIntegral(xset, NormSet=xset, Range=""signal""); print(""gx_Int[x|signal]_Norm[x] = "", igx_sig.getVal()); ; # Construct cumulative distribution function from pdf; # -----------------------------------------------------------------------------------------------------; ; # Create the cumulative distribution function of gx; # i.e. calculate Int[-10,x] gx(x') dx'; gx_cdf = gx.createCdf({x}); ; # Plot cdf of gx versus x; frame = x.frame(Title=""cdf of Gaussian pd",MatchSource.WIKI,doc/master/rf110__normintegration_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf110__normintegration_8py.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf110_normintegration.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf110_normintegration.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: examples on normalization and integration of pdfs, construction of cumulative distribution functions from monodimensional pdfs . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Create observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create pdf gaussx(x,-2,3); gx = ROOT.RooGaussian(""gx"", ""gx"", x, -2, 3); ; # Retrieve raw & normalized values of RooFit pdfs; # --------------------------------------------------------------------------------------------------; ; # Return 'raw' unnormalized value of gx; print(""gx = "", gx.getVal()); ; # Return value of gx normalized over x in range [-10,10]; nset = {x}; print(""gx_Norm[x] = "", gx.getVal(nset)); ; # Create object representing integral over gx; # which is used to calculate gx_Norm[x] == gx / gx_Int[x]; igx = gx.createIntegral({x}); print(""gx_Int[x] = "", igx.getVal()); ; # Integrate normalized pdf over subrange; # ----------------------------------------------------------------------------; ; # Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5); ; # Create an integral of gx_Norm[x] over x in range ""signal""; # ROOT.This is the fraction of of pdf gx_Norm[x] which is in the; # range named ""signal""; xset = {x}; igx_sig = gx.createIntegral(xset, NormSet=xset, Range=""signal""); print(""gx_Int[x|signal]_Norm[x] = "", igx_sig.getVal()); ; # Construct cumulative distribution function from pdf; # -----------------------------------------------------------------------------------------------------; ; # Create the cumulative distribution function of gx; # i.e. calculate Int[-10,x] gx(x') dx'; gx_cdf = gx.createCdf({x}); ; # Plot cdf of gx versus x; frame = x.frame(Title=""cdf of Gaussian pd",MatchSource.WIKI,doc/master/rf110__normintegration_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf110__normintegration_8py.html
Deployability,integrat,integrator," Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf111_derivativesDefinition rf111_derivatives.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gauss_Int[sigma]) using numeric integrator RooIntegrator1D to calculate Int(sigma); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf111_derivatives.C. tutorialsroofitrf111_derivatives.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf111__derivatives_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8C.html
Integrability,integrat,integrator," Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf111_derivativesDefinition rf111_derivatives.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gauss_Int[sigma]) using numeric integrator RooIntegrator1D to calculate Int(sigma); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf111_derivatives.C. tutorialsroofitrf111_derivatives.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf111__derivatives_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8C.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf111_derivatives.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf111_derivatives.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: numerical 1st,2nd and 3rd order derivatives w.r.t. ; observables and parameters; pdf = gauss(x,m,s); xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf111_derivatives(); {; // S e t u p m o d e l; // ---------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar mean(""mean"", ""mean of gaussian"", 1, -10, 10);; RooRealVar sigma(""sigma"", ""width of gaussian"", 1, 0.1, 10);; ; // Build gaussian pdf in terms of x,mean and sigma; RooGaussian gauss(""gauss"", ""gaussian PDF"", x, mean, sigma);; ; // C r e a t e a n d p l o t d e r i v a t i v e s w . r . t . x; // ----------------------------------------------------------------------; ; // Derivative of normalized gauss(x) w.r.t. observable x; RooAbsReal *dgdx = gauss.derivative(x, 1);; ; // Second and third derivative of normalized gauss(x) w.r.t. observable x; RooAbsReal *d2gdx2 = gauss.derivative(x, 2);; RooAbsReal *d3gdx3 = gauss.derivative(x, 3);; ; // Construct plot frame in 'x'; RooPlot *xframe = x.frame(Title(""d(Gauss)/dx""));; ; // Plot gauss in frame (i.e. in x); gauss.plotOn(xframe);; ; // Plot derivatives in same frame; dgdx->plotOn(xframe, LineColor(kMagenta));; d2gdx2->plotOn(xframe, LineColor(kRed));; d3gdx3->plotOn(xframe, LineColor(kOrange));; ; // C r e a t e a n d p l o t d e r i v a t i v e s w . r . t . s i g m a; // ------------------------------------------------------------------------------; ; // Derivative of normalized gauss(x) w.r.t. parameter sigma; RooAbsReal ",MatchSource.WIKI,doc/master/rf111__derivatives_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8C.html
Deployability,integrat,integrator,"---------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. observable x; dgdx = gauss.derivative(x, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. observable x; d2gdx2 = gauss.derivative(x, 2); d3gdx3 = gauss.derivative(x, 3); ; # Construct plot frame in 'x'; xframe = x.frame(Title=""d(Gauss)/dx""); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(xframe); ; # Plot derivatives in same frame; dgdx.plotOn(xframe, LineColor=""m""); d2gdx2.plotOn(xframe, LineColor=""r""); d3gdx3.plotOn(xframe, LineColor=""kOrange""); ; # Create and plot derivatives w.r.t. sigma; # ------------------------------------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. parameter sigma; dgds = gauss.derivative(sigma, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. parameter sigma; d2gds2 = gauss.derivative(sigma, 2); d3gds3 = gauss.derivative(sigma, 3); ; # Construct plot frame in 'sigma'; sframe = sigma.frame(Title=""d(Gauss)/d(sigma)"", Range=(0.0, 2.0)); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(sframe); ; # Plot derivatives in same frame; dgds.plotOn(sframe, LineColor=""m""); d2gds2.plotOn(sframe, LineColor=""r""); d3gds3.plotOn(sframe, LineColor=""kOrange""); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf111_derivatives"", ""rf111_derivatives"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); sframe.GetYaxis().SetTitleOffset(1.6); sframe.Draw(); ; c.SaveAs(""rf111_derivatives.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(gauss_Int[sigma]) using numeric integrator RooIntegrator1D to calculate Int(sigma); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf111_derivatives.py. tutorialsroofitrf111_derivatives.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf111__derivatives_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8py.html
Integrability,integrat,integrator,"---------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. observable x; dgdx = gauss.derivative(x, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. observable x; d2gdx2 = gauss.derivative(x, 2); d3gdx3 = gauss.derivative(x, 3); ; # Construct plot frame in 'x'; xframe = x.frame(Title=""d(Gauss)/dx""); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(xframe); ; # Plot derivatives in same frame; dgdx.plotOn(xframe, LineColor=""m""); d2gdx2.plotOn(xframe, LineColor=""r""); d3gdx3.plotOn(xframe, LineColor=""kOrange""); ; # Create and plot derivatives w.r.t. sigma; # ------------------------------------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. parameter sigma; dgds = gauss.derivative(sigma, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. parameter sigma; d2gds2 = gauss.derivative(sigma, 2); d3gds3 = gauss.derivative(sigma, 3); ; # Construct plot frame in 'sigma'; sframe = sigma.frame(Title=""d(Gauss)/d(sigma)"", Range=(0.0, 2.0)); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(sframe); ; # Plot derivatives in same frame; dgds.plotOn(sframe, LineColor=""m""); d2gds2.plotOn(sframe, LineColor=""r""); d3gds3.plotOn(sframe, LineColor=""kOrange""); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf111_derivatives"", ""rf111_derivatives"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); sframe.GetYaxis().SetTitleOffset(1.6); sframe.Draw(); ; c.SaveAs(""rf111_derivatives.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(gauss_Int[sigma]) using numeric integrator RooIntegrator1D to calculate Int(sigma); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf111_derivatives.py. tutorialsroofitrf111_derivatives.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf111__derivatives_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf111_derivatives.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf111_derivatives.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: numerical 1st, and 3rd order derivatives w.r.t. ; observables and parameters; pdf = gauss(x,m,s). ; import ROOT; ; # Set up model; # ---------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); mean = ROOT.RooRealVar(""mean"", ""mean of gaussian"", 1, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 1, 0.1, 10); ; # Build gaussian pdf in terms of x, and sigma; gauss = ROOT.RooGaussian(""gauss"", ""gaussian PDF"", x, mean, sigma); ; # Create and plot derivatives w.r.t. x; # ----------------------------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. observable x; dgdx = gauss.derivative(x, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. observable x; d2gdx2 = gauss.derivative(x, 2); d3gdx3 = gauss.derivative(x, 3); ; # Construct plot frame in 'x'; xframe = x.frame(Title=""d(Gauss)/dx""); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(xframe); ; # Plot derivatives in same frame; dgdx.plotOn(xframe, LineColor=""m""); d2gdx2.plotOn(xframe, LineColor=""r""); d3gdx3.plotOn(xframe, LineColor=""kOrange""); ; # Create and plot derivatives w.r.t. sigma; # ------------------------------------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. parameter sigma; dgds = gauss.derivative(sigma, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. parameter sigma; d2gds2 = gauss.derivative(sigma, 2); d3gds3 = gauss.derivative(sigma, 3); ; # Construct plot frame in 'sigma'; sframe = sigma.frame(Title=""d(Gauss)/d(sigma)"", Range=(0.0, 2.0)); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(sframe); ; # Plot derivatives in same fram",MatchSource.WIKI,doc/master/rf111__derivatives_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8py.html
Availability,error,error,"ss.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7fff963ebea0 RooAddPdf::model = 0.898624/1 [Auto,Clean] ; 0x7fff963eb588/V- RooChebychev::bkg = 0.79893 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963e9588/V- RooRealVar::a0 = 0.441621 +/- 0.0731875; 0x7fff963e9970/V- RooRealVar::a1 = 0.20107 +/- 0.117637; 0x7fff963eac48/V- RooRealVar::bkgfrac = 0.504184 +/- 0.0359091; 0x7fff963e9d58/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7fff963e8860/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963ea478/V- RooRealVar::mean = 5; 0x7fff963e8db8/V- RooRealVar::sigma1 = 0.5; 0x7fff963ea8",MatchSource.WIKI,doc/master/rf201__composite_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html
Modifiability,variab,variable,"kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; kDotted@ kDottedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' wit",MatchSource.WIKI,doc/master/rf201__composite_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html
Performance,optimiz,optimization,"ss.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7fff963ebea0 RooAddPdf::model = 0.898624/1 [Auto,Clean] ; 0x7fff963eb588/V- RooChebychev::bkg = 0.79893 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963e9588/V- RooRealVar::a0 = 0.441621 +/- 0.0731875; 0x7fff963e9970/V- RooRealVar::a1 = 0.20107 +/- 0.117637; 0x7fff963eac48/V- RooRealVar::bkgfrac = 0.504184 +/- 0.0359091; 0x7fff963e9d58/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7fff963e8860/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963ea478/V- RooRealVar::mean = 5; 0x7fff963e8db8/V- RooRealVar::sigma1 = 0.5; 0x7fff963ea8",MatchSource.WIKI,doc/master/rf201__composite_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html
Safety,safe,safe," frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn",MatchSource.WIKI,doc/master/rf201__composite_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html
Availability,error,error,"aw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x5b64db0 RooAddPdf::model = 0.886326/1 [Auto,Clean] ; 0x7475710/V- RooChebychev::bkg = 0.734412 [Auto,Dirty] ; 0x6e5aa50/V- RooRealVar::x = 5; 0x703aa10/V- RooRealVar::a0 = 0.506755 +/- 0.0795919; 0x6eef060/V- RooRealVar::a1 = 0.265588 +/- 0.133931; 0x748b980/V- RooRealVar::bkgfrac = 0.428008 +/- 0.0356013; 0x7492e20/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7078360/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x6e5aa50/V- RooRealVar::x = 5; 0x6dab710/V- RooRealVar::mean = 5; 0x69f2060/V- RooRealVar::sigma1 = 0.5; 0x72776d0/V- RooRealVar::sig1frac = 0.641992 +/- 0.0969095; 0x",MatchSource.WIKI,doc/master/rf201__composite_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html
Performance,optimiz,optimization,"aw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x5b64db0 RooAddPdf::model = 0.886326/1 [Auto,Clean] ; 0x7475710/V- RooChebychev::bkg = 0.734412 [Auto,Dirty] ; 0x6e5aa50/V- RooRealVar::x = 5; 0x703aa10/V- RooRealVar::a0 = 0.506755 +/- 0.0795919; 0x6eef060/V- RooRealVar::a1 = 0.265588 +/- 0.133931; 0x748b980/V- RooRealVar::bkgfrac = 0.428008 +/- 0.0356013; 0x7492e20/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7078360/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x6e5aa50/V- RooRealVar::x = 5; 0x6dab710/V- RooRealVar::mean = 5; 0x69f2060/V- RooRealVar::sigma1 = 0.5; 0x72776d0/V- RooRealVar::sig1frac = 0.641992 +/- 0.0969095; 0x",MatchSource.WIKI,doc/master/rf201__composite_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html
Safety,safe,safe,"---------; ; # Construct sum of models on one go using recursive fraction interpretations; #; # model2 = bkg + (sig1 + sig2); #; model2 = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig1, sig2], [bkgfrac, sig1frac], True); ; # NB: Each coefficient is interpreted as the fraction of the; # left-hand component of the i-th recursive sum, i.e.; #; # sum4 = A + ( B + ( C + D) with fraction fA, and fC expands to; #; # sum4 = fA*A + (1-fA)*(fB*B + (1-fB)*(fC*C + (1-fC)*D)); ; # Plot recursive addition model; # ---------------------------------------------------------; model2.plotOn(xframe, LineColor=""r"", LineStyle=""--""); model2.plotOn(xframe, Components={bkg, sig2}, LineColor=""r"", LineStyle=""--""); model2.Print(""t""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(",MatchSource.WIKI,doc/master/rf201__composite_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html
Availability,error,error,"s of PDFs (or othe...Definition JSONIO.h:26; rf202_extendedmlfitDefinition rf202_extendedmlfit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7ffc9b6dfb50 RooAddPdf::model = 0.898615/1 [Auto,Clean] ; 0x7ffc9b6df238/V- RooChebychev::bkg = 0.79892 [Auto,Dirty] ; 0x7ffc9b6df768/V- RooRealVar::x = 5; 0x7ffc9b6dd3a8/V- RooRealVar::a0 = 0.441701 +/- 0.0731848; 0x7ffc9b6dd790/V- RooRealVar::a1 = 0.20108 +/- 0.1176; 0x7ffc9b6dee50/V- RooRealVar::nbkg = 504.206 +/- 39.3065; 0x7ffc9b6ddf60/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffc9b6dc128/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffc9b6df768/V- RooRealVar::x = 5; 0x7ffc9b6de680/V- RooRealVar::mean = 5; 0x7ffc9b6dcbd8/V- RooRealVar::sigma1 = 0.5; 0x7ffc9b6ddb78/V- Ro",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html
Integrability,wrap,wrapper,"leOffset(1.4);; xframe->Draw();; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooExtendPdf.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kDashed@ kDashedDefinition TAttLine.h:48; kDotted@ kDottedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExtendPdfRooExtendPdf is a wrapper around an existing PDF that adds a parameteric extended likelihood term to ...Definition RooExtendPdf.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly swi",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html
Modifiability,extend,extended,". ROOT: tutorials/roofit/rf202_extendedmlfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf202_extendedmlfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Setting up an extended maximum likelihood fit. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooExtendPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf202_extendedmlfit(); {; ; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; //----------------; // M E T H O D 1; //================; ; // C o n s t r u c t e x t e n d e d c o m p o s i t e m o d e l; // -------------------------------------------------------------------; ; // Sum the composite signal and background into an extended pdf nsig*sig+nbkg*bkg; RooRealVar nsig(""nsig"", ""number of signal events"", 500, 0., 10000);; RooRealVar nbkg(""nbkg"", ""number of background events"", 500, 0, 10000);; RooAddPdf model(""model"", ""(g1+g2)+a"", RooArgList(bkg, sig), RooArgList(nbkg, nsig));; ; // ",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html
Performance,optimiz,optimization,"s of PDFs (or othe...Definition JSONIO.h:26; rf202_extendedmlfitDefinition rf202_extendedmlfit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7ffc9b6dfb50 RooAddPdf::model = 0.898615/1 [Auto,Clean] ; 0x7ffc9b6df238/V- RooChebychev::bkg = 0.79892 [Auto,Dirty] ; 0x7ffc9b6df768/V- RooRealVar::x = 5; 0x7ffc9b6dd3a8/V- RooRealVar::a0 = 0.441701 +/- 0.0731848; 0x7ffc9b6dd790/V- RooRealVar::a1 = 0.20108 +/- 0.1176; 0x7ffc9b6dee50/V- RooRealVar::nbkg = 504.206 +/- 39.3065; 0x7ffc9b6ddf60/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffc9b6dc128/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffc9b6df768/V- RooRealVar::x = 5; 0x7ffc9b6de680/V- RooRealVar::mean = 5; 0x7ffc9b6dcbd8/V- RooRealVar::sigma1 = 0.5; 0x7ffc9b6ddb78/V- Ro",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html
Safety,safe,safe,"hin that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf202_extendedmlfitDefinition rf202_extendedmlfit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plottin",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html
Availability,error,error,"rgin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf202_extendedmlfit.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x79f4920 RooAddPdf::model = 0.885989/1 [Auto,Clean] ; 0x5091a50/V- RooChebychev::bkg = 0.733482 [Auto,Dirty] ; 0x4d77490/V- RooRealVar::x = 5; 0x779ae60/V- RooRealVar::a0 = 0.507382 +/- 0.0795949; 0x76ed210/V- RooRealVar::a1 = 0.266518 +/- 0.133887; 0x797fc10/V- RooRealVar::nbkg = 427.704 +/- 38.0643; 0x77a8710/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7775040/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x4d77490/V- RooRealVar::x = 5; 0x70eb750/V- RooRealVar::mean = 5; 0x3efb120/V- RooRealVar::sigma1 = 0.5; 0x7a11850/V- RooRealVar::sig1frac = 0.640056 +/- 0.0966619; 0x772a3c",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8py.html
Modifiability,extend,extended,". ROOT: tutorials/roofit/rf202_extendedmlfit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf202_extendedmlfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: setting up an extended maximum likelihood fit . ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Method 1 - Construct extended composite model; # -------------------------------------------------------------------; ; # Sum the composite signal and background into an extended pdf; # nsig*sig+nbkg*bkg; nsig = ROOT.RooRealVar(""nsig"", ""number of signal events"", 500, 0.0, 10000); nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events"", 500, 0, 10000); model = ROOT.RooAddPdf(""model"", ""(g1+g2)+a"", [bkg, sig], [nbkg, nsig]); ; # Sample, fit and plot extended model; # ---------------------------------------------------------------------; ; # Generate a data sample of expected number events in x from model; # = model.expectedEvents() = nsig+nbkg; data = model.generate({x}); ; # Fit model ",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8py.html
Performance,optimiz,optimization,"rgin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf202_extendedmlfit.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x79f4920 RooAddPdf::model = 0.885989/1 [Auto,Clean] ; 0x5091a50/V- RooChebychev::bkg = 0.733482 [Auto,Dirty] ; 0x4d77490/V- RooRealVar::x = 5; 0x779ae60/V- RooRealVar::a0 = 0.507382 +/- 0.0795949; 0x76ed210/V- RooRealVar::a1 = 0.266518 +/- 0.133887; 0x797fc10/V- RooRealVar::nbkg = 427.704 +/- 38.0643; 0x77a8710/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7775040/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x4d77490/V- RooRealVar::x = 5; 0x70eb750/V- RooRealVar::mean = 5; 0x3efb120/V- RooRealVar::sigma1 = 0.5; 0x7a11850/V- RooRealVar::sig1frac = 0.640056 +/- 0.0966619; 0x772a3c",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8py.html
Safety,safe,safe,"aleFactor=1.0, scaleType=ROOT.RooAbsReal.RelativeExpected),; ); ; # Print structure of composite pdf; model.Print(""t""); ; ; # Method 2 - Construct extended components first; # ---------------------------------------------------------------------; ; # Associated nsig/nbkg as expected number of events with sig/bkg; esig = ROOT.RooExtendPdf(""esig"", ""extended signal pdf"", sig, nsig); ebkg = ROOT.RooExtendPdf(""ebkg"", ""extended background pdf"", bkg, nbkg); ; # Sum extended components without coefs; # -------------------------------------------------------------------------; ; # Construct sum of two extended pdf (no coefficients required); model2 = ROOT.RooAddPdf(""model2"", ""(g1+g2)+a"", [ebkg, esig]); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf202_extendedmlfit"", ""rf202_extendedmlfit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf202_extendedmlfit.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting",MatchSource.WIKI,doc/master/rf202__extendedmlfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8py.html
Availability,error,error," ; // F i t f u l l r a n g e; // ---------------------------; ; // Fit pdf to all data; std::unique_ptr<RooFitResult> r_full{model.fitTo(*modelData, Save(true), PrintLevel(-1))};; ; // F i t p a r t i a l r a n g e; // ----------------------------------; ; // Define ""signal"" range in x as [-3,3]; x.setRange(""signal"", -3, 3);; ; // Fit pdf only to data in ""signal"" range; std::unique_ptr<RooFitResult> r_sig{model.fitTo(*modelData, Save(true), Range(""signal""), PrintLevel(-1))};; ; // P l o t / p r i n t r e s u l t s; // ---------------------------------------; ; // Make plot frame in x and add data and fitted model; RooPlot *frame = x.frame(Title(""Fitting a sub range""));; modelData->plotOn(frame);; model.plotOn(frame, Range(""""), LineStyle(kDashed), LineColor(kRed)); // Add shape in full ranged dashed; model.plotOn(frame); // By default only fitted range is shown; ; // Print fit results; cout << ""result of fit on all data "" << endl;; r_full->Print();; cout << ""result of fit in in signal region (note increased error on signal fraction)"" << endl;; r_sig->Print();; ; // Draw frame on canvas; new TCanvas(""rf203_ranges"", ""rf203_ranges"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; ; return;; }; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooFitResult.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; mxOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t ",MatchSource.WIKI,doc/master/rf203__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf203__ranges_8C.html
Modifiability,variab,variable,"olor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char mxDefinition TGWin32VirtualXProxy.cxx:228; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::Printvoid Print(Option_t *options=nullptr) const overrideThis method must be overridden when a class wants to print itself.Definition RooPlot.h:138; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc",MatchSource.WIKI,doc/master/rf203__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf203__ranges_8C.html
Performance,optimiz,optimization,"ooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf203_rangesDefinition rf203_ranges.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signal' created with bounds [-3,3]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-3,3]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeNam",MatchSource.WIKI,doc/master/rf203__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf203__ranges_8C.html
Availability,error,error,"= ROOT.RooAddPdf(""model"", ""model"", [gx, px], [f]); ; # Generated 10000 events in (x,y) from pdf model; modelData = model.generate({x}, 10000); ; # Fit full range; # ---------------------------; ; # Fit pdf to all data; r_full = model.fitTo(modelData, Save=True, PrintLevel=-1); ; # Fit partial range; # ----------------------------------; ; # Define ""signal"" range in x as [-3,3]; x.setRange(""signal"", -3, 3); ; # Fit pdf only to data in ""signal"" range; r_sig = model.fitTo(modelData, Save=True, Range=""signal"", PrintLevel=-1); ; # Plot/print results; # ---------------------------------------; ; # Make plot frame in x and add data and fitted model; frame = x.frame(Title=""Fitting a sub range""); modelData.plotOn(frame); model.plotOn(frame, Range=""Full"", LineColor=""r"", LineStyle=""--"") # Add shape in full ranged dashed; model.plotOn(frame) # By default only fitted range is shown; ; # Print fit results; print(""result of fit on all data ""); r_full.Print(); print(""result of fit in in signal region (note increased error on signal fraction)""); r_sig.Print(); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf203_ranges"", ""rf203_ranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf203_ranges.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signal' created with bounds [-3,3]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-3,3]; [#1] INFO:Fittin",MatchSource.WIKI,doc/master/rf203__ranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf203__ranges_8py.html
Modifiability,variab,variable,"ed with bounds [-3,3]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeName>"").; The default (full) range can be denoted with Range("""") / NormRange("""").; [#0] ERROR:Plotting -- Range 'Full' not defined for variable 'x'. Ignoring ...; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) only plotting range 'Full'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_model_modelData'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeName>"").; The default (full) range can be denoted with Range("""") / NormRange("""").; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) only plotting range 'fit_nll_model_modelData'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_model_modelData'; ; R",MatchSource.WIKI,doc/master/rf203__ranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf203__ranges_8py.html
Performance,optimiz,optimization," range is shown; ; # Print fit results; print(""result of fit on all data ""); r_full.Print(); print(""result of fit in in signal region (note increased error on signal fraction)""); r_sig.Print(); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf203_ranges"", ""rf203_ranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf203_ranges.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signal' created with bounds [-3,3]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-3,3]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeName>"").; The defa",MatchSource.WIKI,doc/master/rf203__ranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf203__ranges_8py.html
Availability,error,error,"efinition JSONIO.h:26; rf204a_extendedLikelihoodDefinition rf204a_extendedLikelihood.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -3872.49, estimated distance to minimum: 4.30406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 4.2647e-01 +/- 7.59e-02; a1 1.7594e-01 +/- 1.10e-01; nbkg 5.1101e+02 +/- 3.60e+01; nsig 4.8899e+02 +/- 3.57e+01; sig1frac 8.6392e-01 +/- 1.08e-01; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [6,10]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html
Modifiability,extend,extended,". ROOT: tutorials/roofit/rf204a_extendedLikelihood.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204a_extendedLikelihood.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Extended maximum likelihood fit in multiple ranges. ; When an extended pdf and multiple ranges are used, the RooExtendPdf cannot correctly interpret the coefficients used for extension. This can be solved by using a RooAddPdf for extending the model.; ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooExtendPdf.h""; #include ""RooFitResult.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit ;; ; ; void rf204a_extendedLikelihood(); {; ; ; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Declare observable x; RooRealVar x(""x"",""x"",0,11) ;; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"",""mean of gaussians"",5) ;; RooRealVar sigma1(""sigma1"",""width of gaussians"",0.5) ;; RooRealVar sigma2(""sigma2"",""width of gaussians"",1) ;; ; RooGaussian sig1(""sig1"",""Signal component 1"",x,mean,sigma1) ;; RooGaussian sig2(""sig2"",""Signal component 2"",x,mean,sigma2) ;; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"",""a0"",0.5,0.,1.) ;; RooRealVar a1(""a1"",""a1"",0.2,0.,1.) ;; RooChebychev bkg(""bkg"",""Background"",x,RooArgSet(a0,a1)) ;; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"",""fraction of component 1 in signal"",0.8,0.,1.) ;; RooAddPdf sig(""sig"",""Signal"",RooArgList(sig1,sig2),sig1frac) ;; ; ; // E x t e n d t h e p d f s; // -----------------------------; ; ; // Define signal range in which events counts are to be defined; x.setRange(""signalRange"",4,6) ;; ; // Associated nsig/nbkg as expected number of events with sig/bkg _in_the_range_ ""signalRange""; RooRealVar nsig(""nsi",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html
Performance,optimiz,optimization,"efinition JSONIO.h:26; rf204a_extendedLikelihoodDefinition rf204a_extendedLikelihood.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -3872.49, estimated distance to minimum: 4.30406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 4.2647e-01 +/- 7.59e-02; a1 1.7594e-01 +/- 1.10e-01; nbkg 5.1101e+02 +/- 3.60e+01; nsig 4.8899e+02 +/- 3.57e+01; sig1frac 8.6392e-01 +/- 1.08e-01; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [6,10]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html
Safety,safe,safe,"ate a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::VisualizeErrorRooCmdArg VisualizeError(const RooDataSet &paramData, double Z=1)Definition RooGlobalFunc.cxx:300; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf204a_extendedLikelihoodDefinition rf204a_extendedLikelihood.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimi",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html
Availability,error,error,"On(frame3); model3.plotOn(frame3, VisualizeError=r3); model3.plotOn(frame3); model3.paramOn(frame3); frame3.Draw(); ; canv.Draw(); ; canv.SaveAs(""rf204a_extendedLikelihood.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -3872.49, estimated distance to minimum: 4.30406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 4.2647e-01 +/- 7.59e-02; a1 1.7594e-01 +/- 1.10e-01; nbkg 5.1101e+02 +/- 3.60e+01; nsig 4.8899e+02 +/- 3.57e+01; sig1frac 8.6392e-01 +/- 1.08e-01; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [6,10]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html
Modifiability,extend,extend,"igma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], sig1frac); ; ; # Extend the pdfs; # -----------------------------; ; # Define signal range in which events counts are to be defined; x.setRange(""signalRange"", 4, 6); ; # Associated nsig/nbkg as expected number of events with sig/bkg _in_the_range_ ""signalRange""; nsig = ROOT.RooRealVar(""nsig"", ""number of signal events in signalRange"", 500, 0.0, 10000); nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events in signalRange"", 500, 0, 10000); ; # Use AddPdf to extend the model. Giving as many coefficients as pdfs switches on extension.; model = ROOT.RooAddPdf(""model"", ""(g1+g2)+a"", [bkg, sig], [nbkg, nsig]); ; # Sample data, fit model; # -------------------------------------------; ; # Generate 1000 events from model so that nsig,nbkg come out to numbers <<500 in fit; data = model.generate(x, 1000); ; canv = ROOT.TCanvas(""Canvas"", ""Canvas"", 1500, 600); canv.Divide(3, 1); ; # Fit full range; # -------------------------------------------; ; # Perform unbinned ML fit to data, full range; ; # IMPORTANT:; # The model needs to be copied when fitting with different ranges because; # the interpretation of the coefficients is tied to the fit range; # that's used in the first fit; canv.cd(1); ; model1 = ROOT.RooAddPdf(model); r = model1.fitTo(data, Save=True, PrintLevel=-1); r.Print(); ; frame = x.frame(Title=""Full range fitted""); data.plotOn(frame); model1.plotOn(frame, VisualizeError=r); model1.plotOn(frame); ",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html
Performance,optimiz,optimization,"On(frame3); model3.plotOn(frame3, VisualizeError=r3); model3.plotOn(frame3); model3.paramOn(frame3); frame3.Draw(); ; canv.Draw(); ; canv.SaveAs(""rf204a_extendedLikelihood.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -3872.49, estimated distance to minimum: 4.30406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 4.2647e-01 +/- 7.59e-02; a1 1.7594e-01 +/- 1.10e-01; nbkg 5.1101e+02 +/- 3.60e+01; nsig 4.8899e+02 +/- 3.57e+01; sig1frac 8.6392e-01 +/- 1.08e-01; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [6,10]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html
Safety,safe,safe," x.setRange(""left"", 0.0, 4.0); x.setRange(""right"", 6.0, 10.0); ; model2 = ROOT.RooAddPdf(model); r2 = model2.fitTo(data, Range=""left,right"", Save=True, PrintLevel=-1); r2.Print(); ; frame2 = x.frame(Title=""Fit in left/right sideband""); data.plotOn(frame2); model2.plotOn(frame2, VisualizeError=r2); model2.plotOn(frame2); model2.paramOn(frame2); frame2.Draw(); ; ; # Fit in one region; # -------------------------------------------; # Note how restricting the region to only the left tail increases; # the fit uncertainty; ; canv.cd(3); x.setRange(""leftToMiddle"", 0.0, 5.0); ; model3 = ROOT.RooAddPdf(model); r3 = model3.fitTo(data, Range=""leftToMiddle"", Save=True, PrintLevel=-1); r3.Print(); ; frame3 = x.frame(Title=""Fit from left to middle""); data.plotOn(frame3); model3.plotOn(frame3, VisualizeError=r3); model3.plotOn(frame3); model3.paramOn(frame3); frame3.Draw(); ; canv.Draw(); ; canv.SaveAs(""rf204a_extendedLikelihood.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'signalRange' created with bounds [4,6]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFi",MatchSource.WIKI,doc/master/rf204a__extendedLikelihood_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html
Availability,error,error,"NamedPlaceHolder & Label; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf204b_extendedLikelihood_rangedFitDefinition rf204b_extendedLikelihood_rangedFit.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'RIGHT' created with bounds [60,100]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [10,100]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_extmodel_modelData' created with bounds [10,20]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(extmodel) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_extmodel_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::N = 3395.66 +/- 58.2751 L(0 - 20000) ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_RIGHT' created with bounds [60,100]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x|LEFT,RIGHT]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x|LEFT,RIGHT]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimizati",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html
Integrability,wrap,wrapper,"ooExponential.h; RooExtendPdf.h; RooFitResult.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TCanvas.h; N#define N; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooExponentialExponential PDF.Definition RooExponential.h:22; RooExtendPdfRooExtendPdf is a wrapper around an existing PDF that adds a parameteric extended likelihood term to ...Definition RooExtendPdf.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::LayoutRooCmdArg Layout(double xmin, double xmax=0.99, double ymin=0.95)Definition RooGlobalFunc.cxx:783; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::VisualizeErrorRooCmdA",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html
Modifiability,extend,extended,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model paramet",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html
Performance,perform,performed,"master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model parameter results in a number that is not easily interpreted.; If both regions correct their inte",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html
Safety,predict,predicted,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model paramet",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html
Usability,intuit,intuition,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model paramet",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html
Availability,error,error,"t(); ; frame3 = x.frame(); data.plotOn(frame3); modelsum.plotOn(frame3); modelsum.plotOn(frame3, VisualizeError=r3); modelsum.paramOn(frame3, Label=""S+B fit with RooAddPdf"", Layout=(0.3, 0.95)); frame3.Draw(); ; c.Draw(); ; c.SaveAs(""rf204b_extendedLikelihood_rangedFit.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'RIGHT' created with bounds [60,100]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [10,100]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_extmodel_modelData' created with bounds [10,20]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(extmodel) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_extmodel_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::N = 3395.66 +/- 58.2751 L(0 - 20000) ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_RIGHT' created with bounds [60,100]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x|LEFT,RIGHT]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x|LEFT,RIGHT]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimizati",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html
Modifiability,extend,extended,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same ",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html
Performance,perform,performed,"rence Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model parameter results in a number that is not easily interpreted.; If both regions correct their inte",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html
Safety,predict,predicted,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same ",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html
Usability,intuit,intuition,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same ",MatchSource.WIKI,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html
Modifiability,variab,variable,"ebychev.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kCyan@ kCyanDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; kDotted@ kDottedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::InvisibleRooCmdArg Invisible(bool inv=true)Definition RooGlobalFunc.cxx:276; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx",MatchSource.WIKI,doc/master/rf205__compplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf205__compplot_8C.html
Safety,safe,safe,"tTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::InvisibleRooCmdArg Invisible(bool inv=true)Definition RooGlobalFunc.cxx:276; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf205_compplotDefinition rf205_compplot.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2,sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bk",MatchSource.WIKI,doc/master/rf205__compplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf205__compplot_8C.html
Safety,safe,safe,"-----; ; # Plot single background component specified by name; model.plotOn(xframe2, Components=""bkg"", LineColor=""c""); ; # Plot multiple background components specified by name; model.plotOn(xframe2, Components=""bkg1,sig2"", LineStyle="":"", LineColor=""c""); ; # Plot multiple background components specified by regular expression on; # name; model.plotOn(xframe2, Components=""sig*"", LineStyle=""--"", LineColor=""c""); ; # Plot multiple background components specified by multiple regular; # expressions on name; model.plotOn(xframe2, Invisible=True, Components=""bkg1,sig*"", LineStyle=""--"", LineColor=""y""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf205_compplot"", ""rf205_compplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf205_compplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2,sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1",MatchSource.WIKI,doc/master/rf205__compplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf205__compplot_8py.html
Availability,avail,available,"""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0., 1.);; RooAddPdf bkg(""bkg"", ""Signal"", RooArgList(bkg1, bkg2), bkg1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // P r i n t c o m p o s i t e t r e e i n A S C I I; // -----------------------------------------------------------; ; // Print tree to stdout; model.Print(""t"");; ; // Print tree to file; model.printCompactTree("""", ""rf206_asciitree.txt"");; ; // D r a w c o m p o s i t e t r e e g r a p h i c a l l y; // -------------------------------------------------------------; ; // Print GraphViz DOT file with representation of tree; model.graphVizTree(""rf206_model.dot"");; ; // Make graphic output file with one of the GraphViz tools; // (freely available from www.graphviz.org); //; // 'Top-to-bottom graph'; // unix> dot -Tgif -o rf207_model_dot.gif rf207_model.dot; //; // 'Spring-model graph'; // unix> fdp -Tgif -o rf207_model_fdp.gif rf207_model.dot; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; RooFitTh",MatchSource.WIKI,doc/master/rf206__treevistools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8C.html
Safety,safe,safe,"oAddPdf.h; RooChebychev.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf206_treevistoolsDefinition rf206_treevistools.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7ffd18ff9e50 RooAddPdf::model = 0.582695/1 [Auto,Clean] ; 0x7ffd18ff8f60/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x7ffd18ff65f8/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff7bd8/V- RooRealVar::a0 = 0.5; 0x7ffd18ff7fc0/V- RooRealVar::a1 = 0.2; 0x7ffd18ff8790/V- RooRealVar::bkg1frac = 0.2; 0x7ffd18ff6b28/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff83a8/V- RooRealVar::alpha = -1; 0x7ffd18ff9a68/V- RooRealVar::bkgfrac = 0.5; 0x7ffd18ff5428/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffd18ff5b48/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff8b78/V- RooRealVar::mean = 5; 0x7ffd18ff702",MatchSource.WIKI,doc/master/rf206__treevistools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8C.html
Availability,avail,available,"pontential pdf; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -1); bkg2 = ROOT.RooExponential(""bkg2"", ""Background 2"", x, alpha); ; # Sum the background components into a composite background pdf; bkg1frac = ROOT.RooRealVar(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0.0, 1.0); bkg = ROOT.RooAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Print composite tree in ASCII; # -----------------------------------------------------------; ; # Print tree to stdout; model.Print(""t""); ; # Print tree to file; model.printCompactTree("""", ""rf206_asciitree.txt""); ; # Draw composite tree graphically; # -------------------------------------------------------------; ; # Print GraphViz DOT file with representation of tree; model.graphVizTree(""rf206_model.dot""); ; # Make graphic output file with one of the GraphViz tools; # (freely available from www.graphviz.org); #; # 'Top-to-bottom graph'; # unix> dot -Tgif -o rf207_model_dot.gif rf207_model.dot; #; # 'Spring-model graph'; # unix> fdp -Tgif -o rf207_model_fdp.gif rf207_model.dot; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x788d230 RooAddPdf::model = 0.602695/1 [Auto,Clean] ; 0x73f4730/V- RooAddPdf::bkg = 0.20539/1 [Auto,Clean] ; 0x793f3e0/V- RooChebychev::bkg1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7539e30/V- RooRealVar::a0 = 0.5; 0x7496810/V- RooRealVar::a1 = 0; 0x7353b80/V- RooRealVar::bkg1frac = 0.2; 0x792d390/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7429310/V- RooRealVar::alpha = -1;",MatchSource.WIKI,doc/master/rf206__treevistools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8py.html
Safety,safe,safe,"oAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Print composite tree in ASCII; # -----------------------------------------------------------; ; # Print tree to stdout; model.Print(""t""); ; # Print tree to file; model.printCompactTree("""", ""rf206_asciitree.txt""); ; # Draw composite tree graphically; # -------------------------------------------------------------; ; # Print GraphViz DOT file with representation of tree; model.graphVizTree(""rf206_model.dot""); ; # Make graphic output file with one of the GraphViz tools; # (freely available from www.graphviz.org); #; # 'Top-to-bottom graph'; # unix> dot -Tgif -o rf207_model_dot.gif rf207_model.dot; #; # 'Spring-model graph'; # unix> fdp -Tgif -o rf207_model_fdp.gif rf207_model.dot; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x788d230 RooAddPdf::model = 0.602695/1 [Auto,Clean] ; 0x73f4730/V- RooAddPdf::bkg = 0.20539/1 [Auto,Clean] ; 0x793f3e0/V- RooChebychev::bkg1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7539e30/V- RooRealVar::a0 = 0.5; 0x7496810/V- RooRealVar::a1 = 0; 0x7353b80/V- RooRealVar::bkg1frac = 0.2; 0x792d390/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7429310/V- RooRealVar::alpha = -1; 0x2ee1ac0/V- RooRealVar::bkgfrac = 0.5; 0x4d76f30/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7444460/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x6dbe690/V- RooRealVar::mean = 5; 0x3bcf160/V- RooRealVar::sigma1 = 0.5; 0x736e030/V- RooRealVar::sig1frac = 0.8; 0x7422370/V- R",MatchSource.WIKI,doc/master/rf206__treevistools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8py.html
Integrability,interface,interface,"uched. The name of each cloned node is that; // of the original node suffixed by the name of the customizer object; //; // The returned head node own all nodes that were cloned as part of; // the build process so when cust_clone is deleted so will all other; // nodes that were created in the process.; RooAbsPdf *cust_clone = (RooAbsPdf *)cust.build(true);; ; // Print structure of clone of model with sig->sigsum replacement.; cust_clone->Print(""t"");; ; delete cust_clone;; }; RooAddPdf.h; RooChebychev.h; RooCustomizer.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooCustomizerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition lege",MatchSource.WIKI,doc/master/rf207__comptools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf207__comptools_8C.html
Modifiability,variab,variables,"nent 1"", x, mean, sigma);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg1(""bkg1"", ""Background 1"", x, RooArgSet(a0, a1));; ; // Build exponential pdf; RooRealVar alpha(""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0., 1.);; RooAddPdf bkg(""bkg"", ""Signal"", RooArgList(bkg1, bkg2), bkg1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // Create dummy dataset that has more observables than the above pdf; RooRealVar y(""y"", ""y"", -10, 10);; RooDataSet data(""data"", ""data"", RooArgSet(x, y));; ; // ---------------------------------------------------; // B a s i c i n f o r m a t i o n r e q u e s t s; // ===================================================; ; // G e t l i s t o f o b s e r v a b l e s; // ---------------------------------------------; ; // Get list of observables of pdf in context of a dataset; //; // Observables are define each context as the variables; // shared between a model and a dataset. In this case; // that is the variable 'x'; ; std::unique_ptr<RooArgSet> model_obs{model.getObservables(data)};; model_obs->Print(""v"");; ; // G e t l i s t o f p a r a m e t e r s; // -------------------------------------------; ; // Get list of parameters, given list of observables; std::unique_ptr<RooArgSet> model_params{model.getParameters(x)};; model_params->Print(""v"");; ; // Get list of parameters, given a dataset; // (Gives identical results to operation above); std::unique_ptr<RooArgSet> model_params2{model.getParameters(data)};; model_params2->Print();; ; // G e t l i s t o f c o m p o n e n t s; // -------------------------------------------; ; // Get list",MatchSource.WIKI,doc/master/rf207__comptools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf207__comptools_8C.html
Safety,safe,safe,".h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooCustomizerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf207_comptoolsDefinition rf207_comptools.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; 1) 0x7ffcf3635ea0 RooRealVar:: x = 5 L(0 - 10) ""x""; 1) 0x7ffcf3632040 RooRealVar:: a0 = 0.5 L(0 - 1) ""a0""; 2) 0x7ffcf3632428 RooRealVar:: a1 = 0.2 L(0 - 1) ""a1""; 3) 0x7ffcf3632810 RooRealVar:: alpha = -1 C L(-INF - +INF) ""alpha""; 4) 0x7ffcf3632bf8 RooRealVar:: bkg1frac = 0.2 L(0 - 1) ""fraction of component 1 in background""; 5) 0x7ffcf3632fe0 RooRealVar:: bkgfrac = 0.5 L(0 - 1) ""fraction of background""; 6) 0x7ffcf3634428 RooRealVar:: mean = 5 C L(-INF - +INF) ""mean of gaussians""; 7) 0x7ffcf3631c58 RooRealVar:: sigma = 0.5 C L(-INF - +INF) ""width of gaussians""; RooArgSet::parameters = (a0,a1,alpha,bkg1frac,bkgfrac,mean,sigma); 1) 0x7ffcf3635228 RooAddPdf:: model[ bkgfrac * bkg + [%] * sig ] = 0.582695/1 ""g1+g2+a""; 2) 0x7ffcf3633d08 RooAddPdf:: bkg[ bkg1frac * bkg1 + [%] * bkg2 ] = 0.16539/1 ""Signal""; 3) 0x7ffcf3631230 RooChebychev:: bkg1[ x=x coefficients=(a0,a1) ] = 0.8 ""Background 1""; 4",MatchSource.WIKI,doc/master/rf207__comptools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf207__comptools_8C.html
Integrability,depend,depends,"fraction of background""; 6) 0x82654f0 RooRealVar:: mean = 5 C L(-INF - +INF) ""mean of gaussians""; 7) 0x7ef2000 RooRealVar:: sigma = 0.5 C L(-INF - +INF) ""width of gaussians""; RooArgSet::parameters = (a0,a1,alpha,bkg1frac,bkgfrac,mean,sigma); 1) 0x8a01230 RooAddPdf:: model[ bkgfrac * bkg + [%] * sig ] = 0.582695/1 ""g1+g2+a""; 2) 0x898ff20 RooAddPdf:: bkg[ bkg1frac * bkg1 + [%] * bkg2 ] = 0.16539/1 ""Signal""; 3) 0x891da50 RooChebychev:: bkg1[ x=x coefficients=(a0,a1) ] = 0.8 ""Background 1""; 4) 0x8948240 RooExponential:: bkg2[ x=x c=alpha ] = 0.00673795 ""Background 2""; 5) 0x8554880 RooGaussian:: sig[ x=x mean=mean sigma=sigma ] = 1 ""Signal component 1""; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooCustomizer::build(model): tree node sig will be replaced by sigsum; [#1] INFO:ObjectHandling -- RooCustomizer::build(model) Branch node RooAddPdf::model cloned: depends on a replaced parameter; [#1] INFO:ObjectHandling -- RooCustomizer::build(model) Branch node sig is already replaced; 0x8e664a0 RooAddPdf::model_cust = 0.582695/1 [Auto,Clean] ; 0x898ff20/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x891da50/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x8241e40/V- RooRealVar::x = 5; 0x847fc10/V- RooRealVar::a0 = 0.5; 0x84f2330/V- RooRealVar::a1 = 0.2; 0x8782390/V- RooRealVar::bkg1frac = 0.2; 0x8948240/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x8241e40/V- RooRealVar::x = 5; 0x87f3060/V- RooRealVar::alpha = -1; 0x8926120/V- RooRealVar::bkgfrac = 0.5; 0x8cd8990/V- RooAddPdf::sigsum = 1/1 [Auto,Clean] ; 0x8554880/V- RooGaussian::sig = 1 [Auto,Dirty] ; 0x8241e40/V- RooRealVar::x = 5; 0x82654f0/V- RooRealVar::mean = 5; 0x7ef2000/V- RooRealVar::sigma = 0.5; 0x209c5a0/V- RooRealVar::sig1frac = 0.8; 0x8f54960/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x8241e40/V- RooRealVar::x = 5; 0x82654f0/V- RooRealVar::mean = 5; 0x40132d0/V-",MatchSource.WIKI,doc/master/rf207__comptools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf207__comptools_8py.html
Modifiability,variab,variables,"(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.2, 0.0, 1.0); bkg1 = ROOT.RooChebychev(""bkg1"", ""Background 1"", x, [a0, a1]); ; # Build expontential pdf; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -1); bkg2 = ROOT.RooExponential(""bkg2"", ""Background 2"", x, alpha); ; # Sum the background components into a composite background p.d.f.; bkg1frac = ROOT.RooRealVar(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0.0, 1.0); bkg = ROOT.RooAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create dummy dataset that has more observables than the above pdf; y = ROOT.RooRealVar(""y"", ""y"", -10, 10); data = ROOT.RooDataSet(""data"", ""data"", {x, y}); ; # Basic information requests; # ---------------------------------------------; ; ; # Get list of observables; # ---------------------------------------------; ; # Get list of observables of pdf in context of a dataset; #; # Observables are define each context as the variables; # shared between a model and a dataset. In self case; # that is the variable 'x'; ; model_obs = model.getObservables(data); ROOT.SetOwnership(model_obs, True); model_obs.Print(""v""); ; # Get list of parameters; # -------------------------------------------; ; # Get list of parameters, list of observables; model_params = model.getParameters({x}); ROOT.SetOwnership(model_params, True); model_params.Print(""v""); ; # Get list of parameters, a dataset; # (Gives identical results to operation above); model_params2 = model.getParameters(data); ROOT.SetOwnership(model_params2, True); model_params2.Print(); ; # Get list of components; # -------------------------------------------; ; # Get list of component objects, top-level node; model_comps = model.getComponents(); ROOT.SetOwnership(model_comps, True); model_comps.Print(""v""); ; # Modifications to structure of",MatchSource.WIKI,doc/master/rf207__comptools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf207__comptools_8py.html
Safety,safe,safe,"ent 1 in signal"", 0.8, 0.0, 1.0); sigsum = ROOT.RooAddPdf(""sigsum"", ""sig+sig2"", [sig, sig2], [sig1frac]); ; # Construct a customizer utility to customize model; cust = ROOT.RooCustomizer(model, ""cust""); ; # Instruct the customizer to replace node 'sig' with node 'sigsum'; cust.replaceArg(sig, sigsum); ; # Build a clone of the input pdf according to the above customization; # instructions. Each node that requires modified is clone so that the; # original pdf remained untouched. The name of each cloned node is that; # of the original node suffixed by the name of the customizer object; #; # The returned head node own all nodes that were cloned as part of; # the build process so when cust_clone is deleted so will all other; # nodes that were created in the process.; cust_clone = cust.build(ROOT.kTRUE); ROOT.SetOwnership(cust_clone, True); ; # Print structure of clone of model with sig.sigsum replacement.; cust_clone.Print(""t""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; 1) 0x8241e40 RooRealVar:: x = 5 L(0 - 10) ""x""; 1) 0x847fc10 RooRealVar:: a0 = 0.5 L(0 - 1) ""a0""; 2) 0x84f2330 RooRealVar:: a1 = 0.2 L(0 - 1) ""a1""; 3) 0x87f3060 RooRealVar:: alpha = -1 C L(-INF - +INF) ""alpha""; 4) 0x8782390 RooRealVar:: bkg1frac = 0.2 L(0 - 1) ""fraction of component 1 in background""; 5) 0x8926120 RooRealVar:: bkgfrac = 0.5 L(0 - 1) ""fraction of background""; 6) 0x82654f0 RooRealVar:: mean = 5 C L(-INF - +INF) ""mean of gaussians""; 7) 0x7ef2000 RooRealVar:: sigma = 0.5 C L(-INF - +INF) ""width of gaussians""; RooArgSet::parameters = (a0,a1,alpha,bkg1frac,bkgfrac,mean,sigma); 1) 0x8a01230 RooAddPdf:: model[ bkgfrac * bkg + [%] * sig ] = 0.582695/1 ""g1+g2+a""; 2) 0x898ff20 RooAddPdf:: bkg[ bkg1frac * bkg1 + [%] * bkg2 ] = 0.16539/1 ""Signal""; 3) 0x891da50 RooChebychev:: bkg1[ x=x coefficients=(a0,a1) ] = 0.8 ""Background 1""; 4) 0x8948240 RooExponential:: bkg2[ x=x c=alpha ] = 0.",MatchSource.WIKI,doc/master/rf207__comptools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf207__comptools_8py.html
Availability,error,error,"Yaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf208_convolutionDefinition rf208_convolution.py:1; ; [#1] INFO:Eval -- RooRealVar::setRange(t) new range named 'refrange_fft_lxg' created with bounds [-10,30]; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539f82d770 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lxg_over_lxg_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lxg_over_lxg_Int[t]_lxgData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539fd9f650 with pdf lx_CONV_gauss_CACHE_Obs[t] for nset () with code 1 from preexisting content.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539fcccee0 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf208_convolution.C. tutorialsroofitrf208_convolution.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf208__convolution_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf208__convolution_8C.html
Modifiability,variab,variable,"me, LineStyle(kDashed));; ; // Draw frame on canvas; new TCanvas(""rf208_convolution"", ""rf208_convolution"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; RooDataSet.h; RooFFTConvPdf.h; RooGaussian.h; RooLandau.h; RooPlot.h; RooRealVar.h; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooFFTConvPdfPDF for the numerical (FFT) convolution of two PDFs.Definition RooFFTConvPdf.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooLandauLandau distribution p.d.f.Definition RooLandau.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf208_convolutionDefinition rf208_convolution.py:1; ; [#1] INFO:Eval -- RooRealVar::setRange(t) new range named 'refrange_fft_lxg' created with bounds [-10,30]; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539f82d770 with pdf lx_CONV_gauss_CACH",MatchSource.WIKI,doc/master/rf208__convolution_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf208__convolution_8C.html
Performance,cache,cache,"RooGaussian.h""; #include ""RooLandau.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf208_convolution(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Construct observable; RooRealVar t(""t"", ""t"", -10, 30);; ; // Construct landau(t,ml,sl) ;; RooRealVar ml(""ml"", ""mean landau"", 5., -20, 20);; RooRealVar sl(""sl"", ""sigma landau"", 1, 0.1, 10);; RooLandau landau(""lx"", ""lx"", t, ml, sl);; ; // Construct gauss(t,mg,sg); RooRealVar mg(""mg"", ""mg"", 0);; RooRealVar sg(""sg"", ""sg"", 2, 0.1, 10);; RooGaussian gauss(""gauss"", ""gauss"", t, mg, sg);; ; // C o n s t r u c t c o n v o l u t i o n p d f; // ---------------------------------------; ; // Set #bins to be used for FFT sampling to 10000; t.setBins(10000, ""cache"");; ; // Construct landau (x) gauss; RooFFTConvPdf lxg(""lxg"", ""landau (X) gauss"", t, landau, gauss);; ; // S a m p l e , f i t a n d p l o t c o n v o l u t e d p d f; // ----------------------------------------------------------------------; ; // Sample 1000 events in x from gxlx; std::unique_ptr<RooDataSet> data{lxg.generate(t, 10000)};; ; // Fit gxlx to data; lxg.fitTo(*data, PrintLevel(-1));; ; // Plot data, landau pdf, landau (X) gauss pdf; RooPlot *frame = t.frame(Title(""landau (x) gauss convolution""));; data->plotOn(frame);; lxg.plotOn(frame);; landau.plotOn(frame, LineStyle(kDashed));; ; // Draw frame on canvas; new TCanvas(""rf208_convolution"", ""rf208_convolution"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; RooDataSet.h; RooFFTConvPdf.h; RooGaussian.h; RooLandau.h; RooPlot.h; RooRealVar.h; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#def",MatchSource.WIKI,doc/master/rf208__convolution_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf208__convolution_8C.html
Availability,error,error," Sample, fit and plot convoluted pdf; # ----------------------------------------------------------------------; ; # Sample 1000 events in x from gxlx; data = lxg.generate({t}, 10000); ; # Fit gxlx to data; lxg.fitTo(data, PrintLevel=-1); ; # Plot data, pdf, landau (X) gauss pdf; frame = t.frame(Title=""landau (x) gauss convolution""); data.plotOn(frame); lxg.plotOn(frame); landau.plotOn(frame, LineStyle=""--""); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf208_convolution"", ""rf208_convolution"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf208_convolution.png""); [#1] INFO:Eval -- RooRealVar::setRange(t) new range named 'refrange_fft_lxg' created with bounds [-10,30]; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x85ab260 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lxg_over_lxg_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lxg_over_lxg_Int[t]_lxgData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x88084e0 with pdf lx_CONV_gauss_CACHE_Obs[t] for nset () with code 1 from preexisting content.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x82935f0 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf208_convolution.py. tutorialsroofitrf208_convolution.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf208__convolution_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf208__convolution_8py.html
Performance,cache,cache,"ence Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf208_convolution.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ADDITION AND CONVOLUTION' RooFit tutorial macro #208 One-dimensional numeric convolution (require ROOT to be compiled with –enable-fftw3) ; pdf = landau(t) (x) gauss(t). ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Construct observable; t = ROOT.RooRealVar(""t"", ""t"", -10, 30); ; # Construct landau(t,ml,sl); ml = ROOT.RooRealVar(""ml"", ""mean landau"", 5.0, -20, 20); sl = ROOT.RooRealVar(""sl"", ""sigma landau"", 1, 0.1, 10); landau = ROOT.RooLandau(""lx"", ""lx"", t, ml, sl); ; # Construct gauss(t,mg,sg); mg = ROOT.RooRealVar(""mg"", ""mg"", 0); sg = ROOT.RooRealVar(""sg"", ""sg"", 2, 0.1, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", t, mg, sg); ; # Construct convolution pdf; # ---------------------------------------; ; # Set #bins to be used for FFT sampling to 10000; t.setBins(10000, ""cache""); ; # Construct landau (x) gauss; lxg = ROOT.RooFFTConvPdf(""lxg"", ""landau (X) gauss"", t, landau, gauss); ; # Sample, fit and plot convoluted pdf; # ----------------------------------------------------------------------; ; # Sample 1000 events in x from gxlx; data = lxg.generate({t}, 10000); ; # Fit gxlx to data; lxg.fitTo(data, PrintLevel=-1); ; # Plot data, pdf, landau (X) gauss pdf; frame = t.frame(Title=""landau (x) gauss convolution""); data.plotOn(frame); lxg.plotOn(frame); landau.plotOn(frame, LineStyle=""--""); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf208_convolution"", ""rf208_convolution"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf208_convolution.png""); [#1] INFO:Eval -- RooRealVar::setRange(t) new range named 'refrange_fft_lxg' created with bounds [-10,30]; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x85ab260 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; [#1] INFO:Fitting ",MatchSource.WIKI,doc/master/rf208__convolution_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf208__convolution_8py.html
Energy Efficiency,efficient,efficient,"Var bias2(""bias2"", ""bias2"", 0);; RooRealVar sigma2(""sigma2"", ""sigma2"", 5);; RooGaussModel gm2(""gm2"", ""gauss model 2"", dt, bias2, sigma2);; ; // Build a composite resolution model f*gm1+(1-f)*gm2; RooRealVar gm1frac(""gm1frac"", ""fraction of gm1"", 0.5);; RooAddModel gmsum(""gmsum"", ""sum of gm1 and gm2"", RooArgList(gm1, gm2), gm1frac);; ; // Construct decay(t) (x) (f*gm1 + (1-f)*gm2); RooDecay decay_gmsum(""decay_gmsum"", ""decay"", dt, tau, gmsum, RooDecay::DoubleSided);; ; // Plot pdf (red); decay_gmsum.plotOn(frame, LineColor(kRed));; ; // Draw all frames on canvas; new TCanvas(""rf209_anaconv"", ""rf209_anaconv"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddModel.h; RooDataSet.h; RooDecay.h; RooGaussModel.h; RooPlot.h; RooRealVar.h; RooTruthModel.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAddModelRooAddModel is an efficient implementation of a sum of PDFs of the form.Definition RooAddModel.h:27; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDecaySingle or double sided decay function that can be analytically convolved with any RooResolutionModel ...Definition RooDecay.h:22; RooDecay::DoubleSided@ DoubleSidedDefinition RooDecay.h:25; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; Ro",MatchSource.WIKI,doc/master/rf209__anaconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf209__anaconv_8C.html
Modifiability,variab,variable,"t(1.6);; frame->Draw();; }; RooAddModel.h; RooDataSet.h; RooDecay.h; RooGaussModel.h; RooPlot.h; RooRealVar.h; RooTruthModel.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAddModelRooAddModel is an efficient implementation of a sum of PDFs of the form.Definition RooAddModel.h:27; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDecaySingle or double sided decay function that can be analytically convolved with any RooResolutionModel ...Definition RooDecay.h:22; RooDecay::DoubleSided@ DoubleSidedDefinition RooDecay.h:25; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooTruthModelImplements a RooResolution model that corresponds to a delta function.Definition RooTruthModel.h:21; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf209_anaconvDefinition rf209_anaconv.py:1; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf209_anaconv.C. tutorialsroofitrf209_anaconv.C. ROOT m",MatchSource.WIKI,doc/master/rf209__anaconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf209__anaconv_8C.html
Availability,error,error,"ith bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d599f000 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d5fcc4a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d7a23790 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCach",MatchSource.WIKI,doc/master/rf210__angularconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html
Deployability,integrat,integrator,"finition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf210_angularconvDefinition rf210_angularconv.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d599f000 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d5fcc4a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]",MatchSource.WIKI,doc/master/rf210__angularconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html
Integrability,integrat,integrator,"finition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf210_angularconvDefinition rf210_angularconv.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d599f000 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d5fcc4a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]",MatchSource.WIKI,doc/master/rf210__angularconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html
Modifiability,variab,variable,"1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFFTConvPdf.h; RooFormulaVar.h; RooGaussian.h; RooGenericPdf.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooFFTConvPdfPDF for the numerical (FFT) convolution of two PDFs.Definition RooFFTConvPdf.h:25; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooGenericPdfImplementation of a probability density function that takes a RooArgList of servers and a C++ express...Definition RooGenericPdf.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf210_angularconvDefinition rf210_angularconv.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cx",MatchSource.WIKI,doc/master/rf210__angularconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html
Performance,perform,performed,". ROOT: tutorials/roofit/rf210_angularconv.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf210_angularconv.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: convolution in cyclical angular observables theta ; and construction of pdf in terms of transformed angular coordinates, e.g. cos(theta), where the convolution is performed in theta rather than cos(theta); pdf(theta) = T(theta) (x) gauss(theta); pdf(cosTheta) = T(acos(cosTheta)) (x) gauss(acos(cosTheta)); xDouble_t x[n]Definition legend1.C:17; This tutorial requires FFT3 to be enabled. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooGenericPdf.h""; #include ""RooFormulaVar.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf210_angularconv(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Define angle psi; RooRealVar psi(""psi"", ""psi"", 0, 3.14159268);; ; // Define physics pdf T(psi); RooGenericPdf Tpsi(""Tpsi"", ""1+sin(2*@0)"", psi);; ; // Define resolution R(psi); RooRealVar gbias(""gbias"", ""gbias"", 0.2, 0., 1);; RooRealVar greso(""greso"", ""greso"", 0.3, 0.1, 1.0);; RooGaussian Rpsi(""Rpsi"", ""Rpsi"", psi, gbias, greso);; ; // Define cos(psi) and function psif that calculates psi from cos(psi); RooRealVar cpsi(""cpsi"", ""cos(psi)"", -1, 1);; RooFormulaVar psif(""psif"", ""acos(cpsi)"", cpsi);; ; // Define physics pdf also as function of cos(psi): T(psif(cpsi)) = T(cpsi) ;; RooGenericPdf Tcpsi(""T"", ""1+sin(2*@0)"", psif);; ; // C o n s t r u c t c o n v o l u t i o n p d f i n p s i; // --------------------------------------------------------------; ; // Define convoluted pdf as function of psi: M=[T(x)R](psi) = M(psi); RooFFTConvPdf Mpsi(""Mf"", ""Mf"", psi, Tpsi, Rpsi);; ; // Set the buffer fraction to zero to obtain a true cyclical convolution; Mpsi.setBuffer",MatchSource.WIKI,doc/master/rf210__angularconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html
Availability,error,error,"_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7caf5a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7ef8390 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::g",MatchSource.WIKI,doc/master/rf210__angularconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html
Deployability,integrat,integrator,"rame2); ; # Overlay comparison to unsmeared physics p.d.f ROOT.Tf(cpsi); Tcpsi.plotOn(frame2, LineColor=""r""); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf210_angularconv"", ""rf210_angularconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf210_angularconv.png""); [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7caf5a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () wi",MatchSource.WIKI,doc/master/rf210__angularconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html
Integrability,integrat,integrator,"rame2); ; # Overlay comparison to unsmeared physics p.d.f ROOT.Tf(cpsi); Tcpsi.plotOn(frame2, LineColor=""r""); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf210_angularconv"", ""rf210_angularconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf210_angularconv.png""); [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7caf5a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () wi",MatchSource.WIKI,doc/master/rf210__angularconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html
Modifiability,variab,variable,"ed pdf (cospsi); # --------------------------------------------------------------------------------; ; # Generate some events; data_cpsi = Mcpsi.generate({cpsi}, 10000); ; # set psi constant to exclude to be a parameter of the fit; psi.setConstant(True); ; # Fit convoluted model as function of cos(psi); Mcpsi.fitTo(data_cpsi, PrintLevel=-1); ; # Plot cos(psi) frame with Mf(cpsi); frame2 = cpsi.frame(Title=""Same convolution in psi, in cos(psi)""); data_cpsi.plotOn(frame2); Mcpsi.plotOn(frame2); ; # Overlay comparison to unsmeared physics p.d.f ROOT.Tf(cpsi); Tcpsi.plotOn(frame2, LineColor=""r""); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf210_angularconv"", ""rf210_angularconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf210_angularconv.png""); [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for",MatchSource.WIKI,doc/master/rf210__angularconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html
Performance,perform,performed,". ROOT: tutorials/roofit/rf210_angularconv.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf210_angularconv.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Convolution in cyclical angular observables theta, and construction of p.d.f in terms of transformed angular coordinates, e.g. ; cos(theta), the convolution is performed in theta rather than cos(theta); (require ROOT to be compiled with –enable-fftw3); pdf(theta) = ROOT.T(theta) (x) gauss(theta) pdf(cosTheta) = ROOT.T(acos(cosTheta)) (x) gauss(acos(cosTheta)). ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Define angle psi; psi = ROOT.RooRealVar(""psi"", ""psi"", 0, 3.14159268); ; # Define physics p.d.f T(psi); Tpsi = ROOT.RooGenericPdf(""Tpsi"", ""1+sin(2*@0)"", [psi]); ; # Define resolution R(psi); gbias = ROOT.RooRealVar(""gbias"", ""gbias"", 0.2, 0.0, 1); greso = ROOT.RooRealVar(""greso"", ""greso"", 0.3, 0.1, 1.0); Rpsi = ROOT.RooGaussian(""Rpsi"", ""Rpsi"", psi, gbias, greso); ; # Define cos(psi) and function psif that calculates psi from cos(psi); cpsi = ROOT.RooRealVar(""cpsi"", ""cos(psi)"", -1, 1); psif = ROOT.RooFormulaVar(""psif"", ""acos(cpsi)"", [cpsi]); ; # Define physics p.d.f. also as function of cos(psi): T(psif(cpsi)) = T(cpsi); Tcpsi = ROOT.RooGenericPdf(""T"", ""1+sin(2*@0)"", [psif]); ; # Construct convolution pdf in psi; # --------------------------------------------------------------; ; # Define convoluted p.d.f. as function of psi: M=[T(x)R](psi) = M(psi); Mpsi = ROOT.RooFFTConvPdf(""Mf"", ""Mf"", psi, Tpsi, Rpsi); ; # Set the buffer fraction to zero to obtain a ROOT.True cyclical; # convolution; Mpsi.setBufferFraction(0); ; # Sample, fit and plot convoluted pdf (psi); # --------------------------------------------------------------------------------; ; # Generate some events in observable psi; data_psi = Mpsi.generate({psi}, 10000); ; # Fit convoluted model as function of angle psi; Mpsi.fitTo(dat",MatchSource.WIKI,doc/master/rf210__angularconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html
Availability,error,error,"h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161eb090f0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161eb090f0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[mean]_Norm[mean,x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[mean]_Norm[mean,x]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.2; sigma=0.5, [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral ",MatchSource.WIKI,doc/master/rf211__paramconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html
Deployability,integrat,integrated,"RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateBinnedvirtual RooFit::OwningPtr< RooDataHist > generateBinned(const RooArgSet &whatVars, double nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooFFTConvPdfPDF for the numerical (FFT) convolution of two PDFs.Definition RooFFTConvPdf.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooGenericPdfImplementation of a probability density function that takes a RooArgList of servers and a C++ express...Definition RooGenericPdf.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outs",MatchSource.WIKI,doc/master/rf211__paramconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html
Integrability,interface,interface,"and fitted pdf; RooPlot *frame = x.frame(Bins(25));; d->plotOn(frame);; projModel->plotOn(frame);; ; // Make 2d histogram of model(x;mean); TH1 *hh = model.createHistogram(""hh"", x, Binning(50), YVar(mean, Binning(50)), ConditionalObservables(mean));; hh->SetTitle(""histogram of model(x|mean)"");; hh->SetLineColor(kBlue);; ; // Draw frame on canvas; TCanvas *c = new TCanvas(""rf211_paramconv"", ""rf211_paramconv"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.20);; hh->GetZaxis()->SetTitleOffset(2.5);; hh->Draw(""surf"");; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataHist.h; RooFFTConvPdf.h; RooFormulaVar.h; RooGaussian.h; RooGenericPdf.h; RooPlot.h; RooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TH2.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateBinnedvirtual RooFit::OwningPtr< RooDataHist > generateBinned(const RooArgSet &whatVars, double nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAb",MatchSource.WIKI,doc/master/rf211__paramconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html
Modifiability,variab,variable,"ooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooFFTConvPdfPDF for the numerical (FFT) convolution of two PDFs.Definition RooFFTConvPdf.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooGenericPdfImplementation of a probability density function that takes a RooArgList of servers and a C++ express...Definition RooGenericPdf.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram ",MatchSource.WIKI,doc/master/rf211__paramconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html
Performance,cache,cache,"Tutorials. Detailed Description; Addition and convolution: working with a pdf with a convolution operator in terms of a parameter ; This tutorial requires FFT3 to be enabled. ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooGenericPdf.h""; #include ""RooFormulaVar.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH2.h""; using namespace RooFit;; ; void rf211_paramconv(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Gaussian g(x ; mean,sigma); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar mean(""mean"", ""mean"", -3, 3);; RooRealVar sigma(""sigma"", ""sigma"", 0.5, 0.1, 10);; RooGaussian modelx(""gx"", ""gx"", x, mean, sigma);; ; // Block function in mean; RooRealVar a(""a"", ""a"", 2, 1, 10);; RooGenericPdf model_mean(""model_mean"", ""abs(mean)<a"", RooArgList(mean, a));; ; // Convolution in mean parameter model = g(x,mean,sigma) (x) block(mean); x.setBins(1000, ""cache"");; mean.setBins(50, ""cache"");; RooFFTConvPdf model(""model"", ""model"", mean, modelx, model_mean);; ; // Configure convolution to construct a 2-D cache in (x,mean); // rather than a 1-d cache in mean that needs to be recalculated; // for each value of x; model.setCacheObservables(x);; model.setBufferFraction(1.0);; ; // Integrate model over mean projModel = Int model dmean; RooAbsPdf *projModel = model.createProjection(mean);; ; // Generate 1000 toy events; std::unique_ptr<RooDataHist> d{projModel->generateBinned(x, 1000)};; ; // Fit pdf to toy data; projModel->fitTo(*d, Verbose(), PrintLevel(-1));; ; // Plot data and fitted pdf; RooPlot *frame = x.frame(Bins(25));; d->plotOn(frame);; projModel->plotOn(frame);; ; // Make 2d histogram of model(x;mean); TH1 *hh = model.createHistogram(""hh"", x, Binning(50), YVar(mean, Binning(50)), ConditionalObservables(mean));; hh->SetTitle(""histogram of model(x|mean)"");; hh->SetLineColor(kBlue);; ; // Draw frame on canvas; TCanvas *c = new TCanvas(",MatchSource.WIKI,doc/master/rf211__paramconv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html
Availability,error,error,"994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7f45240 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x84ccbe0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[mean]_Norm[mean,x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[mean]_Norm[mean,x]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.2; sigma=0.5, [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral ",MatchSource.WIKI,doc/master/rf211__paramconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html
Deployability,integrat,integrator,", Binning=50),; ConditionalObservables={mean},; ); hh.SetTitle(""histogram of model(x|mean)""); hh.SetLineColor(ROOT.kBlue); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf211_paramconv"", ""rf211_paramconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); ; c.SaveAs(""rf211_paramconv.png""); [#1] INFO:Eval -- RooRealVar::setRange(mean) new range named 'refrange_fft_model' created with bounds [-3,3]; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7937fb0 with pdf gx_CONV_model_mean_CACHE_Obs[mean,x]_NORM_mean for nset (mean",MatchSource.WIKI,doc/master/rf211__paramconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html
Integrability,integrat,integrator,", Binning=50),; ConditionalObservables={mean},; ); hh.SetTitle(""histogram of model(x|mean)""); hh.SetLineColor(ROOT.kBlue); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf211_paramconv"", ""rf211_paramconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); ; c.SaveAs(""rf211_paramconv.png""); [#1] INFO:Eval -- RooRealVar::setRange(mean) new range named 'refrange_fft_model' created with bounds [-3,3]; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7937fb0 with pdf gx_CONV_model_mean_CACHE_Obs[mean,x]_NORM_mean for nset (mean",MatchSource.WIKI,doc/master/rf211__paramconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html
Performance,cache,cache,". ROOT: tutorials/roofit/rf211_paramconv.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf211_paramconv.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ADDITION AND CONVOLUTION' RooFit tutorial macro #211 Working a with a p.d.f. ; with a convolution operator in terms of a parameter; (require ROOT to be compiled with –enable-fftw3). ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Gaussian g(x ; mean,sigma); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); mean = ROOT.RooRealVar(""mean"", ""mean"", -3, 3); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.1, 10); modelx = ROOT.RooGaussian(""gx"", ""gx"", x, mean, sigma); ; # Block function in mean; a = ROOT.RooRealVar(""a"", ""a"", 2, 1, 10); model_mean = ROOT.RooGenericPdf(""model_mean"", ""abs(mean)<a"", [mean, a]); ; # Convolution in mean model = g(x,mean,sigma) (x) block(mean); x.setBins(1000, ""cache""); mean.setBins(50, ""cache""); model = ROOT.RooFFTConvPdf(""model"", ""model"", mean, modelx, model_mean); ; # Configure convolution to construct a 2-D cache in (x,mean); # rather than a 1-d cache in mean that needs to be recalculated; # for each value of x; model.setCacheObservables({x}); model.setBufferFraction(1.0); ; # Integrate model over projModel = Int model dmean; projModel = model.createProjection({mean}); ; # Generate 1000 toy events; d = projModel.generateBinned({x}, 1000); ; # Fit p.d.f. to toy data; projModel.fitTo(d, Verbose=True, PrintLevel=-1); ; # Plot data and fitted p.d.f.; frame = x.frame(Bins=25); d.plotOn(frame); projModel.plotOn(frame); ; # Make 2d histogram of model(x;mean); hh = model.createHistogram(; ""hh"",; x,; Binning=50,; YVar=dict(var=mean, Binning=50),; ConditionalObservables={mean},; ); hh.SetTitle(""histogram of model(x|mean)""); hh.SetLineColor(ROOT.kBlue); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf211_paramconv"", ""rf211_paramconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargi",MatchSource.WIKI,doc/master/rf211__paramconv_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html
Availability,error,error,"Fit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf212_plottingInRanges_blindingDefinition rf212_plottingInRanges_blinding.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [20,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_right' created with bounds [20,30]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(expo_over_expo_Int[x|left,right]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_expo_over_expo_Int[x|left,right]_expoData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; Now plotting with unique normalisation for each slice.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'full', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right', curve is normalized to data in given range; ; ; Now plotting with correct norm ranges:; [#1] INFO:Plo",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html
Deployability,integrat,integrated,"g is included in the normalisation calculation. The PDF therefore; // comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; std::cout << ""Now plotting with unique normalisation for each slice."" << std::endl;; canvas->cd(1);; RooPlot* plotFrame = x.frame(RooFit::Title(""Wrong: Each slice normalised over its plotting range""));; ; // Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData->plotOn(plotFrame);; expo.plotOn(plotFrame, LineColor(kRed), Range(""full""));; expo.plotOn(plotFrame, LineColor(kBlue), Range(""left""));; expo.plotOn(plotFrame, LineColor(kGreen), Range(""right""));; ; plotFrame->Draw();; ; // Right:; // ----------------------------------------------------------------------------------------------------------; // Make the same plot, but normalise each piece with respect to the regions ""left"" AND ""right"". This requires setting; // a ""NormRange"", which tells RooFit over which range the PDF has to be integrated to normalise.; // This means that the normalisation of the blue and green curves is slightly different from the left plot,; // because they get a common scale factor.; ; std::cout << ""\n\nNow plotting with correct norm ranges:"" << std::endl;; canvas->cd(2);; RooPlot* plotFrameWithNormRange = x.frame(RooFit::Title(""Right: All slices have common normalisation""));; ; // Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData->plotOn(plotFrameWithNormRange);; expo.plotOn(plotFrameWithNormRange, LineColor(kBlue), Range(""left""), RooFit::NormRange(""left,right""));; expo.plotOn(plotFrameWithNormRange, LineColor(kGreen), Range(""right""), RooFit::NormRange(""left,right""));; expo.plotOn(plotFrameWithNormRange, LineColor(kRed), Range(""full""), RooFit::NormRange(""left,right""), LineStyle(10));; ; plotFrameWithNormRange->Draw();; ; canvas->Draw();; ; }; RooDataSet.h; RooExponential.h; RooPlot.h; RooRealVar",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html
Energy Efficiency,reduce,reduce," signal region has to be blinded, one has to exclude the blinded region from the computation of the normalisation.; In this tutorial, we show how to explicitly choose the normalisation when plotting using NormRange().; Thanks to Marc Escalier for asking how to do this correctly. ; #include <RooDataSet.h>; #include <RooExponential.h>; #include <RooPlot.h>; #include <RooRealVar.h>; #include <TCanvas.h>; ; using namespace RooFit;; ; void rf212_plottingInRanges_blinding(); {; // Make a fit model; RooRealVar x(""x"", ""The observable"", 1, 30);; RooRealVar tau(""tau"", ""The exponent"", -0.1337, -10., -0.1);; RooExponential expo(""expo"", ""A falling exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would; // be automatically taken as the NormRange() for plotting. We want to avoid; // this, because the point of this tutorial is to show what can go wrong when; // the NormRange() is not specified.; expo.removeStringAttribute(""fitrange"");; ; ; // Here we will plot the results; TCanvas *canvas=new TCanvas(""canvas"",""canvas"",800,600);; canvas->Divide(2,1);; ; ; // Wrong:; // ----------------------------------------------------------------------------------------------------------; // Plott",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html
Integrability,integrat,integrated,"g is included in the normalisation calculation. The PDF therefore; // comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; std::cout << ""Now plotting with unique normalisation for each slice."" << std::endl;; canvas->cd(1);; RooPlot* plotFrame = x.frame(RooFit::Title(""Wrong: Each slice normalised over its plotting range""));; ; // Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData->plotOn(plotFrame);; expo.plotOn(plotFrame, LineColor(kRed), Range(""full""));; expo.plotOn(plotFrame, LineColor(kBlue), Range(""left""));; expo.plotOn(plotFrame, LineColor(kGreen), Range(""right""));; ; plotFrame->Draw();; ; // Right:; // ----------------------------------------------------------------------------------------------------------; // Make the same plot, but normalise each piece with respect to the regions ""left"" AND ""right"". This requires setting; // a ""NormRange"", which tells RooFit over which range the PDF has to be integrated to normalise.; // This means that the normalisation of the blue and green curves is slightly different from the left plot,; // because they get a common scale factor.; ; std::cout << ""\n\nNow plotting with correct norm ranges:"" << std::endl;; canvas->cd(2);; RooPlot* plotFrameWithNormRange = x.frame(RooFit::Title(""Right: All slices have common normalisation""));; ; // Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData->plotOn(plotFrameWithNormRange);; expo.plotOn(plotFrameWithNormRange, LineColor(kBlue), Range(""left""), RooFit::NormRange(""left,right""));; expo.plotOn(plotFrameWithNormRange, LineColor(kGreen), Range(""right""), RooFit::NormRange(""left,right""));; expo.plotOn(plotFrameWithNormRange, LineColor(kRed), Range(""full""), RooFit::NormRange(""left,right""), LineStyle(10));; ; plotFrameWithNormRange->Draw();; ; canvas->Draw();; ; }; RooDataSet.h; RooExponential.h; RooPlot.h; RooRealVar",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html
Modifiability,adapt,adapt,"anks to Marc Escalier for asking how to do this correctly. ; #include <RooDataSet.h>; #include <RooExponential.h>; #include <RooPlot.h>; #include <RooRealVar.h>; #include <TCanvas.h>; ; using namespace RooFit;; ; void rf212_plottingInRanges_blinding(); {; // Make a fit model; RooRealVar x(""x"", ""The observable"", 1, 30);; RooRealVar tau(""tau"", ""The exponent"", -0.1337, -10., -0.1);; RooExponential expo(""expo"", ""A falling exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would; // be automatically taken as the NormRange() for plotting. We want to avoid; // this, because the point of this tutorial is to show what can go wrong when; // the NormRange() is not specified.; expo.removeStringAttribute(""fitrange"");; ; ; // Here we will plot the results; TCanvas *canvas=new TCanvas(""canvas"",""canvas"",800,600);; canvas->Divide(2,1);; ; ; // Wrong:; // ----------------------------------------------------------------------------------------------------------; // Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; // that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; // co",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html
Performance,optimiz,optimization,"Fit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf212_plottingInRanges_blindingDefinition rf212_plottingInRanges_blinding.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [20,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_right' created with bounds [20,30]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(expo_over_expo_Int[x|left,right]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_expo_over_expo_Int[x|left,right]_expoData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; Now plotting with unique normalisation for each slice.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'full', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right', curve is normalized to data in given range; ; ; Now plotting with correct norm ranges:; [#1] INFO:Plo",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html
Safety,avoid,avoid,"ng exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would; // be automatically taken as the NormRange() for plotting. We want to avoid; // this, because the point of this tutorial is to show what can go wrong when; // the NormRange() is not specified.; expo.removeStringAttribute(""fitrange"");; ; ; // Here we will plot the results; TCanvas *canvas=new TCanvas(""canvas"",""canvas"",800,600);; canvas->Divide(2,1);; ; ; // Wrong:; // ----------------------------------------------------------------------------------------------------------; // Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; // that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; // comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; std::cout << ""Now plotting with unique normalisation for each slice."" << std::endl;; canvas->cd(1);; RooPlot* plotFrame = x.frame(RooFit::Title(""Wrong: Each slice normalised over its plotting range""));; ; // Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands;",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html
Availability,error,error,"left,right""); expo.plotOn(plotFrameWithNormRange, LineColor=""r"", Range=""full"", NormRange=""left,right"", LineStyle=10); ; plotFrameWithNormRange.Draw(); ; canvas.Draw(); ; canvas.SaveAs(""rf212_plottingInRanges_blinding.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [20,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_right' created with bounds [20,30]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(expo_over_expo_Int[x|left,right]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_expo_over_expo_Int[x|left,right]_expoData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'full', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) p.d.f. curve is normalized using explicit choice of ranges 'left,right'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) p.d.f. curve is normalize",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html
Deployability,integrat,integrated,"urve, that means; # that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; # comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; print(""Now plotting with unique normalisation for each slice.\n""); canvas.cd(1); plotFrame = x.frame(Title=""Wrong: Each slice normalised over its plotting range""); ; # Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData.plotOn(plotFrame); expo.plotOn(plotFrame, LineColor=""r"", Range=""full""); expo.plotOn(plotFrame, LineColor=""b"", Range=""left""); expo.plotOn(plotFrame, LineColor=""g"", Range=""right""); ; plotFrame.Draw(); ; # Right:; # ----------------------------------------------------------------------------------------------------------; # Make the same plot, but normalise each piece with respect to the regions ""left"" AND ""right"". This requires setting; # a ""NormRange"", which tells RooFit over which range the PDF has to be integrated to normalise.; # This means that the normalisation of the blue and green curves is slightly different from the left plot,; # because they get a common scale factor.; ; print(""\n\nNow plotting with correct norm ranges:\n""); canvas.cd(2); plotFrameWithNormRange = x.frame(Title=""Right: All slices have common normalisation""); ; # Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData.plotOn(plotFrameWithNormRange); expo.plotOn(plotFrameWithNormRange, LineColor=""b"", Range=""left"", NormRange=""left,right""); expo.plotOn(plotFrameWithNormRange, LineColor=""g"", Range=""right"", NormRange=""left,right""); expo.plotOn(plotFrameWithNormRange, LineColor=""r"", Range=""full"", NormRange=""left,right"", LineStyle=10); ; plotFrameWithNormRange.Draw(); ; canvas.Draw(); ; canvas.SaveAs(""rf212_plottingInRanges_blinding.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html
Energy Efficiency,reduce,reduce,"ion right. ; Usually, when comparing a fit to data, one should first plot the data, and then the PDF. In this case, the PDF is automatically normalised to match the number of data events in the plot. However, when plotting only a sub-range, when e.g. a signal region has to be blinded, one has to exclude the blinded region from the computation of the normalisation.; In this tutorial, we show how to explicitly choose the normalisation when plotting using NormRange(). ; import ROOT; ; # Make a fit model; x = ROOT.RooRealVar(""x"", ""The observable"", 1, 30); tau = ROOT.RooRealVar(""tau"", ""The exponent"", -0.1337, -10.0, -0.1); expo = ROOT.RooExponential(""expo"", ""A falling exponential function"", x, tau); ; # Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30); x.setRange(""left"", 1, 10); x.setRange(""right"", 20, 30); ; # Generate toy data, and cut out the blinded region.; data = expo.generate(x, 1000); blindedData = data.reduce(CutRange=""left,right""); ; # Kick tau a bit, and run an unbinned fit where the blinded data are missing.; # ----------------------------------------------------------------------------------------------------------; # The fit should be done only in the unblinded regions, otherwise it would try; # to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.0); expo.fitTo(blindedData, Range=""left,right"", PrintLevel=-1); ; # Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would be; # automatically taken as the NormRange() for plotting. We want to avoid this,; # because the point of this tutorial is to show what can go wrong when the; # NormRange() is not specified.; expo.removeStringAttribute(""fitrange""); ; ; # Here we will plot the results; canvas = ROOT.TCanvas(""canvas"", ""canvas"", 800, 600); canvas.Divide(2, 1); ; ; # Wrong:; # ----------------------------------------------------------------------------------------------------------; # Plotting each slice on its own normalises the PDF over its pl",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html
Integrability,integrat,integrated,"urve, that means; # that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; # comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; print(""Now plotting with unique normalisation for each slice.\n""); canvas.cd(1); plotFrame = x.frame(Title=""Wrong: Each slice normalised over its plotting range""); ; # Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData.plotOn(plotFrame); expo.plotOn(plotFrame, LineColor=""r"", Range=""full""); expo.plotOn(plotFrame, LineColor=""b"", Range=""left""); expo.plotOn(plotFrame, LineColor=""g"", Range=""right""); ; plotFrame.Draw(); ; # Right:; # ----------------------------------------------------------------------------------------------------------; # Make the same plot, but normalise each piece with respect to the regions ""left"" AND ""right"". This requires setting; # a ""NormRange"", which tells RooFit over which range the PDF has to be integrated to normalise.; # This means that the normalisation of the blue and green curves is slightly different from the left plot,; # because they get a common scale factor.; ; print(""\n\nNow plotting with correct norm ranges:\n""); canvas.cd(2); plotFrameWithNormRange = x.frame(Title=""Right: All slices have common normalisation""); ; # Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData.plotOn(plotFrameWithNormRange); expo.plotOn(plotFrameWithNormRange, LineColor=""b"", Range=""left"", NormRange=""left,right""); expo.plotOn(plotFrameWithNormRange, LineColor=""g"", Range=""right"", NormRange=""left,right""); expo.plotOn(plotFrameWithNormRange, LineColor=""r"", Range=""full"", NormRange=""left,right"", LineStyle=10); ; plotFrameWithNormRange.Draw(); ; canvas.Draw(); ; canvas.SaveAs(""rf212_plottingInRanges_blinding.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html
Modifiability,adapt,adapt,"ts in the plot. However, when plotting only a sub-range, when e.g. a signal region has to be blinded, one has to exclude the blinded region from the computation of the normalisation.; In this tutorial, we show how to explicitly choose the normalisation when plotting using NormRange(). ; import ROOT; ; # Make a fit model; x = ROOT.RooRealVar(""x"", ""The observable"", 1, 30); tau = ROOT.RooRealVar(""tau"", ""The exponent"", -0.1337, -10.0, -0.1); expo = ROOT.RooExponential(""expo"", ""A falling exponential function"", x, tau); ; # Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30); x.setRange(""left"", 1, 10); x.setRange(""right"", 20, 30); ; # Generate toy data, and cut out the blinded region.; data = expo.generate(x, 1000); blindedData = data.reduce(CutRange=""left,right""); ; # Kick tau a bit, and run an unbinned fit where the blinded data are missing.; # ----------------------------------------------------------------------------------------------------------; # The fit should be done only in the unblinded regions, otherwise it would try; # to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.0); expo.fitTo(blindedData, Range=""left,right"", PrintLevel=-1); ; # Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would be; # automatically taken as the NormRange() for plotting. We want to avoid this,; # because the point of this tutorial is to show what can go wrong when the; # NormRange() is not specified.; expo.removeStringAttribute(""fitrange""); ; ; # Here we will plot the results; canvas = ROOT.TCanvas(""canvas"", ""canvas"", 800, 600); canvas.Divide(2, 1); ; ; # Wrong:; # ----------------------------------------------------------------------------------------------------------; # Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; # that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; # comes out too low, and ",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html
Performance,optimiz,optimization,"left,right""); expo.plotOn(plotFrameWithNormRange, LineColor=""r"", Range=""full"", NormRange=""left,right"", LineStyle=10); ; plotFrameWithNormRange.Draw(); ; canvas.Draw(); ; canvas.SaveAs(""rf212_plottingInRanges_blinding.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'full' created with bounds [1,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [20,30]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_left' created with bounds [1,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_expo_expoData_right' created with bounds [20,30]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(expo_over_expo_Int[x|left,right]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_expo_over_expo_Int[x|left,right]_expoData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'full', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right', curve is normalized to data in given range; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'left'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) p.d.f. curve is normalized using explicit choice of ranges 'left,right'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) only plotting range 'right'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(expo) p.d.f. curve is normalize",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html
Safety,avoid,avoid,"ponent"", -0.1337, -10.0, -0.1); expo = ROOT.RooExponential(""expo"", ""A falling exponential function"", x, tau); ; # Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30); x.setRange(""left"", 1, 10); x.setRange(""right"", 20, 30); ; # Generate toy data, and cut out the blinded region.; data = expo.generate(x, 1000); blindedData = data.reduce(CutRange=""left,right""); ; # Kick tau a bit, and run an unbinned fit where the blinded data are missing.; # ----------------------------------------------------------------------------------------------------------; # The fit should be done only in the unblinded regions, otherwise it would try; # to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.0); expo.fitTo(blindedData, Range=""left,right"", PrintLevel=-1); ; # Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would be; # automatically taken as the NormRange() for plotting. We want to avoid this,; # because the point of this tutorial is to show what can go wrong when the; # NormRange() is not specified.; expo.removeStringAttribute(""fitrange""); ; ; # Here we will plot the results; canvas = ROOT.TCanvas(""canvas"", ""canvas"", 800, 600); canvas.Divide(2, 1); ; ; # Wrong:; # ----------------------------------------------------------------------------------------------------------; # Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; # that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; # comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; print(""Now plotting with unique normalisation for each slice.\n""); canvas.cd(1); plotFrame = x.frame(Title=""Wrong: Each slice normalised over its plotting range""); ; # Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData.plotOn(plotFrame); expo.plotOn(plotFrame",MatchSource.WIKI,doc/master/rf212__plottingInRanges__blinding_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html
Deployability,integrat,integrator,"t RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf301_compositionDefinition rf301_composition.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf301_composition.C. tutorialsroofitrf301_composition.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf301__composition_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8C.html
Integrability,depend,depends,". ROOT: tutorials/roofit/rf301_composition.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf301_composition.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: multi-dimensional pdfs through composition e.g. ; substituting a pdf parameter with a function that depends on other observables; pdf = gauss(x,f(y),s) with f(y) = a0 + a1*y. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolyVar.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf301_composition(); {; // S e t u p c o m p o s e d m o d e l g a u s s ( x , m ( y ) , s ); // -----------------------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", -0.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gauss(x,f(y),s); RooRealVar sigma(""sigma"", ""width of gaussian"", 0.5);; RooGaussian model(""model"", ""Gaussian with shifting mean"", x, fy, sigma);; ; // S a m p l e d a t a , p l o t d a t a a n d p d f o n x a n d y; // ---------------------------------------------------------------------------------; ; // Generate 10000 events in x and y from model; std::unique_ptr<RooDataSet> data{model.generate({x, y}, 10000)};; ; // Plot x distribution of data and projection of model on x = Int(dy) model(x,y); RooPlot *xframe = x.frame();; data->plotOn(xframe);; model.plotOn(xframe);; ; // Plot x distribution of data and projection of model on y = Int(dx) model(x,y); RooPlot *yframe = y.frame();; data->plotOn(yframe);; model.plotOn(yframe);; ; // Make two-dimensional plot in x vs y; TH1 *hh_model = model.createHistogram(""hh_model"", x, Binning(50), YVar(y, Binning(50)));; hh_model->SetLineColor(kBlue);; ; // Make can",MatchSource.WIKI,doc/master/rf301__composition_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8C.html
Modifiability,variab,variable,"set(1.4);; xframe->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; yframe->GetYaxis()->SetTitleOffset(1.4);; yframe->Draw();; c->cd(3);; gPad->SetLeftMargin(0.20);; hh_model->GetZaxis()->SetTitleOffset(2.5);; hh_model->Draw(""surf"");; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolyVarA RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overr",MatchSource.WIKI,doc/master/rf301__composition_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8C.html
Safety,safe,safe,":298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf301_compositionDefinition rf301_composition.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::ini",MatchSource.WIKI,doc/master/rf301__composition_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8C.html
Deployability,integrat,integrator,"(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf301_composition"", ""rf301_composition"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf301_composition.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf301_composition.py. tutorialsroofitrf301_composition.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf301__composition_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8py.html
Integrability,depend,depends,". ROOT: tutorials/roofit/rf301_composition.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf301_composition.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: multi-dimensional pdfs through composition, e.g. ; substituting a pdf parameter with a function that depends on other observables; pdf = gauss(x,f(y),s) with f(y) = a0 + a1*y. ; import ROOT; ; # Setup composed model gauss(x, m(y), s); # -----------------------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", -0.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Creat gauss(x,f(y),s); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5); model = ROOT.RooGaussian(""model"", ""Gaussian with shifting mean"", x, fy, sigma); ; # Sample data, plot data and pdf on x and y; # ---------------------------------------------------------------------------------; ; # Generate 10000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf301_composition"", ""rf301_composition"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yf",MatchSource.WIKI,doc/master/rf301__composition_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8py.html
Modifiability,variab,variables,"(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf301_composition"", ""rf301_composition"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf301_composition.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf301_composition.py. tutorialsroofitrf301_composition.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf301__composition_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8py.html
Safety,safe,safe,"nerate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf301_composition"", ""rf301_composition"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf301_composition.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::init",MatchSource.WIKI,doc/master/rf301__composition_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf301__composition_8py.html
Availability,avail,available,". ROOT: tutorials/roofit/rf302_utilfuncs.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf302_utilfuncs.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFormulaVar.h""; #include ""RooAddition.h""; #include ""RooProduct.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; ; using namespace RooFit;; ; void rf302_utilfuncs(); {; // C r e a t e o b s e r v a b l e s , p a r a m e t e r s; // -----------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; // Create parameters; RooRealVar a0(""a0"", ""a0"", -1.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooRealVar sigma(""sigma"", ""width of gaussian"", 0.5);; ; // U s i n g R o o F o r m u l a V a r t o t a i l o r p d f; // -----------------------------------------------------------------------; ; // Create interpreted function f(y) = a0 - a1*sqrt(10*abs(y)); RooFormulaVar fy_1(""fy_1"", ""a0-a1*sqrt(10*abs(y))"", RooArgSet(y, a0, a1));; ; // Create gauss(x,f(y),s); RooGaussian model_1(""model_1"", ""Gaussian with shifting mean"", x, fy_1, sigma);; ; // U s i n g R o o P o l y V a r t o t a i l o r p d f; // -----------------------------------------------------------------------; ; // Create polynomial function f(y) = a0 + a1*y; RooPolyVar fy_2(""fy_2"", ""fy_2"", y, RooArgSet(a0, a1));; ; // Create gauss(x,f(y),s); RooGaussian model_2(""model_2"", ""Gaussian with shifting mean"", x, fy_2, sigma);; ; // U s i n g R o o A d d i t i o n t o t a i l o r p d f; // -----------------------------------------------------------------------; ; // Create sum function f(y) = a0 + y; RooAdd",MatchSource.WIKI,doc/master/rf302__utilfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html
Deployability,integrat,integrator,"TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf302_utilfuncs.C. tutorialsroofitrf302_utilfuncs.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf302__utilfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html
Integrability,integrat,integrator,"TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf302_utilfuncs.C. tutorialsroofitrf302_utilfuncs.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf302__utilfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html
Safety,safe,safe,"riable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calcul",MatchSource.WIKI,doc/master/rf302__utilfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html
Availability,avail,available,". ROOT: tutorials/roofit/rf302_utilfuncs.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf302_utilfuncs.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs . ; import ROOT; ; # Create observables, parameters; # -----------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; # Create parameters; a0 = ROOT.RooRealVar(""a0"", ""a0"", -1.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5); ; # Using RooFormulaVar to tailor pdf; # -----------------------------------------------------------------------; ; # Create interpreted function f(y) = a0 - a1*sqrt(10*abs(y)); fy_1 = ROOT.RooFormulaVar(""fy_1"", ""a0-a1*sqrt(10*abs(y))"", [y, a0, a1]); ; # Create gauss(x,f(y),s); model_1 = ROOT.RooGaussian(""model_1"", ""Gaussian with shifting mean"", x, fy_1, sigma); ; # Using RooPolyVar to tailor pdf; # -----------------------------------------------------------------------; ; # Create polynomial function f(y) = a0 + a1*y; fy_2 = ROOT.RooPolyVar(""fy_2"", ""fy_2"", y, [a0, a1]); ; # Create gauss(x,f(y),s); model_2 = ROOT.RooGaussian(""model_2"", ""Gaussian with shifting mean"", x, fy_2, sigma); ; # Using RooAddition to tailor pdf; # -----------------------------------------------------------------------; ; # Create sum function f(y) = a0 + y; fy_3 = ROOT.RooAddition(""fy_3"", ""a0+y"", [a0, y]); ; # Create gauss(x,f(y),s); model_3 = ROOT.RooGaussian(""model_3"", ""Gaussian with shifting mean"", x, fy_3, sigma); ; # Using RooProduct to tailor pdf; # -----------------------------------------------------------------------; ; # Create product function f(y) = a1*y; fy_4 = ROOT.RooProduct(""fy_4"", ""a1*y"", [a1, y]); ; # Create gauss(x,f(y),s); model_4 = ROOT",MatchSource.WIKI,doc/master/rf302__utilfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html
Deployability,integrat,integrator,"vas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf302_utilfuncs.py. tutorialsroofitrf302_utilfuncs.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf302__utilfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html
Integrability,integrat,integrator,"vas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf302_utilfuncs.py. tutorialsroofitrf302_utilfuncs.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf302__utilfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html
Safety,safe,safe,"); hh_model_3 = model_3.createHistogram(""hh_model_3"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model_4 = model_4.createHistogram(""hh_model_4"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model_1.SetLineColor(ROOT.kBlue); hh_model_2.SetLineColor(ROOT.kBlue); hh_model_3.SetLineColor(ROOT.kBlue); hh_model_4.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calcula",MatchSource.WIKI,doc/master/rf302__utilfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html
Availability,error,error,"ObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf303_conditionalDefinition rf303_conditional.py:1; ; RooDataSet::modelData[x,y] = 6850 entries; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x]_d) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf303_conditional.C. tutorialsroofitrf303_conditional.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf303__conditional_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8C.html
Energy Efficiency,reduce,reduce," using namespace RooFit;; ; RooDataSet *makeFakeDataXY();; ; void rf303_conditional(); {; // S e t u p c o m p o s e d m o d e l g a u s s ( x , m ( y ) , s ); // -----------------------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", -0.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gauss(x,f(y),s); RooRealVar sigma(""sigma"", ""width of gaussian"", 0.5, 0.1, 2.0);; RooGaussian model(""model"", ""Gaussian with shifting mean"", x, fy, sigma);; ; // Obtain fake external experimental dataset with values for x and y; RooDataSet *expDataXY = makeFakeDataXY();; ; // G e n e r a t e d a t a f r o m c o n d i t i o n a l p . d . f m o d e l ( x | y ); // ---------------------------------------------------------------------------------------------; ; // Make subset of experimental data with only y values; std::unique_ptr<RooAbsData> expAbsDataY{expDataXY->reduce(y)};; RooDataSet *expDataY = static_cast<RooDataSet*>(expAbsDataY.get());; ; // Generate 10000 events in x obtained from _conditional_ model(x|y) with y values taken from experimental data; std::unique_ptr<RooDataSet> data{model.generate(x, ProtoData(*expDataY))};; data->Print();; ; // F i t c o n d i t i o n a l p . d . f m o d e l ( x | y ) t o d a t a; // ---------------------------------------------------------------------------------------------; ; model.fitTo(*expDataXY, ConditionalObservables(y), PrintLevel(-1));; ; // P r o j e c t c o n d i t i o n a l p . d . f o n x a n d y d i m e n s i o n s; // ---------------------------------------------------------------------------------------------; ; // Plot x distribution of data and projection of model on x = 1/Ndata sum(data(y_i)) model(x;y_i); RooPlot *xframe = x.frame();; expDataXY->plotOn(xframe);; model.plotOn(xframe, ProjWData(*expDataY));;",MatchSource.WIKI,doc/master/rf303__conditional_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8C.html
Modifiability,variab,variable,"&arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate a reduced copy of this dataset.Definition RooAbsData.cxx:399; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::getconst RooArgSet * get(Int_t index) const overrideReturn RooArgSet with coordinates of event 'index'.Definition RooDataSet.cxx:835; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolyVarA RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; ",MatchSource.WIKI,doc/master/rf303__conditional_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8C.html
Performance,optimiz,optimization,"ObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf303_conditionalDefinition rf303_conditional.py:1; ; RooDataSet::modelData[x,y] = 6850 entries; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x]_d) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf303_conditional.C. tutorialsroofitrf303_conditional.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf303__conditional_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8C.html
Availability,error,error,"-----------------------------------------------------------; ; # Plot x distribution of data and projection of model x = 1/Ndata; # sum(data(y_i)) model(x;y_i); xframe = x.frame(); expDataXY.plotOn(xframe); model.plotOn(xframe, ProjWData=expDataY); ; # Speed up (and approximate) projection by using binned clone of data for; # projection; binnedDataY = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY, LineColor=""c"", LineStyle="":""); ; # Show effect of projection with too coarse binning; (expDataY.get().find(""y"")).setBins(5); binnedDataY2 = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY2, LineColor=""r""); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf303_conditional"", ""rf303_conditional"", 600, 460); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.2); xframe.Draw(); ; c.SaveAs(""rf303_conditional.png""); RooDataSet::modelData[x,y] = 6850 entries; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x]_d) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf303_conditional.py. tutorialsroofitrf303_conditional.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf303__conditional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8py.html
Energy Efficiency,reduce,reduce,"rd); ; return d; ; ; # Set up composed model gauss(x, m(y), s); # -----------------------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", -0.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Creat gauss(x,f(y),s); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5, 0.1, 2.0); model = ROOT.RooGaussian(""model"", ""Gaussian with shifting mean"", x, fy, sigma); ; # Obtain fake external experimental dataset with values for x and y; expDataXY = makeFakeDataXY(); ; # Generate data from conditional p.d.f. model(x|y); # ---------------------------------------------------------------------------------------------; ; # Make subset of experimental data with only y values; expDataY = expDataXY.reduce({y}); ; # Generate 10000 events in x obtained from _conditional_ model(x|y) with y; # values taken from experimental data; data = model.generate({x}, ProtoData=expDataY); data.Print(); ; # Fit conditional p.d.f model(x|y) to data; # ---------------------------------------------------------------------------------------------; ; model.fitTo(expDataXY, ConditionalObservables={y}, PrintLevel=-1); ; # Project conditional p.d.f on x and y dimensions; # ---------------------------------------------------------------------------------------------; ; # Plot x distribution of data and projection of model x = 1/Ndata; # sum(data(y_i)) model(x;y_i); xframe = x.frame(); expDataXY.plotOn(xframe); model.plotOn(xframe, ProjWData=expDataY); ; # Speed up (and approximate) projection by using binned clone of data for; # projection; binnedDataY = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY, LineColor=""c"", LineStyle="":""); ; # Show effect of projection with too coarse binning; (expDataY.get().find(""y"")).setBins(5); binnedDataY2 = expDataY.binnedCl",MatchSource.WIKI,doc/master/rf303__conditional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8py.html
Modifiability,variab,variables,"-----------------------------------------------------------; ; # Plot x distribution of data and projection of model x = 1/Ndata; # sum(data(y_i)) model(x;y_i); xframe = x.frame(); expDataXY.plotOn(xframe); model.plotOn(xframe, ProjWData=expDataY); ; # Speed up (and approximate) projection by using binned clone of data for; # projection; binnedDataY = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY, LineColor=""c"", LineStyle="":""); ; # Show effect of projection with too coarse binning; (expDataY.get().find(""y"")).setBins(5); binnedDataY2 = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY2, LineColor=""r""); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf303_conditional"", ""rf303_conditional"", 600, 460); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.2); xframe.Draw(); ; c.SaveAs(""rf303_conditional.png""); RooDataSet::modelData[x,y] = 6850 entries; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x]_d) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf303_conditional.py. tutorialsroofitrf303_conditional.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf303__conditional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8py.html
Performance,optimiz,optimization,"-----------------------------------------------------------; ; # Plot x distribution of data and projection of model x = 1/Ndata; # sum(data(y_i)) model(x;y_i); xframe = x.frame(); expDataXY.plotOn(xframe); model.plotOn(xframe, ProjWData=expDataY); ; # Speed up (and approximate) projection by using binned clone of data for; # projection; binnedDataY = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY, LineColor=""c"", LineStyle="":""); ; # Show effect of projection with too coarse binning; (expDataY.get().find(""y"")).setBins(5); binnedDataY2 = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY2, LineColor=""r""); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf303_conditional"", ""rf303_conditional"", 600, 460); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.2); xframe.Draw(); ; c.SaveAs(""rf303_conditional.png""); RooDataSet::modelData[x,y] = 6850 entries; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x]_d) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf303_conditional.py. tutorialsroofitrf303_conditional.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf303__conditional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf303__conditional_8py.html
Deployability,integrat,integrates,"on RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf304_uncorrprodDefinition rf304_uncorrprod.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf304_uncorrprod.C. tutorialsroofitrf304_uncorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf304__uncorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html
Integrability,integrat,integrates,"on RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf304_uncorrprodDefinition rf304_uncorrprod.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf304_uncorrprod.C. tutorialsroofitrf304_uncorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf304__uncorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html
Modifiability,variab,variables,"ading...; Searching...; No Matches. rf304_uncorrprod.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: simple uncorrelated multi-dimensional pdfs ; pdf = gauss(x,mx,sx) * gauss(y,my,sy). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf304_uncorrprod(); {; ; // C r e a t e c o m p o n e n t p d f s i n x a n d y; // ----------------------------------------------------------------; ; // Create two pdfs gaussx(x,meanx,sigmax) gaussy(y,meany,sigmay) and its variables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; RooRealVar meanx(""mean1"", ""mean of gaussian x"", 2);; RooRealVar meany(""mean2"", ""mean of gaussian y"", -2);; RooRealVar sigmax(""sigmax"", ""width of gaussian x"", 1);; RooRealVar sigmay(""sigmay"", ""width of gaussian y"", 5);; ; RooGaussian gaussx(""gaussx"", ""gaussian PDF"", x, meanx, sigmax);; RooGaussian gaussy(""gaussy"", ""gaussian PDF"", y, meany, sigmay);; ; // C o n s t r u c t u n c o r r e l a t e d p r o d u c t p d f; // -------------------------------------------------------------------; ; // Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; RooProdPdf gaussxy(""gaussxy"", ""gaussx*gaussy"", RooArgList(gaussx, gaussy));; ; // S a m p l e p d f , p l o t p r o j e c t i o n o n x a n d y; // ---------------------------------------------------------------------------; ; // Generate 10000 events in x and y from gaussxy; std::unique_ptr<RooDataSet> data{gaussxy.generate({x, y}, 10000)};; ; // Plot x distribution of data and projection of gaussxy on x = Int(dy) gaussxy(x,y); RooPlot *xframe = x.frame(Title(""X projection of gauss(x)*gauss(y)""));; data->plotOn(xframe);; gaussxy.plotOn(xframe);; ; // Plot x distribution of data and projection of gaussxy on y = Int(dx) gaussxy(x,y); RooPlot *yframe = y.frame(Title(""Y projection of gauss(x)*gauss(y)""));",MatchSource.WIKI,doc/master/rf304__uncorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html
Safety,safe,safe,"on RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf304_uncorrprodDefinition rf304_uncorrprod.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf304_uncorrprod.C. tutorialsroofitrf304_uncorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf304__uncorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html
Usability,simpl,simple,". ROOT: tutorials/roofit/rf304_uncorrprod.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf304_uncorrprod.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: simple uncorrelated multi-dimensional pdfs ; pdf = gauss(x,mx,sx) * gauss(y,my,sy). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf304_uncorrprod(); {; ; // C r e a t e c o m p o n e n t p d f s i n x a n d y; // ----------------------------------------------------------------; ; // Create two pdfs gaussx(x,meanx,sigmax) gaussy(y,meany,sigmay) and its variables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; RooRealVar meanx(""mean1"", ""mean of gaussian x"", 2);; RooRealVar meany(""mean2"", ""mean of gaussian y"", -2);; RooRealVar sigmax(""sigmax"", ""width of gaussian x"", 1);; RooRealVar sigmay(""sigmay"", ""width of gaussian y"", 5);; ; RooGaussian gaussx(""gaussx"", ""gaussian PDF"", x, meanx, sigmax);; RooGaussian gaussy(""gaussy"", ""gaussian PDF"", y, meany, sigmay);; ; // C o n s t r u c t u n c o r r e l a t e d p r o d u c t p d f; // -------------------------------------------------------------------; ; // Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; RooProdPdf gaussxy(""gaussxy"", ""gaussx*gaussy"", RooArgList(gaussx, gaussy));; ; // S a m p l e p d f , p l o t p r o j e c t i o n o n x a n d y; // ---------------------------------------------------------------------------; ; // Generate 10000 events in x and y from gaussxy; std::unique_ptr<RooDataSet> data{gaussxy.generate({x, y}, 10000)};; ; // Plot x distribution of data and projection of gaussxy on x = Int(dy) gaussxy(x,y); RooPlot *xframe = x.frame(Title(""X projection of gauss(x)*gauss(y)""));; data->plotOn(xframe);; gaussxy.plotOn(xframe);; ; // Plot x distribution of data and projection of ga",MatchSource.WIKI,doc/master/rf304__uncorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html
Deployability,integrat,integrates,"sian PDF"", y, meany, sigmay); ; # Construct uncorrelated product pdf; # -------------------------------------------------------------------; ; # Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; gaussxy = ROOT.RooProdPdf(""gaussxy"", ""gaussx*gaussy"", [gaussx, gaussy]); ; # Sample pdf, plot projection on x and y; # ---------------------------------------------------------------------------; ; # Generate 10000 events in x and y from gaussxy; data = gaussxy.generate({x, y}, 10000); ; # Plot x distribution of data and projection of gaussxy x = Int(dy); # gaussxy(x,y); xframe = x.frame(Title=""X projection of gauss(x)*gauss(y)""); data.plotOn(xframe); gaussxy.plotOn(xframe); ; # Plot x distribution of data and projection of gaussxy y = Int(dx); # gaussxy(x,y); yframe = y.frame(Title=""Y projection of gauss(x)*gauss(y)""); data.plotOn(yframe); gaussxy.plotOn(yframe); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf304_uncorrprod"", ""rf304_uncorrprod"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf304_uncorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf304_uncorrprod.py. tutorialsroofitrf304_uncorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf304__uncorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8py.html
Integrability,integrat,integrates,"sian PDF"", y, meany, sigmay); ; # Construct uncorrelated product pdf; # -------------------------------------------------------------------; ; # Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; gaussxy = ROOT.RooProdPdf(""gaussxy"", ""gaussx*gaussy"", [gaussx, gaussy]); ; # Sample pdf, plot projection on x and y; # ---------------------------------------------------------------------------; ; # Generate 10000 events in x and y from gaussxy; data = gaussxy.generate({x, y}, 10000); ; # Plot x distribution of data and projection of gaussxy x = Int(dy); # gaussxy(x,y); xframe = x.frame(Title=""X projection of gauss(x)*gauss(y)""); data.plotOn(xframe); gaussxy.plotOn(xframe); ; # Plot x distribution of data and projection of gaussxy y = Int(dx); # gaussxy(x,y); yframe = y.frame(Title=""Y projection of gauss(x)*gauss(y)""); data.plotOn(yframe); gaussxy.plotOn(yframe); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf304_uncorrprod"", ""rf304_uncorrprod"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf304_uncorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf304_uncorrprod.py. tutorialsroofitrf304_uncorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf304__uncorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf304_uncorrprod.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf304_uncorrprod.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: simple uncorrelated multi-dimensional pdfs ; pdf = gauss(x,mx,sx) * gauss(y,my,sy). ; import ROOT; ; ; # Create component pdfs in x and y; # ----------------------------------------------------------------; ; # Create two pdfs gaussx(x,meanx,sigmax) gaussy(y,meany,sigmay) and its; # variables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; meanx = ROOT.RooRealVar(""mean1"", ""mean of gaussian x"", 2); meany = ROOT.RooRealVar(""mean2"", ""mean of gaussian y"", -2); sigmax = ROOT.RooRealVar(""sigmax"", ""width of gaussian x"", 1); sigmay = ROOT.RooRealVar(""sigmay"", ""width of gaussian y"", 5); ; gaussx = ROOT.RooGaussian(""gaussx"", ""gaussian PDF"", x, meanx, sigmax); gaussy = ROOT.RooGaussian(""gaussy"", ""gaussian PDF"", y, meany, sigmay); ; # Construct uncorrelated product pdf; # -------------------------------------------------------------------; ; # Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; gaussxy = ROOT.RooProdPdf(""gaussxy"", ""gaussx*gaussy"", [gaussx, gaussy]); ; # Sample pdf, plot projection on x and y; # ---------------------------------------------------------------------------; ; # Generate 10000 events in x and y from gaussxy; data = gaussxy.generate({x, y}, 10000); ; # Plot x distribution of data and projection of gaussxy x = Int(dy); # gaussxy(x,y); xframe = x.frame(Title=""X projection of gauss(x)*gauss(y)""); data.plotOn(xframe); gaussxy.plotOn(xframe); ; # Plot x distribution of data and projection of gaussxy y = Int(dx); # gaussxy(x,y); yframe = y.frame(Title=""Y projection of gauss(x)*gauss(y)""); data.plotOn(yframe); gaussxy.plotOn(yframe); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf304_uncorrprod"", ""rf304_uncorrprod"", 800, 400); c.Divide(2); c.c",MatchSource.WIKI,doc/master/rf304__uncorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8py.html
Safety,safe,safe,"sian PDF"", y, meany, sigmay); ; # Construct uncorrelated product pdf; # -------------------------------------------------------------------; ; # Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; gaussxy = ROOT.RooProdPdf(""gaussxy"", ""gaussx*gaussy"", [gaussx, gaussy]); ; # Sample pdf, plot projection on x and y; # ---------------------------------------------------------------------------; ; # Generate 10000 events in x and y from gaussxy; data = gaussxy.generate({x, y}, 10000); ; # Plot x distribution of data and projection of gaussxy x = Int(dy); # gaussxy(x,y); xframe = x.frame(Title=""X projection of gauss(x)*gauss(y)""); data.plotOn(xframe); gaussxy.plotOn(xframe); ; # Plot x distribution of data and projection of gaussxy y = Int(dx); # gaussxy(x,y); yframe = y.frame(Title=""Y projection of gauss(x)*gauss(y)""); data.plotOn(yframe); gaussxy.plotOn(yframe); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf304_uncorrprod"", ""rf304_uncorrprod"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf304_uncorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf304_uncorrprod.py. tutorialsroofitrf304_uncorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf304__uncorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8py.html
Usability,simpl,simple,". ROOT: tutorials/roofit/rf304_uncorrprod.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf304_uncorrprod.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: simple uncorrelated multi-dimensional pdfs ; pdf = gauss(x,mx,sx) * gauss(y,my,sy). ; import ROOT; ; ; # Create component pdfs in x and y; # ----------------------------------------------------------------; ; # Create two pdfs gaussx(x,meanx,sigmax) gaussy(y,meany,sigmay) and its; # variables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; meanx = ROOT.RooRealVar(""mean1"", ""mean of gaussian x"", 2); meany = ROOT.RooRealVar(""mean2"", ""mean of gaussian y"", -2); sigmax = ROOT.RooRealVar(""sigmax"", ""width of gaussian x"", 1); sigmay = ROOT.RooRealVar(""sigmay"", ""width of gaussian y"", 5); ; gaussx = ROOT.RooGaussian(""gaussx"", ""gaussian PDF"", x, meanx, sigmax); gaussy = ROOT.RooGaussian(""gaussy"", ""gaussian PDF"", y, meany, sigmay); ; # Construct uncorrelated product pdf; # -------------------------------------------------------------------; ; # Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; gaussxy = ROOT.RooProdPdf(""gaussxy"", ""gaussx*gaussy"", [gaussx, gaussy]); ; # Sample pdf, plot projection on x and y; # ---------------------------------------------------------------------------; ; # Generate 10000 events in x and y from gaussxy; data = gaussxy.generate({x, y}, 10000); ; # Plot x distribution of data and projection of gaussxy x = Int(dy); # gaussxy(x,y); xframe = x.frame(Title=""X projection of gauss(x)*gauss(y)""); data.plotOn(xframe); gaussxy.plotOn(xframe); ; # Plot x distribution of data and projection of gaussxy y = Int(dx); # gaussxy(x,y); yframe = y.frame(Title=""Y projection of gauss(x)*gauss(y)""); data.plotOn(yframe); gaussxy.plotOn(yframe); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf304_uncorrprod"", ""rf304_uncorrprod"", 800, 400); c.Divide(2); c.c",MatchSource.WIKI,doc/master/rf304__uncorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8py.html
Deployability,integrat,integrates,"in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf305_condcorrprodDefinition rf305_condcorrprod.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf305_condcorrprod.C. tutorialsroofitrf305_condcorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf305__condcorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8C.html
Integrability,integrat,integrates,"in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf305_condcorrprodDefinition rf305_condcorrprod.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf305_condcorrprod.C. tutorialsroofitrf305_condcorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf305__condcorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8C.html
Modifiability,variab,variable,"ame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; yframe->GetYaxis()->SetTitleOffset(1.6);; yframe->Draw();; c->cd(3);; gPad->SetLeftMargin(0.20);; hh_model->GetZaxis()->SetTitleOffset(2.5);; hh_model->Draw(""surf"");; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolyVar.h; RooProdPdf.h; RooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolyVarA RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH",MatchSource.WIKI,doc/master/rf305__condcorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8C.html
Safety,safe,safe,"in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf305_condcorrprodDefinition rf305_condcorrprod.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf305_condcorrprod.C. tutorialsroofitrf305_condcorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf305__condcorrprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8C.html
Deployability,integrat,integrates,"y(y); model = ROOT.RooProdPdf(""model"", ""gaussx(x|y)*gaussy(y)"", {gaussy}, Conditional=({gaussx}, {x})); ; # Sample, fit and plot product pdf; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, ROOT.RooFit.Binning(50), ROOT.RooFit.YVar(y, ROOT.RooFit.Binning(50))); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf305_condcorrprod"", ""rf05_condcorrprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.6); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf305_condcorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf305_condcorrprod.py. tutorialsroofitrf305_condcorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf305__condcorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8py.html
Integrability,integrat,integrates,"y(y); model = ROOT.RooProdPdf(""model"", ""gaussx(x|y)*gaussy(y)"", {gaussy}, Conditional=({gaussx}, {x})); ; # Sample, fit and plot product pdf; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, ROOT.RooFit.Binning(50), ROOT.RooFit.YVar(y, ROOT.RooFit.Binning(50))); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf305_condcorrprod"", ""rf05_condcorrprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.6); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf305_condcorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf305_condcorrprod.py. tutorialsroofitrf305_condcorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf305__condcorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8py.html
Modifiability,variab,variables,"y(y); model = ROOT.RooProdPdf(""model"", ""gaussx(x|y)*gaussy(y)"", {gaussy}, Conditional=({gaussx}, {x})); ; # Sample, fit and plot product pdf; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, ROOT.RooFit.Binning(50), ROOT.RooFit.YVar(y, ROOT.RooFit.Binning(50))); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf305_condcorrprod"", ""rf05_condcorrprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.6); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf305_condcorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf305_condcorrprod.py. tutorialsroofitrf305_condcorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf305__condcorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8py.html
Safety,safe,safe,"y(y); model = ROOT.RooProdPdf(""model"", ""gaussx(x|y)*gaussy(y)"", {gaussy}, Conditional=({gaussx}, {x})); ; # Sample, fit and plot product pdf; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, ROOT.RooFit.Binning(50), ROOT.RooFit.YVar(y, ROOT.RooFit.Binning(50))); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf305_condcorrprod"", ""rf05_condcorrprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.6); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf305_condcorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf305_condcorrprod.py. tutorialsroofitrf305_condcorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf305__condcorrprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8py.html
Availability,error,errors,". ROOT: tutorials/roofit/rf306_condpereventerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf306_condpereventerrors.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: conditional pdf with per-event errors . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooGaussModel.h""; #include ""RooDecay.h""; #include ""RooLandau.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf306_condpereventerrors(); {; // B - p h y s i c s p d f w i t h p e r - e v e n t G a u s s i a n r e s o l u t i o n; // ----------------------------------------------------------------------------------------------; ; // Observables; RooRealVar dt(""dt"", ""dt"", -10, 10);; RooRealVar dterr(""dterr"", ""per-event error on dt"", 0.01, 10);; ; // Build a gaussian resolution model scaled by the per-event error = gauss(dt,bias,sigma*dterr); RooRealVar bias(""bias"", ""bias"", 0, -10, 10);; RooRealVar sigma(""sigma"", ""per-event error scale factor"", 1, 0.1, 10);; RooGaussModel gm(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr);; ; // Construct decay(dt) (x) gauss1(dt|dterr); RooRealVar tau(""tau"", ""tau"", 1.548);; RooDecay decay_gm(""decay_gm"", ""decay"", dt, tau, gm, RooDecay::DoubleSided);; ; // C o n s t r u c t f a k e ' e x t e r n a l ' d a t a w i t h p e r - e v e n t e r r o r; // ------------------------------------------------------------------------------------------------------; ; // Use landau pdf to get somewhat realistic distribution with long tail; RooLandau pdfDtErr(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25);; std::unique_ptr<RooDataSet> expDataDterr{pdfDtErr.generate(dterr, 10000)};; ; // S a m p l e d a t a f r o m c o n d i t i o n a l d e c a y _ g m ( d t | d t e r r ); // ---------------------------------------------------------------------------------------------; ; // Specify",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8C.html
Deployability,integrat,integrating,"----------------------------------------; ; // Specify dterr as conditional observable; decay_gm.fitTo(*data, ConditionalObservables(dterr), PrintLevel(-1));; ; // P l o t c o n d i t i o n a l d e c a y _ d m ( d t | d t e r r ); // ---------------------------------------------------------------------; ; // Make two-dimensional plot of conditional pdf in (dt,dterr); TH1 *hh_decay = decay_gm.createHistogram(""hh_decay"", dt, Binning(50), YVar(dterr, Binning(50)));; hh_decay->SetLineColor(kBlue);; ; // Plot decay_gm(dt|dterr) at various values of dterr; RooPlot *frame = dt.frame(Title(""Slices of decay(dt|dterr) at various dterr""));; for (Int_t ibin = 0; ibin < 100; ibin += 20) {; dterr.setBin(ibin);; decay_gm.plotOn(frame, Normalization(5.));; }; ; // Make projection of data an dt; RooPlot *frame2 = dt.frame(Title(""Projection of decay(dt|dterr) on dt""));; data->plotOn(frame2);; ; // Make projection of decay(dt|dterr) on dt.; //; // Instead of integrating out dterr, make a weighted average of curves; // at values dterr_i as given in the external dataset.; // (The true argument bins the data before projection to speed up the process); decay_gm.plotOn(frame2, ProjWData(*expDataDterr, true));; ; // Draw all frames on canvas; TCanvas *c = new TCanvas(""rf306_condpereventerrors"", ""rf306_condperventerrors"", 1200, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.20);; hh_decay->GetZaxis()->SetTitleOffset(2.5);; hh_decay->Draw(""surf"");; c->cd(2);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.6);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooDecay.h; RooGaussModel.h; RooGaussian.h; RooLandau.h; RooPlot.h; RooRealVar.h; Int_tint Int_tDefinition RtypesCore.h:45; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerSt",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8C.html
Integrability,integrat,integrating,"----------------------------------------; ; // Specify dterr as conditional observable; decay_gm.fitTo(*data, ConditionalObservables(dterr), PrintLevel(-1));; ; // P l o t c o n d i t i o n a l d e c a y _ d m ( d t | d t e r r ); // ---------------------------------------------------------------------; ; // Make two-dimensional plot of conditional pdf in (dt,dterr); TH1 *hh_decay = decay_gm.createHistogram(""hh_decay"", dt, Binning(50), YVar(dterr, Binning(50)));; hh_decay->SetLineColor(kBlue);; ; // Plot decay_gm(dt|dterr) at various values of dterr; RooPlot *frame = dt.frame(Title(""Slices of decay(dt|dterr) at various dterr""));; for (Int_t ibin = 0; ibin < 100; ibin += 20) {; dterr.setBin(ibin);; decay_gm.plotOn(frame, Normalization(5.));; }; ; // Make projection of data an dt; RooPlot *frame2 = dt.frame(Title(""Projection of decay(dt|dterr) on dt""));; data->plotOn(frame2);; ; // Make projection of decay(dt|dterr) on dt.; //; // Instead of integrating out dterr, make a weighted average of curves; // at values dterr_i as given in the external dataset.; // (The true argument bins the data before projection to speed up the process); decay_gm.plotOn(frame2, ProjWData(*expDataDterr, true));; ; // Draw all frames on canvas; TCanvas *c = new TCanvas(""rf306_condpereventerrors"", ""rf306_condperventerrors"", 1200, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.20);; hh_decay->GetZaxis()->SetTitleOffset(2.5);; hh_decay->Draw(""surf"");; c->cd(2);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.6);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooDecay.h; RooGaussModel.h; RooGaussian.h; RooLandau.h; RooPlot.h; RooRealVar.h; Int_tint Int_tDefinition RtypesCore.h:45; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerSt",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8C.html
Modifiability,variab,variable,"RooDecay.h; RooGaussModel.h; RooGaussian.h; RooLandau.h; RooPlot.h; RooRealVar.h; Int_tint Int_tDefinition RtypesCore.h:45; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooDecaySingle or double sided decay function that can be analytically convolved with any RooResolutionModel ...Definition RooDecay.h:22; RooDecay::DoubleSided@ DoubleSidedDefinition RooDecay.h:25; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooLandauLandau distribution p.d.f.Definition RooLandau.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const ",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8C.html
Performance,optimiz,optimization,"RooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::NormalizationRooCmdArg Normalization(double scaleFactor)Definition RooGlobalFunc.cxx:195; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf306_condpereventerrorsDefinition rf306_condpereventerrors.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]_decay_gmData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt,dterr]) using numeric integrator RooIntegrator1D to calculate Int(dterr); [#1] INFO:Plotting -- RooAbsReal::plotOn(decay_gm) plot on dt averages using data variables (dterr); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf306_condpereventerrors.C. tutorialsroofitrf306_condpereventerrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8C.html
Availability,error,errors,". ROOT: tutorials/roofit/rf306_condpereventerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf306_condpereventerrors.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: complete example with use of conditional pdf with per-event errors . ; import ROOT; ; # B-physics pdf with per-event Gaussian resolution; # ----------------------------------------------------------------------------------------------; ; # Observables; dt = ROOT.RooRealVar(""dt"", ""dt"", -10, 10); dterr = ROOT.RooRealVar(""dterr"", ""per-event error on dt"", 0.01, 10); ; # Build a gaussian resolution model scaled by the per-error =; # gauss(dt,bias,sigma*dterr); bias = ROOT.RooRealVar(""bias"", ""bias"", 0, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""per-event error scale factor"", 1, 0.1, 10); gm = ROOT.RooGaussModel(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr); ; # Construct decay(dt) (x) gauss1(dt|dterr); tau = ROOT.RooRealVar(""tau"", ""tau"", 1.548); decay_gm = ROOT.RooDecay(""decay_gm"", ""decay"", dt, tau, gm, type=""DoubleSided""); ; # Construct fake 'external' data with per-event error; # ------------------------------------------------------------------------------------------------------; ; # Use landau pdf to get somewhat realistic distribution with long tail; pdfDtErr = ROOT.RooLandau(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25); expDataDterr = pdfDtErr.generate({dterr}, 10000); ; # Sample data from conditional decay_gm(dt|dterr); # ---------------------------------------------------------------------------------------------; ; # Specify external dataset with dterr values to use decay_dm as; # conditional pdf; data = decay_gm.generate({dt}, ProtoData=expDataDterr); ; # Fit conditional decay_dm(dt|dterr); # ---------------------------------------------------------------------; ; # Specify dterr as conditional observable; decay_gm.fitTo(data, ConditionalObservables={dterr}, Pri",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8py.html
Deployability,integrat,integrating,"pDataDterr); ; # Fit conditional decay_dm(dt|dterr); # ---------------------------------------------------------------------; ; # Specify dterr as conditional observable; decay_gm.fitTo(data, ConditionalObservables={dterr}, PrintLevel=-1); ; # Plot conditional decay_dm(dt|dterr); # ---------------------------------------------------------------------; ; # Make two-dimensional plot of conditional pdf in (dt,dterr); hh_decay = decay_gm.createHistogram(""hh_decay"", dt, Binning=50, YVar=dict(var=dterr, Binning=50)); hh_decay.SetLineColor(ROOT.kBlue); ; # Plot decay_gm(dt|dterr) at various values of dterr; frame = dt.frame(Title=""Slices of decay(dt|dterr) at various dterr""); for ibin in range(0, 100, 20):; dterr.setBin(ibin); decay_gm.plotOn(frame, Normalization=5.0); ; # Make projection of data an dt; frame2 = dt.frame(Title=""Projection of decay(dt|dterr) on dt""); data.plotOn(frame2); ; # Make projection of decay(dt|dterr) on dt.; #; # Instead of integrating out dterr, a weighted average of curves; # at values dterr_i as given in the external dataset.; # (The kTRUE argument bins the data before projection to speed up the process); decay_gm.plotOn(frame2, ProjWData=(expDataDterr, True)); ; # Draw all frames on canvas; c = ROOT.TCanvas(""rf306_condpereventerrors"", ""rf306_condperventerrors"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_decay.GetZaxis().SetTitleOffset(2.5); hh_decay.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); ; c.SaveAs(""rf306_condpereventerrors.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErro",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8py.html
Integrability,integrat,integrating,"pDataDterr); ; # Fit conditional decay_dm(dt|dterr); # ---------------------------------------------------------------------; ; # Specify dterr as conditional observable; decay_gm.fitTo(data, ConditionalObservables={dterr}, PrintLevel=-1); ; # Plot conditional decay_dm(dt|dterr); # ---------------------------------------------------------------------; ; # Make two-dimensional plot of conditional pdf in (dt,dterr); hh_decay = decay_gm.createHistogram(""hh_decay"", dt, Binning=50, YVar=dict(var=dterr, Binning=50)); hh_decay.SetLineColor(ROOT.kBlue); ; # Plot decay_gm(dt|dterr) at various values of dterr; frame = dt.frame(Title=""Slices of decay(dt|dterr) at various dterr""); for ibin in range(0, 100, 20):; dterr.setBin(ibin); decay_gm.plotOn(frame, Normalization=5.0); ; # Make projection of data an dt; frame2 = dt.frame(Title=""Projection of decay(dt|dterr) on dt""); data.plotOn(frame2); ; # Make projection of decay(dt|dterr) on dt.; #; # Instead of integrating out dterr, a weighted average of curves; # at values dterr_i as given in the external dataset.; # (The kTRUE argument bins the data before projection to speed up the process); decay_gm.plotOn(frame2, ProjWData=(expDataDterr, True)); ; # Draw all frames on canvas; c = ROOT.TCanvas(""rf306_condpereventerrors"", ""rf306_condperventerrors"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_decay.GetZaxis().SetTitleOffset(2.5); hh_decay.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); ; c.SaveAs(""rf306_condpereventerrors.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErro",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8py.html
Modifiability,variab,variables,"t|dterr) on dt.; #; # Instead of integrating out dterr, a weighted average of curves; # at values dterr_i as given in the external dataset.; # (The kTRUE argument bins the data before projection to speed up the process); decay_gm.plotOn(frame2, ProjWData=(expDataDterr, True)); ; # Draw all frames on canvas; c = ROOT.TCanvas(""rf306_condpereventerrors"", ""rf306_condperventerrors"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_decay.GetZaxis().SetTitleOffset(2.5); hh_decay.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); ; c.SaveAs(""rf306_condpereventerrors.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]_decay_gmData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt,dterr]) using numeric integrator RooIntegrator1D to calculate Int(dterr); [#1] INFO:Plotting -- RooAbsReal::plotOn(decay_gm) plot on dt averages using data variables (dterr); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf306_condpereventerrors.py. tutorialsroofitrf306_condpereventerrors.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8py.html
Performance,optimiz,optimization,"t|dterr) on dt.; #; # Instead of integrating out dterr, a weighted average of curves; # at values dterr_i as given in the external dataset.; # (The kTRUE argument bins the data before projection to speed up the process); decay_gm.plotOn(frame2, ProjWData=(expDataDterr, True)); ; # Draw all frames on canvas; c = ROOT.TCanvas(""rf306_condpereventerrors"", ""rf306_condperventerrors"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_decay.GetZaxis().SetTitleOffset(2.5); hh_decay.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); ; c.SaveAs(""rf306_condpereventerrors.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]_decay_gmData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt,dterr]) using numeric integrator RooIntegrator1D to calculate Int(dterr); [#1] INFO:Plotting -- RooAbsReal::plotOn(decay_gm) plot on dt averages using data variables (dterr); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf306_condpereventerrors.py. tutorialsroofitrf306_condpereventerrors.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf306__condpereventerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8py.html
Availability,error,errors,". ROOT: tutorials/roofit/rf307_fullpereventerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf307_fullpereventerrors.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: full pdf with per-event errors ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooGaussModel.h""; #include ""RooDecay.h""; #include ""RooLandau.h""; #include ""RooProdPdf.h""; #include ""RooHistPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf307_fullpereventerrors(); {; // B - p h y s i c s p d f w i t h p e r - e v e n t G a u s s i a n r e s o l u t i o n; // ----------------------------------------------------------------------------------------------; ; // Observables; RooRealVar dt(""dt"", ""dt"", -10, 10);; RooRealVar dterr(""dterr"", ""per-event error on dt"", 0.01, 10);; ; // Build a gaussian resolution model scaled by the per-event error = gauss(dt,bias,sigma*dterr); RooRealVar bias(""bias"", ""bias"", 0, -10, 10);; RooRealVar sigma(""sigma"", ""per-event error scale factor"", 1, 0.1, 10);; RooGaussModel gm(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr);; ; // Construct decay(dt) (x) gauss1(dt|dterr); RooRealVar tau(""tau"", ""tau"", 1.548);; RooDecay decay_gm(""decay_gm"", ""decay"", dt, tau, gm, RooDecay::DoubleSided);; ; // C o n s t r u c t e m p i r i c a l p d f f o r p e r - e v e n t e r r o r; // -----------------------------------------------------------------; ; // Use landau pdf to get empirical distribution with long tail; RooLandau pdfDtErr(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25);; std::unique_ptr<RooDataSet> expDataDterr{pdfDtErr.generate(dterr, 10000)};; ; // Construct a histogram pdf to describe the shape of the dtErr distribution; std::unique_ptr<RooDataHist> expHistDterr{expDataDterr->binnedClone()};; RooHistPdf pdfErr(""pdfErr"", ""pdfErr"", dterr, *expHistDterr);; ; //",MatchSource.WIKI,doc/master/rf307__fullpereventerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf307__fullpereventerrors_8C.html
Modifiability,variab,variable,"ooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooDecaySingle or double sided decay function that can be analytically convolved with any RooResolutionModel ...Definition RooDecay.h:22; RooDecay::DoubleSided@ DoubleSidedDefinition RooDecay.h:25; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooHistPdfA propability density function sampled from a multidimensional histogram.Definition RooHistPdf.h:30; RooLandauLandau distribution p.d.f.Definition RooLandau.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with",MatchSource.WIKI,doc/master/rf307__fullpereventerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf307__fullpereventerrors_8C.html
Availability,error,errors,". ROOT: tutorials/roofit/rf307_fullpereventerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf307_fullpereventerrors.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: usage of full pdf with per-event errors ; ; import ROOT; ; # B-physics pdf with per-event Gaussian resolution; # ----------------------------------------------------------------------------------------------; ; # Observables; dt = ROOT.RooRealVar(""dt"", ""dt"", -10, 10); dterr = ROOT.RooRealVar(""dterr"", ""per-event error on dt"", 0.01, 10); ; # Build a gaussian resolution model scaled by the per-error =; # gauss(dt,bias,sigma*dterr); bias = ROOT.RooRealVar(""bias"", ""bias"", 0, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""per-event error scale factor"", 1, 0.1, 10); gm = ROOT.RooGaussModel(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr); ; # Construct decay(dt) (x) gauss1(dt|dterr); tau = ROOT.RooRealVar(""tau"", ""tau"", 1.548); decay_gm = ROOT.RooDecay(""decay_gm"", ""decay"", dt, tau, gm, type=""DoubleSided""); ; # Construct empirical pdf for per-event error; # -----------------------------------------------------------------; ; # Use landau pdf to get empirical distribution with long tail; pdfDtErr = ROOT.RooLandau(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25); expDataDterr = pdfDtErr.generate({dterr}, 10000); ; # Construct a histogram pdf to describe the shape of the dtErr distribution; expHistDterr = expDataDterr.binnedClone(); pdfErr = ROOT.RooHistPdf(""pdfErr"", ""pdfErr"", {dterr}, expHistDterr); ; # Construct conditional product decay_dm(dt|dterr)*pdf(dterr); # ----------------------------------------------------------------------------------------------------------------------; ; # Construct production of conditional decay_dm(dt|dterr) with empirical; # pdfErr(dterr); model = ROOT.RooProdPdf(""model"", ""model"", {pdfErr}, Conditional=({decay_gm}, {dt})); ; # (Alternatively you could als",MatchSource.WIKI,doc/master/rf307__fullpereventerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf307__fullpereventerrors_8py.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf308_normintegration2d.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf308_normintegration2d.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions . ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooAbsReal.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf308_normintegration2d(); {; // S e t u p m o d e l; // ---------------------; ; // Create observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Create pdf gaussx(x,-2,3), gaussy(y,2,2); RooGaussian gx(""gx"", ""gx"", x, -2.0, 3.0);; RooGaussian gy(""gy"", ""gy"", y, +2.0, 2.0);; ; // Create gxy = gx(x)*gy(y); RooProdPdf gxy(""gxy"", ""gxy"", RooArgSet(gx, gy));; ; // R e t r i e v e r a w & n o r m a l i z e d v a l u e s o f R o o F i t p . d . f . s; // --------------------------------------------------------------------------------------------------; ; // Return 'raw' unnormalized value of gx; cout << ""gxy = "" << gxy.getVal() << endl;; ; // Return value of gxy normalized over x _and_ y in range [-10,10]; RooArgSet nset_xy(x, y);; cout << ""gx_Norm[x,y] = "" << gxy.getVal(&nset_xy) << endl;; ; // Create object representing integral over gx; // which is used to calculate gx_Norm[x,y] == gx / gx_Int[x,y]; std::unique_ptr<RooAbsReal> igxy{gxy.createIntegral(RooArgSet(x, y))};; cout << ""gx_Int[x,y] = "" << igxy->getVal() << endl;; ; // NB: it is also possible to do the following; ; // Return value of gxy normalized over x in range [-10,10] (i.e. treating y as parameter); RooArgSet nset_x(x);; cout << ""gx_Norm[x] = "" << gxy.getVal(&nset_x) << endl;; ; // Return value of gxy normalized over y in range [-10,10] (i.e. treating x as parameter); RooArgSet nset_y(",MatchSource.WIKI,doc/master/rf308__normintegration2d_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf308__normintegration2d_8C.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf308_normintegration2d.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf308_normintegration2d.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions . ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooAbsReal.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf308_normintegration2d(); {; // S e t u p m o d e l; // ---------------------; ; // Create observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Create pdf gaussx(x,-2,3), gaussy(y,2,2); RooGaussian gx(""gx"", ""gx"", x, -2.0, 3.0);; RooGaussian gy(""gy"", ""gy"", y, +2.0, 2.0);; ; // Create gxy = gx(x)*gy(y); RooProdPdf gxy(""gxy"", ""gxy"", RooArgSet(gx, gy));; ; // R e t r i e v e r a w & n o r m a l i z e d v a l u e s o f R o o F i t p . d . f . s; // --------------------------------------------------------------------------------------------------; ; // Return 'raw' unnormalized value of gx; cout << ""gxy = "" << gxy.getVal() << endl;; ; // Return value of gxy normalized over x _and_ y in range [-10,10]; RooArgSet nset_xy(x, y);; cout << ""gx_Norm[x,y] = "" << gxy.getVal(&nset_xy) << endl;; ; // Create object representing integral over gx; // which is used to calculate gx_Norm[x,y] == gx / gx_Int[x,y]; std::unique_ptr<RooAbsReal> igxy{gxy.createIntegral(RooArgSet(x, y))};; cout << ""gx_Int[x,y] = "" << igxy->getVal() << endl;; ; // NB: it is also possible to do the following; ; // Return value of gxy normalized over x in range [-10,10] (i.e. treating y as parameter); RooArgSet nset_x(x);; cout << ""gx_Norm[x] = "" << gxy.getVal(&nset_x) << endl;; ; // Return value of gxy normalized over y in range [-10,10] (i.e. treating x as parameter); RooArgSet nset_y(",MatchSource.WIKI,doc/master/rf308__normintegration2d_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf308__normintegration2d_8C.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf308_normintegration2d.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf308_normintegration2d.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Create observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Create pdf gaussx(x,-2,3), gaussy(y,2,2); gx = ROOT.RooGaussian(""gx"", ""gx"", x, -2.0, 3.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, +2.0, 2.0); ; # gxy = gx(x)*gy(y); gxy = ROOT.RooProdPdf(""gxy"", ""gxy"", [gx, gy]); ; # Retrieve raw & normalized values of RooFit pdfs; # --------------------------------------------------------------------------------------------------; ; # Return 'raw' unnormalized value of gx; print(""gxy = "", gxy.getVal()); ; # Return value of gxy normalized over x _and_ y in range [-10,10]; nset_xy = {x, y}; print(""gx_Norm[x,y] = "", gxy.getVal(nset_xy)); ; # Create object representing integral over gx; # which is used to calculate gx_Norm[x,y] == gx / gx_Int[x,y]; x_and_y = {x, y}; igxy = gxy.createIntegral(x_and_y); print(""gx_Int[x,y] = "", igxy.getVal()); ; # NB: it is also possible to do the following; ; # Return value of gxy normalized over x in range [-10,10] (i.e. treating y; # as parameter); nset_x = {x}; print(""gx_Norm[x] = "", gxy.getVal(nset_x)); ; # Return value of gxy normalized over y in range [-10,10] (i.e. treating x; # as parameter); nset_y = {y}; print(""gx_Norm[y] = "", gxy.getVal(nset_y)); ; # Integrate normalized pdf over subrange; # ----------------------------------------------------------------------------; ; # Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5); y.setRange(""signal"", -3, 3); ; # Create an integral of g",MatchSource.WIKI,doc/master/rf308__normintegration2d_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf308__normintegration2d_8py.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf308_normintegration2d.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf308_normintegration2d.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Create observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Create pdf gaussx(x,-2,3), gaussy(y,2,2); gx = ROOT.RooGaussian(""gx"", ""gx"", x, -2.0, 3.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, +2.0, 2.0); ; # gxy = gx(x)*gy(y); gxy = ROOT.RooProdPdf(""gxy"", ""gxy"", [gx, gy]); ; # Retrieve raw & normalized values of RooFit pdfs; # --------------------------------------------------------------------------------------------------; ; # Return 'raw' unnormalized value of gx; print(""gxy = "", gxy.getVal()); ; # Return value of gxy normalized over x _and_ y in range [-10,10]; nset_xy = {x, y}; print(""gx_Norm[x,y] = "", gxy.getVal(nset_xy)); ; # Create object representing integral over gx; # which is used to calculate gx_Norm[x,y] == gx / gx_Int[x,y]; x_and_y = {x, y}; igxy = gxy.createIntegral(x_and_y); print(""gx_Int[x,y] = "", igxy.getVal()); ; # NB: it is also possible to do the following; ; # Return value of gxy normalized over x in range [-10,10] (i.e. treating y; # as parameter); nset_x = {x}; print(""gx_Norm[x] = "", gxy.getVal(nset_x)); ; # Return value of gxy normalized over y in range [-10,10] (i.e. treating x; # as parameter); nset_y = {y}; print(""gx_Norm[y] = "", gxy.getVal(nset_y)); ; # Integrate normalized pdf over subrange; # ----------------------------------------------------------------------------; ; # Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5); y.setRange(""signal"", -3, 3); ; # Create an integral of g",MatchSource.WIKI,doc/master/rf308__normintegration2d_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf308__normintegration2d_8py.html
Deployability,integrat,integrator,"bsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:850; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf309_ndimplotDefinition rf309_ndimplot.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf309_ndimplot.C. tutorialsroofitrf309_ndimplot.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf309__ndimplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8C.html
Integrability,integrat,integrator,"bsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:850; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf309_ndimplotDefinition rf309_ndimplot.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf309_ndimplot.C. tutorialsroofitrf309_ndimplot.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf309__ndimplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8C.html
Safety,safe,safe,"e class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::ZVarRooCmdArg ZVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:850; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf309_ndimplotDefinition rf309_ndimplot.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrat",MatchSource.WIKI,doc/master/rf309__ndimplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8C.html
Deployability,integrat,integrator,"in(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""box""); c1.cd(4); ROOT.gPad.SetLeftMargin(0.15); hh_pdf.GetZaxis().SetTitleOffset(2.5); hh_pdf.Draw(""cont3""); c1.SaveAs(""rf309_2dimplot.png""); ; c2 = ROOT.TCanvas(""rf309_3dimplot"", ""rf309_3dimplot"", 800, 400); c2.Divide(2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data3.GetZaxis().SetTitleOffset(1.4); hh_data3.Draw(""lego""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_pdf3.GetZaxis().SetTitleOffset(1.4); hh_pdf3.Draw(""iso""); c2.SaveAs(""rf309_3dimplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf309_ndimplot.py. tutorialsroofitrf309_ndimplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf309__ndimplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8py.html
Integrability,integrat,integrator,"in(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""box""); c1.cd(4); ROOT.gPad.SetLeftMargin(0.15); hh_pdf.GetZaxis().SetTitleOffset(2.5); hh_pdf.Draw(""cont3""); c1.SaveAs(""rf309_2dimplot.png""); ; c2 = ROOT.TCanvas(""rf309_3dimplot"", ""rf309_3dimplot"", 800, 400); c2.Divide(2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data3.GetZaxis().SetTitleOffset(1.4); hh_data3.Draw(""lego""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_pdf3.GetZaxis().SetTitleOffset(1.4); hh_pdf3.Draw(""iso""); c2.SaveAs(""rf309_3dimplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf309_ndimplot.py. tutorialsroofitrf309_ndimplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf309__ndimplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8py.html
Safety,safe,safe,"var=y, Binning=20),; ZVar=dict(var=z, Binning=20),; ); hh_pdf3.SetFillColor(ROOT.kBlue); ; c1 = ROOT.TCanvas(""rf309_2dimplot"", ""rf309_2dimplot"", 800, 800); c1.Divide(2, 2); c1.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""lego""); c1.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_pdf.GetZaxis().SetTitleOffset(2.5); hh_pdf.Draw(""surf""); c1.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""box""); c1.cd(4); ROOT.gPad.SetLeftMargin(0.15); hh_pdf.GetZaxis().SetTitleOffset(2.5); hh_pdf.Draw(""cont3""); c1.SaveAs(""rf309_2dimplot.png""); ; c2 = ROOT.TCanvas(""rf309_3dimplot"", ""rf309_3dimplot"", 800, 400); c2.Divide(2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data3.GetZaxis().SetTitleOffset(1.4); hh_data3.Draw(""lego""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_pdf3.GetZaxis().SetTitleOffset(1.4); hh_pdf3.Draw(""iso""); c2.SaveAs(""rf309_3dimplot.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrato",MatchSource.WIKI,doc/master/rf309__ndimplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8py.html
Availability,error,errors,"s; RooRealVar dt(""dt"", ""dt"", -20, 20);; ; // Discrete observables mixState (B0tag==B0reco?) and tagFlav (B0tag==B0(bar)?); RooCategory mixState(""mixState"", ""B0/B0bar mixing state"");; RooCategory tagFlav(""tagFlav"", ""Flavour of the tagged B0"");; ; // Define state labels of discrete observables; mixState.defineType(""mixed"", -1);; mixState.defineType(""unmixed"", 1);; tagFlav.defineType(""B0"", 1);; tagFlav.defineType(""B0bar"", -1);; ; // Model parameters; RooRealVar dm(""dm"", ""delta m(B)"", 0.472, 0., 1.0);; RooRealVar tau(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0);; RooRealVar w(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0);; RooRealVar dw(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01);; ; // Build a gaussian resolution model; RooRealVar bias1(""bias1"", ""bias1"", 0);; RooRealVar sigma1(""sigma1"", ""sigma1"", 0.01);; RooGaussModel gm1(""gm1"", ""gauss model 1"", dt, bias1, sigma1);; ; // Construct a decay pdf, smeared with single gaussian resolution model; RooBMixDecay bmix_gm1(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, RooBMixDecay::DoubleSided);; ; // Generate BMixing data with above set of event errors; std::unique_ptr<RooDataSet> data{bmix_gm1.generate({dt, tagFlav, mixState}, 20000)};; ; // P l o t f u l l d e c a y d i s t r i b u t i o n; // ----------------------------------------------------------; ; // Create frame, plot data and pdf projection (integrated over tagFlav and mixState); RooPlot *frame = dt.frame(Title(""Inclusive decay distribution""));; data->plotOn(frame);; bmix_gm1.plotOn(frame);; ; // P l o t d e c a y d i s t r . f o r m i x e d a n d u n m i x e d s l i c e o f m i x S t a t e; // ------------------------------------------------------------------------------------------------------------------; ; // Create frame, plot data (mixed only); RooPlot *frame2 = dt.frame(Title(""Decay distribution of mixed events""));; data->plotOn(frame2, Cut(""mixState==mixState::mixed""));; ; // Position slice in mixState at ""mixed"" and plot slice of p",MatchSource.WIKI,doc/master/rf310__sliceplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8C.html
Deployability,integrat,integrated,"""mixed"", -1);; mixState.defineType(""unmixed"", 1);; tagFlav.defineType(""B0"", 1);; tagFlav.defineType(""B0bar"", -1);; ; // Model parameters; RooRealVar dm(""dm"", ""delta m(B)"", 0.472, 0., 1.0);; RooRealVar tau(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0);; RooRealVar w(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0);; RooRealVar dw(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01);; ; // Build a gaussian resolution model; RooRealVar bias1(""bias1"", ""bias1"", 0);; RooRealVar sigma1(""sigma1"", ""sigma1"", 0.01);; RooGaussModel gm1(""gm1"", ""gauss model 1"", dt, bias1, sigma1);; ; // Construct a decay pdf, smeared with single gaussian resolution model; RooBMixDecay bmix_gm1(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, RooBMixDecay::DoubleSided);; ; // Generate BMixing data with above set of event errors; std::unique_ptr<RooDataSet> data{bmix_gm1.generate({dt, tagFlav, mixState}, 20000)};; ; // P l o t f u l l d e c a y d i s t r i b u t i o n; // ----------------------------------------------------------; ; // Create frame, plot data and pdf projection (integrated over tagFlav and mixState); RooPlot *frame = dt.frame(Title(""Inclusive decay distribution""));; data->plotOn(frame);; bmix_gm1.plotOn(frame);; ; // P l o t d e c a y d i s t r . f o r m i x e d a n d u n m i x e d s l i c e o f m i x S t a t e; // ------------------------------------------------------------------------------------------------------------------; ; // Create frame, plot data (mixed only); RooPlot *frame2 = dt.frame(Title(""Decay distribution of mixed events""));; data->plotOn(frame2, Cut(""mixState==mixState::mixed""));; ; // Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate over data (integrated over tagFlav); bmix_gm1.plotOn(frame2, Slice(mixState, ""mixed""));; ; // Create frame, plot data (unmixed only); RooPlot *frame3 = dt.frame(Title(""Decay distribution of unmixed events""));; data->plotOn(frame3, Cut(""mixState==mixState::unmixed""));; ; // Position slice in mixStat",MatchSource.WIKI,doc/master/rf310__sliceplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8C.html
Integrability,integrat,integrated,"""mixed"", -1);; mixState.defineType(""unmixed"", 1);; tagFlav.defineType(""B0"", 1);; tagFlav.defineType(""B0bar"", -1);; ; // Model parameters; RooRealVar dm(""dm"", ""delta m(B)"", 0.472, 0., 1.0);; RooRealVar tau(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0);; RooRealVar w(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0);; RooRealVar dw(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01);; ; // Build a gaussian resolution model; RooRealVar bias1(""bias1"", ""bias1"", 0);; RooRealVar sigma1(""sigma1"", ""sigma1"", 0.01);; RooGaussModel gm1(""gm1"", ""gauss model 1"", dt, bias1, sigma1);; ; // Construct a decay pdf, smeared with single gaussian resolution model; RooBMixDecay bmix_gm1(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, RooBMixDecay::DoubleSided);; ; // Generate BMixing data with above set of event errors; std::unique_ptr<RooDataSet> data{bmix_gm1.generate({dt, tagFlav, mixState}, 20000)};; ; // P l o t f u l l d e c a y d i s t r i b u t i o n; // ----------------------------------------------------------; ; // Create frame, plot data and pdf projection (integrated over tagFlav and mixState); RooPlot *frame = dt.frame(Title(""Inclusive decay distribution""));; data->plotOn(frame);; bmix_gm1.plotOn(frame);; ; // P l o t d e c a y d i s t r . f o r m i x e d a n d u n m i x e d s l i c e o f m i x S t a t e; // ------------------------------------------------------------------------------------------------------------------; ; // Create frame, plot data (mixed only); RooPlot *frame2 = dt.frame(Title(""Decay distribution of mixed events""));; data->plotOn(frame2, Cut(""mixState==mixState::mixed""));; ; // Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate over data (integrated over tagFlav); bmix_gm1.plotOn(frame2, Slice(mixState, ""mixed""));; ; // Create frame, plot data (unmixed only); RooPlot *frame3 = dt.frame(Title(""Decay distribution of unmixed events""));; data->plotOn(frame3, Cut(""mixState==mixState::unmixed""));; ; // Position slice in mixStat",MatchSource.WIKI,doc/master/rf310__sliceplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8C.html
Modifiability,variab,variable,"y.h; RooCategory.h; RooDataSet.h; RooDecay.h; RooGaussModel.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooBMixDecayClass RooBMixDecay is a RooAbsAnaConvPdf implementation that describes the decay of B mesons with the...Definition RooBMixDecay.h:23; RooBMixDecay::DoubleSided@ DoubleSidedDefinition RooBMixDecay.h:26; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution.Definition RooGaussModel.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Definition RooGlobalFunc.cxx:134; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf310_sliceplotDefinition rf310_sliceplot.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68;",MatchSource.WIKI,doc/master/rf310__sliceplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8C.html
Availability,error,errors,""", -20, 20); ; # Discrete observables mixState (B0tag==B0reco?) and tagFlav; # (B0tag==B0(bar)?); # Define state labels of discrete observables; mixState = ROOT.RooCategory(""mixState"", ""B0/B0bar mixing state"", {""mixed"": -1, ""unmixed"": 1}); tagFlav = ROOT.RooCategory(""tagFlav"", ""Flavour of the tagged B0"", {""B0"": 1, ""B0bar"": -1}); ; # Model parameters; dm = ROOT.RooRealVar(""dm"", ""delta m(B)"", 0.472, 0.0, 1.0); tau = ROOT.RooRealVar(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0); w = ROOT.RooRealVar(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0); dw = ROOT.RooRealVar(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01); ; # Build a gaussian resolution model; bias1 = ROOT.RooRealVar(""bias1"", ""bias1"", 0); sigma1 = ROOT.RooRealVar(""sigma1"", ""sigma1"", 0.01); gm1 = ROOT.RooGaussModel(""gm1"", ""gauss model 1"", dt, bias1, sigma1); ; # Construct a decay pdf, with single gaussian resolution model; bmix_gm1 = ROOT.RooBMixDecay(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, type=""DoubleSided""); ; # Generate BMixing data with above set of event errors; data = bmix_gm1.generate({dt, tagFlav, mixState}, 20000); ; # Plot full decay distribution; # ----------------------------------------------------------; ; # Create frame, data and pdf projection (integrated over tagFlav and; # mixState); frame = dt.frame(Title=""Inclusive decay distribution""); data.plotOn(frame); bmix_gm1.plotOn(frame); ; # Plot decay distribution for mixed and unmixed slice of mixState; # -------------------------------------------------------------------------------------------; ; # Create frame, data (mixed only); frame2 = dt.frame(Title=""Decay distribution of mixed events""); data.plotOn(frame2, Cut=""mixState==mixState::mixed""); ; # Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate; # over data (integrated over tagFlav); bmix_gm1.plotOn(frame2, Slice=(mixState, ""mixed"")); ; # Create frame, data (unmixed only); frame3 = dt.frame(Title=""Decay distribution of unmixed events""); dat",MatchSource.WIKI,doc/master/rf310__sliceplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8py.html
Deployability,integrat,integrated,"state"", {""mixed"": -1, ""unmixed"": 1}); tagFlav = ROOT.RooCategory(""tagFlav"", ""Flavour of the tagged B0"", {""B0"": 1, ""B0bar"": -1}); ; # Model parameters; dm = ROOT.RooRealVar(""dm"", ""delta m(B)"", 0.472, 0.0, 1.0); tau = ROOT.RooRealVar(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0); w = ROOT.RooRealVar(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0); dw = ROOT.RooRealVar(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01); ; # Build a gaussian resolution model; bias1 = ROOT.RooRealVar(""bias1"", ""bias1"", 0); sigma1 = ROOT.RooRealVar(""sigma1"", ""sigma1"", 0.01); gm1 = ROOT.RooGaussModel(""gm1"", ""gauss model 1"", dt, bias1, sigma1); ; # Construct a decay pdf, with single gaussian resolution model; bmix_gm1 = ROOT.RooBMixDecay(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, type=""DoubleSided""); ; # Generate BMixing data with above set of event errors; data = bmix_gm1.generate({dt, tagFlav, mixState}, 20000); ; # Plot full decay distribution; # ----------------------------------------------------------; ; # Create frame, data and pdf projection (integrated over tagFlav and; # mixState); frame = dt.frame(Title=""Inclusive decay distribution""); data.plotOn(frame); bmix_gm1.plotOn(frame); ; # Plot decay distribution for mixed and unmixed slice of mixState; # -------------------------------------------------------------------------------------------; ; # Create frame, data (mixed only); frame2 = dt.frame(Title=""Decay distribution of mixed events""); data.plotOn(frame2, Cut=""mixState==mixState::mixed""); ; # Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate; # over data (integrated over tagFlav); bmix_gm1.plotOn(frame2, Slice=(mixState, ""mixed"")); ; # Create frame, data (unmixed only); frame3 = dt.frame(Title=""Decay distribution of unmixed events""); data.plotOn(frame3, Cut=""mixState==mixState::unmixed""); ; # Position slice in mixState at ""unmixed"" and plot slice of pdf in; # mixstate over data (integrated over tagFlav); bmix_gm1.plotOn(frame3, Slice=",MatchSource.WIKI,doc/master/rf310__sliceplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8py.html
Integrability,integrat,integrated,"state"", {""mixed"": -1, ""unmixed"": 1}); tagFlav = ROOT.RooCategory(""tagFlav"", ""Flavour of the tagged B0"", {""B0"": 1, ""B0bar"": -1}); ; # Model parameters; dm = ROOT.RooRealVar(""dm"", ""delta m(B)"", 0.472, 0.0, 1.0); tau = ROOT.RooRealVar(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0); w = ROOT.RooRealVar(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0); dw = ROOT.RooRealVar(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01); ; # Build a gaussian resolution model; bias1 = ROOT.RooRealVar(""bias1"", ""bias1"", 0); sigma1 = ROOT.RooRealVar(""sigma1"", ""sigma1"", 0.01); gm1 = ROOT.RooGaussModel(""gm1"", ""gauss model 1"", dt, bias1, sigma1); ; # Construct a decay pdf, with single gaussian resolution model; bmix_gm1 = ROOT.RooBMixDecay(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, type=""DoubleSided""); ; # Generate BMixing data with above set of event errors; data = bmix_gm1.generate({dt, tagFlav, mixState}, 20000); ; # Plot full decay distribution; # ----------------------------------------------------------; ; # Create frame, data and pdf projection (integrated over tagFlav and; # mixState); frame = dt.frame(Title=""Inclusive decay distribution""); data.plotOn(frame); bmix_gm1.plotOn(frame); ; # Plot decay distribution for mixed and unmixed slice of mixState; # -------------------------------------------------------------------------------------------; ; # Create frame, data (mixed only); frame2 = dt.frame(Title=""Decay distribution of mixed events""); data.plotOn(frame2, Cut=""mixState==mixState::mixed""); ; # Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate; # over data (integrated over tagFlav); bmix_gm1.plotOn(frame2, Slice=(mixState, ""mixed"")); ; # Create frame, data (unmixed only); frame3 = dt.frame(Title=""Decay distribution of unmixed events""); data.plotOn(frame3, Cut=""mixState==mixState::unmixed""); ; # Position slice in mixState at ""unmixed"" and plot slice of pdf in; # mixstate over data (integrated over tagFlav); bmix_gm1.plotOn(frame3, Slice=",MatchSource.WIKI,doc/master/rf310__sliceplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8py.html
Modifiability,variab,variables,"ed only); frame2 = dt.frame(Title=""Decay distribution of mixed events""); data.plotOn(frame2, Cut=""mixState==mixState::mixed""); ; # Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate; # over data (integrated over tagFlav); bmix_gm1.plotOn(frame2, Slice=(mixState, ""mixed"")); ; # Create frame, data (unmixed only); frame3 = dt.frame(Title=""Decay distribution of unmixed events""); data.plotOn(frame3, Cut=""mixState==mixState::unmixed""); ; # Position slice in mixState at ""unmixed"" and plot slice of pdf in; # mixstate over data (integrated over tagFlav); bmix_gm1.plotOn(frame3, Slice=(mixState, ""unmixed"")); ; c = ROOT.TCanvas(""rf310_sliceplot"", ""rf310_sliceplot"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); ROOT.gPad.SetLogy(); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); ROOT.gPad.SetLogy(); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); ROOT.gPad.SetLogy(); frame3.Draw(); ; c.SaveAs(""rf310_sliceplot.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt integrates over variables (mixState,tagFlav); [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 3787 events out of 20000 total events; [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt represents a slice in (mixState); [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt integrates over variables (tagFlav); [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 16213 events out of 20000 total events; [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt represents a slice in (mixState); [#1] INFO:Plotting -- RooAbsReal::plotOn(bmix) plot on dt integrates over variables (tagFlav); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf310_sliceplot.py. tutorialsroofitrf310_sliceplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf310__sliceplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8py.html
Deployability,continuous,continuous,". ROOT: tutorials/roofit/rf311_rangeplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf311_rangeplot.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: projecting pdf and data ranges in continuous observables . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooProdPdf.h""; #include ""RooAddPdf.h""; #include ""RooPolynomial.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf311_rangeplot(); {; ; // C r e a t e 3 D p d f a n d d a t a; // -------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; RooRealVar z(""z"", ""z"", -5, 5);; ; // Create signal pdf gauss(x)*gauss(y)*gauss(z); RooGaussian gx(""gx"", ""gx"", x, 0.0, 1.0);; RooGaussian gy(""gy"", ""gy"", y, 0.0, 1.0);; RooGaussian gz(""gz"", ""gz"", z, 0.0, 1.0);; RooProdPdf sig(""sig"", ""sig"", RooArgSet(gx, gy, gz));; ; // Create background pdf poly(x)*poly(y)*poly(z); RooPolynomial px(""px"", ""px"", x, RooArgSet(-0.1, 0.004));; RooPolynomial py(""py"", ""py"", y, RooArgSet(0.1, -0.004));; RooPolynomial pz(""pz"", ""pz"", z);; RooProdPdf bkg(""bkg"", ""bkg"", RooArgSet(px, py, pz));; ; // Create composite pdf sig+bkg; RooRealVar fsig(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // P r o j e c t p d f a n d d a t a o n x i n s i g n a l r a n g e; // ----------------------------------------------------------------------------------; ; // Define signal regi",MatchSource.WIKI,doc/master/rf311__rangeplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8C.html
Integrability,integrat,integrating,"};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // P r o j e c t p d f a n d d a t a o n x i n s i g n a l r a n g e; // ----------------------------------------------------------------------------------; ; // Define signal region in y and z observables; y.setRange(""sigRegion"", -1, 1);; z.setRange(""sigRegion"", -1, 1);; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X in signal range of (Y,Z)""), Bins(40));; ; // Plot subset of data in which all observables are inside ""sigRegion""; // For observables that do not have an explicit ""sigRegion"" range defined (e.g. observable); // an implicit definition is used that is identical to the full range (i.e. [-5,5] for x); data->plotOn(frame2, CutRange(""sigRegion""));; ; // Project model on x, integrating projected observables (y,z) only in ""sigRegion""; model.plotOn(frame2, ProjectionRange(""sigRegion""));; ; TCanvas *c = new TCanvas(""rf311_rangeplot"", ""rf310_rangeplot"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooConstVar.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAb",MatchSource.WIKI,doc/master/rf311__rangeplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8C.html
Modifiability,variab,variable,"ffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooConstVar.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ProjectionRangeRooCmdArg ProjectionRange(const char *rangeName)Definition RooGlobalFunc.cxx:268; RooFit::CutRangeRooCmdArg CutRange(",MatchSource.WIKI,doc/master/rf311__rangeplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8C.html
Deployability,continuous,continuous,". ROOT: tutorials/roofit/rf311_rangeplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf311_rangeplot.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: projecting pdf and data ranges in continuous observables . ; import ROOT; ; # Create 3D pdf and data; # -------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); z = ROOT.RooRealVar(""z"", ""z"", -5, 5); ; # Create signal pdf gauss(x)*gauss(y)*gauss(z); gx = ROOT.RooGaussian(""gx"", ""gx"", x, 0.0, 1.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, 0.0, 1.0); gz = ROOT.RooGaussian(""gz"", ""gz"", z, 0.0, 1.0); sig = ROOT.RooProdPdf(""sig"", ""sig"", [gx, gy, gz]); ; # Create background pdf poly(x)*poly(y)*poly(z); px = ROOT.RooPolynomial(""px"", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; data = model.generate({x, y, z}, 20000); ; # Project pdf and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Project pdf and data on x in signal range; # ----------------------------------------------------------------------------------; ; # Define signal region in y and z observables; y.setRange(""sigRegion"", -1, 1); z.setRange(""sigRegion"", -1, 1); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X in signal range of (Y,Z)"", Bins=40); ; # Plot subset of data in which all observables are inside ""sigRegion""; # For observables that do not have an explicit ""sigRegion"" range defined",MatchSource.WIKI,doc/master/rf311__rangeplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8py.html
Integrability,integrat,integrates,"------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Project pdf and data on x in signal range; # ----------------------------------------------------------------------------------; ; # Define signal region in y and z observables; y.setRange(""sigRegion"", -1, 1); z.setRange(""sigRegion"", -1, 1); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X in signal range of (Y,Z)"", Bins=40); ; # Plot subset of data in which all observables are inside ""sigRegion""; # For observables that do not have an explicit ""sigRegion"" range defined (e.g. observable); # an implicit definition is used that is identical to the full range (i.e.; # [-5,5] for x); data.plotOn(frame2, CutRange=""sigRegion""); ; # Project model on x, projected observables (y,z) only in ""sigRegion""; model.plotOn(frame2, ProjectionRange=""sigRegion""); ; c = ROOT.TCanvas(""rf311_rangeplot"", ""rf310_rangeplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf311_rangeplot.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (z,y); [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'sigRegion' created with bounds [-1,1]; [#1] INFO:Eval -- RooRealVar::setRange(z) new range named 'sigRegion' created with bounds [-1,1]; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1692 events out of 20000 total events; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (z,y) in range sigRegion; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf311_rangeplot.py. tutorialsroofitrf311_rangeplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf311__rangeplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8py.html
Modifiability,variab,variables,"------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Project pdf and data on x in signal range; # ----------------------------------------------------------------------------------; ; # Define signal region in y and z observables; y.setRange(""sigRegion"", -1, 1); z.setRange(""sigRegion"", -1, 1); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X in signal range of (Y,Z)"", Bins=40); ; # Plot subset of data in which all observables are inside ""sigRegion""; # For observables that do not have an explicit ""sigRegion"" range defined (e.g. observable); # an implicit definition is used that is identical to the full range (i.e.; # [-5,5] for x); data.plotOn(frame2, CutRange=""sigRegion""); ; # Project model on x, projected observables (y,z) only in ""sigRegion""; model.plotOn(frame2, ProjectionRange=""sigRegion""); ; c = ROOT.TCanvas(""rf311_rangeplot"", ""rf310_rangeplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf311_rangeplot.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (z,y); [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'sigRegion' created with bounds [-1,1]; [#1] INFO:Eval -- RooRealVar::setRange(z) new range named 'sigRegion' created with bounds [-1,1]; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1692 events out of 20000 total events; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (z,y) in range sigRegion; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf311_rangeplot.py. tutorialsroofitrf311_rangeplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf311__rangeplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8py.html
Availability,error,error,"O:Eval -- RooRealVar::setRange(y) new range named 'SB2' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'SIG' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'SIG' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData' created with bounds [-10,0]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB2' created with bounds [-10,0]; [#",MatchSource.WIKI,doc/master/rf312__multirangefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8C.html
Performance,perform,performing,". ROOT: tutorials/roofit/rf312_multirangefit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf312_multirangefit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooAddPdf.h""; #include ""RooPolynomial.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFitResult.h""; using namespace RooFit;; ; void rf312_multirangefit(); {; ; // C r e a t e 2 D p d f a n d d a t a; // -------------------------------------------; ; // Define observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Construct the signal pdf gauss(x)*gauss(y); RooRealVar mx(""mx"", ""mx"", 1, -10, 10);; RooRealVar my(""my"", ""my"", 1, -10, 10);; ; RooGaussian gx(""gx"", ""gx"", x, mx, 1.0);; RooGaussian gy(""gy"", ""gy"", y, my, 1.0);; ; RooProdPdf sig(""sig"", ""sig"", gx, gy);; ; // Construct the background pdf (flat in x,y); RooPolynomial px(""px"", ""px"", x);; RooPolynomial py(""py"", ""py"", y);; RooProdPdf bkg(""bkg"", ""bkg"", px, py);; ; // Construct the composite model sig+bkg; RooRealVar f(""f"", ""f"", 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), f);; ; // Sample 10000 events in (x,y) from the model; std::unique_ptr<RooDataSet> modelData{model.generate({x, y}, 10000)};; ; // D e f i n e s i g n a l a n d s i d e b a n d r e g i o n s; // -------------------------------------------------------------------; ; // Construct the SideBand1,SideBand2,Signal regions; //; // |; // +-------------+-----------+; // | | |; // | Side | Sig |; // | Band1 | nal |; // | | |; // --+-------------+-----------+--; // | |; // | Side |; // | Band2 |; // | |; // +-------------+-----------+; // |; ; x.setRange(""SB1"", -10, +10);; y.setRange(""SB1"", -10, 0);; ; x.setRange(""SB2"", -10, 0);; y.setRang",MatchSource.WIKI,doc/master/rf312__multirangefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8C.html
Availability,error,error,"O:Eval -- RooRealVar::setRange(y) new range named 'SB2' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'SIG' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'SIG' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData' created with bounds [-10,0]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB2' created with bounds [-10,0]; [#",MatchSource.WIKI,doc/master/rf312__multirangefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8py.html
Performance,perform,performing,". ROOT: tutorials/roofit/rf312_multirangefit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf312_multirangefit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ; ; import ROOT; ; ; # Create 2D pdf and data; # -------------------------------------------; ; # Define observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Construct the signal pdf gauss(x)*gauss(y); mx = ROOT.RooRealVar(""mx"", ""mx"", 1, -10, 10); my = ROOT.RooRealVar(""my"", ""my"", 1, -10, 10); ; gx = ROOT.RooGaussian(""gx"", ""gx"", x, mx, 1.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, my, 1.0); ; sig = ROOT.RooProdPdf(""sig"", ""sig"", gx, gy); ; # Construct the background pdf (flat in x,y); px = ROOT.RooPolynomial(""px"", ""px"", x); py = ROOT.RooPolynomial(""py"", ""py"", y); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", px, py); ; # Construct the composite model sig+bkg; f = ROOT.RooRealVar(""f"", ""f"", 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [f]); ; # Sample 10000 events in (x,y) from the model; modelData = model.generate({x, y}, 10000); ; # Define signal and sideband regions; # -------------------------------------------------------------------; ; # Construct the SideBand1,SideBand2, regions; #; # |; # +-------------+-----------+; # | | |; # | Side | Sig |; # | Band1 | nal |; # | | |; # --+-------------+-----------+--; # | |; # | Side |; # | Band2 |; # | |; # +-------------+-----------+; # |; ; x.setRange(""SB1"", -10, +10); y.setRange(""SB1"", -10, 0); ; x.setRange(""SB2"", -10, 0); y.setRange(""SB2"", 0, +10); ; x.setRange(""SIG"", 0, +10); y.setRange(""SIG"", 0, +10); ; x.setRange(""FULL"", -10, +10); y.setRange(""FULL"", -10, +10); ; # Perform fits in individual sideband regions; # -------------------------------------------------------------------------------------; ; # Perform fit in SideBand1 re",MatchSource.WIKI,doc/master/rf312__multirangefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8py.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf313_paramranges.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf313_paramranges.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parametrized ranges to define non-rectangular regions for fitting and integration . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf313_paramranges(); {; ; // C r e a t e 3 D p d f; // -------------------------; ; // Define observable (x,y,z); RooRealVar x(""x"", ""x"", 0, 10);; RooRealVar y(""y"", ""y"", 0, 10);; RooRealVar z(""z"", ""z"", 0, 10);; ; // Define 3 dimensional pdf; RooRealVar z0(""z0"", ""z0"", -0.1, 1);; RooPolynomial px(""px"", ""px"", x, RooConst(0.0));; RooPolynomial py(""py"", ""py"", y, RooConst(0.0));; RooPolynomial pz(""pz"", ""pz"", z, z0);; RooProdPdf pxyz(""pxyz"", ""pxyz"", RooArgSet(px, py, pz));; ; // D e f i n e d n o n - r e c t a n g u l a r r e g i o n R i n ( x , y , z ); // -------------------------------------------------------------------------------------; ; //; // R = Z[0 - 0.1*Y^2] * Y[0.1*X - 0.9*X] * X[0 - 10]; //; ; // Construct range parametrized in ""R"" in y [ 0.1*x, 0.9*x ]; RooFormulaVar ylo(""ylo"", ""0.1*x"", x);; RooFormulaVar yhi(""yhi"", ""0.9*x"", x);; y.setRange(""R"", ylo, yhi);; ; // Construct parametrized ranged ""R"" in z [ 0, 0.1*y^2 ]; RooFormulaVar zlo(""zlo"", ""0.0*y"", y);; RooFormulaVar zhi(""zhi"", ""0.1*y*y"", y);; z.setRange(""R"", zlo, zhi);; ; // C a l c u l a t e i n t e g r a l o f n o r m a l i z e d p d f i n R; // ----------------------------------------------------------------------------------; ; // Create integral over normalized pdf model over x,y,z in ""R"" region; std::unique_ptr<RooAbsReal> intPdf{pxyz.createIntegral(RooArgSet(x, y, z), RooArgSet(x, y, z), ""R"")};; ; // Plot value of integral as function ",MatchSource.WIKI,doc/master/rf313__paramranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8C.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf313_paramranges.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf313_paramranges.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parametrized ranges to define non-rectangular regions for fitting and integration . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf313_paramranges(); {; ; // C r e a t e 3 D p d f; // -------------------------; ; // Define observable (x,y,z); RooRealVar x(""x"", ""x"", 0, 10);; RooRealVar y(""y"", ""y"", 0, 10);; RooRealVar z(""z"", ""z"", 0, 10);; ; // Define 3 dimensional pdf; RooRealVar z0(""z0"", ""z0"", -0.1, 1);; RooPolynomial px(""px"", ""px"", x, RooConst(0.0));; RooPolynomial py(""py"", ""py"", y, RooConst(0.0));; RooPolynomial pz(""pz"", ""pz"", z, z0);; RooProdPdf pxyz(""pxyz"", ""pxyz"", RooArgSet(px, py, pz));; ; // D e f i n e d n o n - r e c t a n g u l a r r e g i o n R i n ( x , y , z ); // -------------------------------------------------------------------------------------; ; //; // R = Z[0 - 0.1*Y^2] * Y[0.1*X - 0.9*X] * X[0 - 10]; //; ; // Construct range parametrized in ""R"" in y [ 0.1*x, 0.9*x ]; RooFormulaVar ylo(""ylo"", ""0.1*x"", x);; RooFormulaVar yhi(""yhi"", ""0.9*x"", x);; y.setRange(""R"", ylo, yhi);; ; // Construct parametrized ranged ""R"" in z [ 0, 0.1*y^2 ]; RooFormulaVar zlo(""zlo"", ""0.0*y"", y);; RooFormulaVar zhi(""zhi"", ""0.1*y*y"", y);; z.setRange(""R"", zlo, zhi);; ; // C a l c u l a t e i n t e g r a l o f n o r m a l i z e d p d f i n R; // ----------------------------------------------------------------------------------; ; // Create integral over normalized pdf model over x,y,z in ""R"" region; std::unique_ptr<RooAbsReal> intPdf{pxyz.createIntegral(RooArgSet(x, y, z), RooArgSet(x, y, z), ""R"")};; ; // Plot value of integral as function ",MatchSource.WIKI,doc/master/rf313__paramranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8C.html
Modifiability,variab,variable,"e_ptr<RooAbsReal> intPdf{pxyz.createIntegral(RooArgSet(x, y, z), RooArgSet(x, y, z), ""R"")};; ; // Plot value of integral as function of pdf parameter z0; RooPlot *frame = z0.frame(Title(""Integral of pxyz over x,y,z in region R""));; intPdf->plotOn(frame);; ; new TCanvas(""rf313_paramranges"", ""rf313_paramranges"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; ; return;; }; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; ",MatchSource.WIKI,doc/master/rf313__paramranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8C.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf313_paramranges.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf313_paramranges.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parameterized ranges to define non-rectangular regions for fitting and integration . ; import ROOT; ; ; # Create 3D pdf; # -------------------------; ; # Define observable (x,y,z); x = ROOT.RooRealVar(""x"", ""x"", 0, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 10); z = ROOT.RooRealVar(""z"", ""z"", 0, 10); ; # Define 3 dimensional pdf; z0 = ROOT.RooRealVar(""z0"", ""z0"", -0.1, 1); px = ROOT.RooPolynomial(""px"", ""px"", x, [0.0]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.0]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z, [z0]); pxyz = ROOT.RooProdPdf(""pxyz"", ""pxyz"", [px, py, pz]); ; # Defined non-rectangular region R in (x, y, z); # -------------------------------------------------------------------------------------; ; #; # R = Z[0 - 0.1*Y^2] * Y[0.1*X - 0.9*X] * X[0 - 10]; #; ; # Construct range parameterized in ""R"" in y [ 0.1*x, 0.9*x ]; ylo = ROOT.RooFormulaVar(""ylo"", ""0.1*x"", [x]); yhi = ROOT.RooFormulaVar(""yhi"", ""0.9*x"", [x]); y.setRange(""R"", ylo, yhi); ; # Construct parameterized ranged ""R"" in z [ 0, 0.1*y^2 ]; zlo = ROOT.RooFormulaVar(""zlo"", ""0.0*y"", [y]); zhi = ROOT.RooFormulaVar(""zhi"", ""0.1*y*y"", [y]); z.setRange(""R"", zlo, zhi); ; # Calculate integral of normalized pdf in R; # ----------------------------------------------------------------------------------; ; # Create integral over normalized pdf model over x,y, in ""R"" region; intPdf = pxyz.createIntegral({x, y, z}, {x, y, z}, ""R""); ; # Plot value of integral as function of pdf parameter z0; frame = z0.frame(Title=""Integral of pxyz over x,y, in region R""); intPdf.plotOn(frame); ; c = ROOT.TCanvas(""rf313_paramranges"", ""rf313_paramranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf313_paramra",MatchSource.WIKI,doc/master/rf313__paramranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8py.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf313_paramranges.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf313_paramranges.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parameterized ranges to define non-rectangular regions for fitting and integration . ; import ROOT; ; ; # Create 3D pdf; # -------------------------; ; # Define observable (x,y,z); x = ROOT.RooRealVar(""x"", ""x"", 0, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 10); z = ROOT.RooRealVar(""z"", ""z"", 0, 10); ; # Define 3 dimensional pdf; z0 = ROOT.RooRealVar(""z0"", ""z0"", -0.1, 1); px = ROOT.RooPolynomial(""px"", ""px"", x, [0.0]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.0]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z, [z0]); pxyz = ROOT.RooProdPdf(""pxyz"", ""pxyz"", [px, py, pz]); ; # Defined non-rectangular region R in (x, y, z); # -------------------------------------------------------------------------------------; ; #; # R = Z[0 - 0.1*Y^2] * Y[0.1*X - 0.9*X] * X[0 - 10]; #; ; # Construct range parameterized in ""R"" in y [ 0.1*x, 0.9*x ]; ylo = ROOT.RooFormulaVar(""ylo"", ""0.1*x"", [x]); yhi = ROOT.RooFormulaVar(""yhi"", ""0.9*x"", [x]); y.setRange(""R"", ylo, yhi); ; # Construct parameterized ranged ""R"" in z [ 0, 0.1*y^2 ]; zlo = ROOT.RooFormulaVar(""zlo"", ""0.0*y"", [y]); zhi = ROOT.RooFormulaVar(""zhi"", ""0.1*y*y"", [y]); z.setRange(""R"", zlo, zhi); ; # Calculate integral of normalized pdf in R; # ----------------------------------------------------------------------------------; ; # Create integral over normalized pdf model over x,y, in ""R"" region; intPdf = pxyz.createIntegral({x, y, z}, {x, y, z}, ""R""); ; # Plot value of integral as function of pdf parameter z0; frame = z0.frame(Title=""Integral of pxyz over x,y, in region R""); intPdf.plotOn(frame); ; c = ROOT.TCanvas(""rf313_paramranges"", ""rf313_paramranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf313_paramra",MatchSource.WIKI,doc/master/rf313__paramranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8py.html
Modifiability,parameteriz,parameterized,". ROOT: tutorials/roofit/rf313_paramranges.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf313_paramranges.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parameterized ranges to define non-rectangular regions for fitting and integration . ; import ROOT; ; ; # Create 3D pdf; # -------------------------; ; # Define observable (x,y,z); x = ROOT.RooRealVar(""x"", ""x"", 0, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 10); z = ROOT.RooRealVar(""z"", ""z"", 0, 10); ; # Define 3 dimensional pdf; z0 = ROOT.RooRealVar(""z0"", ""z0"", -0.1, 1); px = ROOT.RooPolynomial(""px"", ""px"", x, [0.0]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.0]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z, [z0]); pxyz = ROOT.RooProdPdf(""pxyz"", ""pxyz"", [px, py, pz]); ; # Defined non-rectangular region R in (x, y, z); # -------------------------------------------------------------------------------------; ; #; # R = Z[0 - 0.1*Y^2] * Y[0.1*X - 0.9*X] * X[0 - 10]; #; ; # Construct range parameterized in ""R"" in y [ 0.1*x, 0.9*x ]; ylo = ROOT.RooFormulaVar(""ylo"", ""0.1*x"", [x]); yhi = ROOT.RooFormulaVar(""yhi"", ""0.9*x"", [x]); y.setRange(""R"", ylo, yhi); ; # Construct parameterized ranged ""R"" in z [ 0, 0.1*y^2 ]; zlo = ROOT.RooFormulaVar(""zlo"", ""0.0*y"", [y]); zhi = ROOT.RooFormulaVar(""zhi"", ""0.1*y*y"", [y]); z.setRange(""R"", zlo, zhi); ; # Calculate integral of normalized pdf in R; # ----------------------------------------------------------------------------------; ; # Create integral over normalized pdf model over x,y, in ""R"" region; intPdf = pxyz.createIntegral({x, y, z}, {x, y, z}, ""R""); ; # Plot value of integral as function of pdf parameter z0; frame = z0.frame(Title=""Integral of pxyz over x,y, in region R""); intPdf.plotOn(frame); ; c = ROOT.TCanvas(""rf313_paramranges"", ""rf313_paramranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf313_paramra",MatchSource.WIKI,doc/master/rf313__paramranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8py.html
Availability,error,error,"g=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ProtoDataRooCmdArg ProtoData(const RooDataSet &protoData, bool randomizeOrder=false, bool resample=false)Definition RooGlobalFunc.cxx:812; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf314_paramfitrangeDefinition rf314_paramfitrange.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[t]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 5000 will supersede previous event count of 10000 for normalization of PDF projections; ; RooFitResult: minimized FCN value: 2823.97, estimated distance to minimum: 3.17108e-08; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter InitialValue FinalValue +/- Error GblCorr.; -------------------- ------------ -------------------------- --------; tau -1.5400e+00 -1.5335e+00 +/- 2.22e-02 <none>; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf314_paramfitrange.C. tutorialsroofitrf314_paramfitrange.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf314__paramfitrange_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8C.html
Deployability,update,updateFitRangeNorm,"g=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ProtoDataRooCmdArg ProtoData(const RooDataSet &protoData, bool randomizeOrder=false, bool resample=false)Definition RooGlobalFunc.cxx:812; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf314_paramfitrangeDefinition rf314_paramfitrange.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[t]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 5000 will supersede previous event count of 10000 for normalization of PDF projections; ; RooFitResult: minimized FCN value: 2823.97, estimated distance to minimum: 3.17108e-08; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter InitialValue FinalValue +/- Error GblCorr.; -------------------- ------------ -------------------------- --------; tau -1.5400e+00 -1.5335e+00 +/- 2.22e-02 <none>; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf314_paramfitrange.C. tutorialsroofitrf314_paramfitrange.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf314__paramfitrange_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8C.html
Modifiability,variab,variable,"ar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ProtoDataRooCmdArg ProtoData(const RooDataSet &protoData, bool randomizeOrder=false, bool resample=false)Definition RooGlobalFunc.cxx:812; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::Line",MatchSource.WIKI,doc/master/rf314__paramfitrange_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8C.html
Performance,optimiz,optimization,"g=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ProtoDataRooCmdArg ProtoData(const RooDataSet &protoData, bool randomizeOrder=false, bool resample=false)Definition RooGlobalFunc.cxx:812; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf314_paramfitrangeDefinition rf314_paramfitrange.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[t]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 5000 will supersede previous event count of 10000 for normalization of PDF projections; ; RooFitResult: minimized FCN value: 2823.97, estimated distance to minimum: 3.17108e-08; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter InitialValue FinalValue +/- Error GblCorr.; -------------------- ------------ -------------------------- --------; tau -1.5400e+00 -1.5335e+00 +/- 2.22e-02 <none>; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf314_paramfitrange.C. tutorialsroofitrf314_paramfitrange.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf314__paramfitrange_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8C.html
Availability,error,error,"----------; ; r = model.fitTo(dacc, Save=True, PrintLevel=-1); ; # Plot fitted pdf on full and accepted data; # ---------------------------------------------------------------------------------; ; # Make plot frame, datasets and overlay model; frame = t.frame(Title=""Fit to data with per-event acceptance""); dall.plotOn(frame, MarkerColor=""r"", LineColor=""r""); model.plotOn(frame); dacc.plotOn(frame); ; # Print fit results to demonstrate absence of bias; r.Print(""v""); ; c = ROOT.TCanvas(""rf314_paramranges"", ""rf314_paramranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf314_paramranges.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[t]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 5000 will supersede previous event count of 10000 for normalization of PDF projections; ; RooFitResult: minimized FCN value: 2823.97, estimated distance to minimum: 3.17108e-08; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter InitialValue FinalValue +/- Error GblCorr.; -------------------- ------------ -------------------------- --------; tau -1.5400e+00 -1.5335e+00 +/- 2.22e-02 <none>; ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf314_paramfitrange.py. tutorialsroofitrf314_paramfitrange.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf314__paramfitrange_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8py.html
Deployability,update,updateFitRangeNorm,"----------; ; r = model.fitTo(dacc, Save=True, PrintLevel=-1); ; # Plot fitted pdf on full and accepted data; # ---------------------------------------------------------------------------------; ; # Make plot frame, datasets and overlay model; frame = t.frame(Title=""Fit to data with per-event acceptance""); dall.plotOn(frame, MarkerColor=""r"", LineColor=""r""); model.plotOn(frame); dacc.plotOn(frame); ; # Print fit results to demonstrate absence of bias; r.Print(""v""); ; c = ROOT.TCanvas(""rf314_paramranges"", ""rf314_paramranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf314_paramranges.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[t]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 5000 will supersede previous event count of 10000 for normalization of PDF projections; ; RooFitResult: minimized FCN value: 2823.97, estimated distance to minimum: 3.17108e-08; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter InitialValue FinalValue +/- Error GblCorr.; -------------------- ------------ -------------------------- --------; tau -1.5400e+00 -1.5335e+00 +/- 2.22e-02 <none>; ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf314_paramfitrange.py. tutorialsroofitrf314_paramfitrange.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf314__paramfitrange_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8py.html
Modifiability,parameteriz,parameterized,". ROOT: tutorials/roofit/rf314_paramfitrange.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf314_paramfitrange.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parameterized ranges in a fit. ; This an example of a fit with an acceptance that changes per-event; pdf = exp(-t/tau) with t[tmin,5]; where t and tmin are both observables in the dataset. ; import ROOT; ; ; # Define observables and decay pdf; # ---------------------------------------------------------------; ; # Declare observables; t = ROOT.RooRealVar(""t"", ""t"", 0, 5); tmin = ROOT.RooRealVar(""tmin"", ""tmin"", 0, 0, 5); ; # Make parameterized range in t : [tmin,5]; t.setRange(tmin, ROOT.RooFit.RooConst(t.getMax())); ; # Make pdf; tau = ROOT.RooRealVar(""tau"", ""tau"", -1.54, -10, -0.1); model = ROOT.RooExponential(""model"", ""model"", t, tau); ; # Create input data; # ------------------------------------; ; # Generate complete dataset without acceptance cuts (for reference); dall = model.generate({t}, 10000); ; # Generate a (fake) prototype dataset for acceptance limit values; tmp = ROOT.RooGaussian(""gmin"", ""gmin"", tmin, 0.0, 0.5).generate({tmin}, 5000); ; # Generate dataset with t values that observe (t>tmin); dacc = model.generate({t}, ProtoData=tmp); ; # Fit pdf to data in acceptance region; # -----------------------------------------------------------------------; ; r = model.fitTo(dacc, Save=True, PrintLevel=-1); ; # Plot fitted pdf on full and accepted data; # ---------------------------------------------------------------------------------; ; # Make plot frame, datasets and overlay model; frame = t.frame(Title=""Fit to data with per-event acceptance""); dall.plotOn(frame, MarkerColor=""r"", LineColor=""r""); model.plotOn(frame); dacc.plotOn(frame); ; # Print fit results to demonstrate absence of bias; r.Print(""v""); ; c = ROOT.TCanvas(""rf314_paramranges"", ""rf314_paramranges"", 600, 600); ROOT.gPa",MatchSource.WIKI,doc/master/rf314__paramfitrange_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8py.html
Performance,optimiz,optimization,"----------; ; r = model.fitTo(dacc, Save=True, PrintLevel=-1); ; # Plot fitted pdf on full and accepted data; # ---------------------------------------------------------------------------------; ; # Make plot frame, datasets and overlay model; frame = t.frame(Title=""Fit to data with per-event acceptance""); dall.plotOn(frame, MarkerColor=""r"", LineColor=""r""); model.plotOn(frame); dacc.plotOn(frame); ; # Print fit results to demonstrate absence of bias; r.Print(""v""); ; c = ROOT.TCanvas(""rf314_paramranges"", ""rf314_paramranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf314_paramranges.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[t]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 5000 will supersede previous event count of 10000 for normalization of PDF projections; ; RooFitResult: minimized FCN value: 2823.97, estimated distance to minimum: 3.17108e-08; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter InitialValue FinalValue +/- Error GblCorr.; -------------------- ------------ -------------------------- --------; tau -1.5400e+00 -1.5335e+00 +/- 2.22e-02 <none>; ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf314_paramfitrange.py. tutorialsroofitrf314_paramfitrange.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf314__paramfitrange_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8py.html
Availability,error,error,"ogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf315_projectpdfDefinition rf315_projectpdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); ; prevFCN = 12037.78496 a1=-1.469, ; prevFCN = 1900.132597 a1=-1.531, ; prevFCN = 1901.591671 a1=-1.497, ; prevFCN = 1900.088181 a1=-1.503, ; prevFCN = 1900.238998 a1=-1.5, y=0.03051, ; prevFCN = 1900.156536 y=-0.03051, ; prevFCN = 1900.156536 y=0.003051, ; prevFCN = 1900.156536 y=-0.003051, ; prevFCN = 1900.156536 a1=-1.497, y=0, ; prevFCN = 19",MatchSource.WIKI,doc/master/rf315__projectpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf315_projectpdf.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf315_projectpdf.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: marginizalization of multi-dimensional pdfs through integration . ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooPolyVar.h""; #include ""TH1.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumIntConfig.h""; using namespace RooFit;; ; void rf315_projectpdf(); {; // C r e a t e p d f m ( x , y ) = g x ( x | y ) * g ( y ); // --------------------------------------------------------------; ; // Increase default precision of numeric integration; // as this exercise has high sensitivity to numeric integration precision; RooAbsPdf::defaultIntegratorConfig()->setEpsRel(1e-8);; RooAbsPdf::defaultIntegratorConfig()->setEpsAbs(1e-8);; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -2, 2);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", 0);; RooRealVar a1(""a1"", ""a1"", -1.5, -3, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gaussx(x,f(y),sx); RooRealVar sigmax(""sigmax"", ""width of gaussian"", 0.5);; RooGaussian gaussx(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax);; ; // Create gaussy(y,0,2); RooGaussian gaussy(""gaussy"", ""Gaussian in y"", y, 0.0, 2.0);; ; // Create gaussx(x,sx|y) * gaussy(y); RooProdPdf model(""model"", ""gaussx(x|y)*gaussy(y)"", gaussy, Conditional(gaussx, x));; ; // M a r g i n a l i z e m ( x , y ) t o m ( x ); // ----------------------------------------------------; ; // modelx(x) = Int model(x,y) dy; RooAbsPdf *modelx = model.createProjection(y);; ; // U s e m a r g i n a l i z e d p . d . f . a s r e g u l a r 1 - D p . d . f .; // ------------------------------------------------------------------------------------------; ; // Samp",MatchSource.WIKI,doc/master/rf315__projectpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf315_projectpdf.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf315_projectpdf.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: marginizalization of multi-dimensional pdfs through integration . ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooPolyVar.h""; #include ""TH1.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumIntConfig.h""; using namespace RooFit;; ; void rf315_projectpdf(); {; // C r e a t e p d f m ( x , y ) = g x ( x | y ) * g ( y ); // --------------------------------------------------------------; ; // Increase default precision of numeric integration; // as this exercise has high sensitivity to numeric integration precision; RooAbsPdf::defaultIntegratorConfig()->setEpsRel(1e-8);; RooAbsPdf::defaultIntegratorConfig()->setEpsAbs(1e-8);; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -2, 2);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", 0);; RooRealVar a1(""a1"", ""a1"", -1.5, -3, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gaussx(x,f(y),sx); RooRealVar sigmax(""sigmax"", ""width of gaussian"", 0.5);; RooGaussian gaussx(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax);; ; // Create gaussy(y,0,2); RooGaussian gaussy(""gaussy"", ""Gaussian in y"", y, 0.0, 2.0);; ; // Create gaussx(x,sx|y) * gaussy(y); RooProdPdf model(""model"", ""gaussx(x|y)*gaussy(y)"", gaussy, Conditional(gaussx, x));; ; // M a r g i n a l i z e m ( x , y ) t o m ( x ); // ----------------------------------------------------; ; // modelx(x) = Int model(x,y) dy; RooAbsPdf *modelx = model.createProjection(y);; ; // U s e m a r g i n a l i z e d p . d . f . a s r e g u l a r 1 - D p . d . f .; // ------------------------------------------------------------------------------------------; ; // Samp",MatchSource.WIKI,doc/master/rf315__projectpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html
Modifiability,config,configuration," const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateBinnedvirtual RooFit::OwningPtr< RooDataHist > generateBinned(const RooArgSet &whatVars, double nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooNumIntConfig::setEpsRelvoid setEpsRel(double newEpsRel)Set relative convergence criteria (convergence if std::abs(Err)/abs(Int)<newEpsRel)Definition RooNumIntConfig.cxx:260; RooNumIntConfig::setEpsAbsvoid setEpsAbs(double newEpsAbs)Set absolute convergence criteria (convergence if std::abs(Err)<newEpsAbs)Definition RooNumIntConfig.cxx:230; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(O",MatchSource.WIKI,doc/master/rf315__projectpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html
Performance,optimiz,optimization,"ogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf315_projectpdfDefinition rf315_projectpdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); ; prevFCN = 12037.78496 a1=-1.469, ; prevFCN = 1900.132597 a1=-1.531, ; prevFCN = 1901.591671 a1=-1.497, ; prevFCN = 1900.088181 a1=-1.503, ; prevFCN = 1900.238998 a1=-1.5, y=0.03051, ; prevFCN = 1900.156536 y=-0.03051, ; prevFCN = 1900.156536 y=0.003051, ; prevFCN = 1900.156536 y=-0.003051, ; prevFCN = 1900.156536 a1=-1.497, y=0, ; prevFCN = 19",MatchSource.WIKI,doc/master/rf315__projectpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html
Safety,safe,safe,"DFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf315_projectpdfDefinition rf315_projectpdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooR",MatchSource.WIKI,doc/master/rf315__projectpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html
Availability,error,error," frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = ROOT.TCanvas(""rf315_projectpdf"", ""rf315_projectpdf"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.SaveAs(""rf315_projectpdf.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); ; prevFCN = 12037.78496 a1=-1.469, ; prevFCN = 1900.132597 a1=-1.531, ; prevFCN = 1901.591671 a1=-1.497, ; prevFCN = 1900.088181 a1=-1.503, ; prevFCN = 1900.238998 a1=-1.5, y=0.03051, ; prevFCN = 1900.156536 y=-0.03051, ; prevFCN = 1900.156536 y=0.003051, ; prevFCN = 1900.156536 y=-0.003051, ; prevFCN = 1900.156536 a1=-1.497, y=0, ; prevFCN = 19",MatchSource.WIKI,doc/master/rf315__projectpdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html
Deployability,integrat,integration,". ROOT: tutorials/roofit/rf315_projectpdf.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf315_projectpdf.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: marginizalization of multi-dimensional pdfs through integration . ; import ROOT; ; ; # Create pdf m(x,y) = gx(x|y) * g(y); # --------------------------------------------------------------; ; # Increase default precision of numeric integration; # as self exercise has high sensitivity to numeric integration precision; ROOT.RooAbsPdf.defaultIntegratorConfig().setEpsRel(1e-8); ROOT.RooAbsPdf.defaultIntegratorConfig().setEpsAbs(1e-8); ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -2, 2); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -1.5, -3, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Create gaussx(x,f(y),sx); sigmax = ROOT.RooRealVar(""sigmax"", ""width of gaussian"", 0.5); gaussx = ROOT.RooGaussian(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax); ; # Create gaussy(y,0,2); gaussy = ROOT.RooGaussian(""gaussy"", ""Gaussian in y"", y, 0.0, 2.0); ; # Create gaussx(x,sx|y) * gaussy(y); model = ROOT.RooProdPdf(; ""model"",; ""gaussx(x|y)*gaussy(y)"",; {gaussy},; Conditional=({gaussx}, {x}),; ); ; # Marginalize m(x,y) to m(x); # ----------------------------------------------------; ; # modelx(x) = Int model(x,y) dy; modelx = model.createProjection({y}); ; # Use marginalized pdf as regular 1D pdf; # -----------------------------------------------; ; # Sample 1000 events from modelx; data = modelx.generateBinned({x}, 1000); ; # Fit modelx to toy data; modelx.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot modelx over data; frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = RO",MatchSource.WIKI,doc/master/rf315__projectpdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf315_projectpdf.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf315_projectpdf.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: marginizalization of multi-dimensional pdfs through integration . ; import ROOT; ; ; # Create pdf m(x,y) = gx(x|y) * g(y); # --------------------------------------------------------------; ; # Increase default precision of numeric integration; # as self exercise has high sensitivity to numeric integration precision; ROOT.RooAbsPdf.defaultIntegratorConfig().setEpsRel(1e-8); ROOT.RooAbsPdf.defaultIntegratorConfig().setEpsAbs(1e-8); ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -2, 2); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -1.5, -3, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Create gaussx(x,f(y),sx); sigmax = ROOT.RooRealVar(""sigmax"", ""width of gaussian"", 0.5); gaussx = ROOT.RooGaussian(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax); ; # Create gaussy(y,0,2); gaussy = ROOT.RooGaussian(""gaussy"", ""Gaussian in y"", y, 0.0, 2.0); ; # Create gaussx(x,sx|y) * gaussy(y); model = ROOT.RooProdPdf(; ""model"",; ""gaussx(x|y)*gaussy(y)"",; {gaussy},; Conditional=({gaussx}, {x}),; ); ; # Marginalize m(x,y) to m(x); # ----------------------------------------------------; ; # modelx(x) = Int model(x,y) dy; modelx = model.createProjection({y}); ; # Use marginalized pdf as regular 1D pdf; # -----------------------------------------------; ; # Sample 1000 events from modelx; data = modelx.generateBinned({x}, 1000); ; # Fit modelx to toy data; modelx.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot modelx over data; frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = RO",MatchSource.WIKI,doc/master/rf315__projectpdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html
Performance,optimiz,optimization," frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = ROOT.TCanvas(""rf315_projectpdf"", ""rf315_projectpdf"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.SaveAs(""rf315_projectpdf.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); ; prevFCN = 12037.78496 a1=-1.469, ; prevFCN = 1900.132597 a1=-1.531, ; prevFCN = 1901.591671 a1=-1.497, ; prevFCN = 1900.088181 a1=-1.503, ; prevFCN = 1900.238998 a1=-1.5, y=0.03051, ; prevFCN = 1900.156536 y=-0.03051, ; prevFCN = 1900.156536 y=0.003051, ; prevFCN = 1900.156536 y=-0.003051, ; prevFCN = 1900.156536 a1=-1.497, y=0, ; prevFCN = 19",MatchSource.WIKI,doc/master/rf315__projectpdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html
Safety,safe,safe,"onditional=({gaussx}, {x}),; ); ; # Marginalize m(x,y) to m(x); # ----------------------------------------------------; ; # modelx(x) = Int model(x,y) dy; modelx = model.createProjection({y}); ; # Use marginalized pdf as regular 1D pdf; # -----------------------------------------------; ; # Sample 1000 events from modelx; data = modelx.generateBinned({x}, 1000); ; # Fit modelx to toy data; modelx.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot modelx over data; frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = ROOT.TCanvas(""rf315_projectpdf"", ""rf315_projectpdf"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.SaveAs(""rf315_projectpdf.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRe",MatchSource.WIKI,doc/master/rf315__projectpdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html
Deployability,integrat,integrate,"Polynomial px(""px"", ""px"", x, RooArgSet(-0.1, 0.004));; RooPolynomial py(""py"", ""py"", y, RooArgSet(0.1, -0.004));; RooPolynomial pz(""pz"", ""pz"", z);; RooProdPdf bkg(""bkg"", ""bkg"", RooArgSet(px, py, pz));; ; // Create composite pdf sig+bkg; RooRealVar fsig(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // D e f i n e p r o j e c t e d s i g n a l l i k e l i h o o d r a t i o; // ----------------------------------------------------------------------------------; ; // Calculate projection of signal and total likelihood on (y,z) observables; // i.e. integrate signal and composite model over x; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; ; // Construct the log of the signal / signal+background probability; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // P l o t d a t a w i t h a L L r a t i o c u t; // -------------------------------------------------------; ; // Calculate the llratio value for each event in the dataset; data->addColumn(llratio_func);; ; // Extract the subset of data with large signal likelihood; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X with LLratio(y,z)>0.7""), Bins(40));; ; // Plot select data on frame; dataSel->plotOn(frame2);; ; // M a k e M C p r o j e c t i o n o f p d f w i t h s a m e L L r a t i o c u t; // ---------------------------------------------------------------------------------------------; ; // Generate large number of events for ",MatchSource.WIKI,doc/master/rf316__llratioplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html
Energy Efficiency,reduce,reduce,"ig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // D e f i n e p r o j e c t e d s i g n a l l i k e l i h o o d r a t i o; // ----------------------------------------------------------------------------------; ; // Calculate projection of signal and total likelihood on (y,z) observables; // i.e. integrate signal and composite model over x; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; ; // Construct the log of the signal / signal+background probability; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // P l o t d a t a w i t h a L L r a t i o c u t; // -------------------------------------------------------; ; // Calculate the llratio value for each event in the dataset; data->addColumn(llratio_func);; ; // Extract the subset of data with large signal likelihood; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X with LLratio(y,z)>0.7""), Bins(40));; ; // Plot select data on frame; dataSel->plotOn(frame2);; ; // M a k e M C p r o j e c t i o n o f p d f w i t h s a m e L L r a t i o c u t; // ---------------------------------------------------------------------------------------------; ; // Generate large number of events for MC integration of pdf projection; std::unique_ptr<RooDataSet> mcprojData{model.generate({x, y, z}, 10000)};; ; // Calculate LL ratio for each generated event and select MC events with llratio)0.7; mcprojData->addColumn(llratio_func);; std::unique_ptr<RooAbsData> mcprojDataSel{mcprojData->reduce(Cut(""llratio>0.7""))};; ; // Project model on",MatchSource.WIKI,doc/master/rf316__llratioplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html
Integrability,integrat,integrate,"Polynomial px(""px"", ""px"", x, RooArgSet(-0.1, 0.004));; RooPolynomial py(""py"", ""py"", y, RooArgSet(0.1, -0.004));; RooPolynomial pz(""pz"", ""pz"", z);; RooProdPdf bkg(""bkg"", ""bkg"", RooArgSet(px, py, pz));; ; // Create composite pdf sig+bkg; RooRealVar fsig(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // D e f i n e p r o j e c t e d s i g n a l l i k e l i h o o d r a t i o; // ----------------------------------------------------------------------------------; ; // Calculate projection of signal and total likelihood on (y,z) observables; // i.e. integrate signal and composite model over x; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; ; // Construct the log of the signal / signal+background probability; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // P l o t d a t a w i t h a L L r a t i o c u t; // -------------------------------------------------------; ; // Calculate the llratio value for each event in the dataset; data->addColumn(llratio_func);; ; // Extract the subset of data with large signal likelihood; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X with LLratio(y,z)>0.7""), Bins(40));; ; // Plot select data on frame; dataSel->plotOn(frame2);; ; // M a k e M C p r o j e c t i o n o f p d f w i t h s a m e L L r a t i o c u t; // ---------------------------------------------------------------------------------------------; ; // Generate large number of events for ",MatchSource.WIKI,doc/master/rf316__llratioplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html
Modifiability,enhance,enhanced,". ROOT: tutorials/roofit/rf316_llratioplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf316_llratioplot.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: using the likelihood ratio technique to construct a signal enhanced one-dimensional projection of a multi-dimensional pdf . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf316_llratioplot(); {; ; // C r e a t e 3 D p d f a n d d a t a; // -------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; RooRealVar z(""z"", ""z"", -5, 5);; ; // Create signal pdf gauss(x)*gauss(y)*gauss(z); RooGaussian gx(""gx"", ""gx"", x, 0.0, 1.0);; RooGaussian gy(""gy"", ""gy"", y, 0.0, 1.0);; RooGaussian gz(""gz"", ""gz"", z, 0.0, 1.0);; RooProdPdf sig(""sig"", ""sig"", RooArgSet(gx, gy, gz));; ; // Create background pdf poly(x)*poly(y)*poly(z); RooPolynomial px(""px"", ""px"", x, RooArgSet(-0.1, 0.004));; RooPolynomial py(""py"", ""py"", y, RooArgSet(0.1, -0.004));; RooPolynomial pz(""pz"", ""pz"", z);; RooProdPdf bkg(""bkg"", ""bkg"", RooArgSet(px, py, pz));; ; // Create composite pdf sig+bkg; RooRealVar fsig(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // D e f i n e p r o j e c t e d s i g n a l l i k e l i h o o d r a t i o; // --------------------------------------------------------",MatchSource.WIKI,doc/master/rf316__llratioplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html
Testability,log,log,"ig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // D e f i n e p r o j e c t e d s i g n a l l i k e l i h o o d r a t i o; // ----------------------------------------------------------------------------------; ; // Calculate projection of signal and total likelihood on (y,z) observables; // i.e. integrate signal and composite model over x; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; ; // Construct the log of the signal / signal+background probability; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // P l o t d a t a w i t h a L L r a t i o c u t; // -------------------------------------------------------; ; // Calculate the llratio value for each event in the dataset; data->addColumn(llratio_func);; ; // Extract the subset of data with large signal likelihood; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X with LLratio(y,z)>0.7""), Bins(40));; ; // Plot select data on frame; dataSel->plotOn(frame2);; ; // M a k e M C p r o j e c t i o n o f p d f w i t h s a m e L L r a t i o c u t; // ---------------------------------------------------------------------------------------------; ; // Generate large number of events for MC integration of pdf projection; std::unique_ptr<RooDataSet> mcprojData{model.generate({x, y, z}, 10000)};; ; // Calculate LL ratio for each generated event and select MC events with llratio)0.7; mcprojData->addColumn(llratio_func);; std::unique_ptr<RooAbsData> mcprojDataSel{mcprojData->reduce(Cut(""llratio>0.7""))};; ; // Project model on",MatchSource.WIKI,doc/master/rf316__llratioplot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html
Deployability,integrat,integrate,"OOT.RooProdPdf(""sig"", ""sig"", [gx, gy, gz]); ; # Create background pdf poly(x)*poly(y)*poly(z); px = ROOT.RooPolynomial(""px"", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; data = model.generate({x, y, z}, 20000); ; # Project pdf and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Define projected signal likelihood ratio; # ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Plot data with a LL ratio cut; # -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generate",MatchSource.WIKI,doc/master/rf316__llratioplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html
Energy Efficiency,reduce,reduce,"and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Define projected signal likelihood ratio; # ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Plot data with a LL ratio cut; # -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generated event and select MC events with; # llratio)0.7; mcprojData.addColumn(llratio_func); mcprojDataSel = mcprojData.reduce(Cut=""llratio>0.7""); ; # Project model on x, projected observables (y,z) with Monte Carlo technique; # on set of events with the same llratio cut as was applied to data; model.plotOn(frame2, ProjWData=mcprojDataSel); ; c = ROOT.TCanvas(""rf316_llratioplot"", ""rf316_llratioplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd",MatchSource.WIKI,doc/master/rf316__llratioplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html
Integrability,integrat,integrate,"OOT.RooProdPdf(""sig"", ""sig"", [gx, gy, gz]); ; # Create background pdf poly(x)*poly(y)*poly(z); px = ROOT.RooPolynomial(""px"", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; data = model.generate({x, y, z}, 20000); ; # Project pdf and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Define projected signal likelihood ratio; # ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Plot data with a LL ratio cut; # -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generate",MatchSource.WIKI,doc/master/rf316__llratioplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html
Modifiability,enhance,enhanced,". ROOT: tutorials/roofit/rf316_llratioplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf316_llratioplot.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: using the likelihood ratio technique to construct a signal enhanced one-dimensional projection of a multi-dimensional pdf . ; import ROOT; ; ; # Create 3D pdf and data; # -------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); z = ROOT.RooRealVar(""z"", ""z"", -5, 5); ; # Create signal pdf gauss(x)*gauss(y)*gauss(z); gx = ROOT.RooGaussian(""gx"", ""gx"", x, 0.0, 1.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, 0.0, 1.0); gz = ROOT.RooGaussian(""gz"", ""gz"", z, 0.0, 1.0); sig = ROOT.RooProdPdf(""sig"", ""sig"", [gx, gy, gz]); ; # Create background pdf poly(x)*poly(y)*poly(z); px = ROOT.RooPolynomial(""px"", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; data = model.generate({x, y, z}, 20000); ; # Project pdf and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Define projected signal likelihood ratio; # ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.",MatchSource.WIKI,doc/master/rf316__llratioplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html
Testability,log,log,""", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; data = model.generate({x, y, z}, 20000); ; # Project pdf and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Define projected signal likelihood ratio; # ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Plot data with a LL ratio cut; # -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generated event and select MC events with; # llratio)0.7; mcprojData.addColumn(llratio_func); mcprojDataSel = mcprojData.reduce(Cu",MatchSource.WIKI,doc/master/rf316__llratioplot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html
Energy Efficiency,reduce,reduce,"ooDataSet ds2(""ds2"", ""ds2"", RooArgSet(x, y, z), Import(*tree), Cut(""y+z<0""));; ds2.Print();; ; // I m p o r t i n g i n t e g e r T T r e e b r a n c h e s; // ---------------------------------------------------------------; ; // Import integer tree branch as RooRealVar; RooRealVar i(""i"", ""i"", 0, 5);; RooDataSet ds3(""ds3"", ""ds3"", RooArgSet(i, x), Import(*tree));; ds3.Print();; ; // Define category i; RooCategory icat(""i"", ""i"");; icat.defineType(""State0"", 0);; icat.defineType(""State1"", 1);; ; // Import integer tree branch as RooCategory (only events with i==0 and i==1; // will be imported as those are the only defined states); RooDataSet ds4(""ds4"", ""ds4"", RooArgSet(icat, x), Import(*tree));; ds4.Print();; ; // I m p o r t m u l t i p l e R o o D a t a S e t s i n t o a R o o D a t a S e t; // ----------------------------------------------------------------------------------------; ; // Create three RooDataSets in (y,z); std::unique_ptr<RooAbsData> dsA{ds2.reduce({x, y}, ""z<-5"")};; std::unique_ptr<RooAbsData> dsB{ds2.reduce({x, y}, ""abs(z)<5"")};; std::unique_ptr<RooAbsData> dsC{ds2.reduce({x, y}, ""z>5"")};; ; // Create a dataset that imports contents of all the above datasets mapped by index category c; RooDataSet dsABC{""dsABC"", ""dsABC"", RooArgSet(x, y), Index(c), Import(""SampleA"", *dsA),; Import(""SampleB"", *dsB), Import(""SampleC"", *dsC)};; ; dsABC.Print();; }; ; TH1 *makeTH1(const char *name, double mean, double sigma); {; // Create ROOT TH1 filled with a Gaussian distribution; ; TH1D *hh = new TH1D(name, name, 100, -10, 10);; for (int i = 0; i < 1000; i++) {; hh->Fill(gRandom->Gaus(mean, sigma));; }; return hh;; }; ; TTree *makeTTree(); {; // Create ROOT TTree filled with a Gaussian distribution in x and a uniform distribution in y; ; TTree *tree = new TTree(""tree"", ""tree"");; double *px = new double;; double *py = new double;; double *pz = new double;; Int_t *pi = new Int_t;; tree->Branch(""x"", px, ""x/D"");; tree->Branch(""y"", py, ""y/D"");; tree->Branch(""z"", pz, ""z/D"");;",MatchSource.WIKI,doc/master/rf401__importttreethx_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html
Performance,load,loadValues,"igm...Definition TRandom.cxx:275; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; RooFit::IndexRooCmdArg Index(RooCategory &icat)Definition RooGlobalFunc.cxx:386; RooFit::ImportRooCmdArg Import(const char *state, TH1 &histo)Definition RooGlobalFunc.cxx:390; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf401_importttreethxDefinition rf401_importttreethx.py:1; ; RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValu",MatchSource.WIKI,doc/master/rf401__importttreethx_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html
Energy Efficiency,reduce,reduce,"y,z) but only event for which (y+z<0) is ROOT.True; # Import observables (x,y,z) but only event for which (y+z<0) is ROOT.True; ds2 = ROOT.RooDataSet(""ds2"", ""ds2"", {x, y, z}, Import=tree, Cut=""y+z<0""); ds2.Print(); ; # Importing integer ROOT TTree branches; # ---------------------------------------------------------------; ; # Import integer tree branch as ROOT.RooRealVar; i = ROOT.RooRealVar(""i"", ""i"", 0, 5); ds3 = ROOT.RooDataSet(""ds3"", ""ds3"", {i, x}, Import=tree); ds3.Print(); ; # Define category i; icat = ROOT.RooCategory(""i"", ""i"", {""State0"": 0, ""State1"": 1}); ; # Import integer tree branch as ROOT.RooCategory (only events with i==0 and i==1; # will be imported as those are the only defined states); ds4 = ROOT.RooDataSet(""ds4"", ""ds4"", {icat, x}, Import=tree); ds4.Print(); ; # Import multiple RooDataSets into a RooDataSet; # ----------------------------------------------------------------------------------------; ; # Create three ROOT.RooDataSets in (y,z); dsA = ds2.reduce({x, y}, ""z<-5""); dsB = ds2.reduce({x, y}, ""abs(z)<5""); dsC = ds2.reduce({x, y}, ""z>5""); ; # Create a dataset that imports contents of all the above datasets mapped; # by index category c; dsABC = ROOT.RooDataSet(""dsABC"", ""dsABC"", {x, y}, Index=c, Import={""SampleA"": dsA, ""SampleB"": dsB, ""SampleC"": dsC}); ; dsABC.Print(); RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:Dat",MatchSource.WIKI,doc/master/rf401__importttreethx_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html
Performance,load,loadValues,"3 = ROOT.RooDataSet(""ds3"", ""ds3"", {i, x}, Import=tree); ds3.Print(); ; # Define category i; icat = ROOT.RooCategory(""i"", ""i"", {""State0"": 0, ""State1"": 1}); ; # Import integer tree branch as ROOT.RooCategory (only events with i==0 and i==1; # will be imported as those are the only defined states); ds4 = ROOT.RooDataSet(""ds4"", ""ds4"", {icat, x}, Import=tree); ds4.Print(); ; # Import multiple RooDataSets into a RooDataSet; # ----------------------------------------------------------------------------------------; ; # Create three ROOT.RooDataSets in (y,z); dsA = ds2.reduce({x, y}, ""z<-5""); dsB = ds2.reduce({x, y}, ""abs(z)<5""); dsC = ds2.reduce({x, y}, ""z>5""); ; # Create a dataset that imports contents of all the above datasets mapped; # by index category c; dsABC = ROOT.RooDataSet(""dsABC"", ""dsABC"", {x, y}, Index=c, Import={""SampleA"": dsA, ""SampleB"": dsB, ""SampleC"": dsC}); ; dsABC.Print(); RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because z cannot accommodate the value 10; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(d",MatchSource.WIKI,doc/master/rf401__importttreethx_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html
Deployability,update,updateFitRangeNorm," ""c""; ; >> merge d2(y) with d1(x,c) to form d1(x,c,y); DataStore d (d); Contains 1000 entries; Observables: ; 1) x = 9 L(-10 - 10) ""x""; 2) c = Plus(idx = 1); ""c""; 3) y = 31.607 L(0 - 40) ""y""; ; >> append data points of d3 to d1; DataStore d (d); Contains 1973 entries; Observables: ; 1) x = 9 L(-10 - 10) ""x""; 2) c = Plus(idx = 1); ""c""; 3) y = 31.607 L(0 - 40) ""y""; >> construct dh (binned) from d(unbinned) but only take the x and y dimensions,; >> the category 'c' will be projected in the filling process; DataStore dh (binned version of d); Contains 100 entries; Observables: ; 1) x = 9 L(-10 - 10) B(10) ""x""; 2) y = 38 L(0 - 40) B(10) ""y""; Binned Dataset dh (binned version of d); Contains 100 bins with a total weight of 1000; Observables: 1) x = 9 L(-10 - 10) B(10) ""x""; 2) y = 38 L(0 - 40) B(10) ""y""; >> number of bins in dh : 100; >> sum of weights in dh : 1000; >> integral over histogram: 8000; >> retrieving the properties of the bin enclosing coordinate (x,y) = (0.3,20.5) ; bin center:; 1) 0x55b3355824b0 RooRealVar:: x = 1 L(-10 - 10) B(10) ""x""; 2) 0x55b3355ea380 RooRealVar:: y = 22 L(0 - 40) B(10) ""y""; weight = 76; >> Creating 1-dimensional projection on y of dh for bins with x>0; DataStore dh (binned version of d); Contains 10 entries; Observables: ; 1) y = 38 L(0 - 40) B(10) ""y""; Binned Dataset dh (binned version of d); Contains 10 bins with a total weight of 500; Observables: 1) y = 38 L(0 - 40) B(10) ""y""; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 500 will supersede previous event count of 1000 for normalization of PDF projections; ; >> Persisting d via ROOT I/O; TFile** rf402_datahandling.root ; TFile* rf402_datahandling.root ; KEY: RooDataSet d;1 d; KEY: TProcessID ProcessID0;1 8088a3fa-9b53-11ef-80e8-942c8a89beef; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf402_datahandling.C. tutorialsroofitrf402_datahandling.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf402__datahandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html
Energy Efficiency,reduce,reduce," Instead they are attached to an internal; // clone of the supplied set of arguments; ; // Fill d with dummy values; Int_t i;; for (i = 0; i < 1000; i++) {; x = i / 50 - 10;; y = sqrt(1.0 * i);; c.setLabel((i % 2) ? ""Plus"" : ""Minus"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout << endl;; ; // Get with an argument loads a specific data point in row and returns; // a pointer to row argset. get() always returns the same pointer, unless; // an invalid row number is specified. In that case a null ptr is returned; d.get(900)->Print(""v"");; cout << endl;; ; // R e d u c i n g , A p p e n d i n g a n d M e r g i n g; // -------------------------------------------------------------; ; // The reduce() function returns a new dataset which is a subset of the original; cout << endl << "">> d1 has only columns x,c"" << endl;; std::unique_ptr<RooAbsData> d1{d.reduce({x, c})};; d1->Print(""v"");; ; cout << endl << "">> d2 has only column y"" << endl;; std::unique_ptr<RooAbsData> d2{d.reduce({y})};; d2->Print(""v"");; ; cout << endl << "">> d3 has only the points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d3{d.reduce(""y>5.17"")};; d3->Print(""v"");; ; cout << endl << "">> d4 has only columns x,c for data points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d4{d.reduce({x, c}, ""y>5.17"")};; d4->Print(""v"");; ; // The merge() function adds two data set column-wise; cout << endl << "">> merge d2(y) with d1(x,c) to form d1(x,c,y)"" << endl;; static_cast<RooDataSet&>(*d1).merge(&static_cast<RooDataSet&>(*d2));; d1->Print(""v"");; ; // The append() function adds two datasets row-wise; cout << endl << "">> append data points of d3 to d1"" << endl;; static_cast<RooDataSet&>(*d1).append(stat",MatchSource.WIKI,doc/master/rf402__datahandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html
Integrability,interface,interface,". ROOT: tutorials/roofit/rf402_datahandling.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf402_datahandling.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TFile.h""; using namespace RooFit;; ; // WVE Add reduction by range; ; void rf402_datahandling(); {; ; // Binned (RooDataHist) and unbinned datasets (RooDataSet) share; // many properties and inherit from a common abstract base class; // (RooAbsData), that provides an interface for all operations; // that can be performed regardless of the data format; ; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", 0, 40);; RooCategory c(""c"", ""c"");; c.defineType(""Plus"", +1);; c.defineType(""Minus"", -1);; ; // B a s i c O p e r a t i o n s o n u n b i n n e d d a t a s e t s; // --------------------------------------------------------------; ; // RooDataSet is an unbinned dataset (a collection of points in N-dimensional space); RooDataSet d(""d"", ""d"", RooArgSet(x, y, c));; ; // Unlike RooAbsArgs (RooAbsPdf,RooFormulaVar,....) datasets are not attached to; // the variables they are constructed from. Instead they are attached to an internal; // clone of the supplied set of arguments; ; // Fill d with dummy values; Int_t i;; for (i = 0; i < 1000; i++) {; x = i / 50 - 10;; y = sqrt(1.0 * i);; c.setLabel((i % 2) ? ""Plus"" : ""Minus"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout <<",MatchSource.WIKI,doc/master/rf402__datahandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html
Modifiability,inherit,inherit,". ROOT: tutorials/roofit/rf402_datahandling.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf402_datahandling.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TFile.h""; using namespace RooFit;; ; // WVE Add reduction by range; ; void rf402_datahandling(); {; ; // Binned (RooDataHist) and unbinned datasets (RooDataSet) share; // many properties and inherit from a common abstract base class; // (RooAbsData), that provides an interface for all operations; // that can be performed regardless of the data format; ; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", 0, 40);; RooCategory c(""c"", ""c"");; c.defineType(""Plus"", +1);; c.defineType(""Minus"", -1);; ; // B a s i c O p e r a t i o n s o n u n b i n n e d d a t a s e t s; // --------------------------------------------------------------; ; // RooDataSet is an unbinned dataset (a collection of points in N-dimensional space); RooDataSet d(""d"", ""d"", RooArgSet(x, y, c));; ; // Unlike RooAbsArgs (RooAbsPdf,RooFormulaVar,....) datasets are not attached to; // the variables they are constructed from. Instead they are attached to an internal; // clone of the supplied set of arguments; ; // Fill d with dummy values; Int_t i;; for (i = 0; i < 1000; i++) {; x = i / 50 - 10;; y = sqrt(1.0 * i);; c.setLabel((i % 2) ? ""Plus"" : ""Minus"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout <<",MatchSource.WIKI,doc/master/rf402__datahandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html
Performance,perform,performed,". ROOT: tutorials/roofit/rf402_datahandling.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf402_datahandling.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TFile.h""; using namespace RooFit;; ; // WVE Add reduction by range; ; void rf402_datahandling(); {; ; // Binned (RooDataHist) and unbinned datasets (RooDataSet) share; // many properties and inherit from a common abstract base class; // (RooAbsData), that provides an interface for all operations; // that can be performed regardless of the data format; ; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", 0, 40);; RooCategory c(""c"", ""c"");; c.defineType(""Plus"", +1);; c.defineType(""Minus"", -1);; ; // B a s i c O p e r a t i o n s o n u n b i n n e d d a t a s e t s; // --------------------------------------------------------------; ; // RooDataSet is an unbinned dataset (a collection of points in N-dimensional space); RooDataSet d(""d"", ""d"", RooArgSet(x, y, c));; ; // Unlike RooAbsArgs (RooAbsPdf,RooFormulaVar,....) datasets are not attached to; // the variables they are constructed from. Instead they are attached to an internal; // clone of the supplied set of arguments; ; // Fill d with dummy values; Int_t i;; for (i = 0; i < 1000; i++) {; x = i / 50 - 10;; y = sqrt(1.0 * i);; c.setLabel((i % 2) ? ""Plus"" : ""Minus"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout <<",MatchSource.WIKI,doc/master/rf402__datahandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html
Security,access,access,"olor(kRed));; ; // S a v i n g a n d l o a d i n g f r o m f i l e; // -------------------------------------------------------; ; // Datasets can be persisted with ROOT I/O; cout << endl << "">> Persisting d via ROOT I/O"" << endl;; TFile f(""rf402_datahandling.root"", ""RECREATE"");; d.Write();; f.ls();; ; // To read back in future session:; // > TFile f(""rf402_datahandling.root"") ;; // > RooDataSet* d = (RooDataSet*) f.FindObject(""d"") ;; ; new TCanvas(""rf402_datahandling"", ""rf402_datahandling"", 600, 600);; gPad->SetLeftMargin(0.15);; yframe->GetYaxis()->SetTitleOffset(1.4);; yframe->Draw();; }; d#define d(i)Definition RSha256.hxx:102; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RooCategory.h; RooDataHist.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; Int_tint Int_tDefinition RtypesCore.h:45; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TFile.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooAbsCollection::Printvoid Print(Option_t *options=nullptr) const overrideThis method must be overridden when a class wants to print itself.Definition RooAbsCollection.h:315; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::mergebool merge(RooDataSet *data1, RooDataSet *data2=nullptr, RooDataSet *data3=nullptr, RooDataSet *data4=nullptr, RooDataSet *data5=nullptr, RooDataSet *data6=nullptr)Definition RooDataSet.cxx:1079; RooDataSet::appendvoid append(RooDataSet &data)Add all data points of given data set to this data set.Definition RooDataSet.cxx:1138; RooPlotPlot frame and a container for gr",MatchSource.WIKI,doc/master/rf402__datahandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html
Deployability,update,updateFitRangeNorm," Contains 1000 entries; Observables: ; 1) y = 31.607 L(0 - 40) ""y""; DataStore d (d); Contains 973 entries; Observables: ; 1) x = 9.98 L(-10 - 10) ""x""; 2) y = 31.607 L(0 - 40) ""y""; 3) c = Plus(idx = 1); ""c""; DataStore d (d); Contains 973 entries; Observables: ; 1) x = 9.98 L(-10 - 10) ""x""; 2) c = Plus(idx = 1); ""c""; DataStore d (d); Contains 1000 entries; Observables: ; 1) x = 9.98 L(-10 - 10) ""x""; 2) c = Plus(idx = 1); ""c""; 3) y = 31.607 L(0 - 40) ""y""; DataStore d (d); Contains 1973 entries; Observables: ; 1) x = 9.98 L(-10 - 10) ""x""; 2) c = Plus(idx = 1); ""c""; 3) y = 31.607 L(0 - 40) ""y""; DataStore dh (binned version of d); Contains 100 entries; Observables: ; 1) x = 9 L(-10 - 10) B(10) ""x""; 2) y = 38 L(0 - 40) B(10) ""y""; Binned Dataset dh (binned version of d); Contains 100 bins with a total weight of 1000; Observables: 1) x = 9 L(-10 - 10) B(10) ""x""; 2) y = 38 L(0 - 40) B(10) ""y""; 1) 0x8cc6a00 RooRealVar:: x = 1 L(-10 - 10) B(10) ""x""; 2) 0x8bb47d0 RooRealVar:: y = 22 L(0 - 40) B(10) ""y""; DataStore dh (binned version of d); Contains 10 entries; Observables: ; 1) y = 38 L(0 - 40) B(10) ""y""; Binned Dataset dh (binned version of d); Contains 10 bins with a total weight of 500; Observables: 1) y = 38 L(0 - 40) B(10) ""y""; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 500 will supersede previous event count of 1000 for normalization of PDF projections; TFile** rf402_datahandling.root ; TFile* rf402_datahandling.root ; KEY: RooDataSet d;1 d; KEY: TProcessID ProcessID0;1 8387ccd4-9b53-11ef-895e-942c8a89beef; RooRealVar::x = -10 L(-10 - 10) ; RooRealVar::y = 0 L(0 - 40) ; { {""Minus"" , -1}, {""Plus"" , 1} }; <class cppyy.gbl.RooRealVar at 0x8228040>; RooRealVar::x = -9.98 L(-10 - 10) ; RooRealVar::y = 1 L(0 - 40) ; { {""Minus"" , -1}, {""Plus"" , 1} }; <class cppyy.gbl.RooRealVar at 0x8228040>; RooRealVar::x = -9.96 L(-10 - 10) ; RooRealVar::y = 1.41421 L(0 - 40) ; { {""Minus"" , -1}, {""Plus"" , 1} }; <class cppyy.gbl.RooRealVar at 0x8228040>; ; ; ; ; >> d1 h",MatchSource.WIKI,doc/master/rf402__datahandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html
Energy Efficiency,reduce,reduce,"ey are constructed from. Instead they are attached to an internal; # clone of the supplied set of arguments; ; # Fill d with dummy values; for i in range(1000):; x.setVal(i / 50 - 10); y.setVal(math.sqrt(1.0 * i)); if i % 2:; c.setLabel(""Plus""); else:; c.setLabel(""Minus""); ; # We must explicitly refer to x,y, here to pass the values because; # d is not linked to them (as explained above); if i < 3:; print(x, y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is specified. In that case a null ptr is returned; d.get(900).Print(""v""); print(""""); ; # Reducing, appending and merging; # -------------------------------------------------------------; ; # The reduce() function returns a dataset which is a subset of the; # original; print(""\n >> d1 has only columns x,c""); d1 = d.reduce({x, c}); d1.Print(""v""); ; print(""\n >> d2 has only column y""); d2 = d.reduce({y}); d2.Print(""v""); ; print(""\n >> d3 has only the points with y>5.17""); d3 = d.reduce(""y>5.17""); d3.Print(""v""); ; print(""\n >> d4 has only columns x, for data points with y>5.17""); d4 = d.reduce({x, c}, ""y>5.17""); d4.Print(""v""); ; # The merge() function adds two data set column-wise; print(""\n >> merge d2(y) with d1(x,c) to form d1(x,c,y)""); d1.merge(d2); d1.Print(""v""); ; # The append() function adds two datasets row-wise; print(""\n >> append data points of d3 to d1""); d1.append(d3); d1.Print(""v""); ; # Operations on binned datasets; # ---------------------------------------------------------; ; # A binned dataset can be constructed empty, an unbinned dataset, or; # from a ROOT native histogram (TH1,2,3); ; print("">> construct dh (binned) from d(unbinned) but only take the x an",MatchSource.WIKI,doc/master/rf402__datahandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html
Integrability,interface,interface,". ROOT: tutorials/roofit/rf402_datahandling.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf402_datahandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; from __future__ import print_function; import ROOT; import math; ; # WVE Add reduction by range; ; # Binned (RooDataHist) and unbinned datasets (RooDataSet) share; # many properties and inherit from a common abstract base class; # (RooAbsData), provides an interface for all operations; # that can be performed regardless of the data format; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 40); c = ROOT.RooCategory(""c"", ""c""); c.defineType(""Plus"", +1); c.defineType(""Minus"", -1); ; # Basic operations on unbinned datasetss; # --------------------------------------------------------------; ; # ROOT.RooDataSet is an unbinned dataset (a collection of points in; # N-dimensional space); d = ROOT.RooDataSet(""d"", ""d"", {x, y, c}); ; # Unlike ROOT.RooAbsArgs (ROOT.RooAbsPdf, ROOT.RooFormulaVar,....) datasets are not attached to; # the variables they are constructed from. Instead they are attached to an internal; # clone of the supplied set of arguments; ; # Fill d with dummy values; for i in range(1000):; x.setVal(i / 50 - 10); y.setVal(math.sqrt(1.0 * i)); if i % 2:; c.setLabel(""Plus""); else:; c.setLabel(""Minus""); ; # We must explicitly refer to x,y, here to pass the values because; # d is not linked to them (as explained above); if i < 3:; print(x, y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is ",MatchSource.WIKI,doc/master/rf402__datahandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html
Modifiability,inherit,inherit,". ROOT: tutorials/roofit/rf402_datahandling.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf402_datahandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; from __future__ import print_function; import ROOT; import math; ; # WVE Add reduction by range; ; # Binned (RooDataHist) and unbinned datasets (RooDataSet) share; # many properties and inherit from a common abstract base class; # (RooAbsData), provides an interface for all operations; # that can be performed regardless of the data format; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 40); c = ROOT.RooCategory(""c"", ""c""); c.defineType(""Plus"", +1); c.defineType(""Minus"", -1); ; # Basic operations on unbinned datasetss; # --------------------------------------------------------------; ; # ROOT.RooDataSet is an unbinned dataset (a collection of points in; # N-dimensional space); d = ROOT.RooDataSet(""d"", ""d"", {x, y, c}); ; # Unlike ROOT.RooAbsArgs (ROOT.RooAbsPdf, ROOT.RooFormulaVar,....) datasets are not attached to; # the variables they are constructed from. Instead they are attached to an internal; # clone of the supplied set of arguments; ; # Fill d with dummy values; for i in range(1000):; x.setVal(i / 50 - 10); y.setVal(math.sqrt(1.0 * i)); if i % 2:; c.setLabel(""Plus""); else:; c.setLabel(""Minus""); ; # We must explicitly refer to x,y, here to pass the values because; # d is not linked to them (as explained above); if i < 3:; print(x, y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is ",MatchSource.WIKI,doc/master/rf402__datahandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html
Performance,perform,performed,". ROOT: tutorials/roofit/rf402_datahandling.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf402_datahandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; from __future__ import print_function; import ROOT; import math; ; # WVE Add reduction by range; ; # Binned (RooDataHist) and unbinned datasets (RooDataSet) share; # many properties and inherit from a common abstract base class; # (RooAbsData), provides an interface for all operations; # that can be performed regardless of the data format; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 40); c = ROOT.RooCategory(""c"", ""c""); c.defineType(""Plus"", +1); c.defineType(""Minus"", -1); ; # Basic operations on unbinned datasetss; # --------------------------------------------------------------; ; # ROOT.RooDataSet is an unbinned dataset (a collection of points in; # N-dimensional space); d = ROOT.RooDataSet(""d"", ""d"", {x, y, c}); ; # Unlike ROOT.RooAbsArgs (ROOT.RooAbsPdf, ROOT.RooFormulaVar,....) datasets are not attached to; # the variables they are constructed from. Instead they are attached to an internal; # clone of the supplied set of arguments; ; # Fill d with dummy values; for i in range(1000):; x.setVal(i / 50 - 10); y.setVal(math.sqrt(1.0 * i)); if i % 2:; c.setLabel(""Plus""); else:; c.setLabel(""Minus""); ; # We must explicitly refer to x,y, here to pass the values because; # d is not linked to them (as explained above); if i < 3:; print(x, y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is ",MatchSource.WIKI,doc/master/rf402__datahandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html
Availability,error,error,"---------------------------------------------------------------------; ; // Construct formula to calculate (fake) weight for events; RooFormulaVar wFunc(""w"", ""event weight"", ""(x*x+10)"", x);; ; // Add column with variable w to previously generated dataset; RooRealVar *w = (RooRealVar *)data->addColumn(wFunc);; ; // Dataset d is now a dataset with two observable (x,w) with 1000 entries; data->Print();; ; // Instruct dataset wdata in interpret w as event weight rather than as observable; RooDataSet wdata(data->GetName(), data->GetTitle(), data.get(), *data->get(), 0, w->GetName());; ; // Dataset d is now a dataset with one observable (x) with 1000 entries and a sum of weights of ~430K; wdata.Print();; ; // U n b i n n e d M L f i t t o w e i g h t e d d a t a; // ---------------------------------------------------------------; ; // Construction quadratic polynomial pdf for fitting; RooRealVar a0(""a0"", ""a0"", 1);; RooRealVar a1(""a1"", ""a1"", 0, -1, 1);; RooRealVar a2(""a2"", ""a2"", 1, 0, 10);; RooPolynomial p2(""p2"", ""p2"", x, RooArgList(a0, a1, a2), 0);; ; // Fit quadratic polynomial to weighted data; ; // NOTE: A plain Maximum likelihood fit to weighted data does in general; // NOT result in correct error estimates, unless individual; // event weights represent Poisson statistics themselves.; //; // Fit with 'wrong' errors; std::unique_ptr<RooFitResult> r_ml_wgt{p2.fitTo(wdata, Save(), PrintLevel(-1))};; ; // A first order correction to estimated parameter errors in an; // (unbinned) ML fit can be obtained by calculating the; // covariance matrix as; //; // V' = V C-1 V; //; // where V is the covariance matrix calculated from a fit; // to -logL = - sum [ w_i log f(x_i) ] and C is the covariance; // matrix calculated from -logL' = -sum [ w_i^2 log f(x_i) ]; // (i.e. the weights are applied squared); //; // A fit in this mode can be performed as follows:; ; std::unique_ptr<RooFitResult> r_ml_wgt_corr{p2.fitTo(wdata, Save(), SumW2Error(true), PrintLevel(-1))};; ; // P l o t w e ",MatchSource.WIKI,doc/master/rf403__weightedevts_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html
Deployability,integrat,integrator,"[#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_genPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficien",MatchSource.WIKI,doc/master/rf403__weightedevts_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html
Integrability,interface,interface,"xis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsData::SumW2@ SumW2Definition RooAbsData.h:108; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGenericPdfImplementation of a probability density function that takes a RooArgList of servers and a C++ express...Definition RooGenericPdf.h:25; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") ",MatchSource.WIKI,doc/master/rf403__weightedevts_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html
Modifiability,variab,variable,"taHist.h""; #include ""RooGaussian.h""; #include ""RooFormulaVar.h""; #include ""RooGenericPdf.h""; #include ""RooPolynomial.h""; #include ""RooMinimizer.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFitResult.h""; using namespace RooFit;; ; void rf403_weightedevts(); {; // C r e a t e o b s e r v a b l e a n d u n w e i g h t e d d a t a s e t; // -------------------------------------------------------------------------------; ; // Declare observable; RooRealVar x(""x"", ""x"", -10, 10);; x.setBins(40);; ; // Construction a uniform pdf; RooPolynomial p0(""px"", ""px"", x);; ; // Sample 1000 events from pdf; std::unique_ptr<RooDataSet> data{p0.generate(x, 1000)};; ; // C a l c u l a t e w e i g h t a n d m a k e d a t a s e t w e i g h t e d; // -----------------------------------------------------------------------------------; ; // Construct formula to calculate (fake) weight for events; RooFormulaVar wFunc(""w"", ""event weight"", ""(x*x+10)"", x);; ; // Add column with variable w to previously generated dataset; RooRealVar *w = (RooRealVar *)data->addColumn(wFunc);; ; // Dataset d is now a dataset with two observable (x,w) with 1000 entries; data->Print();; ; // Instruct dataset wdata in interpret w as event weight rather than as observable; RooDataSet wdata(data->GetName(), data->GetTitle(), data.get(), *data->get(), 0, w->GetName());; ; // Dataset d is now a dataset with one observable (x) with 1000 entries and a sum of weights of ~430K; wdata.Print();; ; // U n b i n n e d M L f i t t o w e i g h t e d d a t a; // ---------------------------------------------------------------; ; // Construction quadratic polynomial pdf for fitting; RooRealVar a0(""a0"", ""a0"", 1);; RooRealVar a1(""a1"", ""a1"", 0, -1, 1);; RooRealVar a2(""a2"", ""a2"", 1, 0, 10);; RooPolynomial p2(""p2"", ""p2"", x, RooArgList(a0, a1, a2), 0);; ; // Fit quadratic polynomial to weighted data; ; // NOTE: A plain Maximum likelihood fit to weighted data does in general; // NOT result in correct error ",MatchSource.WIKI,doc/master/rf403__weightedevts_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html
Performance,perform,performed,"uadratic polynomial pdf for fitting; RooRealVar a0(""a0"", ""a0"", 1);; RooRealVar a1(""a1"", ""a1"", 0, -1, 1);; RooRealVar a2(""a2"", ""a2"", 1, 0, 10);; RooPolynomial p2(""p2"", ""p2"", x, RooArgList(a0, a1, a2), 0);; ; // Fit quadratic polynomial to weighted data; ; // NOTE: A plain Maximum likelihood fit to weighted data does in general; // NOT result in correct error estimates, unless individual; // event weights represent Poisson statistics themselves.; //; // Fit with 'wrong' errors; std::unique_ptr<RooFitResult> r_ml_wgt{p2.fitTo(wdata, Save(), PrintLevel(-1))};; ; // A first order correction to estimated parameter errors in an; // (unbinned) ML fit can be obtained by calculating the; // covariance matrix as; //; // V' = V C-1 V; //; // where V is the covariance matrix calculated from a fit; // to -logL = - sum [ w_i log f(x_i) ] and C is the covariance; // matrix calculated from -logL' = -sum [ w_i^2 log f(x_i) ]; // (i.e. the weights are applied squared); //; // A fit in this mode can be performed as follows:; ; std::unique_ptr<RooFitResult> r_ml_wgt_corr{p2.fitTo(wdata, Save(), SumW2Error(true), PrintLevel(-1))};; ; // P l o t w e i g h e d d a t a a n d f i t r e s u l t; // ---------------------------------------------------------------; ; // Construct plot frame; RooPlot *frame = x.frame(Title(""Unbinned ML fit, binned chi^2 fit to weighted data""));; ; // Plot data using sum-of-weights-squared error rather than Poisson errors; wdata.plotOn(frame, DataError(RooAbsData::SumW2));; ; // Overlay result of 2nd order polynomial fit to weighted data; p2.plotOn(frame);; ; // ML Fit of pdf to equivalent unweighted dataset; // -----------------------------------------------------------------------------------------; ; // Construct a pdf with the same shape as p0 after weighting; RooGenericPdf genPdf(""genPdf"", ""x*x+10"", x);; ; // Sample a dataset with the same number of events as data; std::unique_ptr<RooDataSet> data2{genPdf.generate(x, 1000)};; ; // Sample a dataset with the sa",MatchSource.WIKI,doc/master/rf403__weightedevts_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html
Testability,log,logL,"e());; ; // Dataset d is now a dataset with one observable (x) with 1000 entries and a sum of weights of ~430K; wdata.Print();; ; // U n b i n n e d M L f i t t o w e i g h t e d d a t a; // ---------------------------------------------------------------; ; // Construction quadratic polynomial pdf for fitting; RooRealVar a0(""a0"", ""a0"", 1);; RooRealVar a1(""a1"", ""a1"", 0, -1, 1);; RooRealVar a2(""a2"", ""a2"", 1, 0, 10);; RooPolynomial p2(""p2"", ""p2"", x, RooArgList(a0, a1, a2), 0);; ; // Fit quadratic polynomial to weighted data; ; // NOTE: A plain Maximum likelihood fit to weighted data does in general; // NOT result in correct error estimates, unless individual; // event weights represent Poisson statistics themselves.; //; // Fit with 'wrong' errors; std::unique_ptr<RooFitResult> r_ml_wgt{p2.fitTo(wdata, Save(), PrintLevel(-1))};; ; // A first order correction to estimated parameter errors in an; // (unbinned) ML fit can be obtained by calculating the; // covariance matrix as; //; // V' = V C-1 V; //; // where V is the covariance matrix calculated from a fit; // to -logL = - sum [ w_i log f(x_i) ] and C is the covariance; // matrix calculated from -logL' = -sum [ w_i^2 log f(x_i) ]; // (i.e. the weights are applied squared); //; // A fit in this mode can be performed as follows:; ; std::unique_ptr<RooFitResult> r_ml_wgt_corr{p2.fitTo(wdata, Save(), SumW2Error(true), PrintLevel(-1))};; ; // P l o t w e i g h e d d a t a a n d f i t r e s u l t; // ---------------------------------------------------------------; ; // Construct plot frame; RooPlot *frame = x.frame(Title(""Unbinned ML fit, binned chi^2 fit to weighted data""));; ; // Plot data using sum-of-weights-squared error rather than Poisson errors; wdata.plotOn(frame, DataError(RooAbsData::SumW2));; ; // Overlay result of 2nd order polynomial fit to weighted data; p2.plotOn(frame);; ; // ML Fit of pdf to equivalent unweighted dataset; // ------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/rf403__weightedevts_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html
Availability,error,error,"ght for events; wFunc = ROOT.RooFormulaVar(""w"", ""event weight"", ""(x*x+10)"", [x]); ; # Add column with variable w to previously generated dataset; w = data.addColumn(wFunc); ; # Dataset d is now a dataset with two observable (x,w) with 1000 entries; data.Print(); ; # Instruct dataset wdata in interpret w as event weight rather than as; # observable; wdata = ROOT.RooDataSet(data.GetName(), data.GetTitle(), data, data.get(), """", w.GetName()); ; # Dataset d is now a dataset with one observable (x) with 1000 entries and; # a sum of weights of ~430K; wdata.Print(); ; # Unbinned ML fit to weighted data; # ---------------------------------------------------------------; ; # Construction quadratic polynomial pdf for fitting; a0 = ROOT.RooRealVar(""a0"", ""a0"", 1); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0, -1, 1); a2 = ROOT.RooRealVar(""a2"", ""a2"", 1, 0, 10); p2 = ROOT.RooPolynomial(""p2"", ""p2"", x, [a0, a1, a2], 0); ; # Fit quadratic polynomial to weighted data; ; # NOTE: A plain Maximum likelihood fit to weighted data does in general; # NOT result in correct error estimates, individual; # event weights represent Poisson statistics themselves.; #; # Fit with 'wrong' errors; r_ml_wgt = p2.fitTo(wdata, Save=True, PrintLevel=-1); ; # A first order correction to estimated parameter errors in an; # (unbinned) ML fit can be obtained by calculating the; # covariance matrix as; #; # V' = V C-1 V; #; # where V is the covariance matrix calculated from a fit; # to -logL = - sum [ w_i log f(x_i) ] and C is the covariance; # matrix calculated from -logL' = -sum [ w_i^2 log f(x_i) ]; # (i.e. the weights are applied squared); #; # A fit in self mode can be performed as follows:; ; r_ml_wgt_corr = p2.fitTo(wdata, Save=True, SumW2Error=True, PrintLevel=-1); ; # Plot weighted data and fit result; # ---------------------------------------------------------------; ; # Construct plot frame; frame = x.frame(Title=""Unbinned ML fit, chi^2 fit to weighted data""); ; # Plot data using sum-of-weights-squared error ",MatchSource.WIKI,doc/master/rf403__weightedevts_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html
Deployability,integrat,integrator,"[#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_genPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficien",MatchSource.WIKI,doc/master/rf403__weightedevts_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html
Integrability,integrat,integrator,"[#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_genPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficien",MatchSource.WIKI,doc/master/rf403__weightedevts_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html
Modifiability,variab,variable,". ROOT: tutorials/roofit/rf403_weightedevts.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf403_weightedevts.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'DATA AND CATEGORIES' RooFit tutorial macro #403 ; Using weights in unbinned datasets. ; from __future__ import print_function; import ROOT; ; ; # Create observable and unweighted dataset; # -------------------------------------------; ; # Declare observable; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); x.setBins(40); ; # Construction a uniform pdf; p0 = ROOT.RooPolynomial(""px"", ""px"", x); ; # Sample 1000 events from pdf; data = p0.generate({x}, 1000); ; # Calculate weight and make dataset weighted; # --------------------------------------------------; ; # Construct formula to calculate (fake) weight for events; wFunc = ROOT.RooFormulaVar(""w"", ""event weight"", ""(x*x+10)"", [x]); ; # Add column with variable w to previously generated dataset; w = data.addColumn(wFunc); ; # Dataset d is now a dataset with two observable (x,w) with 1000 entries; data.Print(); ; # Instruct dataset wdata in interpret w as event weight rather than as; # observable; wdata = ROOT.RooDataSet(data.GetName(), data.GetTitle(), data, data.get(), """", w.GetName()); ; # Dataset d is now a dataset with one observable (x) with 1000 entries and; # a sum of weights of ~430K; wdata.Print(); ; # Unbinned ML fit to weighted data; # ---------------------------------------------------------------; ; # Construction quadratic polynomial pdf for fitting; a0 = ROOT.RooRealVar(""a0"", ""a0"", 1); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0, -1, 1); a2 = ROOT.RooRealVar(""a2"", ""a2"", 1, 0, 10); p2 = ROOT.RooPolynomial(""p2"", ""p2"", x, [a0, a1, a2], 0); ; # Fit quadratic polynomial to weighted data; ; # NOTE: A plain Maximum likelihood fit to weighted data does in general; # NOT result in correct error estimates, individual; # event weights represent Poisson statistics themselves.; #; # Fit with 'wr",MatchSource.WIKI,doc/master/rf403__weightedevts_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html
Performance,perform,performed,"--------------------------------; ; # Construction quadratic polynomial pdf for fitting; a0 = ROOT.RooRealVar(""a0"", ""a0"", 1); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0, -1, 1); a2 = ROOT.RooRealVar(""a2"", ""a2"", 1, 0, 10); p2 = ROOT.RooPolynomial(""p2"", ""p2"", x, [a0, a1, a2], 0); ; # Fit quadratic polynomial to weighted data; ; # NOTE: A plain Maximum likelihood fit to weighted data does in general; # NOT result in correct error estimates, individual; # event weights represent Poisson statistics themselves.; #; # Fit with 'wrong' errors; r_ml_wgt = p2.fitTo(wdata, Save=True, PrintLevel=-1); ; # A first order correction to estimated parameter errors in an; # (unbinned) ML fit can be obtained by calculating the; # covariance matrix as; #; # V' = V C-1 V; #; # where V is the covariance matrix calculated from a fit; # to -logL = - sum [ w_i log f(x_i) ] and C is the covariance; # matrix calculated from -logL' = -sum [ w_i^2 log f(x_i) ]; # (i.e. the weights are applied squared); #; # A fit in self mode can be performed as follows:; ; r_ml_wgt_corr = p2.fitTo(wdata, Save=True, SumW2Error=True, PrintLevel=-1); ; # Plot weighted data and fit result; # ---------------------------------------------------------------; ; # Construct plot frame; frame = x.frame(Title=""Unbinned ML fit, chi^2 fit to weighted data""); ; # Plot data using sum-of-weights-squared error rather than Poisson errors; wdata.plotOn(frame, DataError=""SumW2""); ; # Overlay result of 2nd order polynomial fit to weighted data; p2.plotOn(frame); ; # ML fit of pdf to equivalent unweighted dataset; # ---------------------------------------------------------------------; ; # Construct a pdf with the same shape as p0 after weighting; genPdf = ROOT.RooGenericPdf(""genPdf"", ""x*x+10"", [x]); ; # Sample a dataset with the same number of events as data; data2 = genPdf.generate({x}, 1000); ; # Sample a dataset with the same number of weights as data; data3 = genPdf.generate({x}, 43000); ; # Fit the 2nd order polynomial to both unweigh",MatchSource.WIKI,doc/master/rf403__weightedevts_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html
Testability,log,logL,"tName(), data.GetTitle(), data, data.get(), """", w.GetName()); ; # Dataset d is now a dataset with one observable (x) with 1000 entries and; # a sum of weights of ~430K; wdata.Print(); ; # Unbinned ML fit to weighted data; # ---------------------------------------------------------------; ; # Construction quadratic polynomial pdf for fitting; a0 = ROOT.RooRealVar(""a0"", ""a0"", 1); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0, -1, 1); a2 = ROOT.RooRealVar(""a2"", ""a2"", 1, 0, 10); p2 = ROOT.RooPolynomial(""p2"", ""p2"", x, [a0, a1, a2], 0); ; # Fit quadratic polynomial to weighted data; ; # NOTE: A plain Maximum likelihood fit to weighted data does in general; # NOT result in correct error estimates, individual; # event weights represent Poisson statistics themselves.; #; # Fit with 'wrong' errors; r_ml_wgt = p2.fitTo(wdata, Save=True, PrintLevel=-1); ; # A first order correction to estimated parameter errors in an; # (unbinned) ML fit can be obtained by calculating the; # covariance matrix as; #; # V' = V C-1 V; #; # where V is the covariance matrix calculated from a fit; # to -logL = - sum [ w_i log f(x_i) ] and C is the covariance; # matrix calculated from -logL' = -sum [ w_i^2 log f(x_i) ]; # (i.e. the weights are applied squared); #; # A fit in self mode can be performed as follows:; ; r_ml_wgt_corr = p2.fitTo(wdata, Save=True, SumW2Error=True, PrintLevel=-1); ; # Plot weighted data and fit result; # ---------------------------------------------------------------; ; # Construct plot frame; frame = x.frame(Title=""Unbinned ML fit, chi^2 fit to weighted data""); ; # Plot data using sum-of-weights-squared error rather than Poisson errors; wdata.plotOn(frame, DataError=""SumW2""); ; # Overlay result of 2nd order polynomial fit to weighted data; p2.plotOn(frame); ; # ML fit of pdf to equivalent unweighted dataset; # ---------------------------------------------------------------------; ; # Construct a pdf with the same shape as p0 after weighting; genPdf = ROOT.RooGenericPdf(""genPdf"", ""x*x+1",MatchSource.WIKI,doc/master/rf403__weightedevts_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html
Energy Efficiency,reduce,reduce,"lav) state combinations; Roo1DTable *bttable = data->table(RooArgSet(tagCat, b0flav));; bttable->Print(""v"");; ; // Retrieve number of events from table; // Number can be non-integer if source dataset has weighed events; double nb0 = btable->get(""B0"");; std::cout << ""Number of events with B0 flavor is "" << nb0 << std::endl;; ; // Retrieve fraction of events with ""Lepton"" tag; double fracLep = ttable->getFrac(""Lepton"");; std::cout << ""Fraction of events tagged with Lepton tag is "" << fracLep << std::endl;; ; // D e f i n i n g r a n g e s f o r p l o t t i n g , f i t t i n g o n c a t e g o r i e s; // ------------------------------------------------------------------------------------------------------; ; // Define named range as comma separated list of labels; tagCat.setRange(""good"", ""Lepton,Kaon"");; ; // Or add state names one by one; tagCat.addToRange(""soso"", ""NetTagger-1"");; tagCat.addToRange(""soso"", ""NetTagger-2"");; ; // Use category range in dataset reduction specification; std::unique_ptr<RooAbsData> goodData{data->reduce(CutRange(""good""))};; static_cast<RooDataSet&>(*goodData).table(tagCat)->Print(""v"");; }; Roo1DTable.h; RooCategory.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; Roo1DTableOne-dimensional table.Definition Roo1DTable.h:23; Roo1DTable::getdouble get(const char *label, bool silent=false) constReturn the table entry named 'label'.Definition Roo1DTable.cxx:245; Roo1DTable::getFracdouble getFrac(const char *label, bool silent=false) constReturn the fraction of entries in the table contained in the slot named 'label'.Definition Roo1DTable.cxx:302; Roo1DTable::Printvoid Print(Option_t *options=nullptr) const overrideThis method must be overridden when a class wants to print itself.Definition Roo1DTable.",MatchSource.WIKI,doc/master/rf404__categories_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf404__categories_8C.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf404_categories.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf404_categories.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: working with RooCategory objects to describe discrete variables ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolynomial.h""; #include ""RooCategory.h""; #include ""Roo1DTable.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include <iostream>; using namespace RooFit;; ; void rf404_categories(); {; ; // C o n s t r u c t a c a t e g o r y w i t h l a b e l s; // ----------------------------------------------------------------; ; // Define a category with labels only; RooCategory tagCat(""tagCat"", ""Tagging category"");; tagCat.defineType(""Lepton"");; tagCat.defineType(""Kaon"");; tagCat.defineType(""NetTagger-1"");; tagCat.defineType(""NetTagger-2"");; tagCat.Print();; ; // C o n s t r u c t a c a t e g o r y w i t h l a b e l s a n d i n d i c e s; // ----------------------------------------------------------------------------------------; ; // Define a category with explicitly numbered states; RooCategory b0flav(""b0flav"", ""B0 flavour eigenstate"");; b0flav[""B0""] = -1;; b0flav[""B0bar""] = 1;; // Print it in ""verbose"" mode to see all states.; b0flav.Print(""V"");; ; ; // Alternatively, define many states at once. The function takes; // a map with std::string --> index mapping.; RooCategory largeCat(""largeCat"", ""A category with many states"");; largeCat.defineTypes({; {""A"", 0}, {""b"", 2}, {""c"", 8}, {""dee"", 4},; {""F"", 133}, {""g"", 15}, {""H"", -20}; });; ; ; // I t e r a t e, q u e r y a n d s e t s t a t e s; // --------------------------------------------------------; ; // One can iterate through the {index,name} pair of category objects; std::cout << ""\nThis is the for loop over states of 'largeCat':"";; for (const auto& idxAndName : largeCat); std::cout << ""\n\t"" << idxAndName.fir",MatchSource.WIKI,doc/master/rf404__categories_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf404__categories_8C.html
Energy Efficiency,reduce,reduce,"le = data.table(tagCat, ""x>8.23""); ttable.Print(); ttable.Print(""v""); ; # Create table for all (tagCat x b0flav) state combinations; bttable = data.table({tagCat, b0flav}); bttable.Print(""v""); ; # Retrieve number of events from table; # Number can be non-integer if source dataset has weighed events; nb0 = btable.get(""B0""); print(""Number of events with B0 flavor is "", nb0); ; # Retrieve fraction of events with ""Lepton"" tag; fracLep = ttable.getFrac(""Lepton""); print(""Fraction of events tagged with Lepton tag is "", fracLep); ; # Defining ranges for plotting, fitting on categories; # ------------------------------------------------------------------------------------------------------; ; # Define named range as comma separated list of labels; tagCat.setRange(""good"", ""Lepton,Kaon""); ; # Or add state names one by one; tagCat.addToRange(""soso"", ""NetTagger-1""); tagCat.addToRange(""soso"", ""NetTagger-2""); ; # Use category range in dataset reduction specification; goodData = data.reduce(CutRange=""good""); goodData.table(tagCat).Print(""v""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; RooCategory::tagCat = Lepton(idx = 0); ; RooCategory::b0flav = B0(idx = -1); ; Roo1DTable::b0flav = (B0=5040,B0bar=4960); ; Table b0flav : pData; +-------+------+; | B0 | 5040 |; | B0bar | 4960 |; +-------+------+; ; Roo1DTable::tagCat = (Lepton=487,Kaon=433,NetTagger-1=439,NetTagger-2=406); ; Table tagCat : pData(x>8.23); +-------------+-----+; | Lepton | 487 |; | Kaon | 433 |; | NetTagger-1 | 439 |; | NetTagger-2 | 406 |; +-------------+-----+; ; ; Table (tagCat x b0flav) : pData; +---------------------+------+; | {Lepton;B0} | 1281 |; | {Kaon;B0} | 1253 |; | {NetTagger-1;B0} | 1234 |; | {NetTagger-2;B0} | 1272 |; | {Lepton;B0bar} | 1269 |; | {Kaon;B0bar} | 1255 |; | {NetTagger-1;B0bar} | 1219 |; | {NetTagger-2;B0bar} | 1217 |; +---------------------+------+; ; ; Table tagCat : pData; +-------------+------+; | Lepton | 2550 |; | Kaon | 2508 |; | NetTa",MatchSource.WIKI,doc/master/rf404__categories_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf404__categories_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf404_categories.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf404_categories.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: working with ROOT.RooCategory objects to describe discrete variables ; ; from __future__ import print_function; import ROOT; ; ; # Construct a category with labels; # --------------------------------------------; ; # Define a category with labels only; tagCat = ROOT.RooCategory(""tagCat"", ""Tagging category""); tagCat.defineType(""Lepton""); tagCat.defineType(""Kaon""); tagCat.defineType(""NetTagger-1""); tagCat.defineType(""NetTagger-2""); tagCat.Print(); ; # Construct a category with labels and indices; # ------------------------------------------------; ; # Define a category with explicitly numbered states; b0flav = ROOT.RooCategory(""b0flav"", ""B0 flavour eigenstate"", {""B0"": -1, ""B0bar"": 1}); b0flav.Print(); ; # Generate dummy data for tabulation demo; # ------------------------------------------------; ; # Generate a dummy dataset; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); data = ROOT.RooPolynomial(""p"", ""p"", x).generate({x, b0flav, tagCat}, 10000); ; # Print tables of category contents of datasets; # --------------------------------------------------; ; # Tables are equivalent of plots for categories; btable = data.table(b0flav); btable.Print(); btable.Print(""v""); ; # Create table for subset of events matching cut expression; ttable = data.table(tagCat, ""x>8.23""); ttable.Print(); ttable.Print(""v""); ; # Create table for all (tagCat x b0flav) state combinations; bttable = data.table({tagCat, b0flav}); bttable.Print(""v""); ; # Retrieve number of events from table; # Number can be non-integer if source dataset has weighed events; nb0 = btable.get(""B0""); print(""Number of events with B0 flavor is "", nb0); ; # Retrieve fraction of events with ""Lepton"" tag; fracLep = ttable.getFrac(""Lepton""); print(""Fraction of events tagged with ",MatchSource.WIKI,doc/master/rf404__categories_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf404__categories_8py.html
Deployability,update,updateFitRangeNorm,"me(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooThresholdCategoryA real-to-category mapping defined by a series of thresholds.Definition RooThresholdCategory.h:24; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf405_realtocatfuncsDefinition rf405_realtocatfuncs.py:1; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 2748 events out of 10000 total events; ; Table xBins : aData; +---------------+------+; | x_coarse_bin0 | 105 |; | x_coarse_bin1 | 329 |; | x_coarse_bin2 | 499 |; | x_coarse_bin3 | 739 |; | x_coarse_bin4 | 934 |; | x_coarse_bin5 | 1218 |; | x_coarse_bin6 | 1450 |; | x_coarse_bin7 | 1675 |; | x_coarse_bin8 | 1767 |; | x_coarse_bin9 | 1284 |; +---------------+------+; ; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 2627 will supersede previous event count of 10000 for normalization of PDF projections; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf405_realtocatfuncs.C. tutorialsroofitrf405_realtocatfuncs.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf405__realtocatfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8C.html
Energy Efficiency,reduce,reduce,"inition; // in a real-valued input observable observables to state names. The state names are automatically; // constructed from the variable name, the binning name and the bin number. If no binning name; // is specified the default binning is mapped; ; x.setBins(10, ""coarse"");; RooBinningCategory xBins(""xBins"", ""coarse bins in x"", x, ""coarse"");; ; // U s e b i n n i n g f u n c t i o n f o r t a b u l a t i o n a n d p l o t t i n g; // -----------------------------------------------------------------------------------------------; ; // Print table of xBins state multiplicity. Note that xBins does not need to be an observable in data; // it can be a function of observables in data as well; Roo1DTable *xbtable = data->table(xBins);; xbtable->Print(""v"");; ; // Add values of xBins function to dataset so that it can be used as observable; RooCategory *xb = (RooCategory *)data->addColumn(xBins);; ; // Define range ""alt"" as including bins 1,3,5,7,9; xb->setRange(""alt"", ""x_coarse_bin1,x_coarse_bin3,x_coarse_bin5,x_coarse_bin7,x_coarse_bin9"");; ; // Construct subset of data matching range ""alt"" but only for the first 5000 events and plot it on the frame; std::unique_ptr<RooAbsData> dataSel{data->reduce(CutRange(""alt""), EventRange(0, 5000))};; dataSel->plotOn(xframe, MarkerColor(kGreen), LineColor(kGreen));; ; new TCanvas(""rf405_realtocatfuncs"", ""rf405_realtocatfuncs"", 600, 600);; xframe->SetMinimum(0.01);; gPad->SetLeftMargin(0.15);; xframe->GetYaxis()->SetTitleOffset(1.4);; xframe->Draw();; }; a#define a(i)Definition RSha256.hxx:99; Roo1DTable.h; RooArgusBG.h; RooBinningCategory.h; RooCategory.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooThresholdCategory.h; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#de",MatchSource.WIKI,doc/master/rf405__realtocatfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8C.html
Modifiability,variab,variable,"ddThreshold(8.23, ""Signal"");; xRegion.addThreshold(9.23, ""SideBand"");; ; // U s e t h r e s h o l d f u n c t i o n t o p l o t d a t a r e g i o n s; // -------------------------------------------------------------------------------------; ; // Add values of threshold function to dataset so that it can be used as observable; data->addColumn(xRegion);; ; // Make plot of data in x; RooPlot *xframe = x.frame(Title(""Demo of threshold and binning mapping functions""));; data->plotOn(xframe);; ; // Use calculated category to select sideband data; data->plotOn(xframe, Cut(""xRegion==xRegion::SideBand""), MarkerColor(kRed), LineColor(kRed));; ; // C r e a t e a b i n n i n g r e a l - > c a t f u n c t i o n; // ----------------------------------------------------------------------; ; // A RooBinningCategory is a category function that maps bins of a (named) binning definition; // in a real-valued input observable observables to state names. The state names are automatically; // constructed from the variable name, the binning name and the bin number. If no binning name; // is specified the default binning is mapped; ; x.setBins(10, ""coarse"");; RooBinningCategory xBins(""xBins"", ""coarse bins in x"", x, ""coarse"");; ; // U s e b i n n i n g f u n c t i o n f o r t a b u l a t i o n a n d p l o t t i n g; // -----------------------------------------------------------------------------------------------; ; // Print table of xBins state multiplicity. Note that xBins does not need to be an observable in data; // it can be a function of observables in data as well; Roo1DTable *xbtable = data->table(xBins);; xbtable->Print(""v"");; ; // Add values of xBins function to dataset so that it can be used as observable; RooCategory *xb = (RooCategory *)data->addColumn(xBins);; ; // Define range ""alt"" as including bins 1,3,5,7,9; xb->setRange(""alt"", ""x_coarse_bin1,x_coarse_bin3,x_coarse_bin5,x_coarse_bin7,x_coarse_bin9"");; ; // Construct subset of data matching range ""alt"" but only for the first 5",MatchSource.WIKI,doc/master/rf405__realtocatfuncs_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8C.html
Deployability,update,updateFitRangeNorm,"""); xBins = ROOT.RooBinningCategory(""xBins"", ""coarse bins in x"", x, ""coarse""); ; # Use binning function for tabulation and plotting; # -----------------------------------------------------------------------------------------------; ; # Print table of xBins state multiplicity. Note that xBins does not need to be an observable in data; # it can be a function of observables in data as well; xbtable = data.table(xBins); xbtable.Print(""v""); ; # Add values of xBins function to dataset so that it can be used as; # observable; xb = data.addColumn(xBins); ; # Define range ""alt"" as including bins 1,3,5,7,9; xb.setRange(""alt"", ""x_coarse_bin1,x_coarse_bin3,x_coarse_bin5,x_coarse_bin7,x_coarse_bin9""); ; # Construct subset of data matching range ""alt"" but only for the first; # 5000 events and plot it on the frame; dataSel = data.reduce(CutRange=""alt"", EventRange=(0, 5000)); dataSel.plotOn(xframe, MarkerColor=""g"", LineColor=""g""); ; c = ROOT.TCanvas(""rf405_realtocatfuncs"", ""rf405_realtocatfuncs"", 600, 600); xframe.SetMinimum(0.01); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf405_realtocatfuncs.png""); [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 2748 events out of 10000 total events; ; Table xBins : aData; +---------------+------+; | x_coarse_bin0 | 105 |; | x_coarse_bin1 | 329 |; | x_coarse_bin2 | 499 |; | x_coarse_bin3 | 739 |; | x_coarse_bin4 | 934 |; | x_coarse_bin5 | 1218 |; | x_coarse_bin6 | 1450 |; | x_coarse_bin7 | 1675 |; | x_coarse_bin8 | 1767 |; | x_coarse_bin9 | 1284 |; +---------------+------+; ; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 2627 will supersede previous event count of 10000 for normalization of PDF projections; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf405_realtocatfuncs.py. tutorialsroofitrf405_realtocatfuncs.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf405__realtocatfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8py.html
Energy Efficiency,reduce,reduce,"from the variable name, binning name and the bin number. If no binning name; # is specified the default binning is mapped; ; x.setBins(10, ""coarse""); xBins = ROOT.RooBinningCategory(""xBins"", ""coarse bins in x"", x, ""coarse""); ; # Use binning function for tabulation and plotting; # -----------------------------------------------------------------------------------------------; ; # Print table of xBins state multiplicity. Note that xBins does not need to be an observable in data; # it can be a function of observables in data as well; xbtable = data.table(xBins); xbtable.Print(""v""); ; # Add values of xBins function to dataset so that it can be used as; # observable; xb = data.addColumn(xBins); ; # Define range ""alt"" as including bins 1,3,5,7,9; xb.setRange(""alt"", ""x_coarse_bin1,x_coarse_bin3,x_coarse_bin5,x_coarse_bin7,x_coarse_bin9""); ; # Construct subset of data matching range ""alt"" but only for the first; # 5000 events and plot it on the frame; dataSel = data.reduce(CutRange=""alt"", EventRange=(0, 5000)); dataSel.plotOn(xframe, MarkerColor=""g"", LineColor=""g""); ; c = ROOT.TCanvas(""rf405_realtocatfuncs"", ""rf405_realtocatfuncs"", 600, 600); xframe.SetMinimum(0.01); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf405_realtocatfuncs.png""); [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 2748 events out of 10000 total events; ; Table xBins : aData; +---------------+------+; | x_coarse_bin0 | 105 |; | x_coarse_bin1 | 329 |; | x_coarse_bin2 | 499 |; | x_coarse_bin3 | 739 |; | x_coarse_bin4 | 934 |; | x_coarse_bin5 | 1218 |; | x_coarse_bin6 | 1450 |; | x_coarse_bin7 | 1675 |; | x_coarse_bin8 | 1767 |; | x_coarse_bin9 | 1284 |; +---------------+------+; ; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 2627 will supersede previous event count of 10000 for normalization of PDF projections; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf405_realtocatfuncs.py",MatchSource.WIKI,doc/master/rf405__realtocatfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8py.html
Modifiability,variab,variable,"ackground; # 4.23 5.23 8.23 9.23; xRegion.addThreshold(4.23, ""Background""); xRegion.addThreshold(5.23, ""SideBand""); xRegion.addThreshold(8.23, ""Signal""); xRegion.addThreshold(9.23, ""SideBand""); ; # Use threshold function to plot data regions; # ----------------------------------------------; ; # Add values of threshold function to dataset so that it can be used as; # observable; data.addColumn(xRegion); ; # Make plot of data in x; xframe = x.frame(Title=""Demo of threshold and binning mapping functions""); data.plotOn(xframe); ; # Use calculated category to select sideband data; data.plotOn(xframe, Cut=""xRegion==xRegion::SideBand"", MarkerColor=""r"", LineColor=""r""); ; # Create a binning real -> cat function; # ----------------------------------------------------------------------; ; # A RooBinningCategory is a category function that maps bins of a (named) binning definition; # in a real-valued input observable observables to state names. The state names are automatically; # constructed from the variable name, binning name and the bin number. If no binning name; # is specified the default binning is mapped; ; x.setBins(10, ""coarse""); xBins = ROOT.RooBinningCategory(""xBins"", ""coarse bins in x"", x, ""coarse""); ; # Use binning function for tabulation and plotting; # -----------------------------------------------------------------------------------------------; ; # Print table of xBins state multiplicity. Note that xBins does not need to be an observable in data; # it can be a function of observables in data as well; xbtable = data.table(xBins); xbtable.Print(""v""); ; # Add values of xBins function to dataset so that it can be used as; # observable; xb = data.addColumn(xBins); ; # Define range ""alt"" as including bins 1,3,5,7,9; xb.setRange(""alt"", ""x_coarse_bin1,x_coarse_bin3,x_coarse_bin5,x_coarse_bin7,x_coarse_bin9""); ; # Construct subset of data matching range ""alt"" but only for the first; # 5000 events and plot it on the frame; dataSel = data.reduce(CutRange=""alt"", EventRa",MatchSource.WIKI,doc/master/rf405__realtocatfuncs_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8py.html
Availability,error,error,"a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg1(""bkg1"", ""Background 1"", x, RooArgSet(a0, a1));; ; // Build expontential pdf; RooRealVar alpha(""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""sig1frac"", ""fraction of component 1 in background"", 0.2, 0., 1.);; RooAddPdf bkg(""bkg"", ""Signal"", RooArgList(bkg1, bkg2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // M a k e l i s t o f p a r a m e t e r s b e f o r e a n d a f t e r f i t; // ----------------------------------------------------------------------------------------; ; // Make list of model parameters; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; ; // Save snapshot of prefit parameters; std::unique_ptr<RooArgSet> initParams{static_cast<RooArgSet *>(params->snapshot())};; ; // Do fit to data, to obtain error estimates on parameters; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; model.fitTo(*data, PrintLevel(-1));; ; // P r i n t l a t ex t a b l e o f p a r a m e t e r s o f p d f; // --------------------------------------------------------------------------; ; // Print parameter list in LaTeX for (one column with names, one column with values); params->printLatex();; ; // Print parameter list in LaTeX for (names values|names values); params->printLatex(Columns(2));; ; // Print two parameter lists side by side (name values initvalues); params->printLatex(Sibling(*initParams));; ; // Print two parameter lists side by side (name values initvalues|name values initvalues); params->printLatex(Sibling(*initParams), Columns(2));; ; // Write LaTex table to file; params->printLatex(Sibling(*initParams), OutputFile(""rf407_latextables.tex""));; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlo",MatchSource.WIKI,doc/master/rf407__latextables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html
Performance,optimiz,optimization,"leRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf407_latextablesDefinition rf407_latextables.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.71\pm 0.06$\\; $\verb+sigma1+ $ & $ 0.5$\\; $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lc|lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$ & $\verb+mean+ $ & $ 5$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$ & $\verb+sig1frac+ $ & $ 0.71\pm 0.06$\\; $\verb+alpha+ $ & $ -1.00$ & $\verb+sigma1+ $ & $ 0.5$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$ & $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lcc}; $\verb+a0+ $ & $ 0.6\pm 0.2$ & $ 0.5$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$ & $ 0.2$\\; $\verb+alpha+ $ & $ -1.00$ & $-1.00$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$ & ",MatchSource.WIKI,doc/master/rf407__latextables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html
Safety,safe,safe,"r object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ColumnsRooCmdArg Columns(Int_t ncol)Definition RooGlobalFunc.cxx:513; RooFit::SiblingRooCmdArg Sibling(const RooAbsCollection &sibling)Definition RooGlobalFunc.cxx:521; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf407_latextablesDefinition rf407_latextables.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.71\pm 0.06",MatchSource.WIKI,doc/master/rf407__latextables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html
Availability,error,error,", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg1 = ROOT.RooChebychev(""bkg1"", ""Background 1"", x, [a0, a1]); ; # Build expontential pdf; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -1); bkg2 = ROOT.RooExponential(""bkg2"", ""Background 2"", x, alpha); ; # Sum the background components into a composite background pdf; bkg1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in background"", 0.2, 0.0, 1.0); bkg = ROOT.RooAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Make list of parameters before and after fit; # ----------------------------------------------------------------------------------------; ; # Make list of model parameters; params = model.getParameters({x}); ; # Save snapshot of prefit parameters; initParams = params.snapshot(); ; # Do fit to data, obtain error estimates on parameters; data = model.generate({x}, 1000); model.fitTo(data, PrintLevel=-1); ; # Print LateX table of parameters of pdf; # --------------------------------------------------------------------------; ; # Print parameter list in LaTeX for (one column with names, column with; # values); params.printLatex(); ; # Print parameter list in LaTeX for (names values|names values); params.printLatex(Columns=2); ; # Print two parameter lists side by side (name values initvalues); params.printLatex(Sibling=initParams); ; # Print two parameter lists side by side (name values initvalues|name; # values initvalues); params.printLatex(Sibling=initParams, Columns=2); ; # Write LaTex table to file; params.printLatex(Sibling=initParams, OutputFile=""rf407_latextables.tex""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2",MatchSource.WIKI,doc/master/rf407__latextables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf407__latextables_8py.html
Performance,optimiz,optimization,"params.printLatex(Columns=2); ; # Print two parameter lists side by side (name values initvalues); params.printLatex(Sibling=initParams); ; # Print two parameter lists side by side (name values initvalues|name; # values initvalues); params.printLatex(Sibling=initParams, Columns=2); ; # Write LaTex table to file; params.printLatex(Sibling=initParams, OutputFile=""rf407_latextables.tex""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.5\pm 0.2$\\; $\verb+a1+ $ & $ 0.3\pm 0.1$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.46\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.79\pm 0.05$\\; $\verb+sigma1+ $ & $ 0.5$\\; $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lc|lc}; $\verb+a0+ $ & $ 0.5\pm 0.2$ & $\verb+mean+ $ & $ 5$\\; $\verb+a1+ $ & $ 0.3\pm 0.1$ & $\verb+sig1frac+ $ & $ 0.79\pm 0.05$\\; $\verb+alpha+ $ & $ -1.00$ & $\verb+sigma1+ $ & $ 0.5$\\; $\verb+bkgfrac+ $ & $ 0.46\pm 0.03$ & $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lcc}; $\verb+a0+ $ & $ 0.5\pm 0.2$ & $ 0.5$\\; $\verb+a1+ $ & $ 0.3\pm 0.1$ & $ 0$\\; $\verb+alpha+ $ & $ -1.00$ & $-1.00$\\; $\verb+bkgfrac+ $ & $ 0.46\pm 0.03$ & $ ",MatchSource.WIKI,doc/master/rf407__latextables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf407__latextables_8py.html
Safety,safe,safe,"odel parameters; params = model.getParameters({x}); ; # Save snapshot of prefit parameters; initParams = params.snapshot(); ; # Do fit to data, obtain error estimates on parameters; data = model.generate({x}, 1000); model.fitTo(data, PrintLevel=-1); ; # Print LateX table of parameters of pdf; # --------------------------------------------------------------------------; ; # Print parameter list in LaTeX for (one column with names, column with; # values); params.printLatex(); ; # Print parameter list in LaTeX for (names values|names values); params.printLatex(Columns=2); ; # Print two parameter lists side by side (name values initvalues); params.printLatex(Sibling=initParams); ; # Print two parameter lists side by side (name values initvalues|name; # values initvalues); params.printLatex(Sibling=initParams, Columns=2); ; # Write LaTex table to file; params.printLatex(Sibling=initParams, OutputFile=""rf407_latextables.tex""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.5\pm 0.2$\\; $\verb+a1+ $ & $ 0.3\pm 0.1$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.46\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.79\pm 0.05$",MatchSource.WIKI,doc/master/rf407__latextables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf407__latextables_8py.html
Integrability,interface,interface,"() {; rf408_RDataFrameToRooFit();; return 0;; }; mainint main()Definition Prototype.cxx:12; RooAbsDataHelper.h; RooDataSetHelperRooAbsDataHelper< RooDataSet > RooDataSetHelperHelper for creating a RooDataSet inside RDataFrame.Definition RooAbsDataHelper.h:157; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::RDF::RInterface::DefineRInterface< Proxied, DS_t > Define(std::string_view name, F expression, const ColumnNames_t &columns={})Define a new column.Definition RInterface.hxx:441; ROOT::RDF::RResultPtrSmart pointer for the return type of actions.Definition RResultPtr.hxx:119; ROOT::RDF::RResultPtr::GetValueconst T & GetValue()Get a const reference to the encapsulated object.Definition RResultPtr.hxx:228; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; RooAbsDataHelperThis is a helper for an RDataFrame action, which fills RooFit data classes.Definition RooAbsDataHelper.h:119; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682",MatchSource.WIKI,doc/master/rf408__RDataFrameToRooFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html
Modifiability,variab,variables," ROOT: tutorials/roofit/rf408_RDataFrameToRooFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf408_RDataFrameToRooFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Fill RooDataSet/RooDataHist in RDataFrame. ; This tutorial shows how to fill RooFit data classes directly from RDataFrame. Using two small helpers, we tell RDataFrame where the data has to go.; ; #include <RooAbsDataHelper.h>; ; #include <TRandom.h>; ; /// Print the first few entries and summary statistics.; void printData(const RooAbsData& data) {; std::cout << ""\n"";; data.Print();; ; for (int i=0; i < data.numEntries() && i < 20; ++i) {; std::cout << ""("";; for (const auto var : *data.get(i)) {; std::cout << std::setprecision(3) << std::right << std::fixed << std::setw(8) << static_cast<const RooAbsReal*>(var)->getVal() << "", "";; }; std::cout << "")\tweight="" << std::setw(10) << data.weight() << std::endl;; }; ; // Get the x and y variables from the dataset:; const auto & x = static_cast<const RooRealVar&>(*(*data.get())[0]);; const auto & y = static_cast<const RooRealVar&>(*(*data.get())[1]);; ; std::cout << ""mean(x) = "" << data.mean(x) << ""\tsigma(x) = "" << std::sqrt(data.moment(x, 2.)); << ""\n"" << ""mean(y) = "" << data.mean(y) << ""\tsigma(y) = "" << std::sqrt(data.moment(y, 2.)) << std::endl;; }; ; void rf408_RDataFrameToRooFit(); {; // Set up; // ------------------------; ; // We create an RDataFrame with two columns filled with 2 million random numbers.; auto df = ROOT::RDataFrame{2000000}.Define(""x"", []() { return gRandom->Uniform(-5., 5.); }).Define(""y"", []() {; return gRandom->Gaus(1., 3.);; });; ; ; // We create RooFit variables that will represent the dataset.; RooRealVar x(""x"", ""x"", -5., 5.);; RooRealVar y(""y"", ""y"", -50., 50.);; x.setBins(10);; y.setBins(20);; ; ; ; // Booking the creation of RooDataSet / RooDataHist in RDataFrame; // ----------------------------------------------------------------; ; // Method 1:; // ---",MatchSource.WIKI,doc/master/rf408__RDataFrameToRooFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html
Usability,learn,learn,", ""y"", -50., 50.);; x.setBins(10);; y.setBins(20);; ; ; ; // Booking the creation of RooDataSet / RooDataHist in RDataFrame; // ----------------------------------------------------------------; ; // Method 1:; // ---------; // We directly book the RooDataSetHelper action.; // We need to pass; // - the RDataFrame column types as template parameters; // - the constructor arguments for RooDataSet (they follow the same syntax as the usual RooDataSet constructors); // - the column names that RDataFrame should fill into the dataset; //; // NOTE: RDataFrame columns are matched to RooFit variables by position, *not by name*!; //; // The returned object is not yet a RooDataSet, but an RResultPtr that will; // be lazy-evaluated once you call GetValue() on it. We will only evaluate; // the RResultPtr once all other RDataFrame related actions are declared.; // This way we trigger the event loop computation only once, which will; // improve the runtime significantly.; //; // To learn more about lazy actions, see:; // https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions; ROOT::RDF::RResultPtr<RooDataSet> rooDataSetResult = df.Book<double, double>(; RooDataSetHelper(""dataset"", // Name; ""Title of dataset"", // Title; RooArgSet(x, y) // Variables in this dataset; ),; {""x"", ""y""} // Column names in RDataFrame.; );; ; ; // Method 2:; // ---------; // We first declare the RooDataHistHelper; RooDataHistHelper rdhMaker{""datahist"", // Name; ""Title of data hist"", // Title; RooArgSet(x, y) // Variables in this dataset; };; ; // Then, we move it into an RDataFrame action:; ROOT::RDF::RResultPtr<RooDataHist> rooDataHistResult = df.Book<double, double>(std::move(rdhMaker), {""x"", ""y""});; ; ; // Run it and inspect the results; // -------------------------------; ; // At this point, all RDF actions were defined (namely, the `Book`; // operations), so we can get values from the RResultPtr objects, triggering; // the event loop and getting the actual RooFit data objects.; RooDataSet const",MatchSource.WIKI,doc/master/rf408__RDataFrameToRooFit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html
Integrability,interface,interface,"(y) = {0:.3f}\n"".format(math.sqrt(data.moment(y, 2.0)))); ; ; print_data(roo_data_set); print_data(roo_data_hist); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; RooDataSet::dataset[x,y] = 2000000 entries; RooDataHist::dataset[x,y] = 200 bins (2e+06 weights); ; ( 4.997, -0.304, ) weight= 1.000; ( 4.472, 0.910, ) weight= 1.000; ( 4.575, 0.830, ) weight= 1.000; ( 0.400, 0.776, ) weight= 1.000; ( 2.599, -0.232, ) weight= 1.000; ( -1.844, 1.575, ) weight= 1.000; ( 0.197, 0.853, ) weight= 1.000; ( -1.077, -0.721, ) weight= 1.000; ( -4.697, -3.165, ) weight= 1.000; ( 4.437, -1.208, ) weight= 1.000; ( 3.983, -0.146, ) weight= 1.000; ( -0.014, -1.447, ) weight= 1.000; ( -3.177, -2.704, ) weight= 1.000; ( -4.371, -0.363, ) weight= 1.000; ( 2.254, -0.499, ) weight= 1.000; ( 2.139, 6.533, ) weight= 1.000; ( 1.993, 6.991, ) weight= 1.000; ( -3.708, 7.781, ) weight= 1.000; ( -4.168, 1.284, ) weight= 1.000; ( -4.177, 4.650, ) weight= 1.000; mean(x) = 0.001 sigma(x) = 2.886; mean(y) = 1.000 sigma(y) = 3.000; ; ; ( -4.500, -47.500, ) weight= 0.000; ( -4.500, -42.500, ) ",MatchSource.WIKI,doc/master/rf408__RDataFrameToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf408_RDataFrameToRooFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf408_RDataFrameToRooFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Fill RooDataSet/RooDataHist in RDataFrame. ; This tutorial shows how to fill RooFit data classes directly from RDataFrame. Using two small helpers, we tell RDataFrame where the data has to go.; ; import ROOT; import math; ; ; # Set up; # ------------------------; ; # We create an RDataFrame with two columns filled with 2 million random numbers.; df = ROOT.RDataFrame(2000000).Define(""x"", ""gRandom->Uniform(-5., 5.)"").Define(""y"", ""gRandom->Gaus(1., 3.)""); ; ; # We create RooFit variables that will represent the dataset.; x = ROOT.RooRealVar(""x"", ""x"", -5.0, 5.0); y = ROOT.RooRealVar(""y"", ""y"", -50.0, 50.0); x.setBins(10); y.setBins(20); ; ; # Booking the creation of RooDataSet / RooDataHist in RDataFrame; # ----------------------------------------------------------------; ; # Method 1:; # ---------; # We directly book the RooDataSetHelper action.; # We need to pass; # - the RDataFrame column types as template parameters; # - the constructor arguments for RooDataSet (they follow the same syntax as the usual RooDataSet constructors); # - the column names that RDataFrame should fill into the dataset; ; # NOTE: RDataFrame columns are matched to RooFit variables by position, *not by name*!; #; # The returned object is not yet a RooDataSet, but an RResultPtr that will be; # lazy-evaluated once you call GetValue() on it. We will only evaluate the; # RResultPtr once all other RDataFrame related actions are declared. This way; # we trigger the event loop computation only once, which will improve the; # runtime significantly.; #; # To learn more about lazy actions, see:; # https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions; roo_data_set_result = df.Book(; ROOT.std.move(ROOT.RooDataSetHelper(""dataset"", ""Title of dat",MatchSource.WIKI,doc/master/rf408__RDataFrameToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8py.html
Usability,learn,learn," = ROOT.RooRealVar(""y"", ""y"", -50.0, 50.0); x.setBins(10); y.setBins(20); ; ; # Booking the creation of RooDataSet / RooDataHist in RDataFrame; # ----------------------------------------------------------------; ; # Method 1:; # ---------; # We directly book the RooDataSetHelper action.; # We need to pass; # - the RDataFrame column types as template parameters; # - the constructor arguments for RooDataSet (they follow the same syntax as the usual RooDataSet constructors); # - the column names that RDataFrame should fill into the dataset; ; # NOTE: RDataFrame columns are matched to RooFit variables by position, *not by name*!; #; # The returned object is not yet a RooDataSet, but an RResultPtr that will be; # lazy-evaluated once you call GetValue() on it. We will only evaluate the; # RResultPtr once all other RDataFrame related actions are declared. This way; # we trigger the event loop computation only once, which will improve the; # runtime significantly.; #; # To learn more about lazy actions, see:; # https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions; roo_data_set_result = df.Book(; ROOT.std.move(ROOT.RooDataSetHelper(""dataset"", ""Title of dataset"", ROOT.RooArgSet(x, y))), (""x"", ""y""); ); ; # Method 2:; # ---------; # We first declare the RooDataHistHelper; rdhMaker = ROOT.RooDataHistHelper(""dataset"", ""Title of dataset"", ROOT.RooArgSet(x, y)); ; # Then, we move it into an RDataFrame action:; roo_data_hist_result = df.Book(ROOT.std.move(rdhMaker), (""x"", ""y"")); ; ; # Run it and inspect the results; # -------------------------------; ; # At this point, all RDF actions were defined (namely, the `Book` operations),; # so we can get values from the RResultPtr objects, triggering the event loop; # and getting the actual RooFit data objects.; roo_data_set = roo_data_set_result.GetValue(); roo_data_hist = roo_data_hist_result.GetValue(); ; # Let's inspect the dataset / datahist.; ; ; def print_data(data):; print(""""); data.Print(); for i in range(min(data.numEn",MatchSource.WIKI,doc/master/rf408__RDataFrameToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8py.html
Availability,error,error,", bins=bins); ; print(""RooDataHist imported with linspace binning and exported back to numpy:""); print_histogram_output(datahist_new_2.to_numpy()); ; # Alternatively, you can specify only the number of bins and the range if your; # binning is uniform. This is preferred over passing the full list of bin; # edges, because RooFit will know that the binning is uniform and do some; # optimizations.; bins = [20]; ranges = [(-10, 10)]; counts, _ = np.histogramdd([x_arr], bins=bins, range=ranges); datahist_new_3 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins, ranges=ranges); ; print(""RooDataHist imported with uniform binning and exported back to numpy:""); print_histogram_output(datahist_new_3.to_numpy()); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 14250.1, estimated distance to minimum: 2.14184e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; mean -9.9828e-01 +/- 1.01e-02; sigma 1.0061e+00 +/- 7.11e-03; ; Mean of numpy array: 1.0066466535473984; Standard deviation of numpy array: 0.9973499677811349; Counts and bin edges from RooDataHist.to_numpy:; [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 2 2 5 10 17 32 38 50 78 123; 195 274 347 442 486 635 682 786 805 768 755 681 639 533 455 350 259 194; 124 93 62 27 28 16 3 2 1 1 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0]; ",MatchSource.WIKI,doc/master/rf409__NumPyPandasToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html
Deployability,update,updated,"; # Now you can use the DataFrame e.g. for plotting. You can even combine this; # with the RooAbsReal.bins PyROOT function, which returns the binning from; # RooFit as a numpy array!; try:; import matplotlib.pyplot as plt; ; df.hist(column=""x"", bins=x.bins()); except Exception:; print(; 'Skipping `df.hist(column=""x"", bins=x.bins())` because matplotlib could not be imported or was not able to display the plot.'; ); ; del data; del arrays; del df; ; ; # Creating a dataset with NumPy and importing it to a RooDataSet; # --------------------------------------------------------------; ; # Now we create some Gaussian toy data with numpy, this time with a different; # mean.; x_arr = np.random.normal(-1.0, 1.0, (n_events,)); ; # Import the data to a RooDataSet, passing a dictionary of arrays and the; # corresponding RooRealVars just like you would pass to the RooDataSet; # constructor.; data = ROOT.RooDataSet.from_numpy({""x"": x_arr}, [x]); ; # Let's fit the Gaussian to the data. The mean is updated accordingly.; fit_result = gauss.fitTo(data, PrintLevel=-1, Save=True); fit_result.Print(); ; # We can now plot the model and the dataset with RooFit.; xframe = x.frame(Title=""Gaussian pdf""); data.plotOn(xframe); gauss.plotOn(xframe); ; # Draw RooFit plot on a canvas.; c = ROOT.TCanvas(""rf409_NumPyPandasToRooFit"", ""rf409_NumPyPandasToRooFit"", 800, 400); xframe.Draw(); c.SaveAs(""rf409_NumPyPandasToRooFit.png""); ; ; # Exporting a RooDataHist to NumPy arrays for histogram counts and bin edges; # --------------------------------------------------------------------------; ; ; def print_histogram_output(histogram_output):; counts, bin_edges = histogram_output; print(np.array(counts, dtype=int)); print(bin_edges[0]); ; ; # Create a binned clone of the dataset to show RooDataHist to NumPy export.; datahist = data.binnedClone(); ; # You can also export a RooDataHist to numpy arrays with; # RooDataHist.to_numpy(). As output, you will get a multidimensional array with; # the histogram counts ",MatchSource.WIKI,doc/master/rf409__NumPyPandasToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html
Integrability,interface,interface,"data.binnedClone(); ; # You can also export a RooDataHist to numpy arrays with; # RooDataHist.to_numpy(). As output, you will get a multidimensional array with; # the histogram counts and a list of arrays with bin edges. This is comparable; # to the output of numpy.histogram (or numpy.histogramdd for the; # multidimensional case).; counts, bin_edges = datahist.to_numpy(); ; print(""Counts and bin edges from RooDataHist.to_numpy:""); print_histogram_output((counts, bin_edges)); ; # Let's compare the output to the counts and bin edges we get with; # numpy.histogramdd when we pass it the original samples:; print(""Counts and bin edges from np.histogram:""); print_histogram_output(np.histogramdd([x_arr], bins=[x.bins()])); ; # The array values should be the same!; ; ; # Importing a RooDataHist from NumPy arrays with histogram counts and bin edges; # -----------------------------------------------------------------------------; ; # There is also a `RooDataHist.from_numpy` function, again with an interface; # inspired by `numpy.histogramdd`. You need to pass at least the histogram; # counts and the list of variables. The binning is optional: the default; # binning of the RooRealVars is used if not explicitly specified.; datahist_new_1 = ROOT.RooDataHist.from_numpy(counts, [x]); ; print(""RooDataHist imported with default binning and exported back to numpy:""); print_histogram_output(datahist_new_1.to_numpy()); ; ; # It's also possible to pass custom bin edges to `RooDataHist.from_numpy`, just; # like you pass them to `numpy.histogramdd` when you get the counts to fill the; # RooDataHist with:; bins = [np.linspace(-10, 10, 21)]; counts, _ = np.histogramdd([x_arr], bins=bins); datahist_new_2 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins); ; print(""RooDataHist imported with linspace binning and exported back to numpy:""); print_histogram_output(datahist_new_2.to_numpy()); ; # Alternatively, you can specify only the number of bins and the range if your; # binning is uniform. ",MatchSource.WIKI,doc/master/rf409__NumPyPandasToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html
Modifiability,variab,variables,"DataHist.to_numpy(). As output, you will get a multidimensional array with; # the histogram counts and a list of arrays with bin edges. This is comparable; # to the output of numpy.histogram (or numpy.histogramdd for the; # multidimensional case).; counts, bin_edges = datahist.to_numpy(); ; print(""Counts and bin edges from RooDataHist.to_numpy:""); print_histogram_output((counts, bin_edges)); ; # Let's compare the output to the counts and bin edges we get with; # numpy.histogramdd when we pass it the original samples:; print(""Counts and bin edges from np.histogram:""); print_histogram_output(np.histogramdd([x_arr], bins=[x.bins()])); ; # The array values should be the same!; ; ; # Importing a RooDataHist from NumPy arrays with histogram counts and bin edges; # -----------------------------------------------------------------------------; ; # There is also a `RooDataHist.from_numpy` function, again with an interface; # inspired by `numpy.histogramdd`. You need to pass at least the histogram; # counts and the list of variables. The binning is optional: the default; # binning of the RooRealVars is used if not explicitly specified.; datahist_new_1 = ROOT.RooDataHist.from_numpy(counts, [x]); ; print(""RooDataHist imported with default binning and exported back to numpy:""); print_histogram_output(datahist_new_1.to_numpy()); ; ; # It's also possible to pass custom bin edges to `RooDataHist.from_numpy`, just; # like you pass them to `numpy.histogramdd` when you get the counts to fill the; # RooDataHist with:; bins = [np.linspace(-10, 10, 21)]; counts, _ = np.histogramdd([x_arr], bins=bins); datahist_new_2 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins); ; print(""RooDataHist imported with linspace binning and exported back to numpy:""); print_histogram_output(datahist_new_2.to_numpy()); ; # Alternatively, you can specify only the number of bins and the range if your; # binning is uniform. This is preferred over passing the full list of bin; # edges, because RooFit will know",MatchSource.WIKI,doc/master/rf409__NumPyPandasToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html
Performance,optimiz,optimizations,"st the histogram; # counts and the list of variables. The binning is optional: the default; # binning of the RooRealVars is used if not explicitly specified.; datahist_new_1 = ROOT.RooDataHist.from_numpy(counts, [x]); ; print(""RooDataHist imported with default binning and exported back to numpy:""); print_histogram_output(datahist_new_1.to_numpy()); ; ; # It's also possible to pass custom bin edges to `RooDataHist.from_numpy`, just; # like you pass them to `numpy.histogramdd` when you get the counts to fill the; # RooDataHist with:; bins = [np.linspace(-10, 10, 21)]; counts, _ = np.histogramdd([x_arr], bins=bins); datahist_new_2 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins); ; print(""RooDataHist imported with linspace binning and exported back to numpy:""); print_histogram_output(datahist_new_2.to_numpy()); ; # Alternatively, you can specify only the number of bins and the range if your; # binning is uniform. This is preferred over passing the full list of bin; # edges, because RooFit will know that the binning is uniform and do some; # optimizations.; bins = [20]; ranges = [(-10, 10)]; counts, _ = np.histogramdd([x_arr], bins=bins, range=ranges); datahist_new_3 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins, ranges=ranges); ; print(""RooDataHist imported with uniform binning and exported back to numpy:""); print_histogram_output(datahist_new_3.to_numpy()); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 14250.1, estimated distance to",MatchSource.WIKI,doc/master/rf409__NumPyPandasToRooFit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html
Availability,error,error,"; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Definition RooGlobalFunc.cxx:134; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf501_simultaneouspdfDefinition rf501_simultaneouspdf.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_simPdf_combData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 8630.62, estimated distance to minimum: 0.000174671; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 6.7634e-02 +/- 6.04e-02; a0_ctl -1.5627e-01 +/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); ",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Deployability,integrat,integrated,"ng category sample as index:; // associate model with the physics state and model_ctl with the control state; RooSimultaneous simPdf(""simPdf"", ""simultaneous pdf"", {{""physics"", &model}, {""control"", &model_ctl}}, sample);; ; // P e r f o r m a s i m u l t a n e o u s f i t; // ---------------------------------------------------; ; // Perform simultaneous fit of model to data and model_ctl to data_ctl; std::unique_ptr<RooFitResult> fitResult{simPdf.fitTo(combData, PrintLevel(-1), Save(), PrintLevel(-1))};; fitResult->Print();; ; // P l o t m o d e l s l i c e s o n d a t a s l i c e s; // ----------------------------------------------------------------; ; // Make a frame for the physics sample; RooPlot *frame1 = x.frame(Title(""Physics sample""));; ; // Plot all data tagged as physics sample; combData.plotOn(frame1, Cut(""sample==sample::physics""));; ; // Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedDat",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Energy Efficiency,reduce,reduce,"ex category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedData{combData.reduce(Cut(""sample==sample::control""))};; slicedData->plotOn(frame2);; simPdf.plotOn(frame2, ProjWData(sample, *slicedData));; simPdf.plotOn(frame2, Components(""px_ctl""), ProjWData(sample, *slicedData), LineStyle(kDashed));; ; // The same plot for all the phase space. Here, we can just use the original; // combined dataset.; RooPlot *frame3 = x.frame(Title(""Both samples""));; combData.plotOn(frame3);; simPdf.plotOn(frame3, ProjWData(sample, combData));; simPdf.plotOn(frame3, Components(""px,px_ctl""), ProjWData(sample, combData),; LineStyle(kDashed));; ; TCanvas *c = new TCanvas(""rf501_simultaneouspdf"", ""rf403_simultaneouspdf"", 1200, 400);; c->Divide(3);; auto draw = [&](int i, RooPlot & frame) {; c->cd(i);; gPad->SetLeftMargin(0.15);; frame.GetYaxis()->SetTitleOffset(1.4);; frame.Draw();; };; draw(1, *frame1);; draw(2, *frame2);; draw(3, *frame3);; }; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooCategory.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Integrability,integrat,integrated,"ng category sample as index:; // associate model with the physics state and model_ctl with the control state; RooSimultaneous simPdf(""simPdf"", ""simultaneous pdf"", {{""physics"", &model}, {""control"", &model_ctl}}, sample);; ; // P e r f o r m a s i m u l t a n e o u s f i t; // ---------------------------------------------------; ; // Perform simultaneous fit of model to data and model_ctl to data_ctl; std::unique_ptr<RooFitResult> fitResult{simPdf.fitTo(combData, PrintLevel(-1), Save(), PrintLevel(-1))};; fitResult->Print();; ; // P l o t m o d e l s l i c e s o n d a t a s l i c e s; // ----------------------------------------------------------------; ; // Make a frame for the physics sample; RooPlot *frame1 = x.frame(Title(""Physics sample""));; ; // Plot all data tagged as physics sample; combData.plotOn(frame1, Cut(""sample==sample::physics""));; ; // Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedDat",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Modifiability,variab,variable,"ition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooSimultaneousFacilitates simultaneous fitting of multiple PDFs to subsets of a given dataset.Definition RooSimultaneous.h:41; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::IndexRooCmdArg Index(RooCategory &icat)Definition RooGlobalFunc.cxx:386; RooFit::ImportRooCmdArg Import(const char *state, TH1 &histo)Definition RooGlobalFunc.cxx:390; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::Sli",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Performance,optimiz,optimization,"; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Definition RooGlobalFunc.cxx:134; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf501_simultaneouspdfDefinition rf501_simultaneouspdf.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_simPdf_combData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 8630.62, estimated distance to minimum: 0.000174671; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 6.7634e-02 +/- 6.04e-02; a0_ctl -1.5627e-01 +/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); ",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Safety,predict,prediction,"ng category sample as index:; // associate model with the physics state and model_ctl with the control state; RooSimultaneous simPdf(""simPdf"", ""simultaneous pdf"", {{""physics"", &model}, {""control"", &model_ctl}}, sample);; ; // P e r f o r m a s i m u l t a n e o u s f i t; // ---------------------------------------------------; ; // Perform simultaneous fit of model to data and model_ctl to data_ctl; std::unique_ptr<RooFitResult> fitResult{simPdf.fitTo(combData, PrintLevel(-1), Save(), PrintLevel(-1))};; fitResult->Print();; ; // P l o t m o d e l s l i c e s o n d a t a s l i c e s; // ----------------------------------------------------------------; ; // Make a frame for the physics sample; RooPlot *frame1 = x.frame(Title(""Physics sample""));; ; // Plot all data tagged as physics sample; combData.plotOn(frame1, Cut(""sample==sample::physics""));; ; // Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedDat",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Testability,log,logical,"le::physics""));; ; // Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedData{combData.reduce(Cut(""sample==sample::control""))};; slicedData->plotOn(frame2);; simPdf.plotOn(frame2, ProjWData(sample, *slicedData));; simPdf.plotOn(frame2, Components(""px_ctl""), ProjWData(sample, *slicedData), LineStyle(kDashed));; ; // The same plot for all the phase space. Here, we can just use the original; // combined dataset.; RooPlot *frame3 = x.frame(Title(""Both samples""));; combData.plotOn(frame3);; simPdf.plotOn(frame3, ProjWData(sample, combData));; simPdf.plotOn(frame3, Components(""px,px_ctl""), ProjWData(sample, combData),; LineStyle(kDashed));; ; TCanvas *c = new TCanvas(""rf501_simultaneouspdf"", ""rf403_simultaneouspdf"", 1200, 400);; c->Divide(3);; auto draw = [&](int i, RooPlot & frame) {; c->cd(i);; gPad->SetLeftMargin(0.15);; frame.GetYaxis()->SetTitleOffset(1.4);; frame.Draw();; };; draw(1, *frame1);; draw(2, ",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html
Availability,error,error,"slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_simPdf_combData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 8630.62, estimated distance to minimum: 0.000174671; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 6.7634e-02 +/- 6.04e-02; a0_ctl -1.5627e-01 +/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); [#",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Deployability,integrat,integrated,"-----------------------------------------------------------------------; ; # Construct a simultaneous pdf using category sample as index: associate model; # with the physics state and model_ctl with the control state; simPdf = ROOT.RooSimultaneous(""simPdf"", ""simultaneous pdf"", {""physics"": model, ""control"": model_ctl}, sample); ; # Perform a simultaneous fit; # ---------------------------------------------------; ; # Perform simultaneous fit of model to data and model_ctl to data_ctl; fitResult = simPdf.fitTo(combData, PrintLevel=-1, Save=True); fitResult.Print(); ; # Plot model slices on data slices; # ----------------------------------------------------------------; ; # Make a frame for the physics sample; frame1 = x.frame(Title=""Physics sample""); ; # Plot all data tagged as physics sample; combData.plotOn(frame1, Cut=""sample==sample::physics""); ; # Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(fr",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Energy Efficiency,reduce,reduce," using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(frame2); simPdf.plotOn(frame2, ProjWData=(sample, slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mav",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Integrability,integrat,integrated,"-----------------------------------------------------------------------; ; # Construct a simultaneous pdf using category sample as index: associate model; # with the physics state and model_ctl with the control state; simPdf = ROOT.RooSimultaneous(""simPdf"", ""simultaneous pdf"", {""physics"": model, ""control"": model_ctl}, sample); ; # Perform a simultaneous fit; # ---------------------------------------------------; ; # Perform simultaneous fit of model to data and model_ctl to data_ctl; fitResult = simPdf.fitTo(combData, PrintLevel=-1, Save=True); fitResult.Print(); ; # Plot model slices on data slices; # ----------------------------------------------------------------; ; # Make a frame for the physics sample; frame1 = x.frame(Title=""Physics sample""); ; # Plot all data tagged as physics sample; combData.plotOn(frame1, Cut=""sample==sample::physics""); ; # Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(fr",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Modifiability,variab,variable,"+/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) slice variable sample was not projected anyway; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (px); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) slice variable sample was not projected anyway; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x averages with data index category (sample); [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x averages with data index category (sample); [#1] INFO:Plotting -- RooAbsPdf::plotOn(simPdf) directly selected PDF components: (px_ctl); [#1] INFO:Plotting -- RooAbsPdf::plotOn(simPdf) indirectly selected PDF components: (model_ctl); [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x averages with data index category (sample); [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x averages with data index category (sample); [#1] INFO:Plotting -- RooAbsPdf::plotOn(simPdf) directly selected PDF components: (px,px_ctl); [#1] INFO:Plotting -- RooAbsPdf::plotOn(simPdf) indirectly selected PDF components: (model_ctl,model); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf501_simultaneouspdf.py. tutorialsroofitrf501_simultaneouspdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Performance,optimiz,optimization,"slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_simPdf_combData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 8630.62, estimated distance to minimum: 0.000174671; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 6.7634e-02 +/- 6.04e-02; a0_ctl -1.5627e-01 +/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); [#",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Safety,predict,prediction,"-----------------------------------------------------------------------; ; # Construct a simultaneous pdf using category sample as index: associate model; # with the physics state and model_ctl with the control state; simPdf = ROOT.RooSimultaneous(""simPdf"", ""simultaneous pdf"", {""physics"": model, ""control"": model_ctl}, sample); ; # Perform a simultaneous fit; # ---------------------------------------------------; ; # Perform simultaneous fit of model to data and model_ctl to data_ctl; fitResult = simPdf.fitTo(combData, PrintLevel=-1, Save=True); fitResult.Print(); ; # Plot model slices on data slices; # ----------------------------------------------------------------; ; # Make a frame for the physics sample; frame1 = x.frame(Title=""Physics sample""); ; # Plot all data tagged as physics sample; combData.plotOn(frame1, Cut=""sample==sample::physics""); ; # Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(fr",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Testability,log,logical,"n(frame1, Cut=""sample==sample::physics""); ; # Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(frame2); simPdf.plotOn(frame2, ProjWData=(sample, slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) ",MatchSource.WIKI,doc/master/rf501__simultaneouspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html
Modifiability,variab,variables,"wspacewriteDefinition rf502_wspacewrite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; ; RooWorkspace(w) workspace contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; datasets; --------; RooDataSet::modelData(x); ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition",MatchSource.WIKI,doc/master/rf502__wspacewrite_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8C.html
Safety,safe,safe,"yle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf502_wspacewriteDefinition rf502_wspacewrite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf502__wspacewrite_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8C.html
Modifiability,variab,variables,"file; w.writeToFile(""rf502_workspace_py.root""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; ; RooWorkspace(w) workspace contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; datasets; --------; RooDataSet::modelData(x); ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verke",MatchSource.WIKI,doc/master/rf502__wspacewrite_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8py.html
Safety,safe,safe,"1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Generate a data sample of 1000 events in x from model; data = model.generate({x}, 1000); ; # Create workspace, import data and model; # -----------------------------------------------------------------------------; ; # Create a empty workspace; w = ROOT.RooWorkspace(""w"", ""workspace""); ; # Import model and all its components into the workspace; w.Import(model); ; # Import data into the workspace; w.Import(data); ; # Print workspace contents; w.Print(); ; # Save workspace in file; # -------------------------------------------; ; # Save the workspace into a ROOT file; w.writeToFile(""rf502_workspace_py.root""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf502__wspacewrite_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8py.html
Availability,error,error,"FitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf503_wspacereadDefinition rf503_wspaceread.py:1; ; 0x559b3dca42c0 RooAddPdf::model = 0.9/1 [Auto,Clean] ; 0x559b3deb0210/V- RooChebychev::bkg = 0.8 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3c2d1250/V- RooRealVar::a0 = 0.5; 0x559b3c353b60/V- RooRealVar::a1 = 0.2; 0x559b3df69400/V- RooRealVar::bkgfrac = 0.5; 0x559b3defe0a0/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x559b3ded9e50/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3d77d310/V- RooRealVar::mean = 5; 0x559b3d6274d0/V- RooRealVar::sigma1 = 0.5; 0x559b3bf56940/V- RooRealVar::sig1frac = 0.8; 0x559b3def8000/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3d77d310/V- RooRealVar::mean = 5; 0x559b3d7146b0/V- RooRealVar::sigma2 = 1; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf503_wspaceread.C. tutorialsroofitrf503_wspaceread.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf503__wspaceread_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8C.html
Integrability,interface,interface,"e frame on the canvas; new TCanvas(""rf503_wspaceread"", ""rf503_wspaceread"", 600, 600);; gPad->SetLeftMargin(0.15);; xframe->GetYaxis()->SetTitleOffset(1.4);; xframe->Draw();; }; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; kDashed@ kDashedDefinition TAttLine.h:48; kDotted@ kDottedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TFile.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option",MatchSource.WIKI,doc/master/rf503__wspaceread_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8C.html
Modifiability,variab,variable,"st overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf503_wspacereadDef",MatchSource.WIKI,doc/master/rf503__wspaceread_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8C.html
Performance,optimiz,optimization,"FitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf503_wspacereadDefinition rf503_wspaceread.py:1; ; 0x559b3dca42c0 RooAddPdf::model = 0.9/1 [Auto,Clean] ; 0x559b3deb0210/V- RooChebychev::bkg = 0.8 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3c2d1250/V- RooRealVar::a0 = 0.5; 0x559b3c353b60/V- RooRealVar::a1 = 0.2; 0x559b3df69400/V- RooRealVar::bkgfrac = 0.5; 0x559b3defe0a0/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x559b3ded9e50/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3d77d310/V- RooRealVar::mean = 5; 0x559b3d6274d0/V- RooRealVar::sigma1 = 0.5; 0x559b3bf56940/V- RooRealVar::sig1frac = 0.8; 0x559b3def8000/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x559b3c0035d0/V- RooRealVar::x = 5; 0x559b3d77d310/V- RooRealVar::mean = 5; 0x559b3d7146b0/V- RooRealVar::sigma2 = 1; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf503_wspaceread.C. tutorialsroofitrf503_wspaceread.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf503__wspaceread_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8C.html
Availability,error,error,"Style="":""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf503_wspaceread"", ""rf503_wspaceread"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf503_wspaceread.png""); 0x8fdb600 RooAddPdf::model = 1/1 [Auto,Clean] ; 0x91994b0/V- RooChebychev::bkg = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x27be9c0/V- RooRealVar::a0 = 0.5; 0x2765460/V- RooRealVar::a1 = 0; 0x9279200/V- RooRealVar::bkgfrac = 0.5; 0x926e430/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x91f8100/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x87e28d0/V- RooRealVar::mean = 5; 0x4735f60/V- RooRealVar::sigma1 = 0.5; 0x4735b70/V- RooRealVar::sig1frac = 0.8; 0x9205290/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x87e28d0/V- RooRealVar::mean = 5; 0x873e5a0/V- RooRealVar::sigma2 = 1; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf503_wspaceread.py. tutorialsroofitrf503_wspaceread.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf503__wspaceread_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8py.html
Performance,optimiz,optimization,"Style="":""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf503_wspaceread"", ""rf503_wspaceread"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf503_wspaceread.png""); 0x8fdb600 RooAddPdf::model = 1/1 [Auto,Clean] ; 0x91994b0/V- RooChebychev::bkg = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x27be9c0/V- RooRealVar::a0 = 0.5; 0x2765460/V- RooRealVar::a1 = 0; 0x9279200/V- RooRealVar::bkgfrac = 0.5; 0x926e430/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x91f8100/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x87e28d0/V- RooRealVar::mean = 5; 0x4735f60/V- RooRealVar::sigma1 = 0.5; 0x4735b70/V- RooRealVar::sig1frac = 0.8; 0x9205290/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x87e28d0/V- RooRealVar::mean = 5; 0x873e5a0/V- RooRealVar::sigma2 = 1; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf503_wspaceread.py. tutorialsroofitrf503_wspaceread.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf503__wspaceread_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8py.html
Modifiability,config,configured,"Var::p0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::c; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::d; Splitrule for p.d.f model with state list ; parameter m is split with constraint in categories (c); [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: list of prototype pdfs (model); [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: list of splitting categories (c); [#1] INFO:ObjectHandling -- RooSimPdfBuilder::executeBuild: processing prototype pdf model; [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: configured customizers for all prototype pdfs; [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: Customizing prototype pdf model for mode run1; [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: Customizing prototype pdf model for mode run2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooSimultaneous::model_sim; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model_run1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g_run1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m_run1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model_run2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g_run2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m_run2; 0x55656a223190 RooSimultaneous::model_sim = 1 [Auto,Dirty] ; 0x556569c50c80/V- RooCategory::c = run2(idx = 1); ; 0x55656a228010/V- RooAddPdf::model_run1 = 1/1 [Auto,Clean] ; 0x556569f7c820/V- RooGaussian::g_run1 = 1 [Auto,Dirty] ; 0x55656b8aeb30/V- RooRealVar::x = 0; 0x556569f7f4c0/V- RooRealVar::m_run1 = 0; 0x55656b8a01d0/V- RooRealVar::s = 1; 0x556569cc56f0/V- RooRealVar::f = 0.5; 0x55656b8a52d0/V- RooPolynomial::p = 1 [Auto,Dirty] ; 0x55656b8aeb30/V- RooRealVar::x = 0; 0x55656b8a99b0/V- RooRealVar::p0 = 0.01; 0x55656a397b30/V- RooAddPdf::model_run2 = 1/1 [A",MatchSource.WIKI,doc/master/rf504__simwstool_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8C.html
Safety,safe,safe,"; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooSimWSToolThe RooSimWSTool is a tool operating on RooWorkspace objects that can clone PDFs into a series of var...Definition RooSimWSTool.h:38; RooSimultaneousFacilitates simultaneous fitting of multiple PDFs to subsets of a given dataset.Definition RooSimultaneous.h:41; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf504_simwstoolDefinition rf504_simwstool.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::s; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::f; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooPolynomial::p; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::p0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::c; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::d; Splitrule for p.d.f model with state list ; parameter m is split with constraint in categories (c); [#1] INFO:ObjectHandling",MatchSource.WIKI,doc/master/rf504__simwstool_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8C.html
Modifiability,config,configured," importing RooPolynomial::p; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::p0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::c; Splitrule for p.d.f model with state list ; parameter m is split with constraint in categories (c); [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: list of prototype pdfs (model); [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: list of splitting categories (c); [#1] INFO:ObjectHandling -- RooSimPdfBuilder::executeBuild: processing prototype pdf model; [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: configured customizers for all prototype pdfs; [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: Customizing prototype pdf model for mode run1; [#1] INFO:ObjectHandling -- RooSimWSTool::executeBuild: Customizing prototype pdf model for mode run2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooSimultaneous::model_sim; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model_run1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g_run1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m_run1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model_run2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g_run2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m_run2; 0x8977910 RooSimultaneous::model_sim = 1 [Auto,Dirty] ; 0x7e3df80/V- RooCategory::c = run2(idx = 1); ; 0x88c8b40/V- RooAddPdf::model_run1 = 1/1 [Auto,Clean] ; 0x8bb84f0/V- RooGaussian::g_run1 = 1 [Auto,Dirty] ; 0x1c88ae0/V- RooRealVar::x = 0; 0x8baab20/V- RooRealVar::m_run1 = 0; 0x889de80/V- RooRealVar::s = 1; 0x88077e0/V- RooRealVar::f = 0.5; 0x88a49d0/V- RooPolynomial::p = 1 [Auto,Dirty] ; 0x1c88ae0/V- RooRealVar::x = 0; 0x87a0f50/V- RooRealVar::p0 = 0.01; 0x8bf9210/V- RooAddPdf::model_run2 = 1/1 [Auto,Clean] ; 0x896d2a0/V- RooGaussian::g",MatchSource.WIKI,doc/master/rf504__simwstool_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8py.html
Safety,safe,safe,"--------------; ; # Construct a simultaneous pdf with the following form; #; # model_run1(x) = f*gauss_run1(x,m_run1,s) + (1-f)*poly; # model_run2(x) = f*gauss_run2(x,m_run2,s) + (1-f)*poly; # simpdf(x,c) = model_run1(x) if c==""run1""; # = model_run2(x) if c==""run2""; #; # Returned pdf is owned by the workspace; model_sim = sct.build(""model_sim"", ""model"", SplitParam=(""m"", ""c"")); ; # Print tree structure of model; model_sim.Print(""t""); ; # Adjust model_sim parameters in workspace; w.var(""m_run1"").setVal(-3); w.var(""m_run2"").setVal(+3); ; # Print contents of workspace; w.Print(""v""); ; # Build a simultaneous model with product split; # -----------------------------------------------------------------------------------------; ; # Build another simultaneous pdf using a composite split in states c X d; model_sim2 = sct.build(""model_sim2"", ""model"", SplitParam=(""p0"", ""c,d"")); ; # Print tree structure of self model; model_sim2.Print(""t""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::d; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::s; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::f; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooPolynomial::p; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::p0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::c; Splitrule for p.d.f model with state list ; parameter m is split with constraint in categories (c); [#1] INFO:ObjectHandl",MatchSource.WIKI,doc/master/rf504__simwstool_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8py.html
Availability,error,error," RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TStringBasic string class.Definition TString.h:139; TString::AppendTString & Append(const char *cs)Definition TString.h:572; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf505_asciicfgDefinition rf505_asciicfg.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x7ffc52bb96d8 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x7ffc52bb8b20 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7ffc52bb92f0 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x7ffc52bb8f08 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_example.txt; 1) 0x7ffc52bb96d8 RooRealVar:: f = 0.45 +/- 0.03 L(0 - 1) ""f""; 2) 0x7ffc52bb8b20 RooRealVar:: m = 0.025 +/- 0.02 L(-10 - 10) ""m""; 3) 0x7ffc52bb92f0 RooRealVar:: p0 = 0.0022 +/- 0.0001 L(0 - 1) ""p0""; 4) 0x7ffc52bb8f08 RooRealVar:: s = 0.98 +/- 0.03 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing incl",MatchSource.WIKI,doc/master/rf505__asciicfg_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8C.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf505_asciicfg.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf505_asciicfg.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: reading and writing ASCII configuration files ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf505_asciicfg(); {; // C r e a t e p d f; // ------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; // F i t m o d e l t o t o y d a t a; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 1000)};; model.fitTo(*d, PrintLevel(-1));; ; // W r i t e p a r a m e t e r s t o a s c i i f i l e; // -----------------------------------------------------------; ; // Obtain set of parameters; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; ; // Write parameters to file; params->writeToFile(""rf505_asciicfg_example.txt"");; ; TString dir1 = gROOT->GetTutorialDir() ;; dir1.Append(""/roofit/rf505_asciicfg.txt"") ;; TString dir2 = ""rf505_asciicfg_example.txt"";; ; // R e a d p a r a m e t e r s f r o m a s c i i f i l e; // ----------------------------------------------------------------; ; // Read parameters from file; params->readFromFile(dir2);; params->Print(""v"");; ; // Read parameters from section 'Section2' of file; params->readFromFile(dir1, 0, ""Section2"");; params->Print(""v"");; ; // Read parameters from se",MatchSource.WIKI,doc/master/rf505__asciicfg_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8C.html
Modifiability,config,configuration,". ROOT: tutorials/roofit/rf505_asciicfg.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf505_asciicfg.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: reading and writing ASCII configuration files ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf505_asciicfg(); {; // C r e a t e p d f; // ------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; // F i t m o d e l t o t o y d a t a; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 1000)};; model.fitTo(*d, PrintLevel(-1));; ; // W r i t e p a r a m e t e r s t o a s c i i f i l e; // -----------------------------------------------------------; ; // Obtain set of parameters; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; ; // Write parameters to file; params->writeToFile(""rf505_asciicfg_example.txt"");; ; TString dir1 = gROOT->GetTutorialDir() ;; dir1.Append(""/roofit/rf505_asciicfg.txt"") ;; TString dir2 = ""rf505_asciicfg_example.txt"";; ; // R e a d p a r a m e t e r s f r o m a s c i i f i l e; // ----------------------------------------------------------------; ; // Read parameters from file; params->readFromFile(dir2);; params->Print(""v"");; ; // Read parameters from section 'Section2' of file; params->readFromFile(dir1, 0, ""Section2"");; params->Print(""v"");; ; // Read parameters from se",MatchSource.WIKI,doc/master/rf505__asciicfg_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8C.html
Performance,optimiz,optimization," RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TStringBasic string class.Definition TString.h:139; TString::AppendTString & Append(const char *cs)Definition TString.h:572; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf505_asciicfgDefinition rf505_asciicfg.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x7ffc52bb96d8 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x7ffc52bb8b20 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7ffc52bb92f0 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x7ffc52bb8f08 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_example.txt; 1) 0x7ffc52bb96d8 RooRealVar:: f = 0.45 +/- 0.03 L(0 - 1) ""f""; 2) 0x7ffc52bb8b20 RooRealVar:: m = 0.025 +/- 0.02 L(-10 - 10) ""m""; 3) 0x7ffc52bb92f0 RooRealVar:: p0 = 0.0022 +/- 0.0001 L(0 - 1) ""p0""; 4) 0x7ffc52bb8f08 RooRealVar:: s = 0.98 +/- 0.03 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing incl",MatchSource.WIKI,doc/master/rf505__asciicfg_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8C.html
Safety,safe,safe,"ussian.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; gROOT#define gROOTDefinition TROOT.h:406; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TStringBasic string class.Definition TString.h:139; TString::AppendTString & Append(const char *cs)Definition TString.h:572; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf505_asciicfgDefinition rf505_asciicfg.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x7ffc52bb96d8 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x7ffc52bb8b20 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7ffc52bb92f0 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x7ffc52bb8f08 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf5",MatchSource.WIKI,doc/master/rf505__asciicfg_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8C.html
Availability,error,error,"rameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.selectByAttrib(""READ"", False)); ; # Read parameters from section 'Section4' of file, contains; # 'include file' statement of rf505_asciicfg_example.txt; # so that we effective read the same; params.readFromFile(configFile, """", ""Section4""); params.Print(""v""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x803b610 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x79b4c50 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7f83920 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x47c4aa0 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_example.txt; 1) 0x803b610 RooRealVar:: f = 0.45 +/- 0.03 L(0 - 1) ""f""; 2) 0x79b4c50 RooRealVar:: m = 0.025 +/- 0.02 L(-10 - 10) ""m""; 3) 0x7f83920 RooRealVar:: p0 = 0.0022 +/- 0.0001 L(0 - 1) ""p0""; 4) 0x47c4aa0 RooRealVar:: s = 0.98 +/- 0.03 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_example.txt; [",MatchSource.WIKI,doc/master/rf505__asciicfg_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf505_asciicfg.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf505_asciicfg.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: reading and writing ASCII configuration files ; ; from __future__ import print_function; import ROOT; ; ; # Create pdf; # ------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; # Fit model to toy data; # -----------------------------------------; ; d = model.generate({x}, 1000); model.fitTo(d, PrintLevel=-1); ; # Write parameters to ASCII file; # -----------------------------------------------------------; ; # Obtain set of parameters; params = model.getParameters({x}); ; # Write parameters to file; params.writeToFile(""rf505_asciicfg_example.txt""); ; # Read parameters from ASCII file; # ----------------------------------------------------------------; ; # Read parameters from file; params.readFromFile(""rf505_asciicfg_example.txt""); params.Print(""v""); ; configFile = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf505_asciicfg.txt""; ; # Read parameters from section 'Section2' of file; params.readFromFile(configFile, """", ""Section2""); params.Print(""v""); ; # Read parameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.select",MatchSource.WIKI,doc/master/rf505__asciicfg_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html
Modifiability,config,configuration,". ROOT: tutorials/roofit/rf505_asciicfg.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf505_asciicfg.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: reading and writing ASCII configuration files ; ; from __future__ import print_function; import ROOT; ; ; # Create pdf; # ------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; # Fit model to toy data; # -----------------------------------------; ; d = model.generate({x}, 1000); model.fitTo(d, PrintLevel=-1); ; # Write parameters to ASCII file; # -----------------------------------------------------------; ; # Obtain set of parameters; params = model.getParameters({x}); ; # Write parameters to file; params.writeToFile(""rf505_asciicfg_example.txt""); ; # Read parameters from ASCII file; # ----------------------------------------------------------------; ; # Read parameters from file; params.readFromFile(""rf505_asciicfg_example.txt""); params.Print(""v""); ; configFile = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf505_asciicfg.txt""; ; # Read parameters from section 'Section2' of file; params.readFromFile(configFile, """", ""Section2""); params.Print(""v""); ; # Read parameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.select",MatchSource.WIKI,doc/master/rf505__asciicfg_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html
Performance,optimiz,optimization,"rameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.selectByAttrib(""READ"", False)); ; # Read parameters from section 'Section4' of file, contains; # 'include file' statement of rf505_asciicfg_example.txt; # so that we effective read the same; params.readFromFile(configFile, """", ""Section4""); params.Print(""v""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x803b610 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x79b4c50 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7f83920 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x47c4aa0 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_example.txt; 1) 0x803b610 RooRealVar:: f = 0.45 +/- 0.03 L(0 - 1) ""f""; 2) 0x79b4c50 RooRealVar:: m = 0.025 +/- 0.02 L(-10 - 10) ""m""; 3) 0x7f83920 RooRealVar:: p0 = 0.0022 +/- 0.0001 L(0 - 1) ""p0""; 4) 0x47c4aa0 RooRealVar:: s = 0.98 +/- 0.03 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_example.txt; [",MatchSource.WIKI,doc/master/rf505__asciicfg_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html
Safety,safe,safe,"-------------------------------------------------------; ; # Read parameters from file; params.readFromFile(""rf505_asciicfg_example.txt""); params.Print(""v""); ; configFile = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf505_asciicfg.txt""; ; # Read parameters from section 'Section2' of file; params.readFromFile(configFile, """", ""Section2""); params.Print(""v""); ; # Read parameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.selectByAttrib(""READ"", False)); ; # Read parameters from section 'Section4' of file, contains; # 'include file' statement of rf505_asciicfg_example.txt; # so that we effective read the same; params.readFromFile(configFile, """", ""Section4""); params.Print(""v""); [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 1) 0x803b610 RooRealVar:: f = 0.50733 +/- 0.020971 L(0 - 1) ""f""; 2) 0x79b4c50 RooRealVar:: m = 0.0064018 +/- 0.053686 L(-10 - 10) ""m""; 3) 0x7f83920 RooRealVar:: p0 = 0.0073509 +/- 0.0078312 L(0 - 1) ""p0""; 4) 0x47c4aa0 RooRealVar:: s = 0.96516 +/- 0.047052 L(-10 - 10) ""s""; [#1] INFO:InputArguments -- RooArgSet::readFromStream(parameters): processing include file rf505_asciicfg_examp",MatchSource.WIKI,doc/master/rf505__asciicfg_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html
Availability,error,error,"istFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; pr",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
Deployability,configurat,configuration,"d simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // ----------------",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
Integrability,message,message,". ROOT: tutorials/roofit/rf506_msgservice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf506_msgservice.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
Modifiability,config,configuration,"d simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // ----------------",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
Performance,optimiz,optimization,"istFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; pr",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
Safety,safe,safe,"Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopic newTopic)Definition RooMsgService.h:118; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
Testability,log,logging,". ROOT: tutorials/roofit/rf506_msgservice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf506_msgservice.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
Availability,error,error," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
Integrability,message,message,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
Modifiability,config,configuration,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
Performance,optimiz,optimization," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
Safety,safe,safe,"o; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) C",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
Testability,log,logging,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
Availability,error,error,"nitial arguments; RooArgSet s(a, b);; ; // At any time objects can be added with add(); s.add(e);; ; // Add up to 9 additional arguments in one call; s.add(RooArgSet(c, d));; ; // Sets can contain any type of RooAbsArg, also pdf and functions; s.add(g);; ; // Remove element d; s.remove(d);; ; // A c c e s s i n g R o o A r g S e t c o n t e n t s; // -------------------------------------------------------; ; // You can look up objects by name; RooAbsArg *aptr = s.find(""a"");; ; // Construct a subset by name; RooArgSet *subset1 = (RooArgSet *)s.selectByName(""a,b,c"");; ; // Construct asubset by attribute; RooArgSet *subset2 = (RooArgSet *)s.selectByAttrib(""Constant"", true);; ; // Construct the subset of overlapping contents with another set; RooArgSet s1(a, b, c);; RooArgSet s2(c, d, e);; RooArgSet *subset3 = (RooArgSet *)s1.selectCommon(s2);; ; // O w n i n g R o o A r g S e t s; // ---------------------------------; ; // Create a RooArgSet that owns its components; // A set either owns all of its components or none,; // so once addOwned() is used, add() can no longer be; // used and will result in an error message; ; RooRealVar *ac = (RooRealVar *)a.clone(""a"");; RooRealVar *bc = (RooRealVar *)b.clone(""b"");; RooRealVar *cc = (RooRealVar *)c.clone(""c"");; ; RooArgSet s3;; s3.addOwned(RooArgSet(*ac, *bc, *cc));; ; // Another possibility is to add an owned clone; // of an object instead of the original; s3.addClone(RooArgSet(d, e, g));; ; // A clone of a owning set is non-owning and its; // contents is owned by the originating owning set; RooArgSet *sclone = (RooArgSet *)s3.Clone(""sclone"");; ; // To make a clone of a set and its contents use; // the snapshot method; RooArgSet *sclone2 = (RooArgSet *)s3.snapshot();; ; // If a set contains function objects, only the head node; // is cloned in a snapshot. To make a snapshot of all; // servers of a function object do as follows. The result; // of a RooArgSet snapshot with deepCloning option is a set; // of cloned objects, and ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
Integrability,message,message,"nitial arguments; RooArgSet s(a, b);; ; // At any time objects can be added with add(); s.add(e);; ; // Add up to 9 additional arguments in one call; s.add(RooArgSet(c, d));; ; // Sets can contain any type of RooAbsArg, also pdf and functions; s.add(g);; ; // Remove element d; s.remove(d);; ; // A c c e s s i n g R o o A r g S e t c o n t e n t s; // -------------------------------------------------------; ; // You can look up objects by name; RooAbsArg *aptr = s.find(""a"");; ; // Construct a subset by name; RooArgSet *subset1 = (RooArgSet *)s.selectByName(""a,b,c"");; ; // Construct asubset by attribute; RooArgSet *subset2 = (RooArgSet *)s.selectByAttrib(""Constant"", true);; ; // Construct the subset of overlapping contents with another set; RooArgSet s1(a, b, c);; RooArgSet s2(c, d, e);; RooArgSet *subset3 = (RooArgSet *)s1.selectCommon(s2);; ; // O w n i n g R o o A r g S e t s; // ---------------------------------; ; // Create a RooArgSet that owns its components; // A set either owns all of its components or none,; // so once addOwned() is used, add() can no longer be; // used and will result in an error message; ; RooRealVar *ac = (RooRealVar *)a.clone(""a"");; RooRealVar *bc = (RooRealVar *)b.clone(""b"");; RooRealVar *cc = (RooRealVar *)c.clone(""c"");; ; RooArgSet s3;; s3.addOwned(RooArgSet(*ac, *bc, *cc));; ; // Another possibility is to add an owned clone; // of an object instead of the original; s3.addClone(RooArgSet(d, e, g));; ; // A clone of a owning set is non-owning and its; // contents is owned by the originating owning set; RooArgSet *sclone = (RooArgSet *)s3.Clone(""sclone"");; ; // To make a clone of a set and its contents use; // the snapshot method; RooArgSet *sclone2 = (RooArgSet *)s3.snapshot();; ; // If a set contains function objects, only the head node; // is cloned in a snapshot. To make a snapshot of all; // servers of a function object do as follows. The result; // of a RooArgSet snapshot with deepCloning option is a set; // of cloned objects, and ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf508_listsetmanip.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf508_listsetmanip.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: RooArgSet and RooArgList tools and tricks ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooArgSet.h""; #include ""RooArgList.h""; #include ""RooCategory.h""; using namespace RooFit;; ; void rf508_listsetmanip(); {; ; // C r e a t e d u m m y o b j e c t s; // ---------------------------------------; ; // Create some variables; RooRealVar a(""a"", ""a"", 1, -10, 10);; RooRealVar b(""b"", ""b"", 2, -10, 10);; RooRealVar c(""c"", ""c"", 3, -10, 10);; RooRealVar d(""d"", ""d"", 4, -10, 10);; RooRealVar x(""x"", ""x"", 0, -10, 10);; c.setError(0.5);; a.setConstant();; b.setConstant();; ; // Create a category; RooCategory e(""e"", ""e"");; e.defineType(""sig"");; e.defineType(""bkg"");; ; // Create a pdf; RooGaussian g(""g"", ""g"", x, a, b);; ; // C r e a t i n g , f i l l i n g R o o A r g S e t s; // -------------------------------------------------------; ; // A RooArgSet is a set of RooAbsArg objects. Each object in the set must have; // a unique name; ; // Set constructors exists with up to 9 initial arguments; RooArgSet s(a, b);; ; // At any time objects can be added with add(); s.add(e);; ; // Add up to 9 additional arguments in one call; s.add(RooArgSet(c, d));; ; // Sets can contain any type of RooAbsArg, also pdf and functions; s.add(g);; ; // Remove element d; s.remove(d);; ; // A c c e s s i n g R o o A r g S e t c o n t e n t s; // -------------------------------------------------------; ; // You can look up objects by name; RooAbsArg *aptr = s.find(""a"");; ; // Construct a subset by name; RooArgSet *subset1 = (RooArgSet *)s.selectByName(""a,b,c"");; ; // Construct asubset by attribute; RooArgSet *subset2 = (RooArgSet *)s.selectByA",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
Safety,safe,safe,"y=true) constUse RooAbsCollection::snapshot(), but return as RooArgSet.Definition RooArgSet.h:154; RooArgSet::selectByNameRooArgSet * selectByName(const char *nameList, bool verbose=false) constUse RooAbsCollection::selectByName(), but return as RooArgSet.Definition RooArgSet.h:144; RooArgSet::selectCommonRooArgSet * selectCommon(const RooAbsCollection &refColl) constUse RooAbsCollection::selecCommon(), but return as RooArgSet.Definition RooArgSet.h:149; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::cloneTObject * clone(const char *newname) const overrideDefinition RooRealVar.h:48; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf508_listsetmanipDefinition rf508_listsetmanip.py:1; lTLine lDefinition textangle.C:4; ; [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; sclone = (a,b,c,d,e,g); RooArgSet::sclone = (a,b,c,d,e,g); 1) RooRealVar:: a = 1; 2) RooRealVar:: b = 2; 3) RooRealVar:: c = 3 +/- 0.5; 4) RooRealVar:: d = 4; 5) RooCategory:: e = sig(idx = 0); ; 6) RooGaussian:: g = 0.882497; 1) 0x5569466c3940 RooRealVar:: a = 1 C L(-10 - 10) ""a""; 2) 0x556948df5f70 RooRealVar:: b = 2 C L(-10 - 10) ""b""; 3) 0x556946cacdc0 RooRealVar:: c = 3 +/- 0.5 L(-10 - 10) ""c""; 4) 0x5569492af150 RooRealVar:: d = 4 L(-10 - 10) ""d""; 5) 0x5569468860e0 RooCategory:: e = sig(idx = 0); ""e""; 6) 0x5569458db0b0 RooGaussian:: g[ x=x mean=a sigma=b ] = 0.882497 ""g""; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf508_listsetmanip.C. tutorialsroofitrf508_listsetmanip.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
Availability,error,error," s = ROOT.RooArgSet(a, b); ; # At any time objects can be added with add(); s.add(e); ; # Add up to 9 additional arguments in one call; # s.add(ROOT.RooArgSet(c, d)); s.add(c); s.add(d); ; # Sets can contain any type of RooAbsArg, pdf and functions; s.add(g); ; # Remove element d; s.remove(d); ; # Accessing RooArgSet contents; # -------------------------------------------------------; ; # You can look up objects by name; aptr = s.find(""a""); ; # Construct a subset by name; subset1 = s.selectByName(""a,b,c""); ; # Construct asubset by attribute; subset2 = s.selectByAttrib(""Constant"", ROOT.kTRUE); ; # Construct the subset of overlapping contents with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ; # You can create a RooArgSet that owns copies of the objects instead of; # referencing the originals. A set either owns all of its components or none,; # so once addClone() is used, add() can no longer be used and will result in an; # error message; s3 = ROOT.RooArgSet(); for arg in [a, b, c, d, e, g]:; s3.addClone(arg); ; # A clone of a owning set is non-owning and its; # contents is owned by the originating owning set; sclone = s3.Clone(""sclone""); ; # To make a clone of a set and its contents use; # the snapshot method; sclone2 = s3.snapshot(); ; # If a set contains function objects, the head node; # is cloned in a snapshot. To make a snapshot of all; # servers of a function object do as follows. The result; # of a RooArgSet snapshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standar",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
Integrability,message,message," s = ROOT.RooArgSet(a, b); ; # At any time objects can be added with add(); s.add(e); ; # Add up to 9 additional arguments in one call; # s.add(ROOT.RooArgSet(c, d)); s.add(c); s.add(d); ; # Sets can contain any type of RooAbsArg, pdf and functions; s.add(g); ; # Remove element d; s.remove(d); ; # Accessing RooArgSet contents; # -------------------------------------------------------; ; # You can look up objects by name; aptr = s.find(""a""); ; # Construct a subset by name; subset1 = s.selectByName(""a,b,c""); ; # Construct asubset by attribute; subset2 = s.selectByAttrib(""Constant"", ROOT.kTRUE); ; # Construct the subset of overlapping contents with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ; # You can create a RooArgSet that owns copies of the objects instead of; # referencing the originals. A set either owns all of its components or none,; # so once addClone() is used, add() can no longer be used and will result in an; # error message; s3 = ROOT.RooArgSet(); for arg in [a, b, c, d, e, g]:; s3.addClone(arg); ; # A clone of a owning set is non-owning and its; # contents is owned by the originating owning set; sclone = s3.Clone(""sclone""); ; # To make a clone of a set and its contents use; # the snapshot method; sclone2 = s3.snapshot(); ; # If a set contains function objects, the head node; # is cloned in a snapshot. To make a snapshot of all; # servers of a function object do as follows. The result; # of a RooArgSet snapshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standar",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf508_listsetmanip.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf508_listsetmanip.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #508 ; RooArgSet and RooArgList tools and tricks; ; from __future__ import print_function; import ROOT; ; ; # Create dummy objects; # ---------------------------------------; ; # Create some variables; a = ROOT.RooRealVar(""a"", ""a"", 1, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 2, -10, 10); c = ROOT.RooRealVar(""c"", ""c"", 3, -10, 10); d = ROOT.RooRealVar(""d"", ""d"", 4, -10, 10); x = ROOT.RooRealVar(""x"", ""x"", 0, -10, 10); c.setError(0.5); a.setConstant(); b.setConstant(); ; # Create a category; e = ROOT.RooCategory(""e"", ""e""); e.defineType(""sig""); e.defineType(""bkg""); ; # Create a pdf; g = ROOT.RooGaussian(""g"", ""g"", x, a, b); ; # Creating, killing RooArgSets; # -------------------------------------------------------; ; # A ROOT.RooArgSet is a set of RooAbsArg objects. Each object in the set must have; # a unique name; ; # Set constructors exists with up to 9 initial arguments; s = ROOT.RooArgSet(a, b); ; # At any time objects can be added with add(); s.add(e); ; # Add up to 9 additional arguments in one call; # s.add(ROOT.RooArgSet(c, d)); s.add(c); s.add(d); ; # Sets can contain any type of RooAbsArg, pdf and functions; s.add(g); ; # Remove element d; s.remove(d); ; # Accessing RooArgSet contents; # -------------------------------------------------------; ; # You can look up objects by name; aptr = s.find(""a""); ; # Construct a subset by name; subset1 = s.selectByName(""a,b,c""); ; # Construct asubset by attribute; subset2 = s.selectByAttrib(""Constant"", ROOT.kTRUE); ; # Construct the subset of overlapping contents with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
Safety,safe,safe,"apshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standard printing shows one line for each item with the items name, name; # and value; sclone.Print(""s""); ; # Verbose printing adds each items arguments, and 'extras' as defined by; # the object; sclone.Print(""v""); ; # Using RooArgLists; # ---------------------------------; ; # List constructors exists with up to 9 initial arguments; l = ROOT.RooArgList(a, b, c, d); ; # Lists have an explicit order and allow multiple arguments with the same; # name; l.add(ROOT.RooArgList(a, b, c, d)); ; # Access by index is provided; arg4 = l.at(4); [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; RooArgSet::sclone = (a,b,c,d,e,g); 1) RooRealVar:: a = 1; 2) RooRealVar:: b = 2; 3) RooRealVar:: c = 3 +/- 0.5; 4) RooRealVar:: d = 4; 5) RooCategory:: e = sig(idx = 0); ; 6) RooGaussian:: g = 0.882497; 1) 0x7b39df0 RooRealVar:: a = 1 C L(-10 - 10) ""a""; 2) 0x7b3a1e0 RooRealVar:: b = 2 C L(-10 - 10) ""b""; 3) 0x7b13900 RooRealVar:: c = 3 +/- 0.5 L(-10 - 10) ""c""; 4) 0x7aa7d60 RooRealVar:: d = 4 L(-10 - 10) ""d""; 5) 0x7e8fbd0 RooCategory:: e = sig(idx = 0); ""e""; 6) 0x7ea8d00 RooGaussian:: g[ x=x mean=a sigma=b ] = 0.882497 ""g""; sclone = { @0x7eaa940, @0x7eaa948, @0x7eaa950, @0x7eaa958, @0x7eaa960, @0x7eaa968 }; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf508_listsetmanip.py. tutorialsroofitrf508_listsetmanip.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
Availability,error,error,"rkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf509_wsinteractive.C. tutorialsroofitrf509_wsinteractive.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
Integrability,interface,interface,""", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; w.import(model);; }; d#define d(i)Definition RSha256.hxx:102; kDashed@ kDashedDefinition TAttLine.h:48; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAddPdfEfficient imple",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
Modifiability,variab,variable,"rence Guide ; .  . Loading...; Searching...; No Matches. rf509_wsinteractive.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf509_wsinteractive(); {; // C r e a t e a n d f i l l w o r k s p a c e; // ------------------------------------------------; ; // Create a workspace named 'w'; // With CINT w could exports its contents to; // a same-name C++ namespace in CINT 'namespace w'.; // but this does not work anymore in CLING.; // so this tutorial is an example on how to; // change the code; RooWorkspace *w1 = new RooWorkspace(""w"", true);; ; // Fill workspace with pdf and data in a separate function; fillWorkspace(*w1);; ; // Print workspace contents; w1->Print();; ; // this does not work anymore with CLING; // use normal workspace functionality; ; // U s e w o r k s p a c e c o n t e n t s; // ----------------------------------------------; ; // use normal workspace methods; RooAbsPdf *model = w1->pdf(""model"");; RooRealVar *x = w1->var(""x"");; ; std::unique_ptr<RooDataSet> d{ model->generate(*x, 1000)};; std::unique_ptr<RooFitResult> r{model->fitTo(*d, PrintLevel(-1))};; ; // old syntax to access the variable x; // RooPlot* frame = w::x.frame() ;; ; RooPlot *frame = x->frame();; d->plotOn(frame);; ; // OLD syntax to omit x::; // NB: The 'w::' prefix can be omitted if namespace w is imported in local namespace; // in the usual C++ way; //; // using namespace w;; // model.plotOn(frame) ;; // model.plotOn(frame,Components(bkg),LineStyle(kDashed)) ;; ; // new correct syntax; RooAbsPdf *bkg = w1->pdf(""bkg"");; model->plotOn(frame);; model->plotOn(frame, Components(*bkg), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
Performance,optimiz,optimization,"rkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf509_wsinteractive.C. tutorialsroofitrf509_wsinteractive.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
Safety,safe,safe,"iew name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
Security,access,access,". ROOT: tutorials/roofit/rf509_wsinteractive.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf509_wsinteractive.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf509_wsinteractive(); {; // C r e a t e a n d f i l l w o r k s p a c e; // ------------------------------------------------; ; // Create a workspace named 'w'; // With CINT w could exports its contents to; // a same-name C++ namespace in CINT 'namespace w'.; // but this does not work anymore in CLING.; // so this tutorial is an example on how to; // change the code; RooWorkspace *w1 = new RooWorkspace(""w"", true);; ; // Fill workspace with pdf and data in a separate function; fillWorkspace(*w1);; ; // Print workspace contents; w1->Print();; ; // this does not work anymore with CLING; // use normal workspace functionality; ; // U s e w o r k s p a c e c o n t e n t s; // ----------------------------------------------; ; // use normal workspace methods; RooAbsPdf *model = w1->pdf(""model"");; RooRealVar *x = w1->var(""x"");; ; std::unique_ptr<RooDataSet> d{ model->generate(*x, 1000)};; std::unique_ptr<RooFitResult> r{model->fitTo(*d, PrintLevel(-1))};; ; // old syntax to access the variable x; // RooPlot* frame = w::x.frame() ;; ; RooPlot *frame = x->frame();; d->plotOn(frame);; ; // OLD syntax to omit x::; // NB: The 'w::' prefix can be omitted if namespace w is imported in local namespace; // in the usual C++ way; //; // using namespace w;; // model.plotOn(frame) ;; // model.plotOn(frame,Components(bkg),LineStyle(kDashed)) ;; ; // new correct syntax; RooAbsPdf *bkg = w1->pdf(""bkg"");; model->plotOn(frame);; model->plotOn(frame, Components(*bkg), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"",",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
Availability,error,error,"oRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf509_wsinteractive.py. tutorialsroofitrf509_wsinteractive.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
Modifiability,variab,variable,"f(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and data in a separate function; fillWorkspace(w); ; # Print workspace contents; w.Print(); ; # self does not work anymore with CLING; # use normal workspace functionality; ; # Use workspace contents; # ----------------------------------------------; ; # Old syntax to use the name space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
Performance,optimiz,optimization,"oRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf509_wsinteractive.py. tutorialsroofitrf509_wsinteractive.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
Safety,safe,safe,"ame space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Object",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
Security,access,access,". ROOT: tutorials/roofit/rf509_wsinteractive.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf509_wsinteractive.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; import ROOT; ; ; def fillWorkspace(w):; # Create pdf and fill workspace; # --------------------------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, 0, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and da",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
Availability,error,errors,"ve in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snapshot; std::unique_ptr<RooDataSet> refData{model.generate(x, 10000)};; model.fitTo(*refData, PrintLevel(-1));; ; // The true flag imports the values of the objects in (*params) into the workspace; // If not set, the present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", *params, true);; ; // Make another fit with the signal component forced to zero; // and save those parameters too; ; bkgfrac.setVal(1);; bkgfrac.setConstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
Integrability,interface,interface,"onstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TFile.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsArg::getParametersRooFit::OwningPtr< RooArgSet > getParameters(const RooAbsData *data, bool stripDisconnected=true) constCreate a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of...Definition RooAbsArg.cxx:541; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAddPdfEfficient impl",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
Modifiability,variab,variables,", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // Import model into pdf; w.import(model);; ; // E n c o d e d e f i n i t i o n o f p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------; ; // Define named sets ""parameters"" and ""observables"", which list which variables should be considered; // parameters and observables by the users convention; //; // Variables appearing in sets _must_ live in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using t",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
Performance,load,loadSnapshot,"oFit Tutorials. Detailed Description; Organization and simultaneous fits: working with named parameter sets and parameter snapshots in workspaces . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf510_wsnamedsets(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; RooWorkspace *w = new RooWorkspace(""w"");; fillWorkspace(*w);; ; // Exploit convention encoded in named set ""parameters"" and ""observables""; // to use workspace contents w/o need for introspected; RooAbsPdf *model = w->pdf(""model"");; ; // Generate data from pdf in given observables; std::unique_ptr<RooDataSet> data{model->generate(*w->set(""observables""), 1000)};; ; // Fit model to data; model->fitTo(*data, PrintLevel(-1));; ; // Plot fitted model and data on frame of first (only) observable; RooPlot *frame = ((RooRealVar *)w->set(""observables"")->first())->frame();; data->plotOn(frame);; model->plotOn(frame);; ; // Overlay plot with model with reference parameters as stored in snapshots; w->loadSnapshot(""reference_fit"");; model->plotOn(frame, LineColor(kRed));; w->loadSnapshot(""reference_fit_bkgonly"");; model->plotOn(frame, LineColor(kRed), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; ; // Print workspace contents; w->Print();; ; // Workspace will remain in memory after macro finishes; gDirectory->Add(w);; }; ; void fillWorkspace(RooWorkspace &w); {; // C r e a t e m o d e l; // -----------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
Safety,safe,safe,"s objects within that frame.Definition RooPlot.h:45; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf510_wsnamedsetsDefinition rf510_wsnamedsets.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
Availability,error,errors,"ters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, PrintLevel=-1); ; # The kTRUE flag imports the values of the objects in (*params) into the workspace; # If not set, present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
Modifiability,variab,variables,"OT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial p.d.f.; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal p.d.f.; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Import model into p.d.f.; w.Import(model); ; # Encode definition of parameters in workspace; # ---------------------------------------------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
Performance,load,loadSnapshot,"----------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, PrintLevel=-1); ; # The kTRUE flag imports the values of the objects in (*params) into the workspace; # If not set, present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
Safety,safe,safe,"rospected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
Integrability,depend,depending,"ac[0.5,0.,1.]*bkg,sig)"");; ; } else {; ; // Use object factory to build pdf of tutorial rs502_wspacewrite but; // - Contracted to a single line recursive expression,; // - Omitting explicit names for components that are not referred to explicitly later; ; w->factory(""SUM::model(bkgfrac[0.5,0.,1.]*Chebychev::bkg(x[-10,10],{a0[0.5,0.,1],a1[0.2,0.,1.]}),""; ""SUM(sig1frac[0.8,0.,1.]*Gaussian(x,mean[5,0,10],0.5), Gaussian(x,mean,1)))"");; }; ; // A d v a n c e d p . d . f . c o n s t r u c t o r a r g u m e n t s; // ----------------------------------------------------------------; //; // P.d.f. constructor arguments may by any type of RooAbsArg, but also; //; // double --> converted to RooConst(...); // {a,b,c} --> converted to RooArgSet() or RooArgList() depending on required ctor arg; // dataset name --> converted to RooAbsData reference for any dataset residing in the workspace; // enum --> Any enum label that belongs to an enum defined in the (base) class; ; // Make a dummy dataset pdf 'model' and import it in the workspace; std::unique_ptr<RooDataSet> data{w->pdf(""model"")->generate(*w->var(""x""), 1000)};; w->import(*data, Rename(""data""));; ; // Construct a KEYS pdf passing a dataset name and an enum type defining the; // mirroring strategy; w->factory(""KeysPdf::k(x,data,NoMirror,0.2)"");; ; // Print workspace contents; w->Print();; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFit::RenameRooCmdArg Rename(const char *suffix)Definition RooGlobalFunc.cxx:1055; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or o",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html
Modifiability,variab,variables,"ake a dummy dataset pdf 'model' and import it in the workspace; std::unique_ptr<RooDataSet> data{w->pdf(""model"")->generate(*w->var(""x""), 1000)};; w->import(*data, Rename(""data""));; ; // Construct a KEYS pdf passing a dataset name and an enum type defining the; // mirroring strategy; w->factory(""KeysPdf::k(x,data,NoMirror,0.2)"");; ; // Print workspace contents; w->Print();; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFit::RenameRooCmdArg Rename(const char *suffix)Definition RooGlobalFunc.cxx:1055; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf511_wsfactory_basicDefinition rf511_wsfactory_basic.py:1; ; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; [#1] INFO:ObjectHandling -- RooWorkSpace::import(w) changing name of dataset from modelData to data; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooKeysPdf::k[ x=x ] = 0.0210129; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.4/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 7.45331e-07/1; RooGaussian::sig1[ x=x mean=mean sigma=0.5 ] = 1.92875e-22; RooGaussian::sig2[ x=x mean=mean sigma=1 ] = 3.72665e-06; ; datasets; --------; RooDataSet::data(x); ; DateJuly 2009 ; AuthorWouter Verkerke ; Definition in file rf511_wsfactory_basic.C. tutorialsroofitrf511_wsfactory_basic.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html
Integrability,depend,depending,"wspacewrite; w.factory(""Gaussian::sig1(x[-10,10],mean[5,0,10],0.5)""); w.factory(""Gaussian::sig2(x,mean,1)""); w.factory(""Chebychev::bkg(x,{a0[0.5,0.,1],a1[-0.2,0.,1.]})""); w.factory(""SUM::sig(sig1frac[0.8,0.,1.]*sig1,sig2)""); w.factory(""SUM::model(bkgfrac[0.5,0.,1.]*bkg,sig)""); ; else:; ; # Use object factory to build pdf of tutorial rs502_wspacewrite but; # - Contracted to a single line recursive expression,; # - Omitting explicit names for components that are not referred to explicitly later; ; w.factory(; ""SUM::model(bkgfrac[0.5,0.,1.]*Chebychev::bkg(x[-10,10],{a0[0.5,0.,1],a1[-0.2,0.,1.]}), ""; ""SUM(sig1frac[0.8,0.,1.]*Gaussian(x,mean[5,0,10],0.5), Gaussian(x,mean,1)))""; ); ; # Advanced pdf constructor arguments; # ----------------------------------------------------------------; #; # P.d.f. constructor arguments may by any type of ROOT.RooAbsArg, also; #; # Double_t -. converted to ROOT.RooConst(...); # {a,b,c} -. converted to ROOT.RooArgSet() or ROOT.RooArgList() depending on required ctor arg; # dataset name -. converted to ROOT.RooAbsData reference for any dataset residing in the workspace; # enum -. Any enum label that belongs to an enum defined in the (base); # class; ; # Make a dummy dataset pdf 'model' and import it in the workspace; data = w[""model""].generate({w[""x""]}, 1000); # Cannot call 'import' directly because this is a python keyword:; w.Import(data, Rename=""data""); ; # Construct a KEYS pdf passing a dataset name and an enum type defining the; # mirroring strategy; # w.factory(""KeysPdf::k(x,data,NoMirror,0.2)""); # Workaround for pyROOT; x = w[""x""]; k = ROOT.RooKeysPdf(""k"", ""k"", x, data, ROOT.RooKeysPdf.NoMirror, 0.2); w.Import(k, RenameAllNodes=""workspace""); ; # Print workspace contents; w.Print(); [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; [#1] INFO:ObjectHandling -- RooWorkSpace::import(w) changing name of dataset from modelData to data; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) Resolving name confli",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8py.html
Modifiability,variab,variables,"OOT.RooConst(...); # {a,b,c} -. converted to ROOT.RooArgSet() or ROOT.RooArgList() depending on required ctor arg; # dataset name -. converted to ROOT.RooAbsData reference for any dataset residing in the workspace; # enum -. Any enum label that belongs to an enum defined in the (base); # class; ; # Make a dummy dataset pdf 'model' and import it in the workspace; data = w[""model""].generate({w[""x""]}, 1000); # Cannot call 'import' directly because this is a python keyword:; w.Import(data, Rename=""data""); ; # Construct a KEYS pdf passing a dataset name and an enum type defining the; # mirroring strategy; # w.factory(""KeysPdf::k(x,data,NoMirror,0.2)""); # Workaround for pyROOT; x = w[""x""]; k = ROOT.RooKeysPdf(""k"", ""k"", x, data, ROOT.RooKeysPdf.NoMirror, 0.2); w.Import(k, RenameAllNodes=""workspace""); ; # Print workspace contents; w.Print(); [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; [#1] INFO:ObjectHandling -- RooWorkSpace::import(w) changing name of dataset from modelData to data; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) Resolving name conflict in workspace by changing name of imported node k to k_workspace; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooKeysPdf::k_workspace; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooKeysPdf::k_workspace[ x=x ] = 0.0139016; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.5/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 7.45331e-07/1; RooGaussian::sig1[ x=x mean=mean sigma=0.5 ] = 1.92875e-22; RooGaussian::sig2[ x=x mean=mean sigma=1 ] = 3.72665e-06; ; datasets; --------; RooDataSet::data(x); ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf511_wsfactory_basic.py. tutorialsroofitrf511_wsfactory_basic.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8py.html
Modifiability,coupling,couplings,"gy( y[-10,10], x, 1.0 )"");; w->factory(""PROD::gxycond( gy|x, gx )"");; ; // Convolution (numeric/ fft) is done with NCONV/FCONV (obs,pdf1,pdf2); w->factory(""FCONV::lxg( x, Gaussian::g(x,mg[0],1), Landau::lc(x,0,1) )"");; ; // Simultaneous pdfs are constructed with SIMUL( index, state1=pdf1, state2=pdf2,...); w->factory(""SIMUL::smodel( c[A=0,B=1], A=Gaussian::gs(x,m,s[1.0, 0.01, 10.0]), B=Landau::ls(x,0,1) )"");; ; // O p e r a t o r f u n c t i o n e x a m p l e s; // ---------------------------------------------------; ; // Function multiplication is done with prod (func1, func2,...); w->factory(""prod::uv(u[10],v[10])"");; ; // Function addition is done with sum(func1,func2); w->factory(""sum::uv2(u,v)"");; ; // Lagrangian morphing function for the example shown in rf711_lagrangianmorph; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; w->factory((""lagrangianmorph::morph($fileName('""+infilename+""'),$observableName('pTV'),$couplings({cHq3[0,1],SM[1]}),$NewPhysics(cHq3=1,SM=0),$folders({'SM_NPsq0','cHq3_NPsq1','cHq3_NPsq2'}))"").c_str());; ; ; // Taylor expansion is done with taylorexpand(func,{var1,var2,...},val,order); w->factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)"");; ; ; // I n t e r p r e t e d a n d c o m p i l e d e x p r e s s i o n b a s e d p . d . f . s .; // ---------------------------------------------------------------------------------------------------; ; // Create a RooGenericPdf interpreted pdf You can use single quotes to pass the expression string argument; w->factory(""EXPR::G('x*x+1',x)"");; ; // Create a custom compiled pdf similar to the above interpreted pdf; // The code required to make this pdf is automatically embedded in the workspace; w->factory(""CEXPR::GC('x*x+a',{x,a[1]})"");; ; // Compiled and interpreted functions (rather than pdfs) can be made with the lower case; // 'expr' and 'cexpr' types; ; // Print workspace contents; w->Print();; ; // Make works",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html
Performance,cache,cache,"; w->factory(""CEXPR::GC('x*x+a',{x,a[1]})"");; ; // Compiled and interpreted functions (rather than pdfs) can be made with the lower case; // 'expr' and 'cexpr' types; ; // Print workspace contents; w->Print();; ; // Make workspace visible on command line; gDirectory->Add(w);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; gROOT#define gROOTDefinition TROOT.h:406; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf512_wsfactory_operDefinition rf512_wsfactory_oper.py:1; ; [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html
Modifiability,coupling,couplings,"ssian::gy( y[-10,10], x, 1.0 )""); w.factory(""PROD::gxycond( gy|x, gx )""); ; # Convolution (numeric/ fft) is done with NCONV/FCONV (obs,pdf1,pdf2); w.factory(""FCONV::lxg( x, Gaussian::g(x,mg[0],1), Landau::lc(x,0,1) )""); ; # Simultaneous p.d.f.s are constructed with SIMUL( index, state1=pdf1,; # state2=pdf2,...); w.factory(""SIMUL::smodel( c[A=0,B=1], A=Gaussian::gs(x,m,s[1.0, 0.01, 10.0]), B=Landau::ls(x,0,1) )""); ; # Operator function examples; # ---------------------------------------------------; ; # Function multiplication is done with prod (func1, func2,...); w.factory(""prod::uv(u[10],v[10])""); ; # Function addition is done with sum(func1,func2); w.factory(""sum::uv2(u,v)""); ; # Lagrangian morphing function for the example shown in rf711_lagrangianmorph; infilename = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/input_histos_rf_lagrangianmorph.root""; w.factory(; ""lagrangianmorph::morph($observableName('pTV'),$fileName('""; + infilename; + ""'),$couplings({cHq3[0,1],SM[1]}),$NewPhysics(cHq3=1,SM=0),$folders({'SM_NPsq0','cHq3_NPsq1','cHq3_NPsq2'}))""; ); ; # Taylor expansion is done with taylorexpand(func,{var1,var2,...},val,order); w.factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)""); ; ; # Interpreted and compiled expression based pdfs; # ---------------------------------------------------------------------------------------------------; ; # Create a ROOT.RooGenericPdf interpreted p.d.f. You can use single quotes; # to pass the expression string argument; w.factory(""EXPR::G('x*x+1',x)""); ; # Create a custom compiled p.d.f similar to the above interpreted p.d.f.; # The code required to make self p.d.f. is automatically embedded in; # the workspace; w.factory(""CEXPR::GC('x*x+a',{x,a[1]})""); ; # Compiled and interpreted functions (rather than p.d.f.s) can be made with the lower case; # 'expr' and 'cexpr' types; ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); [#1] INFO:Caching -- Changin",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html
Performance,cache,cache," w.factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)""); ; ; # Interpreted and compiled expression based pdfs; # ---------------------------------------------------------------------------------------------------; ; # Create a ROOT.RooGenericPdf interpreted p.d.f. You can use single quotes; # to pass the expression string argument; w.factory(""EXPR::G('x*x+1',x)""); ; # Create a custom compiled p.d.f similar to the above interpreted p.d.f.; # The code required to make self p.d.f. is automatically embedded in; # the workspace; w.factory(""CEXPR::GC('x*x+a',{x,a[1]})""); ; # Compiled and interpreted functions (rather than p.d.f.s) can be made with the lower case; # 'expr' and 'cexpr' types; ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html
Integrability,interface,interface,". ROOT: tutorials/roofit/rf513_wsfactory_tools.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf513_wsfactory_tools.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: RooCustomizer and RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf513_wsfactory_tools(); {; RooWorkspace *w = new RooWorkspace(""w"");; ; // B u i l d a c o m p l e x e x a m p l e p . d . f .; // -----------------------------------------------------------; ; // Make signal model for CPV: A bmixing decay function in t (convoluted with a triple Gaussian resolution model); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
Modifiability,parameteriz,parameterizations,"odel); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to 4 flavour tagging techniques with different performance that require different; // parameterizations of the fit model; //; // RooSimWSTool operation:; // - Make 4 clones of model (for each tagCat) state, that will gain an individual; // copy of parameters w,dw and biasC. The other parameters remain common; // - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; // state of the tagCat index category; ; // RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); // argument maps to the SplitParam() named argument in the RooSimWSTool constructor; w->factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))"");; ; // E x a m p l e o f R o o C u s t o m i z e r i n t e r f a c e; // -------------------------------------------------------------------; //; // Class RooCustomizer makes clones of existing pdfs with certain prescribed; // modifications ",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
Performance,perform,performance,"odel); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to 4 flavour tagging techniques with different performance that require different; // parameterizations of the fit model; //; // RooSimWSTool operation:; // - Make 4 clones of model (for each tagCat) state, that will gain an individual; // copy of parameters w,dw and biasC. The other parameters remain common; // - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; // state of the tagCat index category; ; // RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); // argument maps to the SplitParam() named argument in the RooSimWSTool constructor; w->factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))"");; ; // E x a m p l e o f R o o C u s t o m i z e r i n t e r f a c e; // -------------------------------------------------------------------; //; // Class RooCustomizer makes clones of existing pdfs with certain prescribed; // modifications ",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
Integrability,interface,interface,". ROOT: tutorials/roofit/rf513_wsfactory_tools.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf513_wsfactory_tools.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: illustration use of ROOT.RooCustomizer and ROOT.RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ; ; import ROOT; ; ; w = ROOT.RooWorkspace(""w""); ; # Build a complex example pdf; # -----------------------------------------------------------; ; # Make signal model for CPV: A bmixing decay function in t (convoluted with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other paramete",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
Modifiability,parameteriz,parameterizations," with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf no",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
Performance,perform,performance," with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf no",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
Integrability,depend,depending," register them in the set of customiser nodes.; // The customiser will pick them up instead of creating new ones.; // If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; RooRealVar mass(""M"", ""M"", 1, 0, 12000);; RooFormulaVar yield1(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass);; RooFormulaVar yield2(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass);; allCustomiserNodes.add(yield1);; allCustomiserNodes.add(yield2);; ; // Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample);; ; ; // Now we can start building the PDFs for all categories:; auto pdf1 = cust.build(""Sample1"");; auto pdf2 = cust.build(""Sample2"");; auto pdf3 = cust.build(""Sample3"");; ; // And we inspect the two PDFs; std::cout << ""\nPDF 1 with a yield depending on M:"" << std::endl;; pdf1->Print(""T"");; std::cout << ""\nPDF 2 with a yield depending on M:"" << std::endl;; pdf2->Print(""T"");; std::cout << ""\nPDF 3 with a free yield:"" << std::endl;; pdf3->Print(""T"");; ; std::cout << ""\nThe following leaves have been created automatically while customising:"" << std::endl;; newLeaves.Print(""V"");; ; ; // If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; auto& meanG1 = static_cast<RooRealVar&>(allCustomiserNodes[""meanG_Sample1""]);; meanG1.setVal(200);; auto& meanG2 = static_cast<RooRealVar&>(allCustomiserNodes[""meanG_Sample2""]);; meanG2.setVal(300);; ; std::cout << ""\nThe following leaves have been used while customising""; << ""\n\t(partial overlap with the set of automatically created leaves.""; << ""\n\ta new customiser for a different PDF could reuse them if necessary.):"" << std::endl;; allCustomiserNodes.Print(""V"");; ; ; }; RooAddPdf.h; RooCategory.h; RooCustomizer.h; RooFormulaVar.h; RooGaussian.h; RooPolynomial.h; RooRealVar.h; RooAbsCollection::addvirtual bool add(const RooAbsArg &var, bool silent=false)Add ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
Modifiability,variab,variable,"ation:"" << std::endl;; model.Print(""T""); // ""T"" prints the model as a tree; ; ; // Build the categories; RooCategory sample(""sample"",""sample"");; sample[""Sample1""] = 1;; sample[""Sample2""] = 2;; sample[""Sample3""] = 3;; ; ; // Start to customise the proto model that was defined above.; // ---------------------------------------------------------------------------; ; // We need two sets for bookkeeping of PDF nodes:; RooArgSet newLeaves; // This set collects leaves that are created in the process.; RooArgSet allCustomiserNodes; // This set lists leaves that have been used in a replacement operation.; ; ; // 1. Each sample should have its own mean for the gaussian; // The customiser will make copies of `meanG` for each category.; // These will all appear in the set `newLeaves`, which will own the new nodes.; RooCustomizer cust(model, sample, newLeaves, &allCustomiserNodes);; cust.splitArg(meanG, sample);; ; ; // 2. Each sample should have its own signal yield, but there is an extra complication:; // We need the yields 1 and 2 to be a function of the variable ""mass"".; // For this, we pre-define nodes with exactly the names that the customiser would have created automatically,; // that is, ""<nodeName>_<categoryName>"", and we register them in the set of customiser nodes.; // The customiser will pick them up instead of creating new ones.; // If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; RooRealVar mass(""M"", ""M"", 1, 0, 12000);; RooFormulaVar yield1(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass);; RooFormulaVar yield2(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass);; allCustomiserNodes.add(yield1);; allCustomiserNodes.add(yield2);; ; // Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample);; ; ; // Now we can start building the PDFs for all categories:; auto pdf1 = cust.build(""Sample1"");; auto pdf2 = cust.build(""",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
Safety,safe,safe,"bjects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooCustomizerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; rf514_RooCustomizerDefinition rf514_RooCustomizer.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; The proto model before customisation:; 0x7ffc956b53c8 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7ffc956b3d70/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b5ed0/V- RooRealVar::meanG = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b62b8/V- RooRealVar::yieldSig = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 1 with a yield depending on M:; 0x55734032a0f0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x5573405e0390/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x557340631bf0/V- RooRealVar::meanG_Sample1 = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b71f0/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
Integrability,depend,depending,"ss"".; # For this, we pre-define nodes with exactly the names that the customiser would have created automatically,; # that is, ""<nodeName>_<categoryName>"", and we register them in the set of customiser nodes.; # The customiser will pick them up instead of creating new ones.; # If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; mass = ROOT.RooRealVar(""M"", ""M"", 1, 0, 12000); yield1 = ROOT.RooFormulaVar(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass); yield2 = ROOT.RooFormulaVar(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass); allCustomiserNodes.add(yield1); allCustomiserNodes.add(yield2); ; # Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample); ; ; # Now we can start building the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sample2""); pdf3 = cust.build(""Sample3""); ; # And we inspect the two PDFs; print(""\nPDF 1 with a yield depending on M:\n""); pdf1.Print(""T""); print(""\nPDF 2 with a yield depending on M:\n""); pdf2.Print(""T""); print(""\nPDF 3 with a free yield:\n""); pdf3.Print(""T""); ; print(""\nThe following leaves have been created automatically while customising:\n""); newLeaves.Print(""V""); ; # If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; meanG1 = allCustomiserNodes[""meanG_Sample1""]; meanG1.setVal(200); meanG2 = allCustomiserNodes[""meanG_Sample2""]; meanG2.setVal(300); ; print(; ""\nThe following leaves have been used while customising\n\t(partial overlap with the set of automatically created leaves.\n\ta new customiser for a different PDF could reuse them if necessary.):""; ); allCustomiserNodes.Print(""V""); [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7448c10 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x70",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
Modifiability,variab,variable,", ""yieldBkg"", 1, 0, 1.0e4); ; model = ROOT.RooAddPdf(""model"", ""S + B model"", [gauss, linear], [yieldSig, yieldBkg]); ; print(""The proto model before customisation:\n""); model.Print(""T"") # ""T"" prints the model as a tree; ; ; # Build the categories; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ; ; # Start to customise the proto model that was defined above.; # ---------------------------------------------------------------------------; ; # We need two sets for bookkeeping of PDF nodes:; newLeaves = ROOT.RooArgSet(); allCustomiserNodes = ROOT.RooArgSet(); ; ; # 1. Each sample should have its own mean for the gaussian; # The customiser will make copies of `meanG` for each category.; # These will all appear in the set `newLeaves`, which will own the new nodes.; cust = ROOT.RooCustomizer(model, sample, newLeaves, allCustomiserNodes); cust.splitArg(meanG, sample); ; ; # 2. Each sample should have its own signal yield, but there is an extra complication:; # We need the yields 1 and 2 to be a function of the variable ""mass"".; # For this, we pre-define nodes with exactly the names that the customiser would have created automatically,; # that is, ""<nodeName>_<categoryName>"", and we register them in the set of customiser nodes.; # The customiser will pick them up instead of creating new ones.; # If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; mass = ROOT.RooRealVar(""M"", ""M"", 1, 0, 12000); yield1 = ROOT.RooFormulaVar(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass); yield2 = ROOT.RooFormulaVar(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass); allCustomiserNodes.add(yield1); allCustomiserNodes.add(yield2); ; # Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample); ; ; # Now we can start building the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sam",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
Safety,safe,safe,"lding the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sample2""); pdf3 = cust.build(""Sample3""); ; # And we inspect the two PDFs; print(""\nPDF 1 with a yield depending on M:\n""); pdf1.Print(""T""); print(""\nPDF 2 with a yield depending on M:\n""); pdf2.Print(""T""); print(""\nPDF 3 with a free yield:\n""); pdf3.Print(""T""); ; print(""\nThe following leaves have been created automatically while customising:\n""); newLeaves.Print(""V""); ; # If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; meanG1 = allCustomiserNodes[""meanG_Sample1""]; meanG1.setVal(200); meanG2 = allCustomiserNodes[""meanG_Sample2""]; meanG2.setVal(300); ; print(; ""\nThe following leaves have been used while customising\n\t(partial overlap with the set of automatically created leaves.\n\ta new customiser for a different PDF could reuse them if necessary.):""; ); allCustomiserNodes.Print(""V""); [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7448c10 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7075f00/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x69b2ac0/V- RooRealVar::meanG = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x7002610/V- RooRealVar::yieldSig = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::pol1 = 1; 0x70456d0/V- RooRealVar::yieldBkg = 1; 0x76dd3d0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x733d770/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x71a3180/V- RooRealVar::meanG_Sample1 = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x769f520/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; 0x74a38c0/V- RooRealVar::M = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::p",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
Modifiability,config,config,". ROOT: tutorials/roofit/rf515_hfJSON.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf515_hfJSON.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Code HistFactory Models in JSON. ; With the HS3 standard, it is possible to code RooFit-Models of any kind as JSON files. In this tutorial, you can see how to code up a (simple) HistFactory-based model in JSON and import it into a RooWorkspace.; ; import ROOT; ; # start by creating an empty workspace; ws = ROOT.RooWorkspace(""workspace""); ; # the RooJSONFactoryWSTool is responsible for importing and exporting things to and from your workspace; tool = ROOT.RooJSONFactoryWSTool(ws); ; # use it to import the information from your JSON file; tool.importJSON(ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf515_hfJSON.json""); ws.Print(); ; # now, you can easily use your workspace to run your fit (as you usually would); # the model config is named after your pdf, i.e. <the pdf name>_modelConfig; model = ws[""ModelConfig""]; ; # for resetting the parameters after the fit; params = model.GetPdf().getParameters(ws[""observed""]); ROOT.SetOwnership(params, True); params_initial = params.snapshot(); ROOT.SetOwnership(params_initial, True); ; # we are fitting a clone of the model now,; result = model.fitTo(ws[""observed""], ROOT.RooFit.Save(), ROOT.RooFit.PrintLevel(-1)); ROOT.SetOwnership(result, True); result.Print(); # reset parameters, such that we are not double-fitting the model in the; # closure check.; params.assign(params_initial); ; # in the end, you can again write to json; # the result will be not completely identical to the JSON file you used as an input, but it will work just the same; tool.exportJSON(""myWorkspace.json""); ; # You can again import it if you want and check for closure; ws_2 = ROOT.RooWorkspace(""workspace""); tool_2 = ROOT.RooJSONFactoryWSTool(ws_2); tool_2.importJSON(""myWorkspace.json""); ws_2.Print(); model_2 = ws_2[""ModelConfig""];",MatchSource.WIKI,doc/master/rf515__hfJSON_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf515__hfJSON_8py.html
Usability,simpl,simple,". ROOT: tutorials/roofit/rf515_hfJSON.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf515_hfJSON.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Code HistFactory Models in JSON. ; With the HS3 standard, it is possible to code RooFit-Models of any kind as JSON files. In this tutorial, you can see how to code up a (simple) HistFactory-based model in JSON and import it into a RooWorkspace.; ; import ROOT; ; # start by creating an empty workspace; ws = ROOT.RooWorkspace(""workspace""); ; # the RooJSONFactoryWSTool is responsible for importing and exporting things to and from your workspace; tool = ROOT.RooJSONFactoryWSTool(ws); ; # use it to import the information from your JSON file; tool.importJSON(ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf515_hfJSON.json""); ws.Print(); ; # now, you can easily use your workspace to run your fit (as you usually would); # the model config is named after your pdf, i.e. <the pdf name>_modelConfig; model = ws[""ModelConfig""]; ; # for resetting the parameters after the fit; params = model.GetPdf().getParameters(ws[""observed""]); ROOT.SetOwnership(params, True); params_initial = params.snapshot(); ROOT.SetOwnership(params_initial, True); ; # we are fitting a clone of the model now,; result = model.fitTo(ws[""observed""], ROOT.RooFit.Save(), ROOT.RooFit.PrintLevel(-1)); ROOT.SetOwnership(result, True); result.Print(); # reset parameters, such that we are not double-fitting the model in the; # closure check.; params.assign(params_initial); ; # in the end, you can again write to json; # the result will be not completely identical to the JSON file you used as an input, but it will work just the same; tool.exportJSON(""myWorkspace.json""); ; # You can again import it if you want and check for closure; ws_2 = ROOT.RooWorkspace(""workspace""); tool_2 = ROOT.RooJSONFactoryWSTool(ws_2); tool_2.importJSON(""myWorkspace.json""); ws_2.Print(); model_2 = ws_2[""ModelConfig""];",MatchSource.WIKI,doc/master/rf515__hfJSON_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf515__hfJSON_8py.html
Availability,error,error,"mean"", ""mean of g1 and g2"", 0);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero proba",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
Integrability,interface,interface,"#include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf601_intminuit(); {; // S e t u p p d f a n d l i k e l i h o o d; // -----------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Model (intentional strong correlations); RooRealVar mean(""mean"", ""mean of g1 and g2"", 0);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snaps",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
Safety,safe,safe,"he title of the RooPlot to 'title'.Definition RooPlot.cxx:1243; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sig",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
Testability,log,logging,"#include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf601_intminuit(); {; // S e t u p p d f a n d l i k e l i h o o d; // -----------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Model (intentional strong correlations); RooRealVar mean(""mean"", ""mean of g1 and g2"", 0);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snaps",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
Availability,error,error,".py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ; Interactive minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initi",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
Integrability,interface,interface,".py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ; Interactive minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initi",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
Safety,safe,safe,"ndicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sig",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
Testability,log,logging,"e minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
Availability,error,error,"RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constRet",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
Energy Efficiency,reduce,reduce,"RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constRet",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
Integrability,message,messages,"RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constRet",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
Modifiability,extend,extended,""", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArg",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
Performance,optimiz,optimization,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
Safety,safe,safe,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
Availability,error,error,".; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - stat",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
Energy Efficiency,reduce,reduce,"al"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn =",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
Integrability,message,messages,".; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - stat",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
Modifiability,extend,extended,"ssian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial p.d.f.; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal p.d.f.; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activatin",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
Performance,optimiz,optimization,"umber of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf602_chi2fit.py. tutorialsroofitrf602_chi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
Safety,safe,safe,"0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAb",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
Availability,error,error,"on RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Do",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
Deployability,integrat,integration,"split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ----------------------------------------------; ; // Construct signal, total likelihood projection on (y,z) observables and likelihood ratio; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // Calculate likelihood ratio for each event, define subset of events with high signal likelihood; data->addColumn(llratio_func);; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame and plot data; RooPlot *frame = x.frame(Title(""Projection on X with LLratio(y,z)>0.7""), Bins(40));; dataSel->plotOn(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density function",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
Energy Efficiency,reduce,reduce,"g(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Generate large dataset; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 200000)};; ; // P a r a l l e l f i t t i n g; // -------------------------------; ; // In parallel mode the likelihood calculation is split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ----------------------------------------------; ; // Construct signal, total likelihood projection on (y,z) observables and likelihood ratio; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // Calculate likelihood ratio for each event, define subset of events with high signal likelihood; data->addColumn(llratio_func);; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame and plot data; RooPlot *frame = x.frame(Title(""Projection on X with LLratio(y,z)>0.7""), Bins(40));; dataSel->plotOn(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxi",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
Integrability,integrat,integration,"split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ----------------------------------------------; ; // Construct signal, total likelihood projection on (y,z) observables and likelihood ratio; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // Calculate likelihood ratio for each event, define subset of events with high signal likelihood; data->addColumn(llratio_func);; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame and plot data; RooPlot *frame = x.frame(Title(""Projection on X with LLratio(y,z)>0.7""), Bins(40));; dataSel->plotOn(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density function",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
Modifiability,variab,variable,"ad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interle",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
Performance,optimiz,optimization,"on RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Do",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
Availability,error,error,"""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
Deployability,integrat,integration,"l fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood ratio for each event, subset of events with high; # signal likelihood; data.addColumn(llratio_func); dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1]",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
Energy Efficiency,reduce,reduce,"g"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Generate large dataset; data = model.generate({x, y, z}, 200000); ; # Parallel fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood ratio for each event, subset of events with high; # signal likelihood; data.addColumn(llratio_func); dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErr",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
Integrability,integrat,integration,"l fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood ratio for each event, subset of events with high; # signal likelihood; data.addColumn(llratio_func); dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1]",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
Modifiability,variab,variables,"ame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
Performance,optimiz,optimization,"""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
Availability,error,error,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
Performance,optimiz,optimization,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
Availability,error,error,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
Performance,optimiz,optimization,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
Availability,error,error,":547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf605_profilellDefinition rf605_profilell.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..............................................................",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
Deployability,configurat,configurations," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
Integrability,interface,interface,"ilell"", ""rf605_profilell"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMinimizer.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooMinimizer::migradint migrad()Execute MIGRAD.Definition RooMinimizer.cxx:318; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMaximumSetMaximum(ymax); RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanva",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
Modifiability,variab,variable,"nimizer.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooMinimizer::migradint migrad()Execute MIGRAD.Definition RooMinimizer.cxx:318; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMaximumSetMaximum(ymax); RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double we",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
Safety,safe,safe,"); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf605_profilellDefinition rf605_profilell.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error l",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
Availability,error,error,"except sigma_g2 for each evaluation; pll_sigmag2 = nll.createProfile({sigma_g2}); ; # Plot the profile likelihood in sigma_g2; pll_sigmag2.plotOn(frame2, LineColor=""r""); ; # Adjust frame maximum for visual clarity; frame2.SetMinimum(0); frame2.SetMaximum(3); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf605_profilell"", ""rf605_profilell"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf605_profilell.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..............................................................",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
Deployability,configurat,configurations," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
Modifiability,config,configurations," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
Safety,safe,safe,"r=""r""); ; # Adjust frame maximum for visual clarity; frame1.SetMinimum(0); frame1.SetMaximum(3); ; # Construct profile likelihood in sigma_g2; # -------------------------------------------------------------------------------; ; # The profile likelihood estimator on nll for sigma_g2 will minimize nll; # w.r.t all floating parameters except sigma_g2 for each evaluation; pll_sigmag2 = nll.createProfile({sigma_g2}); ; # Plot the profile likelihood in sigma_g2; pll_sigmag2.plotOn(frame2, LineColor=""r""); ; # Adjust frame maximum for visual clarity; frame2.SetMinimum(0); frame2.SetMaximum(3); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf605_profilell"", ""rf605_profilell"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf605_profilell.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
Availability,error,error,". ROOT: tutorials/roofit/rf606_nllerrorhandling.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf606_nllerrorhandling.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: understanding and customizing error handling in likelihood evaluations . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooArgusBG.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf606_nllerrorhandling(); {; // C r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Observable; RooRealVar m(""m"", ""m"", 5.20, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disabl",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
Deployability,configurat,configuration,"d::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluat",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
Integrability,message,messages," r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Observable; RooRealVar m(""m"", ""m"", 5.20, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
Modifiability,config,configuration,"d::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluat",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
Performance,optimiz,optimization,":725; RooFit::EvalErrorValueRooCmdArg EvalErrorValue(double value)Definition RooGlobalFunc.cxx:284; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf606_nllerrorhandlingDefinition rf606_nllerrorhandling.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
Testability,log,log,"--; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), E",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
Usability,clear,clearly," lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"",",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
Availability,error,error,". ROOT: tutorials/roofit/rf606_nllerrorhandling.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf606_nllerrorhandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #606 ; Understanding and customizing error handling in likelihood evaluations. ; ; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
Deployability,configurat,configuration,"ooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with err",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
Integrability,message,messages,"ing error handling in likelihood evaluations. ; ; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # -------",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
Modifiability,config,configuration,"ooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with err",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
Performance,optimiz,optimization," but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
Testability,log,log,"---------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
Usability,clear,clearly," value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4);",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
Availability,error,error,"wvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTSym< Double_t >; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf607_fitresultDefinition rf607_fitresult.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
Performance,optimiz,optimization,"wvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTSym< Double_t >; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf607_fitresultDefinition rf607_fitresult.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
Testability,log,log,"<RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // P r i n t f i t r e s u l t s; // ---------------------------------; ; // Summary printing: Basic info plus final values of floating fit parameters; r->Print();; ; // Verbose printing: Basic info, values of constant parameters, initial and; // final values of floating parameters, global correlations; r->Print(""v"");; ; // V i s u a l i z e c o r r e l a t i o n m a t r i x; // -------------------------------------------------------; ; // Construct 2D color plot of correlation matrix; gStyle->SetOptStat(0);; TH2 *hcorr = r->correlationHist();; ; // Visualize ellipse corresponding to single correlation matrix element; RooPlot *frame = new RooPlot(sigma1, sig1frac, 0.45, 0.60, 0.65, 0.90);; frame->SetTitle(""Covariance between sigma1 and sig1frac"");; r->plotOn(frame, sigma1, sig1frac, ""ME12ABHV"");; ; // A c c e s s f i t r e s u l t i n f o r m a t i o n; // ---------------------------------------------------------; ; // Access basic information; cout << ""EDM = "" << r->edm() << endl;; cout << ""-log(L) at minimum = "" << r->minNll() << endl;; ; // Access list of final fit parameter values; cout << ""final value of floating parameters"" << endl;; r->floatParsFinal().Print(""s"");; ; // Access correlation matrix elements; cout << ""correlation between sig1frac and a0 is "" << r->correlation(sig1frac, a0) << endl;; cout << ""correlation between bkgfrac and mean is "" << r->correlation(""bkgfrac"", ""mean"") << endl;; ; // Extract covariance and correlation matrix as TMatrixDSym; const TMatrixDSym &cor = r->correlationMatrix();; const TMatrixDSym &cov = r->covarianceMatrix();; ; // Print correlation, covariance matrix; cout << ""correlation matrix"" << endl;; cor.Print();; cout << ""covariance matrix"" << endl;; cov.Print();; ; // P e r s i s t f i t r e s u l t i n r o o t f i l e; // -------------------------------------------------------------; ; // Open new ROOT file save save result; TFile f(""rf607_fitresult.root"", ""RECRE",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
Availability,error,error,"; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf607_fitresult.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue ",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
Performance,optimiz,optimization,"; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf607_fitresult.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue ",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
Testability,log,log,"---; ; # Perform fit and save result; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Print fit results; # ---------------------------------; ; # Summary printing: Basic info plus final values of floating fit parameters; r.Print(); ; # Verbose printing: Basic info, of constant parameters, and; # final values of floating parameters, correlations; r.Print(""v""); ; # Visualize correlation matrix; # -------------------------------------------------------; ; # Construct 2D color plot of correlation matrix; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetPalette(1); hcorr = r.correlationHist(); ; # Visualize ellipse corresponding to single correlation matrix element; frame = ROOT.RooPlot(sigma1, sig1frac, 0.45, 0.60, 0.65, 0.90); frame.SetTitle(""Covariance between sigma1 and sig1frac""); r.plotOn(frame, sigma1, sig1frac, ""ME12ABHV""); ; # Access fit result information; # ---------------------------------------------------------; ; # Access basic information; print(""EDM = "", r.edm()); print(""-log(L) minimum = "", r.minNll()); ; # Access list of final fit parameter values; print(""final value of floating parameters""); r.floatParsFinal().Print(""s""); ; # Access correlation matrix elements; print(""correlation between sig1frac and a0 is "", r.correlation(sig1frac, a0)); print(""correlation between bkgfrac and mean is "", r.correlation(""bkgfrac"", ""mean"")); ; # Extract covariance and correlation matrix as ROOT.TMatrixDSym; cor = r.correlationMatrix(); cov = r.covarianceMatrix(); ; # Print correlation, matrix; print(""correlation matrix""); cor.Print(); print(""covariance matrix""); cov.Print(); ; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2)",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
Availability,error,error,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
Deployability,integrat,integrations,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
Integrability,integrat,integrations,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
Modifiability,variab,variables,"olor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2.h; TH3.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
Performance,perform,performed,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
Safety,safe,safe,"etween the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf608_fitresultaspdfDefinition rf608_fitresultaspdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf608_fitresultaspdf.C. tutorialsroofitrf608_fitresultaspdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
Availability,error,error,"OOT.RooRealVar(""sigma_g1"", ""width of g1"", 2); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 5.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
Deployability,integrat,integrations," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
Integrability,integrat,integrations," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
Performance,perform,performed," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
Safety,safe,safe,"g""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600); c2.Divide(3, 2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_mean_sigmag2.GetZaxis().SetTitleOffset(1.4); hh_mean_sigmag2.Draw(""surf3""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_sigmag2_frac.GetZaxis().SetTitleOffset(1.4); hh_sigmag2_frac.Draw(""surf3""); c2.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_mean_frac.GetZaxis().SetTitleOffset(1.4); hh_mean_frac.Draw(""surf3""); ; # Draw the distributions of parameter points sampled from the pdf; tmp1 = d.createHistogram(mean, sigma_g2, 50, 50); tmp2 = d.createHistogram(sigma_g2, frac, 50, 50); tmp3 = d.createHistogram(mean, frac, 50, 50); ; c2.cd(4); ROOT.gPad.SetLeftMargin(0.15); tmp1.GetZaxis().SetTitleOffset(1.4); tmp1.Draw(""lego3""); c2.cd(5); ROOT.gPad.SetLeftMargin(0.15); tmp2.GetZaxis().SetTitleOffset(1.4); tmp2.Draw(""lego3""); c2.cd(6); ROOT.gPad.SetLeftMargin(0.15); tmp3.GetZaxis().SetTitleOffset(1.4); tmp3.Draw(""lego3""); ; c2.SaveAs(""rf608_fitresultaspdf_2.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf608_fitresultaspdf.py. tutorialsroofitrf608_fitresultaspdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
Availability,error,errors,". ROOT: tutorials/roofit/rf609_xychi2fit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
Deployability,integrat,integrating,"and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetConta",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
Integrability,integrat,integrating,"and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetConta",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
Modifiability,variab,variable,"yle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolyVarA RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Defi",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
Performance,optimiz,optimization,"ooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; fit1Definition fit1.py:1; rf609_xychi2fitDefinition rf609_xychi2fit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.17354, estimated distance to minimum: 3.83787e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -6.4539e-02 +/- 5.85e-01; b 2.9760e-01 +/- 4.74e-01; c 1.0442e+00 +/- 9.06e-02; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.81819, estimated distance to minimum: 5.77434e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -5.5529e-02 +/- 3.37e-01; b 3.6741e-02 +/- 4.64e-01; c 1.0407e+00 +/- 4.98e-02; ; DateJuly 20",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
Availability,error,errors,". ROOT: tutorials/roofit/rf609_xychi2fit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf609_xychi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; import ROOT; import math; ; ; # Create dataset with X and Y values; # -------------------------------------------------------------------; ; # Make weighted XY dataset with asymmetric errors stored; # The StoreError() argument is essential as it makes; # the dataset store the error in addition to the values; # of the observables. If errors on one or more observables; # are asymmetric, can store the asymmetric error; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
Deployability,integrat,integrating,"mple dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
Integrability,integrat,integrating,"mple dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
Performance,optimiz,optimization,"lVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.77875, estimated distance to minimum: 0.000387499; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.9593e-02 +/- 3.62e-01; b 4.5829e-02 +/- 4.65e-01; c 1.0343e+00 +/- 5.76e-02; ; DateFebruary",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
Availability,error,errors,". ROOT: tutorials/roofit/rf610_visualerror.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf610_visualerror.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf610_visualerror(); {; // S e t u p e x a m p l e f i t; // ---------------------------------------; ; // Create sum of two Gaussians pdf with factory; RooRealVar x(""x"", ""x"", -10, 10);; ; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 2, 1, 50);; RooGaussian sig(""sig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; //",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
Energy Efficiency,reduce,reduced,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
Modifiability,variab,variable,"inition Rtypes.h:66; kMagenta@ kMagentaDefinition Rtypes.h:66; kCyan@ kCyanDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::DrawOptionRooCmdArg DrawOption(const char *opt)Definition RooGlobalFunc.cxx:130; RooFit::FillColorRooCmdArg FillColor(Color_t color)Definition RooGlobalFunc.cxx:252; RooFit::LineWidthRooCmdArg L",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
Performance,perform,perform,"(required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // is chosen to be such that at least 100 curves are expected to be outside the N% interval, and is minimally; // 100 (e.g. Z=1->Ncurve=356, Z=2->Ncurve=2156)) Intervals from the sampling method can be asymmetric,; // and may perform better in the presence of strong correlations, but may take (much) longer to calculate; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed));; ; // Perform the same type of error visualization on the background component only.; // The VisualizeError() option can generally applied to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
Usability,simpl,simple,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
Availability,error,errors,". ROOT: tutorials/roofit/rf610_visualerror.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf610_visualerror.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; import ROOT; ; ; # Setup example fit; # ---------------------------------------; ; # Create sum of two Gaussians pdf with factory; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 1, 50); sig = ROOT.RooGaussian(""sig"", ""sig"", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r,",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
Energy Efficiency,reduce,reduced,"ckground component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; fr",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
Performance,perform,perform,"inear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization th",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
Usability,simpl,simple,"ckground component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; fr",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
Availability,error,error," M.Definition TRandom3.h:27; TRandom3::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom3.cxx:99; TRandom3::SetSeedvoid SetSeed(ULong_t seed=0) overrideSet the random generator sequence if seed is 0 (default value) a TUUID is generated and used to fill ...Definition TRandom3.cxx:206; TRandom::Poissonvirtual ULong64_t Poisson(Double_t mean)Generates a random integer N according to a Poisson law.Definition TRandom.cxx:404; TStyle::SetPadTopMarginvoid SetPadTopMargin(Float_t margin=0.1)Definition TStyle.h:359; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetPadBottomMarginvoid SetPadBottomMargin(Float_t margin=0.1)Definition TStyle.h:358; TStyle::SetPaintTextFormatvoid SetPaintTextFormat(const char *format=""g"")Definition TStyle.h:386; TStyle::SetEndErrorSizevoid SetEndErrorSize(Float_t np=2)Set the size (in pixels) of the small lines drawn at the end of the error bars (TH1 or TGraphErrors).Definition TStyle.cxx:1340; TStyle::SetPadRightMarginvoid SetPadRightMargin(Float_t margin=0.1)Definition TStyle.h:361; TStyle::SetTitleOffsetvoid SetTitleOffset(Float_t offset=1, Option_t *axis=""X"")Specify a parameter offset to control the distance between the axis and the axis title.Definition TStyle.cxx:1798; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::SetHistLineColorvoid SetHistLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::SetTitleSizevoid SetTitleSize(Float_t size=0.02, Option_t *axis=""X"")Definition TStyle.cxx:1817; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TStyle::SetLabelSizevoid SetLabelSize(Float_t size=0.04, Option_t *axis=""X"")Set size of axis labels.Definition TStyle.cxx:1444; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the hist",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
Integrability,message,messages,"g const &iLabel = std::to_string(i);; // using the inverse Hessian matrix; std::string hc0XLabel = methodLabels[i] + "";"" + makePullXLabel(""c_{0}"") + "";"";; std::string hc1XLabel = methodLabels[i] + "";"" + makePullXLabel(""c_{1}"") + "";"";; std::string hntotXLabel = methodLabels[i] + "";"" + makePullXLabel(""N_{tot}"") + "";"";; hc0pull[i] = new TH1D((""hc0pull"" + iLabel).c_str(), hc0XLabel.c_str(), 20, -5.0, 5.0);; // using the correction with the Hessian matrix with squared weights; hc1pull[i] = new TH1D((""hc1pull"" + iLabel).c_str(), hc1XLabel.c_str(), 20, -5.0, 5.0);; // asymptotically correct approach; hntotpull[i] = new TH1D((""hntotpull"" + iLabel).c_str(), hntotXLabel.c_str(), 20, -5.0, 5.0);; }; ; // number of pseudoexperiments (toys) and number of events per pseudoexperiment; constexpr std::size_t ntoys = 500;; constexpr std::size_t nstats = 500;; // parameters used in the generation; constexpr double c0gen = 0.0;; constexpr double c1gen = 0.0;; ; // Silence fitting and minimisation messages; auto &msgSv = RooMsgService::instance();; msgSv.getStream(1).removeTopic(RooFit::Minimization);; msgSv.getStream(1).removeTopic(RooFit::Fitting);; ; std::cout << ""Running "" << ntoys * 3 << "" toy fits ..."" << std::endl;; ; // M a i n l o o p : r u n p s e u d o e x p e r i m e n t s; //----------------------------------------------------------------; for (std::size_t i = 0; i < ntoys; i++) {; // S e t u p p a r a m e t e r s a n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
Modifiability,extend,extended,"n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
Performance,perform,performs,"d to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined as \( (\lambda_i -; \lambda_{gen})/\sigma(\lambda_i) \), where \( \lambda_i \) is the fitted parameter and \( \sigma(\lambda_i) \) its uncertainty for pseudoexperiment number i. If",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
Testability,log,log,"ning parameter uncertainties in weighted unbinned maximum likelihood fits. Performing a weighted unbinned maximum likelihood fits can be useful to account for acceptance effects and to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
Usability,simpl,simple,"ting and minimisation messages; auto &msgSv = RooMsgService::instance();; msgSv.getStream(1).removeTopic(RooFit::Minimization);; msgSv.getStream(1).removeTopic(RooFit::Fitting);; ; std::cout << ""Running "" << ntoys * 3 << "" toy fits ..."" << std::endl;; ; // M a i n l o o p : r u n p s e u d o e x p e r i m e n t s; //----------------------------------------------------------------; for (std::size_t i = 0; i < ntoys; i++) {; // S e t u p p a r a m e t e r s a n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account ",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
Availability,recover,recovery,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
Integrability,message,messages,"vice.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""n",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
Modifiability,variab,variable," ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TCanvasThe Canvas class.Definition TCanvas.h:23; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TPave::SetB",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
Performance,optimiz,optimization,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
Safety,recover,recovery,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
Testability,test,test,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
Availability,recover,recovery,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
Integrability,message,messages,"e, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # ------------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
Performance,optimiz,optimization,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
Safety,recover,recovery,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
Testability,log,logEvalError,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
Integrability,depend,depend,". ROOT: tutorials/roofit/rf613_global_observables.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf613_global_observables.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlike a Gaussian, a",MatchSource.WIKI,doc/master/rf613__global__observables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8C.html
Performance,optimiz,optimize,". ROOT: tutorials/roofit/rf613_global_observables.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf613_global_observables.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlike a Gaussian, a",MatchSource.WIKI,doc/master/rf613__global__observables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8C.html
Integrability,depend,depend,". ROOT: tutorials/roofit/rf613_global_observables.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf613_global_observables.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlik",MatchSource.WIKI,doc/master/rf613__global__observables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8py.html
Performance,optimiz,optimize,". ROOT: tutorials/roofit/rf613_global_observables.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf613_global_observables.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlik",MatchSource.WIKI,doc/master/rf613__global__observables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8py.html
Deployability,integrat,integrating,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Energy Efficiency,reduce,reduce,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Integrability,integrat,integrating,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Modifiability,config,config,"> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -------------------; ; // Set up the observable; RooRealVar x{""x"", ""x"", 0.1, 5.1};; x.setBins(10); // fewer bins so we have larger binning effects for this demo; ; // Let's first look at the example of an exponential function; RooRealVar c{""c"", ""c"", -1.8, -5, 5};; RooExponential expo{""expo"", ""expo"", x, c};; ; // Generate an Asimov dataset such that the only difference between the fit; // result and the true parameters comes from binning effects.; std::unique_ptr<RooAbsData> expoData{generateBinnedAsimov(expo, x,",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Performance,perform,performance,"ntLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects beca",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Safety,predict,predicted,"powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Testability,log,log,"powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Usability,learn,learn,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
Deployability,integrat,integrating,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Energy Efficiency,reduce,reduce,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Integrability,integrat,integrating,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Modifiability,config,config,"ely it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binning effects for this demo; ; # Let's first look at the example of an exponential function; c = ROOT.RooRealVar(""c"", ""c"", -1.8, -5, 5); expo = ROOT.RooExponential(""expo"", ""expo"", x, c); ; # Generate an Asimov dataset such that the only difference between the fit; # result and the true parameters comes from binning effects.; expo_data = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Performance,perform,performance,"ins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numer",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Safety,predict,predicted,"Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # there are not so many events. And we can't afford any precision loss for; # these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100) # It's not about binning effects anymore, so reset the number of bins.; ; mu = ROOT.RooRealVar(""mu"", ""mu"", 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""fr",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Testability,log,log,"Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # there are not so many events. And we can't afford any precision loss for; # these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100) # It's not about binning effects anymore, so reset the number of bins.; ; mu = ROOT.RooRealVar(""mu"", ""mu"", 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""fr",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Usability,learn,learn,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
Availability,error,error,", 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf615_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf615_plot_2.png""); ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, True); result.Print(); ; del nll_morph; del nllr_learned; del nll_gauss; del workspace; ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.modules[""libROOTPythonizations""]; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
Integrability,message,messages,"trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Grid(ROOT.RooBinning(4, 0.0, 4.0)); x_var.setBins(50); ; # Number of 'sampled' gaussians, if you change it, adjust the binning properly; n_grid = 5; ; for i in range(n_grid):; # Define the sampled gausians; mu_help = ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", i); help = ROOT.RooGaussian(f""g{i}"", f""g{i}"", x_var, mu_help, sigma); workspace.Import(help, Silence=True); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples); ; # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, 1), Silence=True",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
Modifiability,extend,extend,"# f1 = x_var.frame(Title=""linear morphing;x;pdf"", Range=(-4, 8)); # for i in range(n_grid):; # workspace[f""histpdf{i}""].plotOn(f1); # workspace[""morph""].plotOn(f1, LineColor=""r""); # c0 = ROOT.TCanvas(); # f1.Draw(); # input() # Wait for user input to proceed; ; ; # Class used in this case to demonstrate the use of SBI in Root; class SBI:; # Initializing the class SBI; def __init__(self, workspace):; # Choose the hyperparameters for training the neural network; self.classifier = MLPClassifier(hidden_layer_sizes=(20, 20), max_iter=1000, random_state=42); self.data_model = None; self.data_ref = None; self.X_train = None; self.y_train = None; self.workspace = workspace; ; # Defining the target / training data for different values of mean value mu; def model_data(self, model, x, mu, n_samples):; ws = self.workspace; data_test_model = []; samples_gaussian = ws[model].generate([ws[x], ws[mu]], n_samples).to_numpy(); self._training_mus = samples_gaussian[mu]; data_test_model.extend(samples_gaussian[x]); ; self.data_model = np.array(data_test_model).reshape(-1, 1); ; # Generating samples for the reference distribution; def reference_data(self, model, x, n_samples):; ws = self.workspace; # Ensuring the normalization with generating as many reference data as target data; samples_uniform = ws[model].generate(ws[x], n_samples); data_reference_model = np.array(; [samples_uniform.get(i).getRealValue(""x"") for i in range(samples_uniform.numEntries())]; ); self.data_ref = data_reference_model.reshape(-1, 1); ; # Bringing the data in the right format for training; def preprocessing(self):; thetas_model = self._training_mus.reshape(-1, 1); thetas_reference = self._training_mus.reshape(-1, 1); thetas = np.concatenate((thetas_model, thetas_reference), axis=0); X = np.concatenate([self.data_model, self.data_ref]); self.y_train = np.concatenate([np.ones(len(self.data_model)), np.zeros(len(self.data_ref))]); self.X_train = np.concatenate([X, thetas], axis=1); ; # Train the classifier; def t",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
Testability,log,logarithmic,"The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; We compare the approach of using the likelihood ratio trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Grid(ROOT.RooBinning(4, 0.0, 4.0)); x_var.setBins(50); ; # Number of 'sampled' gaussians, if you change it, adjust the binning properly; n_grid = 5; ; for i in range(n_grid):; # Define the sampled gausians; mu_help = ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", i); help = ROOT.RooGaussian(f""g{i}"", f""g{i}"", x_var, mu_help, sigma); workspace.Import(help, Silence=True); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples); ; # Make sure that every bin is filled and we don't get zero prob",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
Usability,simpl,simple,". ROOT: tutorials/roofit/rf615_simulation_based_inference.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf615_simulation_based_inference.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in RooFit. ; This tutorial shows how to use SBI in ROOT. As reference distribution we choose a simple uniform distribution. The target distribution is chosen to be gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; We compare the approach of using the likelihood ratio trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Gr",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
Integrability,rout,routine,"orphing.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/b67830e46d53d5f7cf2d. ; #include ""RooRealVar.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooGaussian.h""; #include ""RooUniform.h""; #include ""RooDataSet.h""; #include ""RooPlot.h""; #include ""RooMomentMorphFuncND.h""; #include ""RooAbsPdf.h""; ; using namespace RooFit;; ; // Number of samples to fill the histograms; const int n_samples = 1000;; ; // Kills warning massages; RooMsgService::instance().setGlobalKillBelow(RooFit::WARNING);; ; // Define the morphing routine; RooPlot *perform_morphing(RooWorkspace &ws, RooMomentMorphFuncND::Setting setting, double sigma); {; // Get Variables from the workspace; RooRealVar *x_var = ws.var(""x"");; RooRealVar *mu_var = ws.var(""mu"");; RooAbsPdf *gauss = ws.pdf(""gauss"");; ; // Initialize a plot; RooPlot *frame1 = x_var->frame();; ; // Define binning for morphing; RooMomentMorphFuncND::Grid grid(RooBinning(4, 0.0, 4.0));; ; // Set binning of histograms, has to be customized for optimal results; x_var->setBins(50);; ; std::vector<int> parampoints = {0, 1, 2, 3, 4};; ; for (auto i : parampoints) {; // Define the sampled gaussians; RooRealVar mu_help(Form(""mu%d"", i), Form(""mu%d"", i), i);; // Use * because RooGaussian expects objects no pointers; RooGaussian help(Form(""g%d"", i), Form(""g%d"", i), *x_var, mu_help, sigma);; ws.import(help, Silence(true));; ; // Fill the histograms use a unique pointer to prevent memory leaks; std::unique_ptr<RooDataHist> hist1{; dynamic_cast<RooDataHist *>(ws.pdf(Form(""g%d"", i))->generateBinned(*x_var, 100 * n_samples))};; ; // Add ",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
Modifiability,variab,variables,"rph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_var = ws->var(""mu"");; RooAbsPdf *gauss = ws->pdf(""gauss"");; RooDataSet *obs_data = gauss->generate(*x_var, n_samples);; ; // Create the exact negative log likelihood function for Gaussian model; RooAbsReal *nll_gauss = gauss->createNLL(*obs_data);; ; // Create the morphed negative log likelihood function; // TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; RooAbsReal *nll_morph = ws->pdf(""morph"")->createNLL(*obs_data, RooFit::EvalBackend(""legacy""));; ; // Plot the negative logarithmic summed likelihood; RooPlot *frame2 = mu_var->frame(Title(""Negative log Likelihood""));; nll_gauss->plotOn(frame2, LineColor(kBlue), ShiftToZero(), Name(""gauss""));; nll_morph->plotOn(frame2, LineColor(kRed), ShiftToZero(), Name(""morph""));; ; TCanvas *c = new TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; ; // Compute the minimum of the nll via minuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Pr",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
Security,access,access,"nuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Print();; }; }; c#define c(i)Definition RSha256.hxx:101; RooAbsPdf.h; RooDataSet.h; RooGaussian.h; RooMomentMorphFuncND.h; RooPlot.h; RooRealVar.h; RooUniform.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createNLLRooFit::OwningPtr< RooAbsReal > createNLL(RooAbsData &data, CmdArgs_t const &... cmdArgs)Construct representation of -log(L) of PDF with given dataset.Definition RooAbsPdf.h:163; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmd",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
Testability,log,log,". ROOT: tutorials/roofit/rf616_morphing.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf616_morphing.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/b67830e46d53d5f7cf2d. ; #include ""RooRealVar.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooGaussian.h""; #include ""RooUniform.h""; #include ""RooDataSet.h""; #include ""RooPlot.h""; #include ""RooMomentMorphFuncND.h""; #include ""RooAbsPdf.h""; ; using namespace RooFit;; ; // Number of samples to fill the histograms; const int n_samples = 1000;; ; // Kills warning massages; RooMsgService::instance().setGlobalKillBelow(RooFit::WARNING);; ; // Define the morphing routine; RooPlot *perform_morphing(RooWorkspace &ws, RooMomentMorphFuncND::Setting setting, double sigma); {; // Get Variables from the workspace; RooRealVar *x_var = ws.var(""x"");; RooRealVar *mu_var = ws.var(""mu"");; RooAbsPdf *gauss = ws.pdf(""gauss"");; ; // Initialize a plot; RooPlot *frame1 = x_var->frame();; ; // Define binning for morphing; RooMomentMorphFuncND::Grid grid(RooBinning(4, 0.0, 4.0));; ; // Set binning of histograms, has to be customized for optimal results; x_var->setBins(50);; ; std::vector<int> parampoints = {0, 1, 2, 3, 4};; ; for (auto i : parampoints) {; // Define the sampled gaussians; RooRealVar mu_help(Form(""mu%d"", i), Form(""mu%d"", i), i);; // Use * because RooGaussian expects objects no pointers; RooGaussian help(Form(""g%d"", i), Form(""g%d"", i), *x_var, mu_help, sigma);; ws.import(help, Silence(true));; ; // Fill the histograms use a unique pointer to prevent memory lea",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
Integrability,message,messages,". ROOT: tutorials/roofit/rf616_morphing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf616_morphing.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/46fff8d22015e5a26619. ; ; import ROOT; ; # Number of samples to fill the histograms; n_samples = 1000; ; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # morphing as a baseline; def morphing(setting):; # set up a frame for plotting; frame1 = x_var.frame(); ; # define binning for morphing; bin_mu_x = ROOT.RooBinning(4, 0.0, 4.0); grid = ROOT.RooMomentMorphFuncND.Grid(bin_mu_x); x_var.setBins(50); ; # number of 'sampled' Gaussians, if you change it, adjust the binning properly; for i in range(5):; # Create the sampled Gaussian; workspace.factory(f""Gaussian::g{i}(x, mu{i}[{i}], {sigma})"".format(i=i)); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples * 100); # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; # Adjust it to 0 to see binning; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, intOrder=1)); ; # Add the pdf to the grid and to the plot; grid.addPdf(workspace[f""histpdf{i}""], int(i)); workspace[f""histpdf{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
Testability,log,log,". ROOT: tutorials/roofit/rf616_morphing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf616_morphing.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/46fff8d22015e5a26619. ; ; import ROOT; ; # Number of samples to fill the histograms; n_samples = 1000; ; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # morphing as a baseline; def morphing(setting):; # set up a frame for plotting; frame1 = x_var.frame(); ; # define binning for morphing; bin_mu_x = ROOT.RooBinning(4, 0.0, 4.0); grid = ROOT.RooMomentMorphFuncND.Grid(bin_mu_x); x_var.setBins(50); ; # number of 'sampled' Gaussians, if you change it, adjust the binning properly; for i in range(5):; # Create the sampled Gaussian; workspace.factory(f""Gaussian::g{i}(x, mu{i}[{i}], {sigma})"".format(i=i)); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples * 100); # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; # Adjust it to 0 to see binning; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, intOrder=1)); ; # Add the pdf to the grid and to the plot; grid.addPdf(workspace[f""histpdf{i}""], int(i)); workspace[f""histpdf{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
Integrability,message,messages,"Tutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; # Create a product of Gaussians for all dimensions; gaussians = []; for j in range(n_dimensions):; gaussian = ROOT.RooGaussian(f""gdim{j}"", f""gdim{j}"", x_vars[j], mu_helps[j], sigmas[j]); gaussians.append(gaussian); ; # Create a product PDF for the multidi",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
Modifiability,variab,variable,"ce and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; # Create a product of Gaussians for all dimensions; gaussians = []; for j in range(n_dimensions):; gaussian = ROOT.RooGaussian(f""gdim{j}"", f""gdim{j}"", x_vars[j], mu_helps[j], sigmas[j]); gaussians.append(gaussian); ; # Create a product PDF for the multidimensional Gaussian; gauss_product = ROOT.RooProdPdf(""gauss_product"", ""gauss_product"", ROOT.RooArgList(*gaussians)); ; templates = dict(); ; # Iterate through each tuple; for idx, nd_idx in enumerate(itertools.product(range(n_bins), repeat=n_dimensions)):; for i_dim in range(n_dimensions):; mu_helps[i_dim].setVal(nd_idx[i_dim]); ; # Fill the histograms; hist = gauss_product.generateBinned(ROOT.RooArgSet(*x_vars), n_samples_morph); ; # Ensure that every bin is filled and there are no zero probabilities; for i_bin in range(hist.numEntries())",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
Testability,log,log,"t/rf617_simulation_based_inference_multidimensional.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf617_simulation_based_inference_multidimensional.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; # Create a product of G",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
Usability,simpl,simple,". ROOT: tutorials/roofit/rf617_simulation_based_inference_multidimensional.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf617_simulation_based_inference_multidimensional.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; #",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
Availability,mask,mask,"ey are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""] == sample_category; # Normalize each weight; weights = data_dict[""weight""][mask]; # Extract the weight_modified; weight_modified = weights / weight_sum; ; count = np.sum(mask); ; # Store the count and weight sum in the dictionary; results[sample_category] = {; ""weight_sum"": weight_sum,; ""weight_modified"": weight_modified,; ""count"": count,; ""weight"": weights,; }; ; ; # Extract the mass for higgs and zz; higgs_data = data_dict[""m4l""][data_dict[""sample_category""] == [""higgs""]]; zz_data = data_dict[""m4l""][data_dict[""sample_category""] == [""zz""]]; ; ; # Prepare sample weights; sample_weight_higgs = np.array([results[""higgs""][""weight_modified""]]).flatten(); sample_weight_zz = np.array([results[""zz""][""weight_modified""]]).flatten(); ; # Putting sample weights together in the same manner as the training data; sample_weight = np.concatenate([sample_weight_higgs, sample_weight_zz]); ; # For Training purposes we have to get rid of the negative weights, since xgb can",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
Integrability,depend,dependence,"amples from an background hypothesis here the zz samples and a target hypothesis, here the higgs samples. The data preparation is based on the tutorial 'df106_HiggsToFourLeptons.py'.; An introduction to mixture models can be found here https://arxiv.org/pdf/1506.02169.; A short summary: We assume the whole probability distribution can be written as a mixture of several components, i.e. $$p(x|\theta)= \sum_{c}w_{c}(\theta)p_{c}(x|\theta)$$ We can write the likelihood ratio in terms of pairwise classification problems \begin{align*} \frac{p(x|\mu)}{p(x|0)}&= \frac{\sum_{c}w_{c}(\mu)p_{c}(x|\mu)}{\sum_{c'}w_{c'}(0)p_{c'}(x|0)}\ &=\sum_{c}\Bigg[\sum_{c'}\frac{w_{c'}(0)}{w_{c}(\mu)}\frac{p_{c'}(x|0)}{p_{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # L",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
Safety,avoid,avoid,"{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""] == sample_category; # Normalize each weight; weights = data_dict[""weight""][mask]; # Extract the weight_modified; weight_modified = weights / weight_sum; ; count = np.sum(mask); ; # Store the count and weight sum in the dictionary; results[sample_category] = {; ""weight_sum"": weight_sum,; ""weight_modified"": weight_modified,; ""count"": count,; ""weight"": weights,; }; ; ; # Extract the mass for higgs and zz; higgs_data = data_dict[""m4l""][data_dict[""sample_category""] == [""higgs""]]; zz_data = data_dict[""m4l""][data_dict[""sample_category",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
Usability,simpl,simplify,"tons.py'.; An introduction to mixture models can be found here https://arxiv.org/pdf/1506.02169.; A short summary: We assume the whole probability distribution can be written as a mixture of several components, i.e. $$p(x|\theta)= \sum_{c}w_{c}(\theta)p_{c}(x|\theta)$$ We can write the likelihood ratio in terms of pairwise classification problems \begin{align*} \frac{p(x|\mu)}{p(x|0)}&= \frac{\sum_{c}w_{c}(\mu)p_{c}(x|\mu)}{\sum_{c'}w_{c'}(0)p_{c'}(x|0)}\ &=\sum_{c}\Bigg[\sum_{c'}\frac{w_{c'}(0)}{w_{c}(\mu)}\frac{p_{c'}(x|0)}{p_{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""]",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
Availability,error,error,"et &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::EfficiencyRooCmdArg Efficiency(const RooCategory &cat)Definition RooGlobalFunc.cxx:372; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf701_efficiencyfitDefinition rf701_efficiencyfit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf701_efficiencyfit.C. tutorialsroofitrf701_efficiencyfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf701_efficiencyfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf701_efficiencyfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function ; to a dataset D(x,cut), where cut is a category encoding a selection, of which the efficiency as function of x should be described by eff(x). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooFormulaVar.h""; #include ""RooProdPdf.h""; #include ""RooEfficiency.h""; #include ""RooPolynomial.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf701_efficiencyfit(); {; // C o n s t r u c t e f f i c i e n c y f u n c t i o n e ( x ); // -------------------------------------------------------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; ; // Efficiency function eff(x;a,b); RooRealVar a(""a"", ""a"", 0.4, 0, 1);; RooRealVar b(""b"", ""b"", 5);; RooRealVar c(""c"", ""c"", -1, -10, 10);; RooFormulaVar effFunc(""effFunc"", ""(1-a)+a*cos((x-c)/b)"", RooArgList(a, b, c, x));; ; // C o n s t r u c t c o n d i t i o n a l e f f i c i e n c y p d f E ( c u t | x ); // ------------------------------------------------------------------------------------------; ; // Acceptance state cut (1 or 0); RooCategory cut(""cut"", ""cutr"", { {""accept"", 1}, {""reject"", 0} });; ; // Construct efficiency pdf eff(cut|x); RooEfficiency effPdf(""effPdf"", ""effPdf"", effFunc, cut, ""accept"");; ; // G e n e r a t e d a t a ( x , c u t ) f r o m a t o y m o d e l; // -----------------------------------------------------------------------------; ; // Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); // (These are _only_ needed to generate some toy MC here ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
Performance,optimiz,optimization,"et &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::EfficiencyRooCmdArg Efficiency(const RooCategory &cat)Definition RooGlobalFunc.cxx:372; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf701_efficiencyfitDefinition rf701_efficiencyfit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf701_efficiencyfit.C. tutorialsroofitrf701_efficiencyfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
Availability,error,error,"------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; effPdf.fitTo(data, ConditionalObservables={x}, PrintLevel=-1); ; # Plot fitted, data efficiency; # --------------------------------------------------------; ; # Plot distribution of all events and accepted fraction of events on frame; frame1 = x.frame(Bins=20, Title=""Data (all, accepted)""); data.plotOn(frame1); data.plotOn(frame1, Cut=""cut==cut::accept"", MarkerColor=""r"", LineColor=""r""); ; # Plot accept/reject efficiency on data overlay fitted efficiency curve; frame2 = x.frame(Bins=20, Title=""Fitted efficiency""); data.plotOn(frame2, Efficiency=cut) # needs ROOT version >= 5.21; effFunc.plotOn(frame2, LineColor=""r""); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf701_efficiency"", ""rf701_efficiency"", 800, 400); ca.Divide(2); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; ca.SaveAs(""rf701_efficiencyfit.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf701_efficiencyfit.py. tutorialsroofitrf701_efficiencyfit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf701_efficiencyfit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf701_efficiencyfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection, which the efficiency as function of x should be described by eff(x) . ; import ROOT; ; ; # Construct efficiency function e(x); # -------------------------------------------------------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Efficiency function eff(x;a,b); a = ROOT.RooRealVar(""a"", ""a"", 0.4, 0, 1); b = ROOT.RooRealVar(""b"", ""b"", 5); c = ROOT.RooRealVar(""c"", ""c"", -1, -10, 10); effFunc = ROOT.RooFormulaVar(""effFunc"", ""(1-a)+a*cos((x-c)/b)"", [a, b, c, x]); ; # Construct conditional efficiency pdf E(cut|x); # ------------------------------------------------------------------------------------------; ; # Acceptance state cut (1 or 0); cut = ROOT.RooCategory(""cut"", ""cutr"", {""accept"": 1, ""reject"": 0}); ; # Construct efficiency pdf eff(cut|x); effPdf = ROOT.RooEfficiency(""effPdf"", ""effPdf"", effFunc, cut, ""accept""); ; # Generate data (x, cut) from a toy model; # -----------------------------------------------------------------------------; ; # Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); # (These are _only_ needed to generate some toy MC here to be used later); shapePdf = ROOT.RooPolynomial(""shapePdf"", ""shapePdf"", x, [-0.095]); model = ROOT.RooProdPdf(""model"", ""model"", {shapePdf}, Conditional=({effPdf}, {cut})); ; # Generate some toy data from model; data = model.generate({x, cut}, 10000); ; # Fit conditional efficiency pdf to data; # --------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; ef",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html
Performance,optimiz,optimization,"------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; effPdf.fitTo(data, ConditionalObservables={x}, PrintLevel=-1); ; # Plot fitted, data efficiency; # --------------------------------------------------------; ; # Plot distribution of all events and accepted fraction of events on frame; frame1 = x.frame(Bins=20, Title=""Data (all, accepted)""); data.plotOn(frame1); data.plotOn(frame1, Cut=""cut==cut::accept"", MarkerColor=""r"", LineColor=""r""); ; # Plot accept/reject efficiency on data overlay fitted efficiency curve; frame2 = x.frame(Bins=20, Title=""Fitted efficiency""); data.plotOn(frame2, Efficiency=cut) # needs ROOT version >= 5.21; effFunc.plotOn(frame2, LineColor=""r""); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf701_efficiency"", ""rf701_efficiency"", 800, 400); ca.Divide(2); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; ca.SaveAs(""rf701_efficiencyfit.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf701_efficiencyfit.py. tutorialsroofitrf701_efficiencyfit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html
Availability,error,error,"ditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf702_efficiencyfit_2DDefinition rf702_efficiencyfit_2D.py:1; ; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.C. tutorialsroofitrf702_efficiencyfit_2D.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf702_efficiencyfit_2D.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf702_efficiencyfit_2D.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection whose efficiency as function of x should be described by eff(x) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooCategory.h""; #include ""RooEfficiency.h""; #include ""RooPolynomial.h""; #include ""RooProdPdf.h""; #include ""RooFormulaVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf702_efficiencyfit_2D(bool flat = false); {; // C o n s t r u c t e f f i c i e n c y f u n c t i o n e ( x , y ); // -----------------------------------------------------------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Efficiency function eff(x;a,b); RooRealVar ax(""ax"", ""ay"", 0.6, 0, 1);; RooRealVar bx(""bx"", ""by"", 5);; RooRealVar cx(""cx"", ""cy"", -1, -10, 10);; ; RooRealVar ay(""ay"", ""ay"", 0.2, 0, 1);; RooRealVar by(""by"", ""by"", 5);; RooRealVar cy(""cy"", ""cy"", -1, -10, 10);; ; RooFormulaVar effFunc(""effFunc"", ""((1-ax)+ax*cos((x-cx)/bx))*((1-ay)+ay*cos((y-cy)/by))"",; RooArgList(ax, bx, cx, x, ay, by, cy, y));; ; // Acceptance state cut (1 or 0); RooCategory cut(""cut"", ""cutr"", { {""accept"", 1}, {""reject"", 0} });; ; // C o n s t r u c t c o n d i t i o n a l e f f i c i e n c y p d f E ( c u t | x , y ); // ---------------------------------------------------------------------------------------------; ; // Construct efficiency pdf eff(cut|x); RooEfficiency effPdf(""effPdf"", ""effPdf"", effFunc, cut, ""accept"");; ; // G e n e r a t e d a t a ( x , y , c u t",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
Performance,perform,performing,"RooFit::ConditionalRooCmdArg Conditional(const RooArgSet &pdfSet, const RooArgSet &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf702_efficiencyfit_2DDefinition rf702_efficiencyfit_2D.py:1; ; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
Availability,error,error,"tMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.py. tutorialsroofitrf702_efficiencyfit_2D.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf702_efficiencyfit_2D.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf702_efficiencyfit_2D.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection whose efficiency as function of x should be described by eff(x) . ; import ROOT; ; ; flat = False; # Construct efficiency function e(x,y); # -----------------------------------------------------------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Efficiency function eff(x;a,b); ax = ROOT.RooRealVar(""ax"", ""ay"", 0.6, 0, 1); bx = ROOT.RooRealVar(""bx"", ""by"", 5); cx = ROOT.RooRealVar(""cx"", ""cy"", -1, -10, 10); ; ay = ROOT.RooRealVar(""ay"", ""ay"", 0.2, 0, 1); by = ROOT.RooRealVar(""by"", ""by"", 5); cy = ROOT.RooRealVar(""cy"", ""cy"", -1, -10, 10); ; effFunc = ROOT.RooFormulaVar(; ""effFunc"", ""((1-ax)+ax*cos((x-cx)/bx))*((1-ay)+ay*cos((y-cy)/by))"", [ax, bx, cx, x, ay, by, cy, y]; ); ; # Acceptance state cut (1 or 0); cut = ROOT.RooCategory(""cut"", ""cutr"", {""accept"": 1, ""reject"": 0}); ; # Construct conditional efficiency pdf E(cut|x,y); # ---------------------------------------------------------------------------------------------; ; # Construct efficiency pdf eff(cut|x); effPdf = ROOT.RooEfficiency(""effPdf"", ""effPdf"", effFunc, cut, ""accept""); ; # Generate data(x,y,cut) from a toy model; # -------------------------------------------------------------------------------; ; # Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); # (These are _only_ needed to generate some toy MC here to be used later); shapePdfX = ROOT.RooPolynomial(""shapePdfX"", ""shapePdfX"", x, [0 if flat else -0.095]); shapePdfY = ROOT.RooPolynomial(""shapePdfY"", ""shape",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
Performance,perform,performing," hh_data_all = data.createHistogram(""hh_data_all"", x, Binning=8, YVar=dict(var=y, Binning=8)); hh_data_sel = data.createHistogram(""hh_data_sel"", x, Binning=8, YVar=dict(var=y, Binning=8), Cut=""cut==cut::accept""); hh_eff = effFunc.createHistogram(""hh_eff"", x, Binning=50, YVar=dict(var=y, Binning=50)); ; # Some adjustsment for good visualization; hh_data_all.SetMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
Availability,error,error,". ROOT: tutorials/roofit/rf703_effpdfprod.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf703_effpdfprod.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a product of an (acceptance) efficiency and a pdf as pdf . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooExponential.h""; #include ""RooEffProd.h""; #include ""RooFormulaVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf703_effpdfprod(); {; // D e f i n e o b s e r v a b l e s a n d d e c a y p d f; // ---------------------------------------------------------------; ; // Declare observables; RooRealVar t(""t"", ""t"", 0, 5);; ; // Make pdf; RooRealVar tau(""tau"", ""tau"", -1.54, -4, -0.1);; RooExponential model(""model"", ""model"", t, tau);; ; // D e f i n e e f f i c i e n c y f u n c t i o n; // ---------------------------------------------------; ; // Use error function to simulate turn-on slope; RooFormulaVar eff(""eff"", ""0.5*(TMath::Erf((t-1)/0.5)+1)"", t);; ; // D e f i n e d e c a y p d f w i t h e f f i c i e n c y; // ---------------------------------------------------------------; ; // Multiply pdf(t) with efficiency in t; RooEffProd modelEff(""modelEff"", ""model with efficiency"", model, eff);; ; // P l o t e f f i c i e n c y , p d f; // ----------------------------------------; ; RooPlot *frame1 = t.frame(Title(""Efficiency""));; eff.plotOn(frame1, LineColor(kRed));; ; RooPlot *frame2 = t.frame(Title(""Pdf with and without efficiency""));; ; model.plotOn(frame2, LineStyle(kDashed));; modelEff.plotOn(frame2);; ; // G e n e r a t e t o y d a t a , f i t m o d e l E f f t o d a t a; // ------------------------------------------------------------------------------; ; // Generate events. If the input pdf has an internal generator, the internal generator; // is used and an accept/reject sampling on the efficiency is",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
Deployability,integrat,integrator,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
Integrability,integrat,integrator,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
Modifiability,variab,variable,"ine c(i)Definition RSha256.hxx:101; RooConstVar.h; RooDataSet.h; RooEffProd.h; RooExponential.h; RooFormulaVar.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooEffProdThe class RooEffProd implements the product of a PDF with an efficiency function.Definition RooEffProd.h:19; RooExponentialExponential PDF.Definition RooExponential.h:22; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
Performance,optimiz,optimization,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
Availability,error,error,". ROOT: tutorials/roofit/rf703_effpdfprod.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf703_effpdfprod.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a product of an (acceptance) efficiency and a pdf as pdf . ; import ROOT; ; ; # Define observables and decay pdf; # ---------------------------------------------------------------; ; # Declare observables; t = ROOT.RooRealVar(""t"", ""t"", 0, 5); ; # Make pdf; tau = ROOT.RooRealVar(""tau"", ""tau"", -1.54, -4, -0.1); model = ROOT.RooExponential(""model"", ""model"", t, tau); ; # Define efficiency function; # ---------------------------------------------------; ; # Use error function to simulate turn-on slope; eff = ROOT.RooFormulaVar(""eff"", ""0.5*(TMath::Erf((t-1)/0.5)+1)"", [t]); ; # Define decay pdf with efficiency; # ---------------------------------------------------------------; ; # Multiply pdf(t) with efficiency in t; modelEff = ROOT.RooEffProd(""modelEff"", ""model with efficiency"", model, eff); ; # Plot efficiency, pdf; # ----------------------------------------; ; frame1 = t.frame(Title=""Efficiency""); eff.plotOn(frame1, LineColor=""r""); ; frame2 = t.frame(Title=""Pdf with and without efficiency""); ; model.plotOn(frame2, LineStyle=""--""); modelEff.plotOn(frame2); ; # Generate toy data, fit model eff to data; # ------------------------------------------------------------------------------; ; # Generate events. If the input pdf has an internal generator, internal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); RO",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
Deployability,integrat,integrator,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
Integrability,integrat,integrator,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
Performance,optimiz,optimization,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
Availability,error,error,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
Deployability,integrat,integrator,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
Integrability,integrat,integrator,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
Modifiability,variab,variable,"sin->Draw(""surf"");; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFormulaVar.h; RooGaussian.h; RooPlot.h; RooPolyVar.h; RooProduct.h; RooRealSumPdf.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolyVarA RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProductRepresents the product of a given set of RooAbsReal objects.Definition RooProduct.h:29; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definit",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
Performance,optimiz,optimization,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
Availability,error,error,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
Deployability,integrat,integrator,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
Integrability,integrat,integrator,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
Modifiability,variab,variables,"RealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components:",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
Performance,optimiz,optimization,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
Availability,error,error,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
Integrability,synchroniz,synchronize,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
Modifiability,variab,variable,"; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf705_linearmorph.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: linear interpolation between pdf shapes using the 'Alex Read' algorithm . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooIntegralMorph.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; a",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
Performance,cache,cache,"olation between pdf shapes using the 'Alex Read' algorithm . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooIntegralMorph.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
Testability,log,log,"setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; // S h o w 2 D d i s t r i b u t i o n o f p d f ( x , a l p h a ); // -----------------------------------------------------------------------; ; // Create 2D histogram; TH1 *hh = lmorph.createHistogram(""hh"", x, Binning(40), YVar(alpha, Binning(40)));; hh->SetLineColor(kBlue);; ; // F i t p d f t o d a t a s e t w i t h a l p h a = 0 . 8; // -----------------------------------------------------------------; ; // Generate a toy dataset at alpha = 0.8; alpha = 0.8;; std::unique_ptr<RooDataSet> data{lmorph.generate(x, 1000)};; ; // Fit pdf to toy data; lmorph.setCacheAlpha(true);; lmorph.fitTo(*data, Verbose(true), PrintLevel(-1));; ; // Plot fitted pdf and data overlaid; RooPlot *frame2 = x.frame(Bins(100));; data->plotOn(frame2);; lmorph.plotOn(frame2);; ; // S c a n - l o g ( L ) v s a l p h a; // -----------------------------------------; ; // Show scan -log(L) of dataset w.r.t alpha; RooPlot *frame3 = alpha.frame(Bins(100), Range(0.1, 0.9));; ; // Make 2D pdf of histogram; std::unique_ptr<RooAbsReal> nll{lmorph.createNLL(*data)};; nll->plotOn(frame3, ShiftToZero());; ; lmorph.setCacheAlpha(false);; ; TCanvas *c = new TCanvas(""rf705_linearmorph"", ""rf705_linearmorph"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.6);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.20);; hh->GetZaxis()->SetTitleOffset(2.5);; hh->Draw(""surf"");; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.4);; frame3->Draw();; c->cd(4);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; ; return;; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooIntegralMorph.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
Availability,error,error,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
Integrability,synchroniz,synchronize,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
Modifiability,variab,variable,". ROOT: tutorials/roofit/rf705_linearmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
Performance,cache,cache,"it/rf705_linearmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); # -------------------",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
Testability,log,log,"etVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); # -----------------------------------------------------------------------; ; # Create 2D histogram; hh = lmorph.createHistogram(""hh"", x, Binning=40, YVar=dict(var=alpha, Binning=40)); hh.SetLineColor(ROOT.kBlue); ; # Fit pdf to dataset with alpha=0.8; # -----------------------------------------------------------------; ; # Generate a toy dataset alpha = 0.8; alpha.setVal(0.8); data = lmorph.generate({x}, 1000); ; # Fit pdf to toy data; lmorph.setCacheAlpha(True); lmorph.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot fitted pdf and data overlaid; frame2 = x.frame(Bins=100); data.plotOn(frame2); lmorph.plotOn(frame2); ; # Scan -log(L) vs alpha; # -----------------------------------------; ; # Show scan -log(L) of dataset w.r.t alpha; frame3 = alpha.frame(Bins=100, Range=(0.1, 0.9)); ; # Make 2D pdf of histogram; nll = lmorph.createNLL(data); nll.plotOn(frame3, ShiftToZero=True); ; lmorph.setCacheAlpha(False); ; c = ROOT.TCanvas(""rf705_linearmorph"", ""rf705_linearmorph"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MOR",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
Modifiability,variab,variable,"plotOn(frame2);; histpdf2.plotOn(frame2);; ; TCanvas *c = new TCanvas(""rf706_histpdf"", ""rf706_histpdf"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooHistPdf.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooHistPdfA propability density function sampled from a multidimensional histogram.Definition RooHistPdf.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf706_histpdfDefinition rf706_histpdf.py:1; xmlio::Titleconst c",MatchSource.WIKI,doc/master/rf706__histpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf706__histpdf_8C.html
Deployability,configurat,configuration,".h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooAr",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
Energy Efficiency,adapt,adaptive,"le Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf707_kernelestimation.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooKeysPdf.h""; #include ""RooNDKeysPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel esti",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
Modifiability,adapt,adaptive,"le Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf707_kernelestimation.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooKeysPdf.h""; #include ""RooNDKeysPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel esti",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
Energy Efficiency,adapt,adaptive,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
Modifiability,adapt,adaptive,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
Deployability,integrat,integrates,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
Integrability,integrat,integrates,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
Modifiability,variab,variable,"fDecayPDF describing decay time distribution of B meson including effects of standard model CP violation.Definition RooBCPEffDecay.h:23; RooBCPEffDecay::DoubleSided@ DoubleSidedDefinition RooBCPEffDecay.h:26; RooBDecayMost general description of B decay time distribution with effects of CP violation,...Definition RooBDecay.h:25; RooBDecay::DoubleSided@ DoubleSidedDefinition RooBDecay.h:29; RooBMixDecayClass RooBMixDecay is a RooAbsAnaConvPdf implementation that describes the decay of B mesons with the...Definition RooBMixDecay.h:23; RooBMixDecay::DoubleSided@ DoubleSidedDefinition RooBMixDecay.h:26; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooTruthModelImplements a RooResolution model that corresponds to a delta function.Definition RooTruthModel.h:21; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Definition RooGlobalFunc.cxx:134; RooFit::CutRooCmdArg Cut(const ",MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
Deployability,integrat,integrates,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
Integrability,integrat,integrates,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
Modifiability,variab,variables,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
Availability,down,down,"sp_ph"", ""sp_ph"",; RooArgList(p_ph_sig1,p_ph_bkg1),; RooArgList(Asig1,Abkg1),; true);; ; // Construct the subsidiary poisson measurements constraining the histogram parameters; // These ensure that the bin contents of the histograms are only allowed to vary within; // the statistical uncertainty of the Monte Carlo.; RooHistConstraint hc_sig(""hc_sig"",""hc_sig"",p_ph_sig1);; RooHistConstraint hc_bkg(""hc_bkg"",""hc_bkg"",p_ph_bkg1);; ; // Construct the joint model with template PDFs and constraints; RooProdPdf model1(""model1"",""model1"",RooArgSet(hc_sig,hc_bkg),Conditional(model_tmp,x));; ; ; ; // ***** Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples) *****; ; // Construct the histogram shapes, using the same parameters for signal and background; // This requires passing the first histogram to the second, so that their common parameters; // can be re-used.; // The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; // This allows bin 0 to fluctuate up and down.; // Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; // synchronously. This reduces the number of parameters.; RooParamHistFunc p_ph_sig2(""p_ph_sig2"", ""p_ph_sig2"", *dh_sig, x);; RooParamHistFunc p_ph_bkg2(""p_ph_bkg2"", ""p_ph_bkg2"", *dh_bkg, x, &p_ph_sig2, true);; ; RooRealVar Asig2(""Asig"",""Asig"",1,0.01,5000);; RooRealVar Abkg2(""Abkg"",""Abkg"",1,0.01,5000);; ; // As before, construct the sum of signal2 and background2; RooRealSumPdf model2_tmp(""sp_ph"",""sp_ph"",; RooArgList(p_ph_sig2,p_ph_bkg2),; RooArgList(Asig2,Abkg2),; true);; ; // Construct the subsidiary poisson measurements constraining the statistical fluctuations; RooHistConstraint hc_sigbkg(""hc_sigbkg"",""hc_sigbkg"",RooArgSet(p_ph_sig2,p_ph_bkg2));; ; // Construct the joint model; RooProdPdf model2(""model2"",""model2"",hc_sigbkg, RooFit::Conditional(model2_tmp,x));; ; ; ; // ************ Fit all models to data and plot *********************; ; auto result0 = model0.fitTo",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
Deployability,update,updateFitRangeNorm,gamma_bin_7 = 0.996957 +/- 0.0460029 (limited); p_ph_sig2_gamma_bin_8 = 0.980068 +/- 0.0463103 (limited); p_ph_sig2_gamma_bin_9 = 1.00949 +/- 0.0478068 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) directly selected PDF components: (p_h_sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) directly selected PDF components: (p_h_bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 50 will supersede previous event count of 1050 for normalization of PDF projections; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) directly selected PDF components: (p_ph_sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) directly selected PDF components: (p_ph_bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 50 will supersede previous event count of 1050 for normalization of PDF projections; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) directly selected PDF components: (p_ph_sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) directly selected PDF components: (p_ph_bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 50 will supersede previous event count of 1050 for normalization of PDF projections; Asig [normal ] = 0.833778 +/- 0.189814; Asig [BB ] = 0.850329 +/- 0.235783; Asig [BBlight] = 0.834474 +/- 0.202955; Based on a demo by Wouter Verkerke ; Definition,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
Energy Efficiency,reduce,reduces,"togram parameters; // These ensure that the bin contents of the histograms are only allowed to vary within; // the statistical uncertainty of the Monte Carlo.; RooHistConstraint hc_sig(""hc_sig"",""hc_sig"",p_ph_sig1);; RooHistConstraint hc_bkg(""hc_bkg"",""hc_bkg"",p_ph_bkg1);; ; // Construct the joint model with template PDFs and constraints; RooProdPdf model1(""model1"",""model1"",RooArgSet(hc_sig,hc_bkg),Conditional(model_tmp,x));; ; ; ; // ***** Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples) *****; ; // Construct the histogram shapes, using the same parameters for signal and background; // This requires passing the first histogram to the second, so that their common parameters; // can be re-used.; // The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; // This allows bin 0 to fluctuate up and down.; // Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; // synchronously. This reduces the number of parameters.; RooParamHistFunc p_ph_sig2(""p_ph_sig2"", ""p_ph_sig2"", *dh_sig, x);; RooParamHistFunc p_ph_bkg2(""p_ph_bkg2"", ""p_ph_bkg2"", *dh_bkg, x, &p_ph_sig2, true);; ; RooRealVar Asig2(""Asig"",""Asig"",1,0.01,5000);; RooRealVar Abkg2(""Abkg"",""Abkg"",1,0.01,5000);; ; // As before, construct the sum of signal2 and background2; RooRealSumPdf model2_tmp(""sp_ph"",""sp_ph"",; RooArgList(p_ph_sig2,p_ph_bkg2),; RooArgList(Asig2,Abkg2),; true);; ; // Construct the subsidiary poisson measurements constraining the statistical fluctuations; RooHistConstraint hc_sigbkg(""hc_sigbkg"",""hc_sigbkg"",RooArgSet(p_ph_sig2,p_ph_bkg2));; ; // Construct the joint model; RooProdPdf model2(""model2"",""model2"",hc_sigbkg, RooFit::Conditional(model2_tmp,x));; ; ; ; // ************ Fit all models to data and plot *********************; ; auto result0 = model0.fitTo(sumData, PrintLevel(0), Save());; auto result1 = model1.fitTo(sumData, PrintLevel(0), Save());; auto result2 = model2.fitTo(sumData, PrintLevel(0), Save());;",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
Modifiability,parameteriz,parameterized,"end(*sigData);; sumData.append(*bkgData);; ; ; // Make histogram templates for signal and background.; // Let's take a signal distribution with low statistics and a more accurate; // background distribution.; // Normally, these come from Monte Carlo simulations, but we will just generate them.; std::unique_ptr<RooDataHist> dh_sig( g.generateBinned(x, 50) );; std::unique_ptr<RooDataHist> dh_bkg( u.generateBinned(x, 10000) );; ; ; // ***** Case 0 - 'Rigid templates' *****; ; // Construct histogram shapes for signal and background; RooHistFunc p_h_sig(""p_h_sig"",""p_h_sig"",x,*dh_sig);; RooHistFunc p_h_bkg(""p_h_bkg"",""p_h_bkg"",x,*dh_bkg);; ; // Construct scale factors for adding the two distributions; RooRealVar Asig0(""Asig"",""Asig"",1,0.01,5000);; RooRealVar Abkg0(""Abkg"",""Abkg"",1,0.01,5000);; ; // Construct the sum model; RooRealSumPdf model0(""model0"",""model0"",; RooArgList(p_h_sig,p_h_bkg),; RooArgList(Asig0,Abkg0),; true);; ; ; ; // ***** Case 1 - 'Barlow Beeston' *****; ; // Construct parameterized histogram shapes for signal and background; RooParamHistFunc p_ph_sig1(""p_ph_sig"",""p_ph_sig"",*dh_sig, x);; RooParamHistFunc p_ph_bkg1(""p_ph_bkg"",""p_ph_bkg"",*dh_bkg, x);; ; RooRealVar Asig1(""Asig"",""Asig"",1,0.01,5000);; RooRealVar Abkg1(""Abkg"",""Abkg"",1,0.01,5000);; ; // Construct the sum of these; RooRealSumPdf model_tmp(""sp_ph"", ""sp_ph"",; RooArgList(p_ph_sig1,p_ph_bkg1),; RooArgList(Asig1,Abkg1),; true);; ; // Construct the subsidiary poisson measurements constraining the histogram parameters; // These ensure that the bin contents of the histograms are only allowed to vary within; // the statistical uncertainty of the Monte Carlo.; RooHistConstraint hc_sig(""hc_sig"",""hc_sig"",p_ph_sig1);; RooHistConstraint hc_bkg(""hc_bkg"",""hc_bkg"",p_ph_bkg1);; ; // Construct the joint model with template PDFs and constraints; RooProdPdf model1(""model1"",""model1"",RooArgSet(hc_sig,hc_bkg),Conditional(model_tmp,x));; ; ; ; // ***** Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
Performance,optimiz,optimization,"&paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf709_BarlowBeestonDefinition rf709_BarlowBeeston.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
Safety,safe,safe,"figure1.C:7; RooFit::ParametersRooCmdArg Parameters(const RooArgSet &params)Definition RooGlobalFunc.cxx:787; RooFit::ConditionalRooCmdArg Conditional(const RooArgSet &pdfSet, const RooArgSet &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::VisualizeErrorRooCmdArg VisualizeError(const RooDataSet &paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf709_BarlowBeestonDefinition rf709_BarlowBeeston.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOpt",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
Testability,log,log,"_bin_13,p_ph_sig_gamma_bin_14,p_ph_sig_gamma_bin_15,p_ph_sig_gamma_bin_16,p_ph_sig_gamma_bin_17,p_ph_sig_gamma_bin_18,p_ph_sig_gamma_bin_19,p_ph_sig_gamma_bin_2,p_ph_sig_gamma_bin_20,p_ph_sig_gamma_bin_21,p_ph_sig_gamma_bin_22,p_ph_sig_gamma_bin_23,p_ph_sig_gamma_bin_24,p_ph_sig_gamma_bin_3,p_ph_sig_gamma_bin_4,p_ph_sig_gamma_bin_5,p_ph_sig_gamma_bin_6,p_ph_sig_gamma_bin_7,p_ph_sig_gamma_bin_8,p_ph_sig_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model1) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model1_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 16000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10425.6) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=0.024352 Asig=0.0100451 p_ph_bkg_gamma_bin_0=0.351482 p_ph_bkg_gamma_bin_1=0.352595 p_ph_bkg_gamma_bin_10=0.342683 p_ph_bkg_gamma_bin_11=0.368891 p_ph_bkg_gamma_bin_12=0.38197 p_ph_bkg_gamma_bin_13=0.365529 p_ph_bkg_gamma_bin_14=0.358098 p_ph_bkg_gamma_bin_15=0.358584 p_ph_bkg_gamma_bin_16=0.367344 p_ph_bkg_gamma_bin_17=0.356263 p_ph_bkg_gamma_bin_18=0.362211 p_ph_bkg_gamma_bin_19=0.340063 p_ph_bkg_gamma_bin_2=0.35054 p_ph_bkg_gamma_bin_20=0.352376 p_ph_bkg_gamma_bin_21=0.351589 p_ph_bkg_gamma_bin_22=0.351615 p_ph_bkg_gamma_bin_23=0.344488 p_ph_bkg_gamma_bin_24=0.365687 p_ph_bkg_gamma_bin_3=0.355197 p_ph_bkg_gamma_bin_4=0.347776 p_ph_bkg_gamma_bin_5=0.348629 p_ph_bkg_gamma_bin_6=0.357616 p_ph_bkg_gamma_bin_7=0.351061 p_ph_bkg_gamma_bin_8=0.342678 p_ph_bkg_gamma_bin_9=0.357292 p_ph_sig_gamma_bin_11=0.3339 p_ph_sig_gamma_bin_12=0.341347 p_ph_sig_gamma_bin_13=0.333434 p_ph_sig_gamma_bin_14=0.328932 p_ph_sig_gamma_bin_15=0.328666; ; RooAbsMinimizerFcn: Min",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
Availability,down,down,"_tmp = ROOT.RooRealSumPdf(""sp_ph"", ""sp_ph"", [p_ph_sig1, p_ph_bkg1], [Asig1, Abkg1], True); ; # Construct the subsidiary poisson measurements constraining the histogram parameters; # These ensure that the bin contents of the histograms are only allowed to vary within; # the statistical uncertainty of the Monte Carlo.; hc_sig = ROOT.RooHistConstraint(""hc_sig"", ""hc_sig"", p_ph_sig1); hc_bkg = ROOT.RooHistConstraint(""hc_bkg"", ""hc_bkg"", p_ph_bkg1); ; # Construct the joint model with template PDFs and constraints; model1 = ROOT.RooProdPdf(""model1"", ""model1"", {hc_sig, hc_bkg}, Conditional=(model_tmp, x)); ; ; # Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples); ; # Construct the histogram shapes, using the same parameters for signal and background; # This requires passing the first histogram to the second, so that their common parameters; # can be re-used.; # The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; # This allows bin 0 to fluctuate up and down.; # Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; # synchronously. This reduces the number of parameters.; p_ph_sig2 = ROOT.RooParamHistFunc(""p_ph_sig2"", ""p_ph_sig2"", dh_sig, x); p_ph_bkg2 = ROOT.RooParamHistFunc(""p_ph_bkg2"", ""p_ph_bkg2"", dh_bkg, x, p_ph_sig2, True); ; Asig2 = ROOT.RooRealVar(""Asig"", ""Asig"", 1, 0.01, 5000); Abkg2 = ROOT.RooRealVar(""Abkg"", ""Abkg"", 1, 0.01, 5000); ; # As before, construct the sum of signal2 and background2; model2_tmp = ROOT.RooRealSumPdf(""sp_ph"", ""sp_ph"", [p_ph_sig2, p_ph_bkg2], [Asig2, Abkg2], True); ; # Construct the subsidiary poisson measurements constraining the statistical fluctuations; hc_sigbkg = ROOT.RooHistConstraint(""hc_sigbkg"", ""hc_sigbkg"", {p_ph_sig2, p_ph_bkg2}); ; # Construct the joint model; model2 = ROOT.RooProdPdf(""model2"", ""model2"", hc_sigbkg, Conditional=(model2_tmp, x)); ; ; # ************ Fit all models to data and plot *********************; ; result0 = model0.fi",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html
Deployability,update,updateFitRangeNorm,gamma_bin_7 = 0.996957 +/- 0.0460029 (limited); p_ph_sig2_gamma_bin_8 = 0.980068 +/- 0.0463103 (limited); p_ph_sig2_gamma_bin_9 = 1.00949 +/- 0.0478068 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) directly selected PDF components: (p_h_sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) directly selected PDF components: (p_h_bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model0) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 50 will supersede previous event count of 1050 for normalization of PDF projections; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) directly selected PDF components: (p_ph_sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) directly selected PDF components: (p_ph_bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model1) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 50 will supersede previous event count of 1050 for normalization of PDF projections; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) directly selected PDF components: (p_ph_sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) directly selected PDF components: (p_ph_bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model2) indirectly selected PDF components: (sp_ph); [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 50 will supersede previous event count of 1050 for normalization of PDF projections; Asig [normal ] = 0.8337778709310433 +/- 0.1898141852388937; Asig [BB ] = 0.8503293171898778 +/- 0.23578281150991715; Asig [BBlight] = 0.8344736023864808 +/- 0.2029,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html
Energy Efficiency,reduce,reduces,"he histogram parameters; # These ensure that the bin contents of the histograms are only allowed to vary within; # the statistical uncertainty of the Monte Carlo.; hc_sig = ROOT.RooHistConstraint(""hc_sig"", ""hc_sig"", p_ph_sig1); hc_bkg = ROOT.RooHistConstraint(""hc_bkg"", ""hc_bkg"", p_ph_bkg1); ; # Construct the joint model with template PDFs and constraints; model1 = ROOT.RooProdPdf(""model1"", ""model1"", {hc_sig, hc_bkg}, Conditional=(model_tmp, x)); ; ; # Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples); ; # Construct the histogram shapes, using the same parameters for signal and background; # This requires passing the first histogram to the second, so that their common parameters; # can be re-used.; # The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; # This allows bin 0 to fluctuate up and down.; # Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; # synchronously. This reduces the number of parameters.; p_ph_sig2 = ROOT.RooParamHistFunc(""p_ph_sig2"", ""p_ph_sig2"", dh_sig, x); p_ph_bkg2 = ROOT.RooParamHistFunc(""p_ph_bkg2"", ""p_ph_bkg2"", dh_bkg, x, p_ph_sig2, True); ; Asig2 = ROOT.RooRealVar(""Asig"", ""Asig"", 1, 0.01, 5000); Abkg2 = ROOT.RooRealVar(""Abkg"", ""Abkg"", 1, 0.01, 5000); ; # As before, construct the sum of signal2 and background2; model2_tmp = ROOT.RooRealSumPdf(""sp_ph"", ""sp_ph"", [p_ph_sig2, p_ph_bkg2], [Asig2, Abkg2], True); ; # Construct the subsidiary poisson measurements constraining the statistical fluctuations; hc_sigbkg = ROOT.RooHistConstraint(""hc_sigbkg"", ""hc_sigbkg"", {p_ph_sig2, p_ph_bkg2}); ; # Construct the joint model; model2 = ROOT.RooProdPdf(""model2"", ""model2"", hc_sigbkg, Conditional=(model2_tmp, x)); ; ; # ************ Fit all models to data and plot *********************; ; result0 = model0.fitTo(sumData, PrintLevel=0, Save=True); result1 = model1.fitTo(sumData, PrintLevel=0, Save=True); result2 = model2.fitTo(sumData, PrintLevel=0, Save=True); ",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html
Modifiability,parameteriz,parameterized,", 50); bkgData = u.generate(x, 1000); ; sumData = ROOT.RooDataSet(""sumData"", ""Gauss + Uniform"", x); sumData.append(sigData); sumData.append(bkgData); ; ; # Make histogram templates for signal and background.; # Let's take a signal distribution with low statistics and a more accurate; # background distribution.; # Normally, these come from Monte Carlo simulations, but we will just generate them.; dh_sig = g.generateBinned(x, 50); dh_bkg = u.generateBinned(x, 10000); ; ; # Case 0 - 'Rigid templates'; ; # Construct histogram shapes for signal and background; p_h_sig = ROOT.RooHistFunc(""p_h_sig"", ""p_h_sig"", x, dh_sig); p_h_bkg = ROOT.RooHistFunc(""p_h_bkg"", ""p_h_bkg"", x, dh_bkg); ; # Construct scale factors for adding the two distributions; Asig0 = ROOT.RooRealVar(""Asig"", ""Asig"", 1, 0.01, 5000); Abkg0 = ROOT.RooRealVar(""Abkg"", ""Abkg"", 1, 0.01, 5000); ; # Construct the sum model; model0 = ROOT.RooRealSumPdf(""model0"", ""model0"", [p_h_sig, p_h_bkg], [Asig0, Abkg0], True); ; ; # Case 1 - 'Barlow Beeston'; ; # Construct parameterized histogram shapes for signal and background; p_ph_sig1 = ROOT.RooParamHistFunc(""p_ph_sig"", ""p_ph_sig"", dh_sig, x); p_ph_bkg1 = ROOT.RooParamHistFunc(""p_ph_bkg"", ""p_ph_bkg"", dh_bkg, x); ; Asig1 = ROOT.RooRealVar(""Asig"", ""Asig"", 1, 0.01, 5000); Abkg1 = ROOT.RooRealVar(""Abkg"", ""Abkg"", 1, 0.01, 5000); ; # Construct the sum of these; model_tmp = ROOT.RooRealSumPdf(""sp_ph"", ""sp_ph"", [p_ph_sig1, p_ph_bkg1], [Asig1, Abkg1], True); ; # Construct the subsidiary poisson measurements constraining the histogram parameters; # These ensure that the bin contents of the histograms are only allowed to vary within; # the statistical uncertainty of the Monte Carlo.; hc_sig = ROOT.RooHistConstraint(""hc_sig"", ""hc_sig"", p_ph_sig1); hc_bkg = ROOT.RooHistConstraint(""hc_bkg"", ""hc_bkg"", p_ph_bkg1); ; # Construct the joint model with template PDFs and constraints; model1 = ROOT.RooProdPdf(""model1"", ""model1"", {hc_sig, hc_bkg}, Conditional=(model_tmp, x)); ; ; # Case 2 - 'Barlow",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html
Performance,optimiz,optimization,"st char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html
Safety,safe,safe,"Blight] = {} +/- {}"".format(Asig2.getVal(), Asig2.getError())); ; can.SaveAs(""rf709_BarlowBeeston.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOpt",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html
Testability,log,log,"_bin_13,p_ph_sig_gamma_bin_14,p_ph_sig_gamma_bin_15,p_ph_sig_gamma_bin_16,p_ph_sig_gamma_bin_17,p_ph_sig_gamma_bin_18,p_ph_sig_gamma_bin_19,p_ph_sig_gamma_bin_2,p_ph_sig_gamma_bin_20,p_ph_sig_gamma_bin_21,p_ph_sig_gamma_bin_22,p_ph_sig_gamma_bin_23,p_ph_sig_gamma_bin_24,p_ph_sig_gamma_bin_3,p_ph_sig_gamma_bin_4,p_ph_sig_gamma_bin_5,p_ph_sig_gamma_bin_6,p_ph_sig_gamma_bin_7,p_ph_sig_gamma_bin_8,p_ph_sig_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model1) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model1_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 16000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10425.6) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=0.024352 Asig=0.0100451 p_ph_bkg_gamma_bin_0=0.351482 p_ph_bkg_gamma_bin_1=0.352595 p_ph_bkg_gamma_bin_10=0.342683 p_ph_bkg_gamma_bin_11=0.368891 p_ph_bkg_gamma_bin_12=0.38197 p_ph_bkg_gamma_bin_13=0.365529 p_ph_bkg_gamma_bin_14=0.358098 p_ph_bkg_gamma_bin_15=0.358584 p_ph_bkg_gamma_bin_16=0.367344 p_ph_bkg_gamma_bin_17=0.356263 p_ph_bkg_gamma_bin_18=0.362211 p_ph_bkg_gamma_bin_19=0.340063 p_ph_bkg_gamma_bin_2=0.35054 p_ph_bkg_gamma_bin_20=0.352376 p_ph_bkg_gamma_bin_21=0.351589 p_ph_bkg_gamma_bin_22=0.351615 p_ph_bkg_gamma_bin_23=0.344488 p_ph_bkg_gamma_bin_24=0.365687 p_ph_bkg_gamma_bin_3=0.355197 p_ph_bkg_gamma_bin_4=0.347776 p_ph_bkg_gamma_bin_5=0.348629 p_ph_bkg_gamma_bin_6=0.357616 p_ph_bkg_gamma_bin_7=0.351061 p_ph_bkg_gamma_bin_8=0.342678 p_ph_bkg_gamma_bin_9=0.357292 p_ph_sig_gamma_bin_11=0.3339 p_ph_sig_gamma_bin_12=0.341347 p_ph_sig_gamma_bin_13=0.333434 p_ph_sig_gamma_bin_14=0.328932 p_ph_sig_gamma_bin_15=0.328666; ; RooAbsMinimizerFcn: Min",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html
Modifiability,variab,variables,"d), Name(""taylor_o2""));; ; frame->SetMinimum(-8.0);; frame->SetMaximum(+8.0);; frame->SetYTitle(""function value"");; frame->Draw();; ; auto legend = new TLegend(0.53, 0.7, 0.86, 0.87);; legend->SetFillColor(kWhite);; legend->SetLineColor(kWhite);; legend->SetTextSize(0.02);; legend->AddEntry(""taylor_o1"", ""Taylor expansion upto first order"", ""L"");; legend->AddEntry(""taylor_o2"", ""Taylor expansion upto second order"", ""L"");; legend->AddEntry(""f"", ""Polynomial of fourth order"", ""L"");; legend->Draw();; c->Draw();; c->SaveAs(""rf710_roopoly.png"");; }; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RooAbsCollection.h; RooPlot.h; RooPolyFunc.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kWhite@ kWhiteDefinition Rtypes.h:65; kDashed@ kDashedDefinition TAttLine.h:48; kDotted@ kDottedDefinition TAttLine.h:48; TCanvas.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooPolyFuncRooPolyFunc implements a polynomial function in multi-variables.Definition RooPolyFunc.h:28; RooPolyFunc::taylorExpandstatic std::unique_ptr< RooPolyFunc > taylorExpand(const char *name, const char *title, RooAbsReal &func, const RooArgList &observables, int order=1, std::vector< double > const &observableValues={}, double eps1=1e-6, double eps2=1e-3)Taylor expanding given function in terms of observables around observableValues.Definition RooPolyFunc.cxx:242; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or oth",MatchSource.WIKI,doc/master/rf710__roopoly_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf710__roopoly_8C.html
Availability,error,errors," RooLagrangianMorphFunc::Config::fileNamestd::string fileNameDefinition RooLagrangianMorphFunc.h:88; RooLagrangianMorphFunc::Config::folderNamesstd::vector< std::string > folderNamesDefinition RooLagrangianMorphFunc.h:91; ; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x7ffccdd4a418; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count of 24931.9 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 18947.1 will supersede previous event count of 11104.6 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 30765.5 will supersede previous event count of 18947.1 for normalization of PDF projections; [#0] PROGRESS:Caching -- creating cac",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html
Deployability,update,updateFitRangeNorm," RooLagrangianMorphFunc::Config::fileNamestd::string fileNameDefinition RooLagrangianMorphFunc.h:88; RooLagrangianMorphFunc::Config::folderNamesstd::vector< std::string > folderNamesDefinition RooLagrangianMorphFunc.h:91; ; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x7ffccdd4a418; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count of 24931.9 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 18947.1 will supersede previous event count of 11104.6 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 30765.5 will supersede previous event count of 18947.1 for normalization of PDF projections; [#0] PROGRESS:Caching -- creating cac",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html
Integrability,interface,interface,"::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TAxis::SetRangeUservirtual void SetRangeUser(Double_t ufirst, Double_t ulast)Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is,...Definition TAxis.cxx:1080; TCanvasThe Canvas class.Definition TCanvas.h:23; TColor::InvertPalettestatic void InvertPalette()Invert the current color palette.Definition TColor.cxx:3640; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::FindObjectTObject * FindObject(const char *name) const overrideSearch object identified by name in the tree of folders inside this folder.Definition TFolder.cxx:306; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObj",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html
Modifiability,coupling,couplings,"utorials » RooFit Tutorials. Detailed Description; Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. . ; #include <RooAbsCollection.h>; #include <RooDataHist.h>; #include <RooDataSet.h>; #include <RooLagrangianMorphFunc.h>; #include <RooPlot.h>; #include <RooRealVar.h>; ; #include <TCanvas.h>; #include <TColor.h>; #include <TFile.h>; #include <TFolder.h>; #include <TH1.h>; #include <TLegend.h>; #include <TStyle.h>; ; using namespace RooFit;; ; void rf711_lagrangianmorph(); {; // C r e a t e v a r i a b l e s f o r; // m o r p h i n g f u n c t i o n; // ---------------------------------------------; ; std::string observablename = ""pTV"";; ; // Setup observable that is morphed; RooRealVar obsvar(observablename.c_str(), ""p_{T}^{V}"", 10, 600);; ; // Setup two couplings that enters the morphing function; // kSM -> SM coupling set to constant (1); // cHq3 -> EFT parameter with NewPhysics attribute set to true; RooRealVar kSM(""kSM"", ""sm modifier"", 1.0);; RooRealVar cHq3(""cHq3"", ""EFT modifier"", 0.0, 1.0);; cHq3.setAttribute(""NewPhysics"", true);; ; // I n p u t s n e e d e d f o r c o n f i g; // ---------------------------------------------; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; std::vector<std::string> samplelist = {""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2""};; ; // S e t u p C o n f i g; // ---------------------------------------------; RooLagrangianMorphFunc::Config config;; config.fileName = infilename;; config.observableName = observablename;; config.folderNames = samplelist;; config.couplings.add(cHq3);; config.couplings.add(kSM);; ; // C r e a t e m o r p h i n g f u n c t i o n; // ---------------------------------------------; RooLagrangianMorphFunc morphfunc(""morphfunc"", ""morphed dist. of pTV"", config);; ; // G e t m o r p h e d d i s ",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html
Performance,cache,cache,".py:1; xmlio::Nameconst char * NameDefinition TXMLSetup.cxx:67; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RooLagrangianMorphFunc::ConfigDefinition RooLagrangianMorphFunc.h:85; RooLagrangianMorphFunc::Config::couplingsRooArgList couplingsDefinition RooLagrangianMorphFunc.h:92; RooLagrangianMorphFunc::Config::observableNamestd::string observableNameDefinition RooLagrangianMorphFunc.h:86; RooLagrangianMorphFunc::Config::fileNamestd::string fileNameDefinition RooLagrangianMorphFunc.h:88; RooLagrangianMorphFunc::Config::folderNamesstd::vector< std::string > folderNamesDefinition RooLagrangianMorphFunc.h:91; ; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x7ffccdd4a418; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count of 249",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html
Safety,predict,prediction,"auto frame1 = obsvar.frame(Title(""Morphed templates for selected values""));; morph_datahist_0p01.plotOn(frame1, Name(""morph_dh_cHq3=0.01""), DrawOption(""C""), LineColor(kGreen),; DataError(RooAbsData::None), XErrorSize(0));; morph_datahist_0p25.plotOn(frame1, Name(""morph_dh_cHq3=0.25""), DrawOption(""C""), LineColor(kGreen + 1),; DataError(RooAbsData::None), XErrorSize(0));; morph_datahist_0p5.plotOn(frame1, Name(""morph_dh_cHq3=0.5""), DrawOption(""C""), LineColor(kGreen + 2),; DataError(RooAbsData::None), XErrorSize(0));; ; // C r e a t e w r a p p e d p d f t o g e n e r a t e; // 2D d a t a s e t o f c H q 3 a s a f u n c t i o n o f; // o b s e r v a b l e; // ---------------------------------------------; ; RooWrapperPdf model(""wrap_pdf"", ""wrap_pdf"", morphfunc);; std::unique_ptr<RooDataSet> data{model.generate({cHq3, obsvar}, 1000000)};; TH1 *hh_data = data->createHistogram(""pTV vs cHq3"", obsvar, Binning(20), YVar(cHq3, Binning(50)));; hh_data->SetTitle(""Morphing prediction"");; ; // D r a w p l o t s o n c a n v a s; // ---------------------------------------------; TCanvas *c1 = new TCanvas(""fig3"", ""fig3"", 1200, 400);; c1->Divide(3, 1);; ; c1->cd(1);; gPad->SetLeftMargin(0.15);; gPad->SetRightMargin(0.05);; ; frame0->Draw();; TLegend *leg1 = new TLegend(0.55, 0.65, 0.94, 0.87);; leg1->SetTextSize(0.04);; leg1->SetFillColor(kWhite);; leg1->SetLineColor(kWhite);; leg1->AddEntry(""SM_NPsq0"", ""SM"", ""LP"");; leg1->AddEntry((TObject *)0, """", """");; leg1->AddEntry(""cHq3_NPsq1"", ""c_{Hq^(3)}=1.0 at #Lambda^{-2}"", ""LP"");; leg1->AddEntry((TObject *)0, """", """");; leg1->AddEntry(""cHq3_NPsq2"", ""c_{Hq^(3)}=1.0 at #Lambda^{-4}"", ""LP"");; leg1->Draw();; ; c1->cd(2);; gPad->SetLeftMargin(0.15);; gPad->SetRightMargin(0.05);; ; frame1->Draw();; ; TLegend *leg2 = new TLegend(0.60, 0.65, 0.94, 0.87);; leg2->SetTextSize(0.04);; leg2->SetFillColor(kWhite);; leg2->SetLineColor(kWhite);; leg2->AddEntry(""morph_dh_cHq3=0.01"", ""c_{Hq^{(3)}}=0.01"", ""L"");; leg2->AddEntry((TObject *)0, """", """");; leg2->Ad",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html
Availability,error,errors,"InvertPalette(); ROOT.gPad.SetLogz(); hh_data.GetYaxis().SetTitle(""c_{Hq^{(3)}}""); hh_data.GetYaxis().SetRangeUser(0, 0.5); hh_data.GetZaxis().SetTitleOffset(1.8); hh_data.Draw(""COLZ""); c1.SaveAs(""rf711_lagrangianmorph.png""); [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x97df860; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count of 24931.9 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 18947.1 will supersede previous event count of 11104.6 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 30765.5 will supersede previous event count of 18947.1 for normalization of PDF projections; [#0] PROGRESS:Caching -- creati",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html
Deployability,update,updateFitRangeNorm,"InvertPalette(); ROOT.gPad.SetLogz(); hh_data.GetYaxis().SetTitle(""c_{Hq^{(3)}}""); hh_data.GetYaxis().SetRangeUser(0, 0.5); hh_data.GetZaxis().SetTitleOffset(1.8); hh_data.Draw(""COLZ""); c1.SaveAs(""rf711_lagrangianmorph.png""); [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x97df860; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count of 24931.9 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 18947.1 will supersede previous event count of 11104.6 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 30765.5 will supersede previous event count of 18947.1 for normalization of PDF projections; [#0] PROGRESS:Caching -- creati",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html
Integrability,wrap,wrapped,"amplelist; }; ; # Plot input templates; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; frame0 = obsvar.frame(Title=""Input templates for p_{T}^{V}""); for sample, color in zip(samplelist, ""krb""):; input_datahists[sample].plotOn(frame0, Name=sample, LineColor=color, MarkerColor=color, MarkerSize=1); ; # Plot morphed templates for cHq3=0.01,0.25,0.5; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; frame1 = obsvar.frame(Title=""Morphed templates for selected values""); plot_args = dict(; DrawOption=""C"",; DataError=None,; XErrorSize=0,; ); morph_datahist_0p01.plotOn(frame1, Name=""morph_dh_cHq3=0.01"", LineColor=""kGreen"", **plot_args); morph_datahist_0p25.plotOn(frame1, Name=""morph_dh_cHq3=0.25"", LineColor=""kGreen+1"", **plot_args); morph_datahist_0p5.plotOn(frame1, Name=""morph_dh_cHq3=0.5"", LineColor=""kGreen+2"", **plot_args); ; # Create wrapped pdf to generate 2D dataset of cHq3 as a function of pTV; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; model = ROOT.RooWrapperPdf(""wrap_pdf"", ""wrap_pdf"", morphfunc); data = model.generate({cHq3, obsvar}, 1000000); hh_data = data.createHistogram(""x,y"", obsvar, Binning=20, YVar=dict(var=cHq3, Binning=50)); hh_data.SetTitle(""Morphing prediction""); ; # Draw plots on canvas; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; c1 = ROOT.TCanvas(""fig3"", ""fig3"", 1200, 400); c1.Divide(3, 1); ; c1.cd(1); ROOT.gPad.SetLeftMargin(0.15); ROOT.gPad.SetRightMargin(0.05); ; frame0.Draw(); leg1 = ROOT.TLegend(0.55, 0.65, 0.94, 0.87); leg1.SetTextSize(0.04); leg1.SetFillColor(ROOT.kWhite); leg1.SetLineColor(ROOT.kWhite); leg1.AddEntry(""SM_NPsq0"", ""SM"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq1"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-2}"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq2"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-4}"", ""LP""); leg1.Draw();",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html
Modifiability,coupling,couplings,". ROOT: tutorials/roofit/rf711_lagrangianmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf711_lagrangianmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Morphing effective field theory distributions with RooLagrangianMorphFunc. ; A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ROOT.PyConfig.IgnoreCommandLineOptions = True; ROOT.gROOT.SetBatch(True); ; # Create functions; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; observablename = ""pTV""; ; # Setup observable that is to be morphed; obsvar = ROOT.RooRealVar(observablename, ""p_{T}^{V}"", 10, 600); ; # Setup two couplings that enters the morphing function; # kSM -> SM coupling set to constant (1); # cHq3 -> EFT parameter with NewPhysics attribute set to true; kSM = ROOT.RooRealVar(""kSM"", ""sm modifier"", 1.0); cHq3 = ROOT.RooRealVar(""cHq3"", ""EFT modifier"", 0.0, 1.0); cHq3.setAttribute(""NewPhysics"", True); ; # Inputs to setup config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; infilename = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/input_histos_rf_lagrangianmorph.root""; par = ""cHq3""; samplelist = [""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2""]; ; # Set Config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; config = ROOT.RooLagrangianMorphFunc.Config(); config.fileName = infilename; config.observableName = observablename; config.folderNames = samplelist; config.couplings.add(cHq3); config.couplings.add(kSM); ; ; # Create morphing function; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; morphfunc = ROOT.RooLagrangianMorphFunc(""morphfunc"", ""morphed dist. of pTV"", config); ; # Get morphed distribution at c",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html
Performance,cache,cache,"leg2.AddEntry(0, """", """"); leg2.AddEntry(""morph_dh_cHq3=0.25"", ""c_{Hq^{(3)}}=0.25"", ""L""); leg2.AddEntry(0, """", """"); leg2.AddEntry(""morph_dh_cHq3=0.5"", ""c_{Hq^{(3)}}=0.5"", ""L""); leg2.AddEntry(0, """", """"); leg2.Draw(); ; c1.cd(3); ROOT.gPad.SetLeftMargin(0.12); ROOT.gPad.SetRightMargin(0.18); ROOT.gStyle.SetNumberContours(255); ROOT.gStyle.SetPalette(ROOT.kGreyScale); ROOT.gStyle.SetOptStat(0); ROOT.TColor.InvertPalette(); ROOT.gPad.SetLogz(); hh_data.GetYaxis().SetTitle(""c_{Hq^{(3)}}""); hh_data.GetYaxis().SetRangeUser(0, 0.5); hh_data.GetZaxis().SetTitleOffset(1.8); hh_data.Draw(""COLZ""); c1.SaveAs(""rf711_lagrangianmorph.png""); [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x97df860; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(dh_cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count ",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html
Safety,predict,prediction,"0.5; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; frame1 = obsvar.frame(Title=""Morphed templates for selected values""); plot_args = dict(; DrawOption=""C"",; DataError=None,; XErrorSize=0,; ); morph_datahist_0p01.plotOn(frame1, Name=""morph_dh_cHq3=0.01"", LineColor=""kGreen"", **plot_args); morph_datahist_0p25.plotOn(frame1, Name=""morph_dh_cHq3=0.25"", LineColor=""kGreen+1"", **plot_args); morph_datahist_0p5.plotOn(frame1, Name=""morph_dh_cHq3=0.5"", LineColor=""kGreen+2"", **plot_args); ; # Create wrapped pdf to generate 2D dataset of cHq3 as a function of pTV; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; model = ROOT.RooWrapperPdf(""wrap_pdf"", ""wrap_pdf"", morphfunc); data = model.generate({cHq3, obsvar}, 1000000); hh_data = data.createHistogram(""x,y"", obsvar, Binning=20, YVar=dict(var=cHq3, Binning=50)); hh_data.SetTitle(""Morphing prediction""); ; # Draw plots on canvas; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; c1 = ROOT.TCanvas(""fig3"", ""fig3"", 1200, 400); c1.Divide(3, 1); ; c1.cd(1); ROOT.gPad.SetLeftMargin(0.15); ROOT.gPad.SetRightMargin(0.05); ; frame0.Draw(); leg1 = ROOT.TLegend(0.55, 0.65, 0.94, 0.87); leg1.SetTextSize(0.04); leg1.SetFillColor(ROOT.kWhite); leg1.SetLineColor(ROOT.kWhite); leg1.AddEntry(""SM_NPsq0"", ""SM"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq1"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-2}"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq2"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-4}"", ""LP""); leg1.Draw(); ; c1.cd(2); ROOT.gPad.SetLeftMargin(0.15); ROOT.gPad.SetRightMargin(0.05); ; frame1.Draw(); ; leg2 = ROOT.TLegend(0.62, 0.65, 0.94, 0.87); leg2.SetTextSize(0.04); leg2.SetFillColor(ROOT.kWhite); leg2.SetLineColor(ROOT.kWhite); ; leg2.AddEntry(""morph_dh_cHq3=0.01"", ""c_{Hq^{(3)}}=0.01"", ""L""); leg2.AddEntry(0, """", """"); leg2.AddEntry(""morph_dh_cHq3=0.25"", ""c_{Hq^{(3)}}=0.25"", ""L""); leg2.AddEntr",MatchSource.WIKI,doc/master/rf711__lagrangianmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html
Availability,error,error,"ngianMorphFunc::Config config;; config.fileName = infilename;; config.observableName = observablename;; config.folderNames = samplelist;; config.couplings.add(cHq3);; config.couplings.add(cHl3);; config.couplings.add(cHDD);; config.couplings.add(kSM);; ; // C r e a t e m o r p h i n g f u n c t i o n; // ---------------------------------------------; RooLagrangianMorphFunc morphfunc(""morphfunc"", ""morphed dist. of pTV"", config);; ; // C r e a t e p s e u d o d a t a h i s t o g r a m; // f o r f i t; // ---------------------------------------------; morphfunc.setParameter(""cHq3"", 0.01);; morphfunc.setParameter(""cHl3"", 1.0);; morphfunc.setParameter(""cHDD"", 0.2);; ; auto pseudo_hist = morphfunc.createTH1(""pseudo_hist"");; auto pseudo_dh = new RooDataHist(""pseudo_dh"", ""pseudo_dh"", RooArgList(obsvar), pseudo_hist);; ; // reset parameters to zeros before fit; morphfunc.setParameter(""cHq3"", 0.0);; morphfunc.setParameter(""cHl3"", 0.0);; morphfunc.setParameter(""cHDD"", 0.0);; ; // error set used as initial step size; cHq3.setError(0.1);; cHl3.setError(0.1);; cHDD.setError(0.1);; ; // W r a p p d f o n m o r p h f u n c a n d; // f i t t o d a t a h i s t o g r a m; // ---------------------------------------------; // wrapper pdf to normalise morphing function to a morphing pdf; RooWrapperPdf model(""wrap_pdf"", ""wrap_pdf"", morphfunc);; auto fitres = model.fitTo(*pseudo_dh, SumW2Error(true), Optimize(false), Save(), PrintLevel(-1));; auto hcorr = fitres->correlationHist();; ; // E x t r a c t p o s t f i t d i s t r i b u t i o n; // a n d p l o t w i t h i n i t i a l; // h i s t o g r a m; // ---------------------------------------------; auto postfit_hist = morphfunc.createTH1(""morphing_postfit_hist"");; RooDataHist postfit_dh(""morphing_postfit_dh"", ""morphing_postfit_dh"", RooArgList(obsvar), postfit_hist);; ; auto frame0 = obsvar.frame(Title(""Fitted histogram of p_{T}^{V}""));; postfit_dh.plotOn(frame0, Name(""postfit_dist""), DrawOption(""C""), LineColor(kBlue), DataError(RooAbsData",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Deployability,update,updateFitRangeNorm,"-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.372361 cHl3=0.491134 cHq3=-0.886807; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=5.8312, denominator=wrap_pdf_Int[pTV]=12183.6; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:InputArguments -- RooAbsData::plotOn(pseudo_dh) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 7389.24 will supersede previous event count of 9313.81 for normalization of PDF projections; DateJanuary 2022 ; AuthorRahul Balasubramanian ; Definition in file rf712_lagrangianmorphfit.C. tutorialsroofitrf712_lagrangianmorphfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Integrability,wrap,wrapper,");; config.couplings.add(kSM);; ; // C r e a t e m o r p h i n g f u n c t i o n; // ---------------------------------------------; RooLagrangianMorphFunc morphfunc(""morphfunc"", ""morphed dist. of pTV"", config);; ; // C r e a t e p s e u d o d a t a h i s t o g r a m; // f o r f i t; // ---------------------------------------------; morphfunc.setParameter(""cHq3"", 0.01);; morphfunc.setParameter(""cHl3"", 1.0);; morphfunc.setParameter(""cHDD"", 0.2);; ; auto pseudo_hist = morphfunc.createTH1(""pseudo_hist"");; auto pseudo_dh = new RooDataHist(""pseudo_dh"", ""pseudo_dh"", RooArgList(obsvar), pseudo_hist);; ; // reset parameters to zeros before fit; morphfunc.setParameter(""cHq3"", 0.0);; morphfunc.setParameter(""cHl3"", 0.0);; morphfunc.setParameter(""cHDD"", 0.0);; ; // error set used as initial step size; cHq3.setError(0.1);; cHl3.setError(0.1);; cHDD.setError(0.1);; ; // W r a p p d f o n m o r p h f u n c a n d; // f i t t o d a t a h i s t o g r a m; // ---------------------------------------------; // wrapper pdf to normalise morphing function to a morphing pdf; RooWrapperPdf model(""wrap_pdf"", ""wrap_pdf"", morphfunc);; auto fitres = model.fitTo(*pseudo_dh, SumW2Error(true), Optimize(false), Save(), PrintLevel(-1));; auto hcorr = fitres->correlationHist();; ; // E x t r a c t p o s t f i t d i s t r i b u t i o n; // a n d p l o t w i t h i n i t i a l; // h i s t o g r a m; // ---------------------------------------------; auto postfit_hist = morphfunc.createTH1(""morphing_postfit_hist"");; RooDataHist postfit_dh(""morphing_postfit_dh"", ""morphing_postfit_dh"", RooArgList(obsvar), postfit_hist);; ; auto frame0 = obsvar.frame(Title(""Fitted histogram of p_{T}^{V}""));; postfit_dh.plotOn(frame0, Name(""postfit_dist""), DrawOption(""C""), LineColor(kBlue), DataError(RooAbsData::None),; XErrorSize(0));; pseudo_dh->plotOn(frame0, Name(""input""));; ; // D r a w p l o t s o n c a n v a s; // ---------------------------------------------; TCanvas *c1 = new TCanvas(""fig3"", ""fig3"", 800, 400);; c1->Divi",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Modifiability,variab,variables,". ROOT: tutorials/roofit/rf712_lagrangianmorphfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf712_lagrangianmorphfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Performing a simple fit with RooLagrangianMorphFunc. ; a morphing function is setup as a function of three variables and a fit is performed on a pseudo-dataset. ; #include <RooDataHist.h>; #include <RooFitResult.h>; #include <RooLagrangianMorphFunc.h>; #include <RooPlot.h>; #include <RooRealVar.h>; ; #include <TAxis.h>; #include <TCanvas.h>; #include <TH2.h>; #include <TStyle.h>; ; using namespace RooFit;; ; void rf712_lagrangianmorphfit(); {; // C r e a t e v a r i a b l e s f o r; // m o r p h i n g f u n c t i o n; // ---------------------------------------------; ; std::string observablename = ""pTV"";; RooRealVar obsvar(observablename.c_str(), ""observable of pTV"", 10, 600);; RooRealVar kSM(""kSM"", ""sm modifier"", 1.0);; RooRealVar cHq3(""cHq3"", ""EFT modifier"", -10.0, 10.0);; cHq3.setAttribute(""NewPhysics"", true);; RooRealVar cHl3(""cHl3"", ""EFT modifier"", -10.0, 10.0);; cHl3.setAttribute(""NewPhysics"", true);; RooRealVar cHDD(""cHDD"", ""EFT modifier"", -10.0, 10.0);; cHDD.setAttribute(""NewPhysics"", true);; ; // I n p u t s n e e d e d f o r c o n f i g; // ---------------------------------------------; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; std::vector<std::string> samplelist = {""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2"", ""cHl3_NPsq1"",; ""cHl3_NPsq2"", ""cHDD_NPsq1"", ""cHDD_NPsq2"", ""cHl3_cHDD_NPsq2"",; ""cHq3_cHDD_NPsq2"", ""cHl3_cHq3_NPsq2""};; ; // S e t u p C o n f i g; // ---------------------------------------------; RooLagrangianMorphFunc::Config config;; config.fileName = infilename;; config.observableName = observablename;; config.folderNames = samplelist;; config.couplings.add(cHq3);; config.couplings.add(cHl3);; config.couplings.add(cHDD);; config.couplings.add(kSM)",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Performance,perform,performed,". ROOT: tutorials/roofit/rf712_lagrangianmorphfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf712_lagrangianmorphfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Performing a simple fit with RooLagrangianMorphFunc. ; a morphing function is setup as a function of three variables and a fit is performed on a pseudo-dataset. ; #include <RooDataHist.h>; #include <RooFitResult.h>; #include <RooLagrangianMorphFunc.h>; #include <RooPlot.h>; #include <RooRealVar.h>; ; #include <TAxis.h>; #include <TCanvas.h>; #include <TH2.h>; #include <TStyle.h>; ; using namespace RooFit;; ; void rf712_lagrangianmorphfit(); {; // C r e a t e v a r i a b l e s f o r; // m o r p h i n g f u n c t i o n; // ---------------------------------------------; ; std::string observablename = ""pTV"";; RooRealVar obsvar(observablename.c_str(), ""observable of pTV"", 10, 600);; RooRealVar kSM(""kSM"", ""sm modifier"", 1.0);; RooRealVar cHq3(""cHq3"", ""EFT modifier"", -10.0, 10.0);; cHq3.setAttribute(""NewPhysics"", true);; RooRealVar cHl3(""cHl3"", ""EFT modifier"", -10.0, 10.0);; cHl3.setAttribute(""NewPhysics"", true);; RooRealVar cHDD(""cHDD"", ""EFT modifier"", -10.0, 10.0);; cHDD.setAttribute(""NewPhysics"", true);; ; // I n p u t s n e e d e d f o r c o n f i g; // ---------------------------------------------; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; std::vector<std::string> samplelist = {""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2"", ""cHl3_NPsq1"",; ""cHl3_NPsq2"", ""cHDD_NPsq1"", ""cHDD_NPsq2"", ""cHl3_cHDD_NPsq2"",; ""cHq3_cHDD_NPsq2"", ""cHl3_cHq3_NPsq2""};; ; // S e t u p C o n f i g; // ---------------------------------------------; RooLagrangianMorphFunc::Config config;; config.fileName = infilename;; config.observableName = observablename;; config.folderNames = samplelist;; config.couplings.add(cHq3);; config.couplings.add(cHl3);; config.couplings.add(cHDD);; config.couplings.add(kSM)",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Safety,recover,recover," boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x5559dfeef700; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLo",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Testability,log,log,"ling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(pseudo_dh): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x5559dfeef700; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ ",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Usability,simpl,simple,". ROOT: tutorials/roofit/rf712_lagrangianmorphfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf712_lagrangianmorphfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Performing a simple fit with RooLagrangianMorphFunc. ; a morphing function is setup as a function of three variables and a fit is performed on a pseudo-dataset. ; #include <RooDataHist.h>; #include <RooFitResult.h>; #include <RooLagrangianMorphFunc.h>; #include <RooPlot.h>; #include <RooRealVar.h>; ; #include <TAxis.h>; #include <TCanvas.h>; #include <TH2.h>; #include <TStyle.h>; ; using namespace RooFit;; ; void rf712_lagrangianmorphfit(); {; // C r e a t e v a r i a b l e s f o r; // m o r p h i n g f u n c t i o n; // ---------------------------------------------; ; std::string observablename = ""pTV"";; RooRealVar obsvar(observablename.c_str(), ""observable of pTV"", 10, 600);; RooRealVar kSM(""kSM"", ""sm modifier"", 1.0);; RooRealVar cHq3(""cHq3"", ""EFT modifier"", -10.0, 10.0);; cHq3.setAttribute(""NewPhysics"", true);; RooRealVar cHl3(""cHl3"", ""EFT modifier"", -10.0, 10.0);; cHl3.setAttribute(""NewPhysics"", true);; RooRealVar cHDD(""cHDD"", ""EFT modifier"", -10.0, 10.0);; cHDD.setAttribute(""NewPhysics"", true);; ; // I n p u t s n e e d e d f o r c o n f i g; // ---------------------------------------------; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; std::vector<std::string> samplelist = {""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2"", ""cHl3_NPsq1"",; ""cHl3_NPsq2"", ""cHDD_NPsq1"", ""cHDD_NPsq2"", ""cHl3_cHDD_NPsq2"",; ""cHq3_cHDD_NPsq2"", ""cHl3_cHq3_NPsq2""};; ; // S e t u p C o n f i g; // ---------------------------------------------; RooLagrangianMorphFunc::Config config;; config.fileName = infilename;; config.observableName = observablename;; config.folderNames = samplelist;; config.couplings.add(cHq3);; config.couplings.add(cHl3);; config.couplings.add(cHDD);; config.couplings.add(kSM)",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html
Availability,error,error,"name; config.observableName = observablename; config.folderNames = samplelist; config.couplings.add(cHq3); config.couplings.add(cHDD); config.couplings.add(cHl3); config.couplings.add(kSM); ; ; # Create morphing function; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; morphfunc = ROOT.RooLagrangianMorphFunc(""morphfunc"", ""morphed dist. of pTV"", config); ; # Create pseudo data histogram to fit at cHq3 = 0.01, cHl3 = 1.0, cHDD = 0.2; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; morphfunc.setParameter(""cHq3"", 0.01); morphfunc.setParameter(""cHl3"", 1.0); morphfunc.setParameter(""cHDD"", 0.2); ; pseudo_hist = morphfunc.createTH1(""pseudo_hist""); pseudo_dh = ROOT.RooDataHist(""pseudo_dh"", ""pseudo_dh"", [obsvar], pseudo_hist); ; # reset parameters to zeros before fit; morphfunc.setParameter(""cHq3"", 0.0); morphfunc.setParameter(""cHl3"", 0.0); morphfunc.setParameter(""cHDD"", 0.0); ; # set error to set initial step size in fit; cHq3.setError(0.1); cHl3.setError(0.1); cHDD.setError(0.1); ; # Wrap pdf on morphfunc and fit to data histogram; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; # wrapper pdf to normalise morphing function to a morphing pdf; model = ROOT.RooWrapperPdf(""wrap_pdf"", ""wrap_pdf"", morphfunc); fitres = model.fitTo(pseudo_dh, SumW2Error=True, Optimize=False, Save=True, PrintLevel=-1); # run the fit; # Get the correlation matrix; hcorr = fitres.correlationHist(); ; # Extract postfit distribution and plot with initial histogram; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; postfit_hist = morphfunc.createTH1(""morphing_postfit_hist""); postfit_dh = ROOT.RooDataHist(""morphing_postfit_dh"", ""morphing_postfit_dh"", [obsvar], postfit_hist); ; frame0 = obsvar.frame(Title=""Input templates for p_{T}^{V}""); postfit_dh.plotOn(; frame0,; Name=""postfit_dist"",; DrawOption=""C"",; LineColor=""b",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Deployability,update,updateFitRangeNorm,"evel p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.372361 cHl3=0.491134 cHq3=-0.886807; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=5.8312, denominator=wrap_pdf_Int[pTV]=12183.6; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:InputArguments -- RooAbsData::plotOn(pseudo_dh) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 7389.24 will supersede previous event count of 9313.81 for normalization of PDF projections; DateJanuary 2022 ; AuthorRahul Balasubramanian ; Definition in file rf712_lagrangianmorphfit.py. tutorialsroofitrf712_lagrangianmorphfit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Integrability,wrap,wrapper,"# Create morphing function; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; morphfunc = ROOT.RooLagrangianMorphFunc(""morphfunc"", ""morphed dist. of pTV"", config); ; # Create pseudo data histogram to fit at cHq3 = 0.01, cHl3 = 1.0, cHDD = 0.2; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; morphfunc.setParameter(""cHq3"", 0.01); morphfunc.setParameter(""cHl3"", 1.0); morphfunc.setParameter(""cHDD"", 0.2); ; pseudo_hist = morphfunc.createTH1(""pseudo_hist""); pseudo_dh = ROOT.RooDataHist(""pseudo_dh"", ""pseudo_dh"", [obsvar], pseudo_hist); ; # reset parameters to zeros before fit; morphfunc.setParameter(""cHq3"", 0.0); morphfunc.setParameter(""cHl3"", 0.0); morphfunc.setParameter(""cHDD"", 0.0); ; # set error to set initial step size in fit; cHq3.setError(0.1); cHl3.setError(0.1); cHDD.setError(0.1); ; # Wrap pdf on morphfunc and fit to data histogram; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; # wrapper pdf to normalise morphing function to a morphing pdf; model = ROOT.RooWrapperPdf(""wrap_pdf"", ""wrap_pdf"", morphfunc); fitres = model.fitTo(pseudo_dh, SumW2Error=True, Optimize=False, Save=True, PrintLevel=-1); # run the fit; # Get the correlation matrix; hcorr = fitres.correlationHist(); ; # Extract postfit distribution and plot with initial histogram; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; postfit_hist = morphfunc.createTH1(""morphing_postfit_hist""); postfit_dh = ROOT.RooDataHist(""morphing_postfit_dh"", ""morphing_postfit_dh"", [obsvar], postfit_hist); ; frame0 = obsvar.frame(Title=""Input templates for p_{T}^{V}""); postfit_dh.plotOn(; frame0,; Name=""postfit_dist"",; DrawOption=""C"",; LineColor=""b"",; DataError=None,; XErrorSize=0,; ); pseudo_dh.plotOn(frame0, Name=""input""); ; # Draw plots on canvas; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Modifiability,config,config,"e ; .  . Loading...; Searching...; No Matches. Namespaces ; rf712_lagrangianmorphfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Performing a simple fit with RooLagrangianMorphFunc . ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ROOT.PyConfig.IgnoreCommandLineOptions = True; ROOT.gROOT.SetBatch(True); ; # Create functions; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; observablename = ""pTV""; obsvar = ROOT.RooRealVar(observablename, ""observable of pTV"", 10, 600); ; # Setup three EFT coefficient and constant SM modifier; kSM = ROOT.RooRealVar(""kSM"", ""sm modifier"", 1.0); cHq3 = ROOT.RooRealVar(""cHq3"", ""EFT modifier"", -10.0, 10.0); cHq3.setAttribute(""NewPhysics"", True); cHl3 = ROOT.RooRealVar(""cHl3"", ""EFT modifier"", -10.0, 10.0); cHl3.setAttribute(""NewPhysics"", True); cHDD = ROOT.RooRealVar(""cHDD"", ""EFT modifier"", -10.0, 10.0); cHDD.setAttribute(""NewPhysics"", True); ; # Inputs to setup config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; infilename = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/input_histos_rf_lagrangianmorph.root""; par = ""cHq3""; samplelist = [; ""SM_NPsq0"",; ""cHq3_NPsq1"",; ""cHq3_NPsq2"",; ""cHl3_NPsq1"",; ""cHl3_NPsq2"",; ""cHDD_NPsq1"",; ""cHDD_NPsq2"",; ""cHl3_cHDD_NPsq2"",; ""cHq3_cHDD_NPsq2"",; ""cHl3_cHq3_NPsq2"",; ]; ; # Set Config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; config = ROOT.RooLagrangianMorphFunc.Config(); config.fileName = infilename; config.observableName = observablename; config.folderNames = samplelist; config.couplings.add(cHq3); config.couplings.add(cHDD); config.couplings.add(cHl3); config.couplings.add(kSM); ; ; # Create morphing function; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; morphfunc = ROOT.RooLagrangianMorphFunc(""morphfunc"", ""morphed dist. of pTV"", config); ; # Create pseudo data histogram to fit at cHq3 ",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Performance,cache,cache,"}""); hcorr.GetXaxis().SetBinLabel(3, ""c_{HDD}""); hcorr.GetXaxis().SetBinLabel(2, ""c_{Hl^{(3)}}""); hcorr.GetXaxis().SetBinLabel(1, ""c_{Hq^{(3)}}""); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz text""); ; c1.SaveAs(""rf712_lagrangianmorphfit.png""); [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x85555e0; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(pseudo_dh): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x915c650; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, deno",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Safety,recover,recover,"t bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x915c650; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLo",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Testability,log,log,"tHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(pseudo_dh): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x915c650; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ ",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Usability,simpl,simple,". ROOT: tutorials/roofit/rf712_lagrangianmorphfit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf712_lagrangianmorphfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Performing a simple fit with RooLagrangianMorphFunc . ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ROOT.PyConfig.IgnoreCommandLineOptions = True; ROOT.gROOT.SetBatch(True); ; # Create functions; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; observablename = ""pTV""; obsvar = ROOT.RooRealVar(observablename, ""observable of pTV"", 10, 600); ; # Setup three EFT coefficient and constant SM modifier; kSM = ROOT.RooRealVar(""kSM"", ""sm modifier"", 1.0); cHq3 = ROOT.RooRealVar(""cHq3"", ""EFT modifier"", -10.0, 10.0); cHq3.setAttribute(""NewPhysics"", True); cHl3 = ROOT.RooRealVar(""cHl3"", ""EFT modifier"", -10.0, 10.0); cHl3.setAttribute(""NewPhysics"", True); cHDD = ROOT.RooRealVar(""cHDD"", ""EFT modifier"", -10.0, 10.0); cHDD.setAttribute(""NewPhysics"", True); ; # Inputs to setup config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; infilename = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/input_histos_rf_lagrangianmorph.root""; par = ""cHq3""; samplelist = [; ""SM_NPsq0"",; ""cHq3_NPsq1"",; ""cHq3_NPsq2"",; ""cHl3_NPsq1"",; ""cHl3_NPsq2"",; ""cHDD_NPsq1"",; ""cHDD_NPsq2"",; ""cHl3_cHDD_NPsq2"",; ""cHq3_cHDD_NPsq2"",; ""cHl3_cHq3_NPsq2"",; ]; ; # Set Config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; config = ROOT.RooLagrangianMorphFunc.Config(); config.fileName = infilename; config.observableName = observablename; config.folderNames = samplelist; config.couplings.add(cHq3); config.couplings.add(cHDD); config.couplings.add(cHl3); config.couplings.add(kSM); ; ; # Create morphing function; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; morphfunc = ROOT.RooLagrangianM",MatchSource.WIKI,doc/master/rf712__lagrangianmorphfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html
Availability,error,error,"s"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", -0.2, -1, 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar nbkg(""nbkg"", ""number of background events,"", 150, 0, 1000);; RooRealVar nsig(""nsig"", ""number of signal events"", 150, 0, 1000);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), RooArgList(nbkg, nsig));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Instantiate RooMCStudy manager on model with x as observable and given choice of fit options; //; // The Silence() option kills all messages below the PROGRESS level, leaving only a single message; // per sample executed, and any error message that occur during fitting; //; // The Extended() option has two effects:; // 1) The extended ML term is included in the likelihood and; // 2) A poisson fluctuation is introduced on the number of generated events; //; // The FitOptions() given here are passed to the fitting stage of each toy experiment.; // If Save() is specified, the fit result of each experiment is saved by the manager; //; // A Binned() option is added in this example to bin the data between generation and fitting; // to speed up the study at the expense of some precision; ; RooMCStudy *mcstudy =; new RooMCStudy(model, x, Binned(true), Silence(), Extended(), FitOptions(Save(true), PrintEvalErrors(0)));; ; // G e n e r a t e a n d f i t e v e n t s; // ---------------------------------------------; ; // Generate and fit 1000 samples of Poisson(nE",MatchSource.WIKI,doc/master/rf801__mcstudy_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html
Integrability,message,messages,"s"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", -0.2, -1, 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar nbkg(""nbkg"", ""number of background events,"", 150, 0, 1000);; RooRealVar nsig(""nsig"", ""number of signal events"", 150, 0, 1000);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), RooArgList(nbkg, nsig));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Instantiate RooMCStudy manager on model with x as observable and given choice of fit options; //; // The Silence() option kills all messages below the PROGRESS level, leaving only a single message; // per sample executed, and any error message that occur during fitting; //; // The Extended() option has two effects:; // 1) The extended ML term is included in the likelihood and; // 2) A poisson fluctuation is introduced on the number of generated events; //; // The FitOptions() given here are passed to the fitting stage of each toy experiment.; // If Save() is specified, the fit result of each experiment is saved by the manager; //; // A Binned() option is added in this example to bin the data between generation and fitting; // to speed up the study at the expense of some precision; ; RooMCStudy *mcstudy =; new RooMCStudy(model, x, Binned(true), Silence(), Extended(), FitOptions(Save(true), PrintEvalErrors(0)));; ; // G e n e r a t e a n d f i t e v e n t s; // ---------------------------------------------; ; // Generate and fit 1000 samples of Poisson(nE",MatchSource.WIKI,doc/master/rf801__mcstudy_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html
Modifiability,extend,extended,"s"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", -0.2, -1, 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar nbkg(""nbkg"", ""number of background events,"", 150, 0, 1000);; RooRealVar nsig(""nsig"", ""number of signal events"", 150, 0, 1000);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), RooArgList(nbkg, nsig));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Instantiate RooMCStudy manager on model with x as observable and given choice of fit options; //; // The Silence() option kills all messages below the PROGRESS level, leaving only a single message; // per sample executed, and any error message that occur during fitting; //; // The Extended() option has two effects:; // 1) The extended ML term is included in the likelihood and; // 2) A poisson fluctuation is introduced on the number of generated events; //; // The FitOptions() given here are passed to the fitting stage of each toy experiment.; // If Save() is specified, the fit result of each experiment is saved by the manager; //; // A Binned() option is added in this example to bin the data between generation and fitting; // to speed up the study at the expense of some precision; ; RooMCStudy *mcstudy =; new RooMCStudy(model, x, Binned(true), Silence(), Extended(), FitOptions(Save(true), PrintEvalErrors(0)));; ; // G e n e r a t e a n d f i t e v e n t s; // ---------------------------------------------; ; // Generate and fit 1000 samples of Poisson(nE",MatchSource.WIKI,doc/master/rf801__mcstudy_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html
Performance,perform,perform,". ROOT: tutorials/roofit/rf801_mcstudy.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf801_mcstudy.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooMCStudy.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH2.h""; #include ""RooFitResult.h""; #include ""TStyle.h""; #include ""TDirectory.h""; ; using namespace RooFit;; ; void rf801_mcstudy(); {; // C r e a t e m o d e l; // -----------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; x.setBins(40);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5, 0, 10);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", -0.2, -1, 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar nbkg(""nbkg"", ""number of background events,"", 150, 0, 1000);; RooRealVar nsig(""nsig"", ""number of signal events"", 150, 0, 1000);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), RooArgList(nbkg, nsig));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Instantiate RooMCStudy manager on model with x as observable",MatchSource.WIKI,doc/master/rf801__mcstudy_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html
Safety,safe,safe,"he outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf801_mcstudyDefinition rf801_mcstudy.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 990; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 980; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 970; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 960; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 950; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-797.721) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.716236 a1=-0.675686 mean=5.04367 nbkg=115.661 nsig=155.327 sig1frac=0.880121; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 940; [#0] PROGRESS:Generation -- RooMCStudy::run: sampl",MatchSource.WIKI,doc/master/rf801__mcstudy_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html
Testability,log,log,"lation_matrix"") constReturn TH2D of correlation matrix.Definition RooFitResult.cxx:1086; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMCStudyHelper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fittin...Definition RooMCStudy.h:32; RooMCStudy::plotPullRooPlot * plotPull(const RooRealVar &param, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Plot the distribution of pull values for the specified parameter on a newly created frame.Definition RooMCStudy.cxx:1087; RooMCStudy::fitResultconst RooFitResult * fitResult(Int_t sampleNum) constReturn the RooFitResult of the fit with the given run number.Definition RooMCStudy.cxx:831; RooMCStudy::plotNLLRooPlot * plotNLL(const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Plot the distribution of the -log(L) values on a newly created frame.Definition RooMCStudy.cxx:962; RooMCStudy::fitParDataSetconst RooDataSet & fitParDataSet()Return a RooDataSet containing the post-fit parameters of each toy cycle.Definition RooMCStudy.cxx:793; RooMCStudy::generateAndFitbool generateAndFit(Int_t nSamples, Int_t nEvtPerSample=0, bool keepGenData=false, const char *asciiFilePat=nullptr)Generate and fit 'nSamples' samples of 'nEvtPerSample' events.Definition RooMCStudy.cxx:503; RooMCStudy::plotParamRooPlot * plotParam(const RooRealVar &param, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Plot the distribution of the fitted value of the given parameter on a newly created frame.Definition RooMCStudy.cxx:928; RooMCStudy::plot",MatchSource.WIKI,doc/master/rf801__mcstudy_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html
Availability,error,error,"uild Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, -1, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events, "", 150, 0, 1000); nsig = ROOT.RooRealVar(""nsig"", ""number of signal events"", 150, 0, 1000); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [nbkg, nsig]); ; # Create manager; # ---------------------------; ; # Instantiate ROOT.RooMCStudy manager on model with x as observable and given choice of fit options; #; # The Silence() option kills all messages below the PROGRESS level, only a single message; # per sample executed, any error message that occur during fitting; #; # The Extended() option has two effects:; # 1) The extended ML term is included in the likelihood and; # 2) A poisson fluctuation is introduced on the number of generated events; #; # The FitOptions() given here are passed to the fitting stage of each toy experiment.; # If Save() is specified, fit result of each experiment is saved by the manager; #; # A Binned() option is added in self example to bin the data between generation and fitting; # to speed up the study at the expemse of some precision; ; mcstudy = ROOT.RooMCStudy(; model,; {x},; Binned=True,; Silence=True,; Extended=True,; FitOptions=dict(Save=True, PrintEvalErrors=0),; ); ; # Generate and fit events; # ---------------------------------------------; ; # Generate and fit 1000 samples of Poisson(nExpected) events; mcstudy.generateAndFit(1000); ; # Explore results of study; # ------------------------------------------------; ; # Make plots of the distributions of mean, error on mean and the pull of; # mean; frame1 = mcstudy.plotParam(m",MatchSource.WIKI,doc/master/rf801__mcstudy_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html
Integrability,message,messages,"uild Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, -1, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events, "", 150, 0, 1000); nsig = ROOT.RooRealVar(""nsig"", ""number of signal events"", 150, 0, 1000); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [nbkg, nsig]); ; # Create manager; # ---------------------------; ; # Instantiate ROOT.RooMCStudy manager on model with x as observable and given choice of fit options; #; # The Silence() option kills all messages below the PROGRESS level, only a single message; # per sample executed, any error message that occur during fitting; #; # The Extended() option has two effects:; # 1) The extended ML term is included in the likelihood and; # 2) A poisson fluctuation is introduced on the number of generated events; #; # The FitOptions() given here are passed to the fitting stage of each toy experiment.; # If Save() is specified, fit result of each experiment is saved by the manager; #; # A Binned() option is added in self example to bin the data between generation and fitting; # to speed up the study at the expemse of some precision; ; mcstudy = ROOT.RooMCStudy(; model,; {x},; Binned=True,; Silence=True,; Extended=True,; FitOptions=dict(Save=True, PrintEvalErrors=0),; ); ; # Generate and fit events; # ---------------------------------------------; ; # Generate and fit 1000 samples of Poisson(nExpected) events; mcstudy.generateAndFit(1000); ; # Explore results of study; # ------------------------------------------------; ; # Make plots of the distributions of mean, error on mean and the pull of; # mean; frame1 = mcstudy.plotParam(m",MatchSource.WIKI,doc/master/rf801__mcstudy_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html
Modifiability,extend,extended,"uild Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, -1, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events, "", 150, 0, 1000); nsig = ROOT.RooRealVar(""nsig"", ""number of signal events"", 150, 0, 1000); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [nbkg, nsig]); ; # Create manager; # ---------------------------; ; # Instantiate ROOT.RooMCStudy manager on model with x as observable and given choice of fit options; #; # The Silence() option kills all messages below the PROGRESS level, only a single message; # per sample executed, any error message that occur during fitting; #; # The Extended() option has two effects:; # 1) The extended ML term is included in the likelihood and; # 2) A poisson fluctuation is introduced on the number of generated events; #; # The FitOptions() given here are passed to the fitting stage of each toy experiment.; # If Save() is specified, fit result of each experiment is saved by the manager; #; # A Binned() option is added in self example to bin the data between generation and fitting; # to speed up the study at the expemse of some precision; ; mcstudy = ROOT.RooMCStudy(; model,; {x},; Binned=True,; Silence=True,; Extended=True,; FitOptions=dict(Save=True, PrintEvalErrors=0),; ); ; # Generate and fit events; # ---------------------------------------------; ; # Generate and fit 1000 samples of Poisson(nExpected) events; mcstudy.generateAndFit(1000); ; # Explore results of study; # ------------------------------------------------; ; # Make plots of the distributions of mean, error on mean and the pull of; # mean; frame1 = mcstudy.plotParam(m",MatchSource.WIKI,doc/master/rf801__mcstudy_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html
Performance,perform,perform,". ROOT: tutorials/roofit/rf801_mcstudy.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf801_mcstudy.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting . ; import ROOT; ; ; # Create model; # -----------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); x.setBins(40); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, 0, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, -1, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events, "", 150, 0, 1000); nsig = ROOT.RooRealVar(""nsig"", ""number of signal events"", 150, 0, 1000); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [nbkg, nsig]); ; # Create manager; # ---------------------------; ; # Instantiate ROOT.RooMCStudy manager on model with x as observable and given choice of fit options; #; # The Silence() option kills all messages below the PROGRESS level, only a single message; # per sample executed, any error message that occur during fitting; #; # The Extended() option has two effects:; # 1) The extended ML term is included in the likelihood an",MatchSource.WIKI,doc/master/rf801__mcstudy_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html
Safety,safe,safe,"e2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame4.Draw(); c.cd(5); ROOT.gPad.SetLeftMargin(0.15); hh_cor_a0_s1f.GetYaxis().SetTitleOffset(1.4); hh_cor_a0_s1f.Draw(""box""); c.cd(6); ROOT.gPad.SetLeftMargin(0.15); hh_cor_a0_a1.GetYaxis().SetTitleOffset(1.4); hh_cor_a0_a1.Draw(""box""); c.cd(7); ROOT.gPad.SetLeftMargin(0.15); corrHist000.GetYaxis().SetTitleOffset(1.4); corrHist000.Draw(""colz""); c.cd(8); ROOT.gPad.SetLeftMargin(0.15); corrHist127.GetYaxis().SetTitleOffset(1.4); corrHist127.Draw(""colz""); c.cd(9); ROOT.gPad.SetLeftMargin(0.15); corrHist953.GetYaxis().SetTitleOffset(1.4); corrHist953.Draw(""colz""); ; c.SaveAs(""rf801_mcstudy.png""); ; # Make ROOT.RooMCStudy object available on command line after; # macro finishes; ROOT.gDirectory.Add(mcstudy); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 990; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 980; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 970; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 960; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 950; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-797.721) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.716236 a1=-0.675686 mean=5.04367 nbkg=115.661 nsig=155.327 sig1frac=0.880121; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 940; [#0] PROGRESS:Generation -- RooMCStudy::run: sa",MatchSource.WIKI,doc/master/rf801__mcstudy_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html
Testability,log,log,"tMargin(0.15); corrHist953.GetYaxis().SetTitleOffset(1.4); corrHist953.Draw(""colz""); ; c.SaveAs(""rf801_mcstudy.png""); ; # Make ROOT.RooMCStudy object available on command line after; # macro finishes; ROOT.gDirectory.Add(mcstudy); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 990; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 980; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 970; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 960; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 950; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-797.721) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.716236 a1=-0.675686 mean=5.04367 nbkg=115.661 nsig=155.327 sig1frac=0.880121; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 940; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 930; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-867.289) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.907715 a1=-0.26012 mean=4.95881 nbkg=147.451 nsig=156.366 sig1frac=0.890535; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 920; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 910; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 900; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-871.381) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.7163",MatchSource.WIKI,doc/master/rf801__mcstudy_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html
Availability,avail,available," is risky.; auto pullMeanFrame = mcs2->plotPull(mean);; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist2_chi2 = mcs2->fitParDataSet().createHistogram(""chi2"", AutoBinning(nBins));; TH1 *hist2_prob = mcs2->fitParDataSet().createHistogram(""prob"", AutoBinning(nBins));; hist2_chi2->SetLineColor(kRed);; hist2_prob->SetLineColor(kRed);; ; TLegend leg;; leg.AddEntry(hist_chi2, ""Optimal fit"", ""L"");; leg.AddEntry(hist2_chi2, ""Biased fit"", ""L"");; leg.SetBorderSize(0);; leg.SetFillStyle(0);; ; TCanvas *c = new TCanvas(""rf802_mcstudy_addons"", ""rf802_mcstudy_addons"", 800, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.15);; hist_chi2->GetYaxis()->SetTitleOffset(1.4);; hist_chi2->Draw();; hist2_chi2->Draw(""esame"");; leg.DrawClone();; c->cd(2);; gPad->SetLeftMargin(0.15);; hist_prob->GetYaxis()->SetTitleOffset(1.4);; hist_prob->Draw();; hist2_prob->Draw(""esame"");; c->cd(3);; pullMeanFrame->Draw();; ; ; // Make RooMCStudy object available on command line after; // macro finishes; gDirectory->Add(mcs);; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooChebychev.h; RooChi2MCSModule.h; RooDataSet.h; RooGaussian.h; RooMCStudy.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TDirectory.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TH1.h; TLegend.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsData::createHistogramTH1 * createHistogram(const char *name, const RooAbsRealLValue &xvar, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCalls createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooLinkedList& argList) c...Definition RooAbsData.cxx:561; RooChi2MCSModuleRooChi2MCSModule is an add-on module to RooMCStudy that calculates the chi-squared of fitted p....Definition R",MatchSource.WIKI,doc/master/rf802__mcstudy__addons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html
Deployability,configurat,configuration,"000 samples of 1000 events; mcs->generateAndFit(2000, 1000);; ; // Number of bins for chi2 plots; int nBins = 100;; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist_chi2 = mcs->fitParDataSet().createHistogram(""chi2"", AutoBinning(nBins));; hist_chi2->SetTitle(""#chi^{2} values of all toy runs;#chi^{2}"");; TH1 *hist_prob = mcs->fitParDataSet().createHistogram(""prob"", AutoBinning(nBins));; hist_prob->SetTitle(""Corresponding #chi^{2} probability;Prob(#chi^{2},ndof)"");; ; ; // C r e a t e m a n a g e r w i t h s e p a r a t e f i t m o d e l; // ----------------------------------------------------------------------------; ; // Create alternate pdf with shifted mean; RooRealVar mean2(""mean2"", ""mean of gaussian 2"", 2.);; RooGaussian gauss2(""gauss2"", ""gaussian PDF2"", x, mean2, sigma);; ; // Create study manager with separate generation and fit model. This configuration; // is set up to generate biased fits as the fit and generator model have different means,; // and the mean parameter is limited to [-2., 1.8], so it just misses the optimal; // mean value of 2 in the data.; RooMCStudy *mcs2 = new RooMCStudy(gauss2, x, FitModel(gauss), Silence(), Binned());; ; // Add chi^2 calculator module to mcs; RooChi2MCSModule chi2mod2;; mcs2->addModule(chi2mod2);; ; // Generate 1000 samples of 1000 events; mcs2->generateAndFit(2000, 1000);; ; // Request a the pull plot of mean. The pulls will be one-sided because; // `mean` is limited to 1.8.; // Note that RooFit will have trouble to compute the pulls because the parameters; // are called `mean` in the fit, but `mean2` in the generator model. It is not obvious; // that these are related. RooFit will nevertheless compute pulls, but complain that; // this is risky.; auto pullMeanFrame = mcs2->plotPull(mean);; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist2_chi2 = mcs2->fitParDataSet().createHistogram(""",MatchSource.WIKI,doc/master/rf802__mcstudy__addons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html
Modifiability,config,configuration,"000 samples of 1000 events; mcs->generateAndFit(2000, 1000);; ; // Number of bins for chi2 plots; int nBins = 100;; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist_chi2 = mcs->fitParDataSet().createHistogram(""chi2"", AutoBinning(nBins));; hist_chi2->SetTitle(""#chi^{2} values of all toy runs;#chi^{2}"");; TH1 *hist_prob = mcs->fitParDataSet().createHistogram(""prob"", AutoBinning(nBins));; hist_prob->SetTitle(""Corresponding #chi^{2} probability;Prob(#chi^{2},ndof)"");; ; ; // C r e a t e m a n a g e r w i t h s e p a r a t e f i t m o d e l; // ----------------------------------------------------------------------------; ; // Create alternate pdf with shifted mean; RooRealVar mean2(""mean2"", ""mean of gaussian 2"", 2.);; RooGaussian gauss2(""gauss2"", ""gaussian PDF2"", x, mean2, sigma);; ; // Create study manager with separate generation and fit model. This configuration; // is set up to generate biased fits as the fit and generator model have different means,; // and the mean parameter is limited to [-2., 1.8], so it just misses the optimal; // mean value of 2 in the data.; RooMCStudy *mcs2 = new RooMCStudy(gauss2, x, FitModel(gauss), Silence(), Binned());; ; // Add chi^2 calculator module to mcs; RooChi2MCSModule chi2mod2;; mcs2->addModule(chi2mod2);; ; // Generate 1000 samples of 1000 events; mcs2->generateAndFit(2000, 1000);; ; // Request a the pull plot of mean. The pulls will be one-sided because; // `mean` is limited to 1.8.; // Note that RooFit will have trouble to compute the pulls because the parameters; // are called `mean` in the fit, but `mean2` in the generator model. It is not obvious; // that these are related. RooFit will nevertheless compute pulls, but complain that; // this is risky.; auto pullMeanFrame = mcs2->plotPull(mean);; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist2_chi2 = mcs2->fitParDataSet().createHistogram(""",MatchSource.WIKI,doc/master/rf802__mcstudy__addons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html
Safety,risk,risky,"ean2(""mean2"", ""mean of gaussian 2"", 2.);; RooGaussian gauss2(""gauss2"", ""gaussian PDF2"", x, mean2, sigma);; ; // Create study manager with separate generation and fit model. This configuration; // is set up to generate biased fits as the fit and generator model have different means,; // and the mean parameter is limited to [-2., 1.8], so it just misses the optimal; // mean value of 2 in the data.; RooMCStudy *mcs2 = new RooMCStudy(gauss2, x, FitModel(gauss), Silence(), Binned());; ; // Add chi^2 calculator module to mcs; RooChi2MCSModule chi2mod2;; mcs2->addModule(chi2mod2);; ; // Generate 1000 samples of 1000 events; mcs2->generateAndFit(2000, 1000);; ; // Request a the pull plot of mean. The pulls will be one-sided because; // `mean` is limited to 1.8.; // Note that RooFit will have trouble to compute the pulls because the parameters; // are called `mean` in the fit, but `mean2` in the generator model. It is not obvious; // that these are related. RooFit will nevertheless compute pulls, but complain that; // this is risky.; auto pullMeanFrame = mcs2->plotPull(mean);; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist2_chi2 = mcs2->fitParDataSet().createHistogram(""chi2"", AutoBinning(nBins));; TH1 *hist2_prob = mcs2->fitParDataSet().createHistogram(""prob"", AutoBinning(nBins));; hist2_chi2->SetLineColor(kRed);; hist2_prob->SetLineColor(kRed);; ; TLegend leg;; leg.AddEntry(hist_chi2, ""Optimal fit"", ""L"");; leg.AddEntry(hist2_chi2, ""Biased fit"", ""L"");; leg.SetBorderSize(0);; leg.SetFillStyle(0);; ; TCanvas *c = new TCanvas(""rf802_mcstudy_addons"", ""rf802_mcstudy_addons"", 800, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.15);; hist_chi2->GetYaxis()->SetTitleOffset(1.4);; hist_chi2->Draw();; hist2_chi2->Draw(""esame"");; leg.DrawClone();; c->cd(2);; gPad->SetLeftMargin(0.15);; hist_prob->GetYaxis()->SetTitleOffset(1.4);; hist_prob->Draw();; hist2_prob->Draw(""esame"");; c->cd(3);; pullMeanFrame->Draw();",MatchSource.WIKI,doc/master/rf802__mcstudy__addons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html
Availability,avail,available,");; TH1 *z_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,significance_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,nsigerr"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_nsig = mcs->fitParDataSet().createHistogram(""nsig,nsigerr"", AutoBinning(40), AutoBinning(40));; ; // Draw plots on canvas; TCanvas *c = new TCanvas(""rf803_mcstudy_addons2"", ""rf802_mcstudy_addons2"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; dll_vs_ngen->GetYaxis()->SetTitleOffset(1.6);; dll_vs_ngen->Draw(""box"");; c->cd(2);; gPad->SetLeftMargin(0.15);; z_vs_ngen->GetYaxis()->SetTitleOffset(1.6);; z_vs_ngen->Draw(""box"");; c->cd(3);; gPad->SetLeftMargin(0.15);; errnsig_vs_ngen->GetYaxis()->SetTitleOffset(1.6);; errnsig_vs_ngen->Draw(""box"");; c->cd(4);; gPad->SetLeftMargin(0.15);; errnsig_vs_nsig->GetYaxis()->SetTitleOffset(1.6);; errnsig_vs_nsig->Draw(""box"");; ; // Make RooMCStudy object available on command line after; // macro finishes; gDirectory->Add(mcs);; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooChebychev.h; RooDLLSignificanceMCSModule.h; RooDataSet.h; RooGaussian.h; RooMCStudy.h; RooPlot.h; RooRandomizeParamMCSModule.h; RooRealVar.h; TAxis.h; TCanvas.h; TDirectory.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsData::createHistogramTH1 * createHistogram(const char *name, const RooAbsRealLValue &xvar, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCalls createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooLinkedList& argList) c...Definition RooAbsData.cxx:561; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple R",MatchSource.WIKI,doc/master/rf803__mcstudy__addons2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html
Deployability,configurat,configuration,"ummed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sigma^2; ; RooDLLSignificanceMCSModule sigModule(nsig, 0);; mcs->addModule(sigModule);; ; // R u n m a n a g e r , m a k e p l o t s; // ---------------------------------------------; ; // Run 1000 experiments. This configuration will generate a fair number; // of (harmless) MINUIT warnings due to the instability of the Chebychev polynomial fit; // at low statistics.; mcs->generateAndFit(500);; ; // Make some plots; TH1 *dll_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,dll_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *z_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,significance_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,nsigerr"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_nsig = mcs->fitParDataSet().createHistogram(""nsig,nsigerr"", AutoBinning(40), AutoBinning(40));; ; // Draw plots on canvas; TCanvas *c = new TCanvas(""rf803_mcstudy_addons2"", ""rf802_mcstudy_addons2"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; dll_vs_ngen->GetYaxis()->SetTitleOffset(1.6);; dll_vs_ngen->Draw(""box"");; c->cd(2);; gPad->SetLeftMargin(0.15);; z_vs_ngen->GetYaxis()->SetTitleOffset(1.6);; z_vs_ngen->Draw(""box"");; c->cd(3);; gPad->SetLeftMargin(0.15);; errnsig_vs",MatchSource.WIKI,doc/master/rf803__mcstudy__addons2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html
Modifiability,extend,extended," Observable; RooRealVar mjjj(""mjjj"", ""m(3jet) (GeV)"", 100, 85., 350.);; ; // Signal component (Gaussian); RooRealVar mtop(""mtop"", ""m(top)"", 162);; RooRealVar wtop(""wtop"", ""m(top) resolution"", 15.2);; RooGaussian sig(""sig"", ""top signal"", mjjj, mtop, wtop);; ; // Background component (Chebychev); RooRealVar c0(""c0"", ""Chebychev coefficient 0"", -0.846, -1., 1.);; RooRealVar c1(""c1"", ""Chebychev coefficient 1"", 0.112, -1., 1.);; RooRealVar c2(""c2"", ""Chebychev coefficient 2"", 0.076, -1., 1.);; RooChebychev bkg(""bkg"", ""combinatorial background"", mjjj, RooArgList(c0, c1, c2));; ; // Composite model; RooRealVar nsig(""nsig"", ""number of signal events"", 53, 0, 1e3);; RooRealVar nbkg(""nbkg"", ""number of background events"", 103, 0, 5e3);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), RooArgList(nsig, nbkg));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Configure manager to perform binned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), Extended(true),; FitOptions(Extended(true), PrintEvalErrors(-1)));; ; // C u s t o m i z e m a n a g e r; // ---------------------------------; ; // Add module that randomizes the summed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sig",MatchSource.WIKI,doc/master/rf803__mcstudy__addons2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html
Performance,perform,perform," Observable; RooRealVar mjjj(""mjjj"", ""m(3jet) (GeV)"", 100, 85., 350.);; ; // Signal component (Gaussian); RooRealVar mtop(""mtop"", ""m(top)"", 162);; RooRealVar wtop(""wtop"", ""m(top) resolution"", 15.2);; RooGaussian sig(""sig"", ""top signal"", mjjj, mtop, wtop);; ; // Background component (Chebychev); RooRealVar c0(""c0"", ""Chebychev coefficient 0"", -0.846, -1., 1.);; RooRealVar c1(""c1"", ""Chebychev coefficient 1"", 0.112, -1., 1.);; RooRealVar c2(""c2"", ""Chebychev coefficient 2"", 0.076, -1., 1.);; RooChebychev bkg(""bkg"", ""combinatorial background"", mjjj, RooArgList(c0, c1, c2));; ; // Composite model; RooRealVar nsig(""nsig"", ""number of signal events"", 53, 0, 1e3);; RooRealVar nbkg(""nbkg"", ""number of background events"", 103, 0, 5e3);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), RooArgList(nsig, nbkg));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Configure manager to perform binned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), Extended(true),; FitOptions(Extended(true), PrintEvalErrors(-1)));; ; // C u s t o m i z e m a n a g e r; // ---------------------------------; ; // Add module that randomizes the summed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sig",MatchSource.WIKI,doc/master/rf803__mcstudy__addons2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html
Safety,safe,safe,"o, double hi)Request uniform smearing of sum of parameters in paramSet uniform smearing in range [lo,...Definition RooRandomizeParamMCSModule.cxx:124; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf803_mcstudy_addons2Definition rf803_mcstudy_addons2.py:1; ; [#0] WARNING:InputArguments -- The parameter 'wtop' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 495; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 490; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 485; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 480; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 475; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 470; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 465; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 460; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 455; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 450; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 445; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 440; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 435; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 430; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 425; [#0] PROGRESS:Generation -- RooMCStudy::run: ",MatchSource.WIKI,doc/master/rf803__mcstudy__addons2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html
Testability,log,log,"ned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), Extended(true),; FitOptions(Extended(true), PrintEvalErrors(-1)));; ; // C u s t o m i z e m a n a g e r; // ---------------------------------; ; // Add module that randomizes the summed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sigma^2; ; RooDLLSignificanceMCSModule sigModule(nsig, 0);; mcs->addModule(sigModule);; ; // R u n m a n a g e r , m a k e p l o t s; // ---------------------------------------------; ; // Run 1000 experiments. This configuration will generate a fair number; // of (harmless) MINUIT warnings due to the instability of the Chebychev polynomial fit; // at low statistics.; mcs->generateAndFit(500);; ; // Make some plots; TH1 *dll_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,dll_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *z_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,significance_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,nsigerr"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_nsig = mcs->fitParDataSet().createHistogram(""nsig,nsigerr"", AutoBinning(40), AutoBinning(40));; ; // Draw plots on canvas; TCanva",MatchSource.WIKI,doc/master/rf803__mcstudy__addons2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html
Usability,simpl,simple,"ned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), Extended(true),; FitOptions(Extended(true), PrintEvalErrors(-1)));; ; // C u s t o m i z e m a n a g e r; // ---------------------------------; ; // Add module that randomizes the summed value of nsig+nbkg; // sampling from a uniform distribution between 0 and 1000; //; // In general one can randomize a single parameter, or a; // sum of N parameters, using either a uniform or a Gaussian; // distribution. Multiple randomization can be executed; // by a single randomizer module; ; RooRandomizeParamMCSModule randModule;; randModule.sampleSumUniform(RooArgSet(nsig, nbkg), 50, 500);; mcs->addModule(randModule);; ; // Add profile likelihood calculation of significance. Redo each; // fit while keeping parameter nsig fixed to zero. For each toy,; // the difference in -log(L) of both fits is stored, as well; // a simple significance interpretation of the delta(-logL); // using Dnll = 0.5 sigma^2; ; RooDLLSignificanceMCSModule sigModule(nsig, 0);; mcs->addModule(sigModule);; ; // R u n m a n a g e r , m a k e p l o t s; // ---------------------------------------------; ; // Run 1000 experiments. This configuration will generate a fair number; // of (harmless) MINUIT warnings due to the instability of the Chebychev polynomial fit; // at low statistics.; mcs->generateAndFit(500);; ; // Make some plots; TH1 *dll_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,dll_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *z_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,significance_nullhypo_nsig"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_ngen = mcs->fitParDataSet().createHistogram(""ngen,nsigerr"", AutoBinning(40), AutoBinning(40));; TH1 *errnsig_vs_nsig = mcs->fitParDataSet().createHistogram(""nsig,nsigerr"", AutoBinning(40), AutoBinning(40));; ; // Draw plots on canvas; TCanva",MatchSource.WIKI,doc/master/rf803__mcstudy__addons2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html
Availability,error,error,"Study::run: sample 110; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 105; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 100; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 95; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 90; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 85; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 80; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 75; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 70; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 65; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 60; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 55; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 50; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 45; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 40; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 35; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 30; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 25; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 20; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 15; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 10; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 5; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 0; [#1] INFO:ObjectHandling -- RooWorkspace::import() importing RooRealVar::fpull; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pullGauss_over_pullGauss_Int[fpull]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pullGauss_over_pullGauss_Int[fpull]_fitParData_sumc) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf804_mcstudy_constr.",MatchSource.WIKI,doc/master/rf804__mcstudy__constr_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html
Performance,optimiz,optimization,"Study::run: sample 110; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 105; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 100; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 95; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 90; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 85; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 80; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 75; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 70; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 65; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 60; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 55; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 50; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 45; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 40; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 35; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 30; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 25; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 20; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 15; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 10; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 5; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 0; [#1] INFO:ObjectHandling -- RooWorkspace::import() importing RooRealVar::fpull; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pullGauss_over_pullGauss_Int[fpull]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pullGauss_over_pullGauss_Int[fpull]_fitParData_sumc) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf804_mcstudy_constr.",MatchSource.WIKI,doc/master/rf804__mcstudy__constr_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html
Availability,error,error,"ArgSet with RooRealVars holding real-valued parameters; // and RooCategories holding parameters with a finite set of options); customConfig.getConfigSection(""RooAdaptiveGaussKronrodIntegrator1D"").setRealValue(""maxSeg"", 50);; customConfig.getConfigSection(""RooAdaptiveGaussKronrodIntegrator1D"").setCatLabel(""method"", ""15Points"");; ; // Example of how to print set of possible values for ""method"" category; customConfig.getConfigSection(""RooAdaptiveGaussKronrodIntegrator1D"").find(""method"")->Print(""v"");; #endif; ; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; e#define e(i)Definition RSha256.hxx:103; RooArgSet.h; RooDataSet.h; RooGaussian.h; RooLandau.h; RooNumIntConfig.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; RooAbsCollection::setRealValuebool setRealValue(const char *name, double newVal=0.0, bool verbose=false)Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed...Definition RooAbsCollection.cxx:999; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooCategory::setLabelbool setLabel(const char *label, bool printError=true) overrideSet value by specifying the name of the desired state.Definition RooCategory.cxx:186; RooLandauLandau distribution p.d.f.Definition RooLandau.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooNumIntConfig",MatchSource.WIKI,doc/master/rf901__numintconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf901_numintconfig.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf901_numintconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumIntConfig.h""; #include ""RooLandau.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf901_numintconfig(); {; ; // A d j u s t g l o b a l 1 D i n t e g r a t i o n p r e c i s i o n; // ----------------------------------------------------------------------------; ; // Print current global default configuration for numeric integration strategies; RooAbsReal::defaultIntegratorConfig()->Print(""v"");; ; // Example: Change global precision for 1D integrals from 1e-7 to 1e-6; //; // The relative epsilon (change as fraction of current best integral estimate) and; // absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; // separately. For most pdf integrals the relative change criterium is the most important,; // however for certain non-pdf functions that integrate out to zero a separate absolute; // change criterium is necessary to declare convergence of the integral; //; // NB: This change is for illustration only. In general the precision should be at least 1e-7; // for normalization integrals for MINUIT to succeed.; //; RooAbsReal::defaultIntegratorConfig()->setEpsAbs(1e-6);; RooAbsReal::defaultIntegratorConfig()->setEpsRel(1e-6);; ; // N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; // ------------------------------------------------------------------; ; RooRealVar x(""x"", ""x"", -10, 10);; RooLandau landau(""landau"", ""landau"", x, 0.0, 0.1);; ; // Disable analytic integration from demonstration purposes; landau.forc",MatchSource.WIKI,doc/master/rf901__numintconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html
Energy Efficiency,adapt,adaptive,"r normalization integrals for MINUIT to succeed.; //; RooAbsReal::defaultIntegratorConfig()->setEpsAbs(1e-6);; RooAbsReal::defaultIntegratorConfig()->setEpsRel(1e-6);; ; // N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; // ------------------------------------------------------------------; ; RooRealVar x(""x"", ""x"", -10, 10);; RooLandau landau(""landau"", ""landau"", x, 0.0, 0.1);; ; // Disable analytic integration from demonstration purposes; landau.forceNumInt(true);; ; // Activate debug-level messages for topic integration to be able to follow actions below; RooMsgService::instance().addStream(DEBUG, Topic(Integration));; ; // Calculate integral over landau with default choice of numeric integrator; std::unique_ptr<RooAbsReal> intLandau{landau.createIntegral(x)};; double val = intLandau->getVal();; cout << "" [1] int_dx landau(x) = "" << setprecision(15) << val << endl;; ; // S a m e w i t h c u s t o m c o n f i g u r a t i o n; // -----------------------------------------------------------; ; // Construct a custom configuration which uses the adaptive Gauss-Kronrod technique; // for closed 1D integrals; RooNumIntConfig customConfig(*RooAbsReal::defaultIntegratorConfig());; #ifdef R__HAS_MATHMORE; customConfig.method1D().setLabel(""RooAdaptiveGaussKronrodIntegrator1D"");; #else; Warning(""rf901_numintconfig"",""ROOT is built without Mathmore (GSL) support. Cannot use RooAdaptiveGaussKronrodIntegrator1D"");; #endif; ; // Calculate integral over landau with custom integral specification; std::unique_ptr<RooAbsReal> intLandau2{landau.createIntegral(x, NumIntConfig(customConfig))};; double val2 = intLandau2->getVal();; cout << "" [2] int_dx landau(x) = "" << val2 << endl;; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom numeric integration configuration as default for object 'landau'; landau.setIntegratorConf",MatchSource.WIKI,doc/master/rf901__numintconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf901_numintconfig.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf901_numintconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumIntConfig.h""; #include ""RooLandau.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf901_numintconfig(); {; ; // A d j u s t g l o b a l 1 D i n t e g r a t i o n p r e c i s i o n; // ----------------------------------------------------------------------------; ; // Print current global default configuration for numeric integration strategies; RooAbsReal::defaultIntegratorConfig()->Print(""v"");; ; // Example: Change global precision for 1D integrals from 1e-7 to 1e-6; //; // The relative epsilon (change as fraction of current best integral estimate) and; // absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; // separately. For most pdf integrals the relative change criterium is the most important,; // however for certain non-pdf functions that integrate out to zero a separate absolute; // change criterium is necessary to declare convergence of the integral; //; // NB: This change is for illustration only. In general the precision should be at least 1e-7; // for normalization integrals for MINUIT to succeed.; //; RooAbsReal::defaultIntegratorConfig()->setEpsAbs(1e-6);; RooAbsReal::defaultIntegratorConfig()->setEpsRel(1e-6);; ; // N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; // ------------------------------------------------------------------; ; RooRealVar x(""x"", ""x"", -10, 10);; RooLandau landau(""landau"", ""landau"", x, 0.0, 0.1);; ; // Disable analytic integration from demonstration purposes; landau.forc",MatchSource.WIKI,doc/master/rf901__numintconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html
Modifiability,config,configuration,". ROOT: tutorials/roofit/rf901_numintconfig.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf901_numintconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumIntConfig.h""; #include ""RooLandau.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf901_numintconfig(); {; ; // A d j u s t g l o b a l 1 D i n t e g r a t i o n p r e c i s i o n; // ----------------------------------------------------------------------------; ; // Print current global default configuration for numeric integration strategies; RooAbsReal::defaultIntegratorConfig()->Print(""v"");; ; // Example: Change global precision for 1D integrals from 1e-7 to 1e-6; //; // The relative epsilon (change as fraction of current best integral estimate) and; // absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; // separately. For most pdf integrals the relative change criterium is the most important,; // however for certain non-pdf functions that integrate out to zero a separate absolute; // change criterium is necessary to declare convergence of the integral; //; // NB: This change is for illustration only. In general the precision should be at least 1e-7; // for normalization integrals for MINUIT to succeed.; //; RooAbsReal::defaultIntegratorConfig()->setEpsAbs(1e-6);; RooAbsReal::defaultIntegratorConfig()->setEpsRel(1e-6);; ; // N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; // ------------------------------------------------------------------; ; RooRealVar x(""x"", ""x"", -10, 10);; RooLandau landau(""landau"", ""landau"", x, 0.0, 0.1);; ; // Disable analytic integration from demonstration purposes; landau.forc",MatchSource.WIKI,doc/master/rf901__numintconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html
Testability,log,logging," function in warning situations.Definition TError.cxx:229; RooAbsCollection::setRealValuebool setRealValue(const char *name, double newVal=0.0, bool verbose=false)Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed...Definition RooAbsCollection.cxx:999; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooCategory::setLabelbool setLabel(const char *label, bool printError=true) overrideSet value by specifying the name of the desired state.Definition RooCategory.cxx:186; RooLandauLandau distribution p.d.f.Definition RooLandau.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::Printvoid Print(Option_t *options=nullptr) const overrideThis method must be overridden when a class wants to print itself.Definition RooNumIntConfig.h:70; RooNumIntConfig::setEpsRelvoid setEpsRel(double newEpsRel)Set relative convergence criteria (convergence if std::abs(Err)/abs(Int)<newEpsRel)Definition RooNumIntConfig.cxx:260; RooNumIntConfig::getConfigSectionconst RooArgSet & getConfigSection(const char *name) constRetrieve configuration information specific to integrator with given name.Definition RooNumIntConfig.cxx:214; RooNumIntConfig::method1DRooCategory & method1D()Definition RooNumIntConfig.h:34; RooNumIntConfig::setEpsAbsvoid setEpsA",MatchSource.WIKI,doc/master/rf901__numintconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf901_numintconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf901_numintconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; from __future__ import print_function; import ROOT; ; ; # Adjust global 1D integration precision; # ----------------------------------------------------------------------------; ; # Print current global default configuration for numeric integration; # strategies; ROOT.RooAbsReal.defaultIntegratorConfig().Print(""v""); ; # Example: Change global precision for 1D integrals from 1e-7 to 1e-6; #; # The relative epsilon (change as fraction of current best integral estimate) and; # absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; # separately. For most pdf integrals the relative change criterium is the most important,; # however for certain non-pdf functions that integrate out to zero a separate absolute; # change criterium is necessary to declare convergence of the integral; #; # NB: ROOT.This change is for illustration only. In general the precision should be at least 1e-7; # for normalization integrals for MINUIT to succeed.; #; ROOT.RooAbsReal.defaultIntegratorConfig().setEpsAbs(1e-6); ROOT.RooAbsReal.defaultIntegratorConfig().setEpsRel(1e-6); ; # N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; # ------------------------------------------------------------------; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); landau = ROOT.RooLandau(""landau"", ""landau"", x, 0.0, 0.1); ; # Disable analytic integration from demonstration purposes; landau.forceNumInt(True); ; # Activate debug-level messages for topic integration to be able to follow; # actions below; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Integration); ; # Calculate integral over landau with defau",MatchSource.WIKI,doc/master/rf901__numintconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8py.html
Energy Efficiency,adapt,adaptive,"recision should be at least 1e-7; # for normalization integrals for MINUIT to succeed.; #; ROOT.RooAbsReal.defaultIntegratorConfig().setEpsAbs(1e-6); ROOT.RooAbsReal.defaultIntegratorConfig().setEpsRel(1e-6); ; # N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; # ------------------------------------------------------------------; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); landau = ROOT.RooLandau(""landau"", ""landau"", x, 0.0, 0.1); ; # Disable analytic integration from demonstration purposes; landau.forceNumInt(True); ; # Activate debug-level messages for topic integration to be able to follow; # actions below; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Integration); ; # Calculate integral over landau with default choice of numeric integrator; intLandau = landau.createIntegral({x}); val = intLandau.getVal(); print("" [1] int_dx landau(x) = "", val) # setprecision(15); ; # Same with custom configuration; # -----------------------------------------------------------; ; # Construct a custom configuration which uses the adaptive Gauss-Kronrod technique; # for closed 1D integrals; customConfig = ROOT.RooNumIntConfig(ROOT.RooAbsReal.defaultIntegratorConfig()); integratorGKNotExisting = customConfig.method1D().setLabel(""RooAdaptiveGaussKronrodIntegrator1D""); if integratorGKNotExisting:; print(""WARNING: RooAdaptiveGaussKronrodIntegrator is not existing because ROOT is built without Mathmore support""); ; # Calculate integral over landau with custom integral specification; intLandau2 = landau.createIntegral({x}, NumIntConfig=customConfig); val2 = intLandau2.getVal(); print("" [2] int_dx landau(x) = "", val2); ; # Adjusting default config for a specific pdf; # -------------------------------------------------------------------------------------; ; # Another possibility: associate custom numeric integration configuration; # as default for object 'landau'; landau.setIntegratorConfig(customConfig); ; # Calculate integral over landau custom numer",MatchSource.WIKI,doc/master/rf901__numintconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8py.html
Integrability,integrat,integration,". ROOT: tutorials/roofit/rf901_numintconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf901_numintconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; from __future__ import print_function; import ROOT; ; ; # Adjust global 1D integration precision; # ----------------------------------------------------------------------------; ; # Print current global default configuration for numeric integration; # strategies; ROOT.RooAbsReal.defaultIntegratorConfig().Print(""v""); ; # Example: Change global precision for 1D integrals from 1e-7 to 1e-6; #; # The relative epsilon (change as fraction of current best integral estimate) and; # absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; # separately. For most pdf integrals the relative change criterium is the most important,; # however for certain non-pdf functions that integrate out to zero a separate absolute; # change criterium is necessary to declare convergence of the integral; #; # NB: ROOT.This change is for illustration only. In general the precision should be at least 1e-7; # for normalization integrals for MINUIT to succeed.; #; ROOT.RooAbsReal.defaultIntegratorConfig().setEpsAbs(1e-6); ROOT.RooAbsReal.defaultIntegratorConfig().setEpsRel(1e-6); ; # N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; # ------------------------------------------------------------------; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); landau = ROOT.RooLandau(""landau"", ""landau"", x, 0.0, 0.1); ; # Disable analytic integration from demonstration purposes; landau.forceNumInt(True); ; # Activate debug-level messages for topic integration to be able to follow; # actions below; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Integration); ; # Calculate integral over landau with defau",MatchSource.WIKI,doc/master/rf901__numintconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8py.html
Modifiability,config,configuration,". ROOT: tutorials/roofit/rf901_numintconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf901_numintconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; from __future__ import print_function; import ROOT; ; ; # Adjust global 1D integration precision; # ----------------------------------------------------------------------------; ; # Print current global default configuration for numeric integration; # strategies; ROOT.RooAbsReal.defaultIntegratorConfig().Print(""v""); ; # Example: Change global precision for 1D integrals from 1e-7 to 1e-6; #; # The relative epsilon (change as fraction of current best integral estimate) and; # absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; # separately. For most pdf integrals the relative change criterium is the most important,; # however for certain non-pdf functions that integrate out to zero a separate absolute; # change criterium is necessary to declare convergence of the integral; #; # NB: ROOT.This change is for illustration only. In general the precision should be at least 1e-7; # for normalization integrals for MINUIT to succeed.; #; ROOT.RooAbsReal.defaultIntegratorConfig().setEpsAbs(1e-6); ROOT.RooAbsReal.defaultIntegratorConfig().setEpsRel(1e-6); ; # N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; # ------------------------------------------------------------------; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); landau = ROOT.RooLandau(""landau"", ""landau"", x, 0.0, 0.1); ; # Disable analytic integration from demonstration purposes; landau.forceNumInt(True); ; # Activate debug-level messages for topic integration to be able to follow; # actions below; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Integration); ; # Calculate integral over landau with defau",MatchSource.WIKI,doc/master/rf901__numintconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8py.html
Availability,error,error,"aximum number of steps of RooIntegrator1D in the global default configuration; RooAbsPdf::defaultGeneratorConfig()->getConfigSection(""RooAcceptReject"").setRealValue(""nTrial1D"", 2000);; ; // Example of how to change the parameters of a numeric integrator; // (Each config section is a RooArgSet with RooRealVars holding real-valued parameters; // and RooCategories holding parameters with a finite set of options); model.specialGeneratorConfig()->getConfigSection(""RooFoamGenerator"").setRealValue(""chatLevel"", 1);; ; // Generate 10Kevt using RooFoamGenerator (FOAM verbosity increased with above chatLevel adjustment for illustration; // purposes); std::unique_ptr<RooDataSet> data_foam{model.generate(x, 10000, Verbose())};; data_foam->Print();; }; RooArgSet.h; RooChebychev.h; RooDataSet.h; RooNumGenConfig.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAbsCollection::setRealValuebool setRealValue(const char *name, double newVal=0.0, bool verbose=false)Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed...Definition RooAbsCollection.cxx:999; RooAbsPdf::defaultGeneratorConfigstatic RooNumGenConfig * defaultGeneratorConfig()Returns the default numeric MC generator configuration for all RooAbsReals.Definition RooAbsPdf.cxx:2613; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooCategory::setLabelbool setLabel(const char *label, bool printError=true) overrideSet value by specifying the name of the desired state.Definition RooCategory.cxx:186; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooNumGenConfig::method1DRooCategory & method1D(bool cond, bool cat)Definition RooNumGenConfig.cxx:172; RooNumGenConfig::getConfigSectionconst RooArgSet & getConfigSection(const char *name) constRetrieve configuration information specific to integrator with given name.Definition RooNumGenConfig.cxx:288; RooRealVarVariable that can be changed from the outside",MatchSource.WIKI,doc/master/rf902__numgenconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf902_numgenconfig.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf902_numgenconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooChebychev.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumGenConfig.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf902_numgenconfig(); {; ; // A d j u s t g l o b a l MC s a m p l i n g s t r a t e g y; // ------------------------------------------------------------------; ; // Example pdf for use below; RooRealVar x(""x"", ""x"", 0, 10);; RooChebychev model(""model"", ""model"", x, RooArgList(0, 0.5, -0.1));; ; // Change global strategy for 1D sampling problems without conditional observable; // (1st false) and without discrete observable (2nd false) from RooFoamGenerator,; // ( an interface to the TFoam MC generator with adaptive subdivisioning strategy ) to RooAcceptReject,; // a plain accept/reject sampling algorithm [ RooFit default before ROOT 5.23/04 ]; RooAbsPdf::defaultGeneratorConfig()->method1D(false, false).setLabel(""RooAcceptReject"");; ; // Generate 10Kevt using RooAcceptReject; std::unique_ptr<RooDataSet> data_ar{model.generate(x, 10000, Verbose(true))};; data_ar->Print();; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom MC sampling configuration as default for object 'model'; // The true argument will install a clone of the default configuration as specialized configuration; // for this model if none existed so far; model.specialGeneratorConfig(true)->method1D(false, false).setLabel(""RooFoamGenerator"");; ; // A d j u s t ",MatchSource.WIKI,doc/master/rf902__numgenconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html
Energy Efficiency,adapt,adaptive," ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf902_numgenconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooChebychev.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumGenConfig.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf902_numgenconfig(); {; ; // A d j u s t g l o b a l MC s a m p l i n g s t r a t e g y; // ------------------------------------------------------------------; ; // Example pdf for use below; RooRealVar x(""x"", ""x"", 0, 10);; RooChebychev model(""model"", ""model"", x, RooArgList(0, 0.5, -0.1));; ; // Change global strategy for 1D sampling problems without conditional observable; // (1st false) and without discrete observable (2nd false) from RooFoamGenerator,; // ( an interface to the TFoam MC generator with adaptive subdivisioning strategy ) to RooAcceptReject,; // a plain accept/reject sampling algorithm [ RooFit default before ROOT 5.23/04 ]; RooAbsPdf::defaultGeneratorConfig()->method1D(false, false).setLabel(""RooAcceptReject"");; ; // Generate 10Kevt using RooAcceptReject; std::unique_ptr<RooDataSet> data_ar{model.generate(x, 10000, Verbose(true))};; data_ar->Print();; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom MC sampling configuration as default for object 'model'; // The true argument will install a clone of the default configuration as specialized configuration; // for this model if none existed so far; model.specialGeneratorConfig(true)->method1D(false, false).setLabel(""RooFoamGenerator"");; ; // A d j u s t i n g p a r a m e t e r s o f a s p e c i f i c t e c h n i q ",MatchSource.WIKI,doc/master/rf902__numgenconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html
Integrability,interface,interface," ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf902_numgenconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooChebychev.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumGenConfig.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf902_numgenconfig(); {; ; // A d j u s t g l o b a l MC s a m p l i n g s t r a t e g y; // ------------------------------------------------------------------; ; // Example pdf for use below; RooRealVar x(""x"", ""x"", 0, 10);; RooChebychev model(""model"", ""model"", x, RooArgList(0, 0.5, -0.1));; ; // Change global strategy for 1D sampling problems without conditional observable; // (1st false) and without discrete observable (2nd false) from RooFoamGenerator,; // ( an interface to the TFoam MC generator with adaptive subdivisioning strategy ) to RooAcceptReject,; // a plain accept/reject sampling algorithm [ RooFit default before ROOT 5.23/04 ]; RooAbsPdf::defaultGeneratorConfig()->method1D(false, false).setLabel(""RooAcceptReject"");; ; // Generate 10Kevt using RooAcceptReject; std::unique_ptr<RooDataSet> data_ar{model.generate(x, 10000, Verbose(true))};; data_ar->Print();; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom MC sampling configuration as default for object 'model'; // The true argument will install a clone of the default configuration as specialized configuration; // for this model if none existed so far; model.specialGeneratorConfig(true)->method1D(false, false).setLabel(""RooFoamGenerator"");; ; // A d j u s t i n g p a r a m e t e r s o f a s p e c i f i c t e c h n i q ",MatchSource.WIKI,doc/master/rf902__numgenconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html
Modifiability,config,configuration,". ROOT: tutorials/roofit/rf902_numgenconfig.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf902_numgenconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooChebychev.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumGenConfig.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf902_numgenconfig(); {; ; // A d j u s t g l o b a l MC s a m p l i n g s t r a t e g y; // ------------------------------------------------------------------; ; // Example pdf for use below; RooRealVar x(""x"", ""x"", 0, 10);; RooChebychev model(""model"", ""model"", x, RooArgList(0, 0.5, -0.1));; ; // Change global strategy for 1D sampling problems without conditional observable; // (1st false) and without discrete observable (2nd false) from RooFoamGenerator,; // ( an interface to the TFoam MC generator with adaptive subdivisioning strategy ) to RooAcceptReject,; // a plain accept/reject sampling algorithm [ RooFit default before ROOT 5.23/04 ]; RooAbsPdf::defaultGeneratorConfig()->method1D(false, false).setLabel(""RooAcceptReject"");; ; // Generate 10Kevt using RooAcceptReject; std::unique_ptr<RooDataSet> data_ar{model.generate(x, 10000, Verbose(true))};; data_ar->Print();; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom MC sampling configuration as default for object 'model'; // The true argument will install a clone of the default configuration as specialized configuration; // for this model if none existed so far; model.specialGeneratorConfig(true)->method1D(false, false).setLabel(""RooFoamGenerator"");; ; // A d j u s t ",MatchSource.WIKI,doc/master/rf902__numgenconfig_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html
Deployability,configurat,configuration,". ROOT: tutorials/roofit/rf902_numgenconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf902_numgenconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; import ROOT; ; ; # Adjust global MC sampling strategy; # ------------------------------------------------------------------; ; # Example pdf for use below; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); model = ROOT.RooChebychev(""model"", ""model"", x, [0.0, 0.5, -0.1]); ; # Change global strategy for 1D sampling problems without conditional observable; # (1st kFALSE) and without discrete observable (2nd kFALSE) from ROOT.RooFoamGenerator,; # ( an interface to the ROOT.TFoam MC generator with adaptive subdivisioning strategy ) to ROOT.RooAcceptReject,; # a plain accept/reject sampling algorithm [ ROOT.RooFit default before; # ROOT 5.23/04 ]; ROOT.RooAbsPdf.defaultGeneratorConfig().method1D(False, False).setLabel(""RooAcceptReject""); ; # Generate 10Kevt using ROOT.RooAcceptReject; data_ar = model.generate({x}, 10000, Verbose=True); data_ar.Print(); ; # Adjusting default config for a specific pdf; # -------------------------------------------------------------------------------------; ; # Another possibility: associate custom MC sampling configuration as default for object 'model'; # The kTRUE argument will install a clone of the default configuration as specialized configuration; # for self model if none existed so far; model.specialGeneratorConfig(True).method1D(False, False).setLabel(""RooFoamGenerator""); ; # Adjusting parameters of a specific technique; # ---------------------------------------------------------------------------------------; ; # Adjust maximum number of steps of ROOT.RooIntegrator1D in the global; # default configuration; ROOT.RooAbsPdf.defaultGeneratorConfig().getConfigSection(""RooAcceptReject"").setR",MatchSource.WIKI,doc/master/rf902__numgenconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8py.html
Energy Efficiency,adapt,adaptive,". ROOT: tutorials/roofit/rf902_numgenconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf902_numgenconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; import ROOT; ; ; # Adjust global MC sampling strategy; # ------------------------------------------------------------------; ; # Example pdf for use below; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); model = ROOT.RooChebychev(""model"", ""model"", x, [0.0, 0.5, -0.1]); ; # Change global strategy for 1D sampling problems without conditional observable; # (1st kFALSE) and without discrete observable (2nd kFALSE) from ROOT.RooFoamGenerator,; # ( an interface to the ROOT.TFoam MC generator with adaptive subdivisioning strategy ) to ROOT.RooAcceptReject,; # a plain accept/reject sampling algorithm [ ROOT.RooFit default before; # ROOT 5.23/04 ]; ROOT.RooAbsPdf.defaultGeneratorConfig().method1D(False, False).setLabel(""RooAcceptReject""); ; # Generate 10Kevt using ROOT.RooAcceptReject; data_ar = model.generate({x}, 10000, Verbose=True); data_ar.Print(); ; # Adjusting default config for a specific pdf; # -------------------------------------------------------------------------------------; ; # Another possibility: associate custom MC sampling configuration as default for object 'model'; # The kTRUE argument will install a clone of the default configuration as specialized configuration; # for self model if none existed so far; model.specialGeneratorConfig(True).method1D(False, False).setLabel(""RooFoamGenerator""); ; # Adjusting parameters of a specific technique; # ---------------------------------------------------------------------------------------; ; # Adjust maximum number of steps of ROOT.RooIntegrator1D in the global; # default configuration; ROOT.RooAbsPdf.defaultGeneratorConfig().getConfigSection(""RooAcceptReject"").setR",MatchSource.WIKI,doc/master/rf902__numgenconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8py.html
Integrability,interface,interface,". ROOT: tutorials/roofit/rf902_numgenconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf902_numgenconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; import ROOT; ; ; # Adjust global MC sampling strategy; # ------------------------------------------------------------------; ; # Example pdf for use below; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); model = ROOT.RooChebychev(""model"", ""model"", x, [0.0, 0.5, -0.1]); ; # Change global strategy for 1D sampling problems without conditional observable; # (1st kFALSE) and without discrete observable (2nd kFALSE) from ROOT.RooFoamGenerator,; # ( an interface to the ROOT.TFoam MC generator with adaptive subdivisioning strategy ) to ROOT.RooAcceptReject,; # a plain accept/reject sampling algorithm [ ROOT.RooFit default before; # ROOT 5.23/04 ]; ROOT.RooAbsPdf.defaultGeneratorConfig().method1D(False, False).setLabel(""RooAcceptReject""); ; # Generate 10Kevt using ROOT.RooAcceptReject; data_ar = model.generate({x}, 10000, Verbose=True); data_ar.Print(); ; # Adjusting default config for a specific pdf; # -------------------------------------------------------------------------------------; ; # Another possibility: associate custom MC sampling configuration as default for object 'model'; # The kTRUE argument will install a clone of the default configuration as specialized configuration; # for self model if none existed so far; model.specialGeneratorConfig(True).method1D(False, False).setLabel(""RooFoamGenerator""); ; # Adjusting parameters of a specific technique; # ---------------------------------------------------------------------------------------; ; # Adjust maximum number of steps of ROOT.RooIntegrator1D in the global; # default configuration; ROOT.RooAbsPdf.defaultGeneratorConfig().getConfigSection(""RooAcceptReject"").setR",MatchSource.WIKI,doc/master/rf902__numgenconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8py.html
Modifiability,config,configuration,". ROOT: tutorials/roofit/rf902_numgenconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf902_numgenconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; import ROOT; ; ; # Adjust global MC sampling strategy; # ------------------------------------------------------------------; ; # Example pdf for use below; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); model = ROOT.RooChebychev(""model"", ""model"", x, [0.0, 0.5, -0.1]); ; # Change global strategy for 1D sampling problems without conditional observable; # (1st kFALSE) and without discrete observable (2nd kFALSE) from ROOT.RooFoamGenerator,; # ( an interface to the ROOT.TFoam MC generator with adaptive subdivisioning strategy ) to ROOT.RooAcceptReject,; # a plain accept/reject sampling algorithm [ ROOT.RooFit default before; # ROOT 5.23/04 ]; ROOT.RooAbsPdf.defaultGeneratorConfig().method1D(False, False).setLabel(""RooAcceptReject""); ; # Generate 10Kevt using ROOT.RooAcceptReject; data_ar = model.generate({x}, 10000, Verbose=True); data_ar.Print(); ; # Adjusting default config for a specific pdf; # -------------------------------------------------------------------------------------; ; # Another possibility: associate custom MC sampling configuration as default for object 'model'; # The kTRUE argument will install a clone of the default configuration as specialized configuration; # for self model if none existed so far; model.specialGeneratorConfig(True).method1D(False, False).setLabel(""RooFoamGenerator""); ; # Adjusting parameters of a specific technique; # ---------------------------------------------------------------------------------------; ; # Adjust maximum number of steps of ROOT.RooIntegrator1D in the global; # default configuration; ROOT.RooAbsPdf.defaultGeneratorConfig().getConfigSection(""RooAcceptReject"").setR",MatchSource.WIKI,doc/master/rf902__numgenconfig_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8py.html
Availability,avail,available,"e *w1 = getWorkspace(mode);; if (mode == 1) {; ; // Show workspace that was created; w1->Print();; ; // Show plot of cached integral values; RooDataHist *hhcache = (RooDataHist *)w1->expensiveObjectCache().getObj(1);; if (hhcache) {; ; new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; hhcache->createHistogram(""a"")->Draw();; ; } else {; Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace"");; }; return;; }; ; // U s e p . d . f . f r o m w o r k s p a c e f o r g e n e r a t i o n a n d f i t t i n g; // -----------------------------------------------------------------------------------; ; // This is always slow (need to find maximum function value empirically in 3D space); std::unique_ptr<RooDataSet> d{w1->pdf(""model"")->generate({*w1->var(""x""), *w1->var(""y""), *w1->var(""z"")}, 1000)};; ; // This is slow in mode 0, but fast in mode 1; w1->pdf(""model"")->fitTo(*d, Verbose(true), Timer(true), PrintLevel(-1));; ; // Projection on x (always slow as 2D integral over Y,Z at fitted value of a is not cached); RooPlot *framex = w1->var(""x"")->frame(Title(""Projection of 3D model on X""));; d->plotOn(framex);; w1->pdf(""model"")->plotOn(framex);; ; // Draw x projection on canvas; auto canv = new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; framex->Draw();; canv->Draw();; ; // Make workspace available on command line after macro finishes; gDirectory->Add(w1);; }; ; RooWorkspace *getWorkspace(Int_t mode); {; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; //; // Mode = 0 : Create workspace for plain running (no integral caching); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file; // Mode = 2 : Load previously stored workspace from file; ; RooWorkspace *w(0);; ; if (mode != 2) {; ; // Create empty workspace workspace; w = new RooWorkspace(""w"", 1);; ; // Make a difficult to normalize pdf i",MatchSource.WIKI,doc/master/rf903__numintcache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html
Deployability,integrat,integrated,"*w1->var(""y""), *w1->var(""z"")}, 1000)};; ; // This is slow in mode 0, but fast in mode 1; w1->pdf(""model"")->fitTo(*d, Verbose(true), Timer(true), PrintLevel(-1));; ; // Projection on x (always slow as 2D integral over Y,Z at fitted value of a is not cached); RooPlot *framex = w1->var(""x"")->frame(Title(""Projection of 3D model on X""));; d->plotOn(framex);; w1->pdf(""model"")->plotOn(framex);; ; // Draw x projection on canvas; auto canv = new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; framex->Draw();; canv->Draw();; ; // Make workspace available on command line after macro finishes; gDirectory->Add(w1);; }; ; RooWorkspace *getWorkspace(Int_t mode); {; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; //; // Mode = 0 : Create workspace for plain running (no integral caching); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file; // Mode = 2 : Load previously stored workspace from file; ; RooWorkspace *w(0);; ; if (mode != 2) {; ; // Create empty workspace workspace; w = new RooWorkspace(""w"", 1);; ; // Make a difficult to normalize pdf in 3 dimensions that is integrated numerically.; w->factory(""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/""; ""((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])"");; }; ; if (mode == 1) {; ; // Instruct model to pre-calculate normalization integral that integrate at least; // two dimensions numerically. In this specific case the integral value for; // all values of parameter 'a' are stored in a histogram and available for use; // in subsequent fitting and plotting operations (interpolation is applied); ; // w->pdf(""model"")->setNormValueCaching(3) ;; w->pdf(""model"")->setStringAttribute(""CACHEPARMINT"", ""x:y:z"");; ; // Evaluate pdf once to trigger filling of cache; RooArgSet normSet(*w->var(""x""), *w->var(""y""), *w->var(""z""));; w->pdf(""model"")->getVal(&normSet);; w->writeToFi",MatchSource.WIKI,doc/master/rf903__numintcache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html
Integrability,integrat,integrated,"*w1->var(""y""), *w1->var(""z"")}, 1000)};; ; // This is slow in mode 0, but fast in mode 1; w1->pdf(""model"")->fitTo(*d, Verbose(true), Timer(true), PrintLevel(-1));; ; // Projection on x (always slow as 2D integral over Y,Z at fitted value of a is not cached); RooPlot *framex = w1->var(""x"")->frame(Title(""Projection of 3D model on X""));; d->plotOn(framex);; w1->pdf(""model"")->plotOn(framex);; ; // Draw x projection on canvas; auto canv = new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; framex->Draw();; canv->Draw();; ; // Make workspace available on command line after macro finishes; gDirectory->Add(w1);; }; ; RooWorkspace *getWorkspace(Int_t mode); {; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; //; // Mode = 0 : Create workspace for plain running (no integral caching); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file; // Mode = 2 : Load previously stored workspace from file; ; RooWorkspace *w(0);; ; if (mode != 2) {; ; // Create empty workspace workspace; w = new RooWorkspace(""w"", 1);; ; // Make a difficult to normalize pdf in 3 dimensions that is integrated numerically.; w->factory(""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/""; ""((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])"");; }; ; if (mode == 1) {; ; // Instruct model to pre-calculate normalization integral that integrate at least; // two dimensions numerically. In this specific case the integral value for; // all values of parameter 'a' are stored in a histogram and available for use; // in subsequent fitting and plotting operations (interpolation is applied); ; // w->pdf(""model"")->setNormValueCaching(3) ;; w->pdf(""model"")->setStringAttribute(""CACHEPARMINT"", ""x:y:z"");; ; // Evaluate pdf once to trigger filling of cache; RooArgSet normSet(*w->var(""x""), *w->var(""y""), *w->var(""z""));; w->pdf(""model"")->getVal(&normSet);; w->writeToFi",MatchSource.WIKI,doc/master/rf903__numintcache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html
Modifiability,parameteriz,parameterization,". ROOT: tutorials/roofit/rf903_numintcache.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf903_numintcache.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterization of slow numeric integrals . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooWorkspace.h""; #include ""RooExpensiveObjectCache.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; RooWorkspace *getWorkspace(Int_t mode);; ; void rf903_numintcache(Int_t mode = 0); {; // Mode = 0 : Run plain fit (slow); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file (prepare for accelerated running); // Mode = 2 : Run fit from previously stored workspace including cached integrals (fast, requires run in mode=1; // first); ; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; ; // Make/load workspace, exit here in mode 1; RooWorkspace *w1 = getWorkspace(mode);; if (mode == 1) {; ; // Show workspace that was created; w1->Print();; ; // Show plot of cached integral values; RooDataHist *hhcache = (RooDataHist *)w1->expensiveObjectCache().getObj(1);; if (hhcache) {; ; new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; hhcache->createHistogram(""a"")->Draw();; ; } else {; Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace"");; }; return;; }; ; // U s e p . d . f . f r o m w o r k s p a c e f o r g e n e r a t i o n a n d f i t t i n g; // -----------------------------------------------------------------------------------; ; // This is always slow (need to find maximum function value empirically in 3D space); std::unique_ptr<RooDataSet> d{w1->pdf(""model"")->generate(",MatchSource.WIKI,doc/master/rf903__numintcache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html
Performance,cache,cached,". ROOT: tutorials/roofit/rf903_numintcache.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf903_numintcache.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterization of slow numeric integrals . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooWorkspace.h""; #include ""RooExpensiveObjectCache.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; RooWorkspace *getWorkspace(Int_t mode);; ; void rf903_numintcache(Int_t mode = 0); {; // Mode = 0 : Run plain fit (slow); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file (prepare for accelerated running); // Mode = 2 : Run fit from previously stored workspace including cached integrals (fast, requires run in mode=1; // first); ; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; ; // Make/load workspace, exit here in mode 1; RooWorkspace *w1 = getWorkspace(mode);; if (mode == 1) {; ; // Show workspace that was created; w1->Print();; ; // Show plot of cached integral values; RooDataHist *hhcache = (RooDataHist *)w1->expensiveObjectCache().getObj(1);; if (hhcache) {; ; new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; hhcache->createHistogram(""a"")->Draw();; ; } else {; Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace"");; }; return;; }; ; // U s e p . d . f . f r o m w o r k s p a c e f o r g e n e r a t i o n a n d f i t t i n g; // -----------------------------------------------------------------------------------; ; // This is always slow (need to find maximum function value empirically in 3D space); std::unique_ptr<RooDataSet> d{w1->pdf(""model"")->generate(",MatchSource.WIKI,doc/master/rf903__numintcache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html
Availability,avail,available,"terizations of slow numeric integrals . ; import sys; import ROOT; ; ; def getWorkspace(mode):; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; #; # Mode = 0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for accelerated running); # Mode = 2 : Run fit from previously stored workspace including cached; # integrals (fast, run in mode=1 first); ; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; ; # Make/load workspace, here in mode 1; w = getWo",MatchSource.WIKI,doc/master/rf903__numintcache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html
Deployability,integrat,integrated,". ROOT: tutorials/roofit/rf903_numintcache.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf903_numintcache.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterizations of slow numeric integrals . ; import sys; import ROOT; ; ; def getWorkspace(mode):; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; #; # Mode = 0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for acce",MatchSource.WIKI,doc/master/rf903__numintcache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html
Integrability,integrat,integrated,". ROOT: tutorials/roofit/rf903_numintcache.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf903_numintcache.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterizations of slow numeric integrals . ; import sys; import ROOT; ; ; def getWorkspace(mode):; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; #; # Mode = 0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for acce",MatchSource.WIKI,doc/master/rf903__numintcache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html
Modifiability,parameteriz,parameterizations,". ROOT: tutorials/roofit/rf903_numintcache.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf903_numintcache.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterizations of slow numeric integrals . ; import sys; import ROOT; ; ; def getWorkspace(mode):; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; #; # Mode = 0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for acce",MatchSource.WIKI,doc/master/rf903__numintcache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html
Performance,load,load,". ROOT: tutorials/roofit/rf903_numintcache.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf903_numintcache.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterizations of slow numeric integrals . ; import sys; import ROOT; ; ; def getWorkspace(mode):; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; #; # Mode = 0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for acce",MatchSource.WIKI,doc/master/rf903__numintcache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html
Availability,failure,failures,"eTraits.hxx>; 26 ; 27#include <TGenericClassInfo.h>; 28 ; 29#include <algorithm>; 30#include <array>; 31#include <cstddef>; 32#include <iostream>; 33#include <memory>; 34#include <string>; 35#include <type_traits>; 36#include <typeinfo>; 37#include <vector>; 38 ; 39class TClass;; 40class TEnum;; 41class TObject;; 42class TVirtualStreamerInfo;; 43 ; 44namespace ROOT {; 45 ; 46class TSchemaRule;; 47 ; 48namespace Experimental {; 49 ; 50class REntry;; 51 ; 52namespace Detail {; 53class RFieldVisitor;; 54} // namespace Detail; 55 ; 56/// The container field for an ntuple model, which itself has no physical representation.; 57/// Therefore, the zero field must not be connected to a page source or sink.; 58class RFieldZero final : public RFieldBase {; 59protected:; 60 std::unique_ptr<RFieldBase> CloneImpl(std::string_view newName) const final;; 61 void ConstructValue(void *) const final {}; 62 ; 63public:; 64 RFieldZero() : RFieldBase("""", """", ENTupleStructure::kRecord, false /* isSimple */) {}; 65 ; 66 using RFieldBase::Attach;; 67 size_t GetValueSize() const final { return 0; }; 68 size_t GetAlignment() const final { return 0; }; 69 ; 70 void AcceptVisitor(Detail::RFieldVisitor &visitor) const final;; 71};; 72 ; 73/// Used in RFieldBase::Check() to record field creation failures.; 74/// Also used when deserializing a field that contains unknown values that may come from; 75/// future RNTuple versions (e.g. an unknown Structure); 76class RInvalidField final : public RFieldBase {; 77 std::string fError;; 78 ; 79protected:; 80 std::unique_ptr<RFieldBase> CloneImpl(std::string_view newName) const final; 81 {; 82 return std::make_unique<RInvalidField>(newName, GetTypeName(), fError);; 83 }; 84 void ConstructValue(void *) const final {}; 85 ; 86public:; 87 RInvalidField(std::string_view name, std::string_view type, std::string_view error); 88 : RFieldBase(name, type, ENTupleStructure::kLeaf, false /* isSimple */), fError(error); 89 {; 90 }; 91 ; 92 const std::string &GetError()",MatchSource.WIKI,doc/master/RField_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RField_8hxx_source.html
Deployability,release,release,"e.Definition RField.hxx:235; ROOT::Experimental::REnumField::AppendImplstd::size_t AppendImpl(const void *from) finalOperations on values of complex types, e.g.Definition RField.hxx:223; ROOT::Experimental::REnumField::ReadGlobalImplvoid ReadGlobalImpl(NTupleSize_t globalIndex, void *to) finalDefinition RField.hxx:224; ROOT::Experimental::REnumField::ConstructValuevoid ConstructValue(void *where) const finalConstructs value in a given location of size at least GetValueSize(). Called by the base class' Creat...Definition RField.hxx:221; ROOT::Experimental::RExceptionBase class for all ROOT issued exceptions.Definition RError.hxx:78; ROOT::Experimental::RExtraTypeInfoDescriptorField specific extra type information from the header / extenstion header.Definition RNTupleDescriptor.hxx:478; ROOT::Experimental::RFieldBase::RColumnRepresentationsSome fields have multiple possible column representations, e.g.Definition RFieldBase.hxx:142; ROOT::Experimental::RFieldBase::RDeleterA functor to release the memory acquired by CreateValue (memory and constructor).Definition RFieldBase.hxx:81; ROOT::Experimental::RFieldBase::RValuePoints to an object with RNTuple I/O support and keeps a pointer to the corresponding field.Definition RFieldBase.hxx:629; ROOT::Experimental::RFieldBaseA field translates read and write calls from/to underlying columns to/from tree values.Definition RFieldBase.hxx:67; ROOT::Experimental::RFieldBase::GenerateColumnsvirtual void GenerateColumns()Implementations in derived classes should create the backing columns corresponsing to the field type ...Definition RFieldBase.hxx:321; ROOT::Experimental::RFieldBase::Attachvoid Attach(std::unique_ptr< RFieldBase > child)Add a new subfield to the list of nested fields.Definition RField.cxx:981; ROOT::Experimental::RFieldBase::GetTypeNameconst std::string & GetTypeName() constDefinition RFieldBase.hxx:514; ROOT::Experimental::RFieldBase::CallAppendOnstatic std::size_t CallAppendOn(RFieldBase &other, const void *from",MatchSource.WIKI,doc/master/RField_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RField_8hxx_source.html
Safety,avoid,avoid,".Definition TEnum.h:33; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; ROOT::Experimental::NTupleSize_tstd::uint64_t NTupleSize_tInteger type long enough to hold the maximum number of entries in a column.Definition RNTupleUtil.hxx:115; ROOT::Experimental::ENTupleStructureENTupleStructureThe fields in the ntuple model tree can carry different structural information about the type system.Definition RNTupleUtil.hxx:112; ROOT::Experimental::kLeaf@ kLeafDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kRecord@ kRecordDefinition RNTupleUtil.hxx:112; ROOT::Internal::GetDemangledTypeNamestd::string GetDemangledTypeName(const std::type_info &t)Definition TGenericClassInfo.cxx:31; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Experimental::RClassField::RSubFieldInfoDefinition RField.hxx:105; ROOT::Experimental::RClassField::RSubFieldInfo::fRoleESubFieldRole fRoleDefinition RField.hxx:106; ROOT::Experimental::RClassField::RSubFieldInfo::fOffsetstd::size_t fOffsetDefinition RField.hxx:107; ROOT::Experimental::RClusterSizeWrap the integer in a struct in order to avoid template specialization clash with std::uint64_t.Definition RNTupleUtil.hxx:118; ROOT::Experimental::RClusterSize::ValueTypestd::uint64_t ValueTypeDefinition RNTupleUtil.hxx:119; ROOT::Experimental::RFieldBase::RBulkSpecDefinition RFieldBase.hxx:668; ROOT::Experimental::RFieldBase::RCreateObjectDeleter< void >Definition RField.hxx:461; ROOT::Experimental::RFieldBase::RCreateObjectDeleterDefinition RFieldBase.hxx:448; ROOT::RNTupleCardinalityHelper types to present an offset column as array of collection sizes.Definition RNTupleUtil.hxx:32. treentuplev7incROOTRField.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RField_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RField_8hxx_source.html
Security,access,access,,MatchSource.WIKI,doc/master/RField_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RField_8hxx_source.html
Deployability,update,update,"::GetNameFiltersconst auto & GetNameFilters() constReturns array of name filters.Definition RFileDialog.hxx:94; ROOT::RFileDialog::Dialogstatic std::string Dialog(EDialogTypes kind, const std::string &title, const std::string &fname)Start specified dialog type.Definition RFileDialog.cxx:375; ROOT::RFileDialog::fWebWindowstd::shared_ptr< RWebWindow > fWebWindow! web window for file dialogDefinition RFileDialog.hxx:58; ROOT::RFileDialog::fKindEDialogTypes fKind! dialog kind OpenFile, SaveAs, NewFileDefinition RFileDialog.hxx:53; ROOT::RFileDialog::GetFileNameconst std::string & GetFileName() constDefinition RFileDialog.hxx:112; ROOT::RFileDialog::GetCanChangePathbool GetCanChangePath() constReturns true if working path can be change with gui elements.Definition RFileDialog.hxx:100; ROOT::RFileDialog::fCallbackRFileDialogCallback_t fCallback! function receiving result, called onceDefinition RFileDialog.hxx:64; ROOT::RFileDialog::Showvoid Show(const RWebDisplayArgs &args="""")Show or update RFileDialog in web window If web window already started - just refresh it like ""reload...Definition RFileDialog.cxx:114; ROOT::RFileDialog::InvokeCallBackvoid InvokeCallBack()Invoke specified callback.Definition RFileDialog.cxx:361; ROOT::RFileDialog::SaveAsstatic std::string SaveAs(const std::string &title="""", const std::string &fname="""")Start SaveAs dialog.Definition RFileDialog.cxx:405; ROOT::RFileDialog::GetSelectedFilterstd::string GetSelectedFilter() constReturns selected filter Can differ from specified value - if it does not match to existing entry in N...Definition RFileDialog.cxx:161; ROOT::RFileDialog::RWebWindowPluginfriend class Details::RWebWindowPluginDefinition RFileDialog.hxx:42; ROOT::RFileDialog::SetNameFiltersvoid SetNameFilters(const std::vector< std::string > &arr)Set array of name filters like ""Text files (*.txt)"", ""Any files (*)"", ""Image files (*png *....Definition RFileDialog.hxx:92; ROOT::RFileDialog::ProcessMsgvoid ProcessMsg(unsigned connid, const std::strin",MatchSource.WIKI,doc/master/RFileDialog_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RFileDialog_8hxx_source.html
Integrability,message,message,"h>; 22 ; 23namespace ROOT {; 24 ; 25namespace Details {; 26 class RWebWindowPlugin;; 27}; 28 ; 29/** \class ROOT::RFileDialog; 30\ingroup rbrowser; 31Initial message send to client to configure layout; 32*/; 33 ; 34/// function signature for file dialog call-backs; 35/// argument is selected file name; 36using RFileDialogCallback_t = std::function<void(const std::string &)>;; 37 ; 38 ; 39/** Web-based FileDialog */; 40 ; 41class RFileDialog {; 42 friend class Details::RWebWindowPlugin;; 43public:; 44 ; 45 enum EDialogTypes {; 46 kOpenFile,; 47 kSaveAs,; 48 kNewFile; 49 };; 50 ; 51protected:; 52 ; 53 EDialogTypes fKind{kOpenFile}; ///<! dialog kind OpenFile, SaveAs, NewFile; 54 std::string fTitle; ///<! title, when not specified default will be used; 55 RBrowserData fBrowsable; ///<! central browsing element; 56 bool fCanChangePath{true}; ///<! if working path can be changed via gui elements; 57 ; 58 std::shared_ptr<RWebWindow> fWebWindow; ///<! web window for file dialog; 59 ; 60 bool fDidSelect{false}; ///<! ",MatchSource.WIKI,doc/master/RFileDialog_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RFileDialog_8hxx_source.html
Modifiability,config,configure,"h>; 22 ; 23namespace ROOT {; 24 ; 25namespace Details {; 26 class RWebWindowPlugin;; 27}; 28 ; 29/** \class ROOT::RFileDialog; 30\ingroup rbrowser; 31Initial message send to client to configure layout; 32*/; 33 ; 34/// function signature for file dialog call-backs; 35/// argument is selected file name; 36using RFileDialogCallback_t = std::function<void(const std::string &)>;; 37 ; 38 ; 39/** Web-based FileDialog */; 40 ; 41class RFileDialog {; 42 friend class Details::RWebWindowPlugin;; 43public:; 44 ; 45 enum EDialogTypes {; 46 kOpenFile,; 47 kSaveAs,; 48 kNewFile; 49 };; 50 ; 51protected:; 52 ; 53 EDialogTypes fKind{kOpenFile}; ///<! dialog kind OpenFile, SaveAs, NewFile; 54 std::string fTitle; ///<! title, when not specified default will be used; 55 RBrowserData fBrowsable; ///<! central browsing element; 56 bool fCanChangePath{true}; ///<! if working path can be changed via gui elements; 57 ; 58 std::shared_ptr<RWebWindow> fWebWindow; ///<! web window for file dialog; 59 ; 60 bool fDidSelect{false}; ///<! ",MatchSource.WIKI,doc/master/RFileDialog_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RFileDialog_8hxx_source.html
Availability,recover,recover,"sc.emplace_back(node ? node->GetNumber() - offset : 0);; 529 TGeoVolume *vol = node ? node->GetVolume() : topvolume;; 530 ; 531 auto &desc = fDesc[cnt++];; 532 ; 533 sortarr.emplace_back(&desc);; 534 ; 535 desc.name = node ? node->GetName() : vol->GetName();; 536 ; 537 auto shape = dynamic_cast<TGeoBBox *>(vol->GetShape());; 538 if (shape) {; 539 desc.vol = TMath::Sqrt(shape->GetDX() * shape->GetDX() + shape->GetDY() * shape->GetDY() +; 540 shape->GetDZ() * shape->GetDZ());; 541 desc.nfaces = CountShapeFaces(shape);; 542 }; 543 ; 544 CopyMaterialProperties(vol, desc);; 545 ; 546 auto chlds = node ? node->GetNodes() : vol->GetNodes();; 547 ; 548 PackMatrix(desc.matr, node ? node->GetMatrix() : nullptr);; 549 ; 550 if (chlds); 551 for (int n = 0; n <= chlds->GetLast(); ++n) {; 552 auto chld = dynamic_cast<TGeoNode *>(chlds->At(n));; 553 desc.chlds.emplace_back(chld->GetNumber() - offset);; 554 }; 555 }; 556 ; 557 // recover numbers; 558 cnt = 0;; 559 for (auto node : fNodes) {; 560 auto number = numbers[cnt++];; 561 if (node); 562 node->SetNumber(number);; 563 }; 564 ; 565 // sort in volume descent order; 566 std::sort(sortarr.begin(), sortarr.end(), [](RGeomNode *a, RGeomNode *b) { return a->vol > b->vol; });; 567 ; 568 cnt = 0;; 569 for (auto &elem : sortarr) {; 570 fSortMap.emplace_back(elem->id);; 571 elem->sortid = cnt++; // keep place in sorted array to correctly apply cut; 572 }; 573 ; 574 MarkVisible(); // set visibility flags; 575 ; 576 ProduceIdShifts();; 577}; 578 ; 579/////////////////////////////////////////////////////////////////////; 580/// Get volume for specified nodeid; 581/// If specific volume was configured, it will be returned for nodeid==0; 582 ; 583TGeoVolume *RGeomDescription::GetVolume(int nodeid); 584{; 585 auto node = fNodes[nodeid];; 586 if (node); 587 return node->GetVolume();; 588 return nodeid == 0 ? fDrawVolume : nullptr;; 589}; 590 ; 591/////////////////////////////////////////////////////////////////////; 592/// Set visibility flag f",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Deployability,configurat,configuration,"2068 ; 2069 RGeomBrowserIter giter(*this);; 2070 ; 2071 if (!giter.Navigate(path)); 2072 return false;; 2073 ; 2074 auto stack = MakeStackByIds(giter.CurrentIds());; 2075 ; 2076 for (auto iter = fVisibility.begin(); iter != fVisibility.end(); iter++); 2077 if (compare_stacks(iter->stack, stack) == 0) {; 2078 fVisibility.erase(iter);; 2079 ClearDrawData();; 2080 return true;; 2081 }; 2082 ; 2083 return false;; 2084}; 2085 ; 2086/////////////////////////////////////////////////////////////////////////////////; 2087/// Reset all custom visibility settings; 2088 ; 2089bool RGeomDescription::ClearAllPhysVisibility(); 2090{; 2091 TLockGuard lock(fMutex);; 2092 ; 2093 if (fVisibility.empty()); 2094 return false;; 2095 ; 2096 fVisibility.clear();; 2097 ClearDrawData();; 2098 return true;; 2099}; 2100 ; 2101/////////////////////////////////////////////////////////////////////////////////; 2102/// Change configuration by client; 2103/// Returns true if any parameter was really changed; 2104 ; 2105bool RGeomDescription::ChangeConfiguration(const std::string &json); 2106{; 2107 auto cfg = TBufferJSON::FromJSON<RGeomConfig>(json);; 2108 if (!cfg); 2109 return false;; 2110 ; 2111 TLockGuard lock(fMutex);; 2112 ; 2113 auto json1 = TBufferJSON::ToJSON(cfg.get());; 2114 auto json2 = TBufferJSON::ToJSON(&fCfg);; 2115 ; 2116 if (json1 == json2); 2117 return false;; 2118 ; 2119 fCfg = *cfg; // use assign; 2120 ; 2121 ClearDrawData();; 2122 ; 2123 return true;; 2124}; 2125 ; 2126/////////////////////////////////////////////////////////////////////////////////; 2127/// Change search query and belongs to it json string; 2128/// Returns true if any parameter was really changed; 2129 ; 2130bool RGeomDescription::SetSearch(const std::string &query, const std::string &json); 2131{; 2132 TLockGuard lock(fMutex);; 2133 ; 2134 bool changed = (fSearch != query) || (fSearchJson != json);; 2135 fSearch = query;; 2136 fSearchJson = json;; 2137 return changed;; 2138}; 2139 ; 2140/////////////////////",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Energy Efficiency,reduce,reduced,"of nodes, used for search; 1517 std::vector<int> found_map(fDesc.size(), -1); ///<! mapping between nodeid - > foundid; 1518 ; 1519 // these are only selected nodes to produce hierarchy; 1520 ; 1521 found_desc.emplace_back(0);; 1522 found_desc[0].vis = fDesc[0].vis;; 1523 found_desc[0].name = fDesc[0].name;; 1524 found_desc[0].color = fDesc[0].color;; 1525 found_map[0] = 0;; 1526 ; 1527 ResetRndrInfos();; 1528 ; 1529 RGeomDrawing drawing;; 1530 bool has_shape = true;; 1531 ; 1532 ScanNodes(false, 0, [&, this](RGeomNode &node, std::vector<int> &stack, bool is_vis, int seqid) {; 1533 // select only nodes which should match; 1534 if (!match_func(node)); 1535 return true;; 1536 ; 1537 // add entries into hierarchy of found elements; 1538 int prntid = 0;; 1539 for (auto &s : stack) {; 1540 int chldid = fDesc[prntid].chlds[s];; 1541 if (found_map[chldid] <= 0) {; 1542 int newid = found_desc.size();; 1543 found_desc.emplace_back(newid); // potentially original id can be used here; 1544 found_map[chldid] = newid; // re-map into reduced hierarchy; 1545 ; 1546 found_desc.back().vis = fDesc[chldid].vis;; 1547 found_desc.back().name = fDesc[chldid].name;; 1548 found_desc.back().color = fDesc[chldid].color;; 1549 found_desc.back().material = fDesc[chldid].material;; 1550 }; 1551 ; 1552 auto pid = found_map[prntid];; 1553 auto cid = found_map[chldid];; 1554 ; 1555 // now add entry into childs lists; 1556 auto &pchlds = found_desc[pid].chlds;; 1557 if (std::find(pchlds.begin(), pchlds.end(), cid) == pchlds.end()); 1558 pchlds.emplace_back(cid);; 1559 ; 1560 prntid = chldid;; 1561 }; 1562 ; 1563 // no need to add visibles; 1564 if (!is_vis); 1565 return true;; 1566 ; 1567 drawing.visibles.emplace_back(node.id, seqid, stack);; 1568 ; 1569 // no need to transfer shape if it provided with main drawing list; 1570 // also no binary will be transported when too many matches are there; 1571 if (!send_rawdata || (node.sortid < fDrawIdCut)) {; 1572 // do not include render data; 1573 return ",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Modifiability,config,configured,"0 if (chlds); 551 for (int n = 0; n <= chlds->GetLast(); ++n) {; 552 auto chld = dynamic_cast<TGeoNode *>(chlds->At(n));; 553 desc.chlds.emplace_back(chld->GetNumber() - offset);; 554 }; 555 }; 556 ; 557 // recover numbers; 558 cnt = 0;; 559 for (auto node : fNodes) {; 560 auto number = numbers[cnt++];; 561 if (node); 562 node->SetNumber(number);; 563 }; 564 ; 565 // sort in volume descent order; 566 std::sort(sortarr.begin(), sortarr.end(), [](RGeomNode *a, RGeomNode *b) { return a->vol > b->vol; });; 567 ; 568 cnt = 0;; 569 for (auto &elem : sortarr) {; 570 fSortMap.emplace_back(elem->id);; 571 elem->sortid = cnt++; // keep place in sorted array to correctly apply cut; 572 }; 573 ; 574 MarkVisible(); // set visibility flags; 575 ; 576 ProduceIdShifts();; 577}; 578 ; 579/////////////////////////////////////////////////////////////////////; 580/// Get volume for specified nodeid; 581/// If specific volume was configured, it will be returned for nodeid==0; 582 ; 583TGeoVolume *RGeomDescription::GetVolume(int nodeid); 584{; 585 auto node = fNodes[nodeid];; 586 if (node); 587 return node->GetVolume();; 588 return nodeid == 0 ? fDrawVolume : nullptr;; 589}; 590 ; 591/////////////////////////////////////////////////////////////////////; 592/// Set visibility flag for each nodes; 593 ; 594int RGeomDescription::MarkVisible(bool on_screen); 595{; 596 int res = 0;; 597 for (int nodeid = 0; nodeid < (int)fNodes.size(); nodeid++) {; 598 ; 599 auto node = fNodes[nodeid];; 600 auto vol = GetVolume(nodeid);; 601 auto &desc = fDesc[nodeid];; 602 desc.vis = 0;; 603 desc.nochlds = false;; 604 ; 605 if (on_screen) {; 606 if (!node || node->IsOnScreen()); 607 desc.vis = 99;; 608 } else {; 609 if (vol->IsVisible() && !vol->TestAttBit(TGeoAtt::kVisNone)); 610 desc.vis = 99;; 611 ; 612 if (node && !node->IsVisDaughters()); 613 desc.nochlds = true;; 614 ; 615 if ((desc.vis > 0) && (!desc.chlds.empty()) && !desc.nochlds); 616 desc.vis = 1;; 617 }; 618 ; 619 if (desc.IsVisible() && desc.Can",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Performance,load,loads,"01void RGeomDescription::ResetRndrInfos(); 1202{; 1203 for (auto &s : fShapes); 1204 s.reset();; 1205}; 1206 ; 1207/////////////////////////////////////////////////////////////////////; 1208/// Produce JSON string which can be directly used with `build`; 1209/// function from JSROOT to create three.js model of configured geometry; 1210///; 1211/// Collect all information required to draw geometry on the client; 1212/// This includes list of each visible nodes, meshes and matrixes; 1213/// If @param all_nodes is true, all existing nodes will be provided,; 1214/// which allows to create complete nodes hierarchy on client side; 1215///; 1216/// Example of usage:; 1217///; 1218/// void geom() {; 1219/// auto f = TFile::Open(""file_name.root"");; 1220/// auto vol = f->Get<TGeoVolume>(""object_name"");; 1221/// ROOT::RGeomDescription desc;; 1222/// desc.Build(vol);; 1223/// std::ofstream fout(""geom.json"");; 1224/// fout << desc.ProduceJson();; 1225/// }; 1226///; 1227/// In JSROOT one loads data from JSON file and call `build` function to; 1228/// produce three.js model. Also see example in tutorials/webgui/geom/ folder; 1229 ; 1230std::string RGeomDescription::ProduceJson(bool all_nodes); 1231{; 1232 TLockGuard lock(fMutex);; 1233 ; 1234 std::vector<int> viscnt(fDesc.size(), 0);; 1235 ; 1236 int level = GetVisLevel();; 1237 ; 1238 // first count how many times each individual node appears; 1239 int numnodes = ScanNodes(true, level, [&viscnt](RGeomNode &node, std::vector<int> &, bool, int) {; 1240 viscnt[node.id]++;; 1241 return true;; 1242 });; 1243 ; 1244 if (GetMaxVisNodes() > 0) {; 1245 while ((numnodes > GetMaxVisNodes()) && (level > 1)) {; 1246 level--;; 1247 viscnt.assign(viscnt.size(), 0);; 1248 numnodes = ScanNodes(true, level, [&viscnt](RGeomNode &node, std::vector<int> &, bool, int) {; 1249 viscnt[node.id]++;; 1250 return true;; 1251 });; 1252 }; 1253 }; 1254 ; 1255 fActualLevel = level;; 1256 fDrawIdCut = 0;; 1257 ; 1258 int totalnumfaces = 0, totalnumnodes = 0;; ",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Safety,avoid,avoid,"(), len2 = stack2.size(), len = (len1 < len2) ? len1 : len2, indx = 0;; 273 while (indx < len) {; 274 if (stack1[indx] < stack2[indx]); 275 return -1;; 276 if (stack1[indx] > stack2[indx]); 277 return 1;; 278 ++indx;; 279 }; 280 ; 281 if (len1 < len2); 282 return -1;; 283 if (len1 > len2); 284 return 1;; 285 ; 286 return 0;; 287}; 288} // namespace; 289 ; 290/////////////////////////////////////////////////////////////////////; 291/// Issue signal, which distributed on all handlers - excluding source handler; 292 ; 293void RGeomDescription::IssueSignal(const void *handler, const std::string &kind); 294{; 295 std::vector<RGeomSignalFunc_t> funcs;; 296 ; 297 {; 298 TLockGuard lock(fMutex);; 299 for (auto &pair : fSignals); 300 if (!handler || (pair.first != handler)); 301 funcs.emplace_back(pair.second);; 302 }; 303 ; 304 // invoke signal outside locked mutex to avoid any locking; 305 for (auto func : funcs); 306 func(kind);; 307}; 308 ; 309/////////////////////////////////////////////////////////////////////; 310/// Add signal handler; 311 ; 312void RGeomDescription::AddSignalHandler(const void *handler, RGeomSignalFunc_t func); 313{; 314 TLockGuard lock(fMutex);; 315 fSignals.emplace_back(handler, func);; 316}; 317 ; 318/////////////////////////////////////////////////////////////////////; 319/// Remove signal handler; 320 ; 321void RGeomDescription::RemoveSignalHandler(const void *handler); 322{; 323 TLockGuard lock(fMutex);; 324 ; 325 for (auto iter = fSignals.begin(); iter != fSignals.end(); ++iter); 326 if (handler == iter->first) {; 327 fSignals.erase(iter);; 328 return;; 329 }; 330}; 331 ; 332/////////////////////////////////////////////////////////////////////; 333/// Pack matrix into vector, which can be send to client; 334/// Following sizes can be used for vector:; 335/// 0 - Identity matrix; 336/// 3 - Translation; 337/// 4 - Scale (last element always 1); 338/// 9 - Rotation; 339/// 16 - Full size; 340 ; 341void RGeomDescription::PackMatrix(std::vector<f",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Testability,test,test,"ck matrix into vector, which can be send to client; 334/// Following sizes can be used for vector:; 335/// 0 - Identity matrix; 336/// 3 - Translation; 337/// 4 - Scale (last element always 1); 338/// 9 - Rotation; 339/// 16 - Full size; 340 ; 341void RGeomDescription::PackMatrix(std::vector<float> &vect, TGeoMatrix *matr); 342{; 343 vect.clear();; 344 ; 345 if (!matr || matr->IsIdentity()); 346 return;; 347 ; 348 auto trans = matr->GetTranslation();; 349 auto scale = matr->GetScale();; 350 auto rotate = matr->GetRotationMatrix();; 351 ; 352 bool is_translate = matr->IsA() == TGeoTranslation::Class(), is_scale = matr->IsA() == TGeoScale::Class(),; 353 is_rotate = matr->IsA() == TGeoRotation::Class();; 354 ; 355 if (!is_translate && !is_scale && !is_rotate) {; 356 // check if trivial matrix; 357 ; 358 auto test = [](double val, double chk) { return (val == chk) || (TMath::Abs(val - chk) < 1e-20); };; 359 ; 360 bool no_scale = test(scale[0], 1) && test(scale[1], 1) && test(scale[2], 1);; 361 bool no_trans = test(trans[0], 0) && test(trans[1], 0) && test(trans[2], 0);; 362 bool no_rotate = test(rotate[0], 1) && test(rotate[1], 0) && test(rotate[2], 0) && test(rotate[3], 0) &&; 363 test(rotate[4], 1) && test(rotate[5], 0) && test(rotate[6], 0) && test(rotate[7], 0) &&; 364 test(rotate[8], 1);; 365 ; 366 if (no_scale && no_trans && no_rotate); 367 return;; 368 ; 369 if (no_scale && no_trans && !no_rotate) {; 370 is_rotate = true;; 371 } else if (no_scale && !no_trans && no_rotate) {; 372 is_translate = true;; 373 } else if (!no_scale && no_trans && no_rotate) {; 374 is_scale = true;; 375 }; 376 }; 377 ; 378 if (is_translate) {; 379 vect.resize(3);; 380 vect[0] = trans[0];; 381 vect[1] = trans[1];; 382 vect[2] = trans[2];; 383 return;; 384 }; 385 ; 386 if (is_scale) {; 387 vect.resize(4);; 388 vect[0] = scale[0];; 389 vect[1] = scale[1];; 390 vect[2] = scale[2];; 391 vect[3] = 1;; 392 return;; 393 }; 394 ; 395 if (is_rotate) {; 396 vect.resize(9);; 397 for (int n = 0; n < ",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Usability,clear,clear," = fNodeId;; 106 fChild = 0;; 107 fNodeId = node.chlds[fChild];; 108 return true;; 109 }; 110 ; 111 bool Leave(); 112 {; 113 if (fStackParents.empty()) {; 114 fNodeId = -1;; 115 return false;; 116 }; 117 fParentId = fStackParents.back();; 118 fChild = fStackChilds.back();; 119 ; 120 fStackParents.pop_back();; 121 fStackChilds.pop_back();; 122 ; 123 if (fParentId < 0) {; 124 fNodeId = 0;; 125 } else {; 126 fNodeId = fDesc.fDesc[fParentId].chlds[fChild];; 127 }; 128 return true;; 129 }; 130 ; 131 bool Next(); 132 {; 133 // does not have parents; 134 if ((fNodeId <= 0) || (fParentId < 0)) {; 135 Reset();; 136 return false;; 137 }; 138 ; 139 auto &prnt = fDesc.fDesc[fParentId];; 140 if (++fChild >= prnt.chlds.size()) {; 141 fNodeId = -1; // not valid node, only Leave can be called; 142 return false;; 143 }; 144 ; 145 fNodeId = prnt.chlds[fChild];; 146 return true;; 147 }; 148 ; 149 bool Reset(); 150 {; 151 fParentId = -1;; 152 fNodeId = -1;; 153 fChild = 0;; 154 fStackParents.clear();; 155 fStackChilds.clear();; 156 ; 157 return true;; 158 }; 159 ; 160 bool NextNode(); 161 {; 162 if (Enter()); 163 return true;; 164 ; 165 if (Next()); 166 return true;; 167 ; 168 while (Leave()) {; 169 if (Next()); 170 return true;; 171 }; 172 ; 173 return false;; 174 }; 175 ; 176 /** Navigate to specified path - path specified as string and should start with ""/"" */; 177 bool Navigate(const std::string &path); 178 {; 179 size_t pos = path.find('/');; 180 if (pos != 0); 181 return false;; 182 ; 183 Reset(); // set to the top of element; 184 ; 185 while (++pos < path.length()) {; 186 auto last = pos;; 187 ; 188 pos = path.find('/', last);; 189 ; 190 if (pos == std::string::npos); 191 pos = path.length();; 192 ; 193 std::string folder = path.substr(last, pos - last);; 194 ; 195 if (!Enter()); 196 return false;; 197 ; 198 bool find = false;; 199 ; 200 do {; 201 find = (folder.compare(GetName()) == 0);; 202 } while (!find && Next());; 203 ; 204 if (!find); 205 return false;; 206 }; 207 ; 208 re",MatchSource.WIKI,doc/master/RGeomData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html
Availability,avail,available,"d::string &req="""")Find description object for requested shape If not exists - will be created.Definition RGeomData.cxx:767; ROOT::RGeomDescription::fDescstd::vector< RGeomNode > fDesc! converted description, send to clientDefinition RGeomData.hxx:243; ROOT::RGeomDescription::PackMatrixvoid PackMatrix(std::vector< float > &arr, TGeoMatrix *matr)Pack matrix into vector, which can be send to client Following sizes can be used for vector: 0 - Iden...Definition RGeomData.cxx:341; ROOT::RGeomDescription::ProduceDrawingForbool ProduceDrawingFor(int nodeid, std::string &json, bool check_volume=false)Produce shape rendering data for given stack All nodes, which are referencing same shape will be tran...Definition RGeomData.cxx:1757; ROOT::RGeomDescription::MakeNodeInfostd::unique_ptr< RGeomNodeInfo > MakeNodeInfo(const std::vector< int > &stack)Change visibility for specified element Returns true if changes was performed.Definition RGeomData.cxx:1899; ROOT::RGeomDescription::HasDrawDatabool HasDrawData() constCheck if there is draw data available.Definition RGeomData.cxx:1331; ROOT::RGeomDescription::MakeIdsByStackstd::vector< int > MakeIdsByStack(const std::vector< int > &stack)Produce list of node ids for given stack If found nodes preselected - use their ids.Definition RGeomData.cxx:1683; ROOT::RGeomDescription::MarkVisibleint MarkVisible(bool on_screen=false)Set visibility flag for each nodes.Definition RGeomData.cxx:594; ROOT::RGeomDescription::SetVisLevelvoid SetVisLevel(int lvl=3)Set maximal visible level.Definition RGeomData.hxx:327; ROOT::RGeomDescription::IssueSignalvoid IssueSignal(const void *handler, const std::string &kind)Issue signal, which distributed on all handlers - excluding source handler.Definition RGeomData.cxx:293; ROOT::RGeomDescription::GetUsedNSegmentsint GetUsedNSegments(int min=20)Returns really used number of cylindrical segments.Definition RGeomData.cxx:922; ROOT::RGeomDescription::IsPrincipalEndNodebool IsPrincipalEndNode(int nodeid)return tru",MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Deployability,configurat,configurations," _nodeid, int _seqid, const std::vector<int> &_stack) : nodeid(_nodeid), seqid(_seqid), stack(_stack) {}; 156};; 157 ; 158 ; 159/** Configuration parameters which can be configured on the client; 160 * Send as is to-from client */; 161 ; 162class RGeomConfig {; 163public:; 164 int vislevel{0}; ///< visible level; 165 int maxnumnodes{0}; ///< maximal number of nodes; 166 int maxnumfaces{0}; ///< maximal number of faces; 167 bool showtop{false}; ///< show geometry top volume, off by default; 168 int build_shapes{1}; ///< when shapes build on server 0 - never, 1 - TGeoComposite, 2 - plus non-cylindrical, 3 - all; 169 int nsegm{0}; ///< number of segments for cylindrical shapes; 170 std::string drawopt; ///< draw options for TGeoPainter; 171};; 172 ; 173 ; 174/** Object with full description for drawing geometry; 175 * It includes list of visible items and list of nodes required to build them */; 176 ; 177class RGeomDrawing {; 178public:; 179 RGeomConfig *cfg{nullptr}; ///< current configurations; 180 int numnodes{0}; ///< total number of nodes in description; 181 std::vector<RGeomNode*> nodes; ///< all used nodes to display visible items and not known for client; 182 std::vector<RGeomVisible> visibles; ///< all visible items; 183};; 184 ; 185 ; 186/** Node information including rendering data */; 187class RGeomNodeInfo {; 188public:; 189 std::vector<std::string> path; ///< full path to node; 190 std::string node_type; ///< node class name; 191 std::string node_name; ///< node name; 192 std::string shape_type; ///< shape type (if any); 193 std::string shape_name; ///< shape class name (if any); 194 ; 195 RGeomRenderInfo *ri{nullptr}; ///< rendering information (if applicable); 196};; 197 ; 198/** Custom settings for physical Node visibility */; 199class RGeomNodeVisibility {; 200public:; 201 std::vector<int> stack; ///< path to the node; 202 bool visible{false}; ///< visible flag; 203 RGeomNodeVisibility(const std::vector<int> &_stack, bool _visible) : stack(_stack), vis",MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Energy Efficiency,reduce,reduced," 47 std::string name; ///< node name; 48 std::vector<int> chlds; ///< list of childs id; 49 int vis{0}; ///< visibility flag, 0 - off, 1 - only when level==0, 99 - always; 50 bool nochlds{false}; ///< how far in hierarchy depth should be scanned; 51 ; 52 std::string color; ///< rgb code in hex format; 53 std::string material; ///< name of the material; 54 int sortid{0}; ///<! place in sorted array, to check cuts, or id of original node when used search structures; 55 ; 56 RGeomNodeBase(int _id = 0) : id(_id) {}; 57 ; 58 bool IsVisible() const { return vis > 0; }; 59 ; 60 /** Returns argument for regexp */; 61 const char *GetArg(int kind); 62 {; 63 if (kind == 1) return color.c_str();; 64 if (kind == 2) return material.c_str();; 65 return name.c_str();; 66 }; 67};; 68 ; 69/** Full node description including matrices and other attributes */; 70 ; 71class RGeomNode : public RGeomNodeBase {; 72public:; 73 std::vector<float> matr; ///< matrix for the node, can have reduced number of elements; 74 double vol{0}; ///<! volume estimation; 75 int nfaces{0}; ///<! number of shape faces; 76 int idshift{-1}; ///<! used to jump over then scan all geom hierarchy; 77 bool useflag{false}; ///<! extra flag, used for selection; 78 float opacity{1.}; ///<! opacity of the color; 79 ; 80 RGeomNode(int _id = 0) : RGeomNodeBase(_id) {}; 81 ; 82 /** True when there is shape and it can be displayed */; 83 bool CanDisplay() const { return (vol > 0.) && (nfaces > 0); }; 84};; 85 ; 86/** \class RGeoItem; 87\ingroup rbrowser; 88\brief Representation of single item in the geometry browser; 89*/; 90 ; 91class RGeoItem : public Browsable::RItem {; 92 ; 93protected:; 94 // this is part for browser, visible for I/O; 95 int id{0}; ///< node id; 96 std::string color; ///< color; 97 std::string material; ///< material; 98 int vis{0}; ///< visibility of logical node; 99 int pvis{0}; ///< visibility of physical node; 100 bool top{false}; ///< indicates if node selected as top; 101 ; 102public:; 103 ; 104 /",MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Integrability,interface,interface,"Data.hxx:148; ROOT::RGeomVisible::colorstd::string colorcolor in rgb formatDefinition RGeomData.hxx:150; ROOT::RGeomVisible::RGeomVisibleRGeomVisible(int _nodeid, int _seqid, const std::vector< int > &_stack)Definition RGeomData.hxx:155; ROOT::RGeomVisible::riRGeomRenderInfo * rirender information for the shape, can be same for different nodesDefinition RGeomData.hxx:152; ROOT::RGeomVisible::opacitydouble opacityopacityDefinition RGeomData.hxx:151; ROOT::RGeomVisible::nodeidint nodeidselected node id,Definition RGeomData.hxx:147; ROOT::RGeomVisible::RGeomVisibleRGeomVisible()=default; ROOT::RGeomVisible::stackstd::vector< int > stackpath to the node, index in list of childsDefinition RGeomData.hxx:149; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TLockGuardDefinition TVirtualMutex.h:70; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::RGeomSignalFunc_tstd::function< void(const std::string &)> RGeomSignalFunc_tDefinition RGeomData.hxx:208; ROOT::RGeomLogExperimental::RLogChannel & RGeomLog()Log channel for Geomviewer diagnostics.Definition RGeomData.cxx:49; ROOT::RGeomScanFunc_tstd::function< bool(RGeomNode &, std::vector< int > &, bool, int)> RGeomScanFunc_tDefinition RGeomData.hxx:206. geomwebviewerincROOTRGeomData.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Modifiability,config,configured,"5class RGeomShapeRenderInfo : public RGeomRenderInfo {; 136public:; 137 TGeoShape *shape{nullptr}; ///< original shape - can be much less than binary data; 138 ~RGeomShapeRenderInfo() override = default;; 139};; 140 ; 141 ; 142/** RGeomVisible contains description of visible node; 143 * It is path to the node plus reference to shape rendering data */; 144 ; 145class RGeomVisible {; 146public:; 147 int nodeid{0}; ///< selected node id,; 148 int seqid{0}; ///< sequence id, used for merging later; 149 std::vector<int> stack; ///< path to the node, index in list of childs; 150 std::string color; ///< color in rgb format; 151 double opacity{1}; ///< opacity; 152 RGeomRenderInfo *ri{nullptr}; ///< render information for the shape, can be same for different nodes; 153 ; 154 RGeomVisible() = default;; 155 RGeomVisible(int _nodeid, int _seqid, const std::vector<int> &_stack) : nodeid(_nodeid), seqid(_seqid), stack(_stack) {}; 156};; 157 ; 158 ; 159/** Configuration parameters which can be configured on the client; 160 * Send as is to-from client */; 161 ; 162class RGeomConfig {; 163public:; 164 int vislevel{0}; ///< visible level; 165 int maxnumnodes{0}; ///< maximal number of nodes; 166 int maxnumfaces{0}; ///< maximal number of faces; 167 bool showtop{false}; ///< show geometry top volume, off by default; 168 int build_shapes{1}; ///< when shapes build on server 0 - never, 1 - TGeoComposite, 2 - plus non-cylindrical, 3 - all; 169 int nsegm{0}; ///< number of segments for cylindrical shapes; 170 std::string drawopt; ///< draw options for TGeoPainter; 171};; 172 ; 173 ; 174/** Object with full description for drawing geometry; 175 * It includes list of visible items and list of nodes required to build them */; 176 ; 177class RGeomDrawing {; 178public:; 179 RGeomConfig *cfg{nullptr}; ///< current configurations; 180 int numnodes{0}; ///< total number of nodes in description; 181 std::vector<RGeomNode*> nodes; ///< all used nodes to display visible items and not known for clien",MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Performance,perform,performed,"imal number of nodes which should be selected for drawing.Definition RGeomData.hxx:317; ROOT::RGeomDescription::ProcessBrowserRequeststd::string ProcessBrowserRequest(const std::string &req="""")Find description object for requested shape If not exists - will be created.Definition RGeomData.cxx:767; ROOT::RGeomDescription::fDescstd::vector< RGeomNode > fDesc! converted description, send to clientDefinition RGeomData.hxx:243; ROOT::RGeomDescription::PackMatrixvoid PackMatrix(std::vector< float > &arr, TGeoMatrix *matr)Pack matrix into vector, which can be send to client Following sizes can be used for vector: 0 - Iden...Definition RGeomData.cxx:341; ROOT::RGeomDescription::ProduceDrawingForbool ProduceDrawingFor(int nodeid, std::string &json, bool check_volume=false)Produce shape rendering data for given stack All nodes, which are referencing same shape will be tran...Definition RGeomData.cxx:1757; ROOT::RGeomDescription::MakeNodeInfostd::unique_ptr< RGeomNodeInfo > MakeNodeInfo(const std::vector< int > &stack)Change visibility for specified element Returns true if changes was performed.Definition RGeomData.cxx:1899; ROOT::RGeomDescription::HasDrawDatabool HasDrawData() constCheck if there is draw data available.Definition RGeomData.cxx:1331; ROOT::RGeomDescription::MakeIdsByStackstd::vector< int > MakeIdsByStack(const std::vector< int > &stack)Produce list of node ids for given stack If found nodes preselected - use their ids.Definition RGeomData.cxx:1683; ROOT::RGeomDescription::MarkVisibleint MarkVisible(bool on_screen=false)Set visibility flag for each nodes.Definition RGeomData.cxx:594; ROOT::RGeomDescription::SetVisLevelvoid SetVisLevel(int lvl=3)Set maximal visible level.Definition RGeomData.hxx:327; ROOT::RGeomDescription::IssueSignalvoid IssueSignal(const void *handler, const std::string &kind)Issue signal, which distributed on all handlers - excluding source handler.Definition RGeomData.cxx:293; ROOT::RGeomDescription::GetUsedNSegmentsint GetUsedNSegments(int",MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Safety,avoid,avoid,"webviewer/inc/ROOT/RGeomData.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RGeomData.hxx. Go to the documentation of this file. 1// Author: Sergey Linev, 14.12.2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT7_RGeomData; 12#define ROOT7_RGeomData; 13 ; 14#include <vector>; 15#include <string>; 16#include <functional>; 17#include <memory>; 18 ; 19#include <ROOT/Browsable/RItem.hxx>; 20 ; 21#include ""TVirtualMutex.h""; 22 ; 23class TGeoNode;; 24class TGeoManager;; 25class TGeoShape;; 26class TGeoMatrix;; 27class TGeoVolume;; 28 ; 29// do not use namespace to avoid too long JSON; 30 ; 31namespace ROOT {; 32 ; 33class RGeomBrowserIter;; 34 ; 35namespace Experimental {; 36class RLogChannel;; 37} // namespace Experimental; 38 ; 39/// Log channel for Geomviewer diagnostics.; 40Experimental::RLogChannel &RGeomLog();; 41 ; 42/** Base description of geometry node, required only to build hierarchy */; 43 ; 44class RGeomNodeBase {; 45public:; 46 int id{0}; ///< node id, index in array; 47 std::string name; ///< node name; 48 std::vector<int> chlds; ///< list of childs id; 49 int vis{0}; ///< visibility flag, 0 - off, 1 - only when level==0, 99 - always; 50 bool nochlds{false}; ///< how far in hierarchy depth should be scanned; 51 ; 52 std::string color; ///< rgb code in hex format; 53 std::string material; ///< name of the material; 54 int sortid{0}; ///<! place in sorted array, to check cuts, or id of original node when used search structures; 55 ; 56 RGeomNodeBase(int _id = 0) : id(_id) {}; 57 ; 58 bool IsVisible() const { return vis > 0; }; 59 ; 60 /** Returns argument for regexp",MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Testability,log,logical,,MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Usability,clear,clear,,MatchSource.WIKI,doc/master/RGeomData_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html
Availability,avail,available,"ointer to the graph node encapsulated by this RInterface.; 129 ; 130public:; 131 ////////////////////////////////////////////////////////////////////////////; 132 /// \brief Copy-assignment operator for RInterface.; 133 RInterface &operator=(const RInterface &) = default;; 134 ; 135 ////////////////////////////////////////////////////////////////////////////; 136 /// \brief Copy-ctor for RInterface.; 137 RInterface(const RInterface &) = default;; 138 ; 139 ////////////////////////////////////////////////////////////////////////////; 140 /// \brief Move-ctor for RInterface.; 141 RInterface(RInterface &&) = default;; 142 ; 143 ////////////////////////////////////////////////////////////////////////////; 144 /// \brief Move-assignment operator for RInterface.; 145 RInterface &operator=(RInterface &&) = default;; 146 ; 147 ////////////////////////////////////////////////////////////////////////////; 148 /// \brief Build a RInterface from a RLoopManager.; 149 /// This constructor is only available for RInterface<RLoopManager>.; 150 template <typename T = Proxied, typename = std::enable_if_t<std::is_same<T, RLoopManager>::value, int>>; 151 RInterface(const std::shared_ptr<RLoopManager> &proxied) : RInterfaceBase(proxied), fProxiedPtr(proxied); 152 {; 153 }; 154 ; 155 ////////////////////////////////////////////////////////////////////////////; 156 /// \brief Cast any RDataFrame node to a common type ROOT::RDF::RNode.; 157 /// Different RDataFrame methods return different C++ types. All nodes, however,; 158 /// can be cast to this common type at the cost of a small performance penalty.; 159 /// This allows, for example, storing RDataFrame nodes in a vector, or passing them; 160 /// around via (non-template, C++11) helper functions.; 161 /// Example usage:; 162 /// ~~~{.cpp}; 163 /// // a function that conditionally adds a Range to a RDataFrame node.; 164 /// RNode MaybeAddRange(RNode df, bool mustAddRange); 165 /// {; 166 /// return mustAddRange ? df.Range(1) : df;; 167 //",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Deployability,update,updated,"mnNames = ColumnNames_t{column.data()};; 682 CheckAndFillDSColumns(validColumnNames, TTraits::TypeList<T>{});; 683 ; 684 // Declare return type to the interpreter, for future use by jitted actions; 685 auto retTypeName = RDFInternal::TypeID2TypeName(typeid(T));; 686 if (retTypeName.empty()) {; 687 // The type is not known to the interpreter.; 688 // We must not error out here, but if/when this column is used in jitted code; 689 const auto demangledType = RDFInternal::DemangleTypeIdName(typeid(T));; 690 retTypeName = ""CLING_UNKNOWN_TYPE_"" + demangledType;; 691 }; 692 ; 693 auto newColumn = std::make_shared<ROOT::Internal::RDF::RDefaultValueFor<T>>(; 694 column, retTypeName, defaultValue, validColumnNames, fColRegister, *fLoopManager);; 695 ; 696 RDFInternal::RColumnRegister newCols(fColRegister);; 697 newCols.AddDefine(std::move(newColumn));; 698 ; 699 RInterface<Proxied> newInterface(fProxiedPtr, *fLoopManager, std::move(newCols));; 700 ; 701 return newInterface;; 702 }; 703 ; 704 // clang-format off; 705 ////////////////////////////////////////////////////////////////////////////; 706 /// \brief Define a new column that is updated when the input sample changes.; 707 /// \param[in] name The name of the defined column.; 708 /// \param[in] expression A C++ callable that computes the new value of the defined column.; 709 /// \return the first node of the computation graph for which the new quantity is defined.; 710 ///; 711 /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; 712 /// where:; 713 /// - `T` is the type of the defined column; 714 /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; 715 /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; 716 /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; 717 /",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Energy Efficiency,efficient,efficient,"; 403 /// \brief Define a new column.; 404 /// \param[in] name The name of the defined column.; 405 /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; 406 /// \param[in] columns Names of the columns/branches in input to the producer function.; 407 /// \return the first node of the computation graph for which the new quantity is defined.; 408 ///; 409 /// Define a column that will be visible from all subsequent nodes; 410 /// of the functional chain. The `expression` is only evaluated for entries that pass; 411 /// all the preceding filters.; 412 /// A new variable is created called `name`, accessible as if it was contained; 413 /// in the dataset from subsequent transformations/actions.; 414 ///; 415 /// Use cases include:; 416 /// * caching the results of complex calculations for easy and efficient multiple access; 417 /// * extraction of quantities of interest from complex objects; 418 ///; 419 /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; 420 ///; 421 /// ### Example usage:; 422 /// ~~~{.cpp}; 423 /// // assuming a function with signature:; 424 /// double myComplexCalculation(const RVec<float> &muon_pts);; 425 /// // we can pass it directly to Define; 426 /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; 427 /// // alternatively, we can pass the body of the function as a string, as in Filter:; 428 /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; 429 /// ~~~; 430 ///; 431 /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; 432 /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; 433 /// ~~~{.cpp}; 434 /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); 435 /// ~~~; 436 /// but instead thi",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Integrability,interface,interface,"isto actions; 42#include ""THn.h""; 43#include ""TProfile.h""; 44#include ""TProfile2D.h""; 45#include ""TStatistic.h""; 46 ; 47#include <algorithm>; 48#include <cstddef>; 49#include <initializer_list>; 50#include <iterator> // std::back_insterter; 51#include <limits>; 52#include <memory>; 53#include <set>; 54#include <sstream>; 55#include <stdexcept>; 56#include <string>; 57#include <type_traits> // is_same, enable_if; 58#include <typeinfo>; 59#include <unordered_set>; 60#include <utility> // std::index_sequence; 61#include <vector>; 62 ; 63class TGraph;; 64 ; 65// Windows requires a forward decl of printValue to accept it as a valid friend function in RInterface; 66namespace ROOT {; 67void DisableImplicitMT();; 68bool IsImplicitMTEnabled();; 69void EnableImplicitMT(UInt_t numthreads);; 70class RDataFrame;; 71} // namespace ROOT; 72namespace cling {; 73std::string printValue(ROOT::RDataFrame *tdf);; 74}; 75 ; 76namespace ROOT {; 77namespace RDF {; 78namespace RDFDetail = ROOT::Detail::RDF;; 79namespace RDFInternal = ROOT::Internal::RDF;; 80namespace TTraits = ROOT::TypeTraits;; 81 ; 82template <typename Proxied, typename DataSource>; 83class RInterface;; 84 ; 85using RNode = RInterface<::ROOT::Detail::RDF::RNodeBase, void>;; 86} // namespace RDF; 87 ; 88namespace Internal {; 89namespace RDF {; 90class GraphCreatorHelper;; 91void ChangeEmptyEntryRange(const ROOT::RDF::RNode &node, std::pair<ULong64_t, ULong64_t> &&newRange);; 92void ChangeSpec(const ROOT::RDF::RNode &node, ROOT::RDF::Experimental::RDatasetSpec &&spec);; 93void TriggerRun(ROOT::RDF::RNode node);; 94std::string GetDataSourceLabel(const ROOT::RDF::RNode &node);; 95} // namespace RDF; 96} // namespace Internal; 97 ; 98namespace RDF {; 99 ; 100// clang-format off; 101/**; 102 * \class ROOT::RDF::RInterface; 103 * \ingroup dataframe; 104 * \brief The public interface to the RDataFrame federation of classes.; 105 * \tparam Proxied One of the ""node"" base types (e.g. RLoopManager, RFilterBase). The user never specifi",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Modifiability,variab,variable,"Node's by value.; 173 operator RNode() const; 174 {; 175 return RNode(std::static_pointer_cast<::ROOT::Detail::RDF::RNodeBase>(fProxiedPtr), *fLoopManager, fColRegister);; 176 }; 177 ; 178 ////////////////////////////////////////////////////////////////////////////; 179 /// \brief Append a filter to the call graph.; 180 /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; 181 /// signalling whether the event has passed the selection (true) or not (false).; 182 /// \param[in] columns Names of the columns/branches in input to the filter function.; 183 /// \param[in] name Optional name of this filter. See `Report`.; 184 /// \return the filter node of the computation graph.; 185 ///; 186 /// Append a filter node at the point of the call graph corresponding to the; 187 /// object this method is called on.; 188 /// The callable `f` should not have side-effects (e.g. modification of an; 189 /// external or static variable) to ensure correct results when implicit; 190 /// multi-threading is active.; 191 ///; 192 /// RDataFrame only evaluates filters when necessary: if multiple filters; 193 /// are chained one after another, they are executed in order and the first; 194 /// one returning false causes the event to be discarded.; 195 /// Even if multiple actions or transformations depend on the same filter,; 196 /// it is executed once per entry. If its result is requested more than; 197 /// once, the cached result is served.; 198 ///; 199 /// ### Example usage:; 200 /// ~~~{.cpp}; 201 /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; 202 /// auto filtered = df.Filter(myCut, {""x"", ""y""});; 203 ///; 204 /// // String: it must contain valid C++ except that column names can be used instead of variable names; 205 /// auto filtered = df.Filter(""x*y > 0"");; 206 /// ~~~; 207 ///; 208 /// \note If the body of the string expression contains an explicit `return` stat",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Performance,perform,performance,"f Move-ctor for RInterface.; 141 RInterface(RInterface &&) = default;; 142 ; 143 ////////////////////////////////////////////////////////////////////////////; 144 /// \brief Move-assignment operator for RInterface.; 145 RInterface &operator=(RInterface &&) = default;; 146 ; 147 ////////////////////////////////////////////////////////////////////////////; 148 /// \brief Build a RInterface from a RLoopManager.; 149 /// This constructor is only available for RInterface<RLoopManager>.; 150 template <typename T = Proxied, typename = std::enable_if_t<std::is_same<T, RLoopManager>::value, int>>; 151 RInterface(const std::shared_ptr<RLoopManager> &proxied) : RInterfaceBase(proxied), fProxiedPtr(proxied); 152 {; 153 }; 154 ; 155 ////////////////////////////////////////////////////////////////////////////; 156 /// \brief Cast any RDataFrame node to a common type ROOT::RDF::RNode.; 157 /// Different RDataFrame methods return different C++ types. All nodes, however,; 158 /// can be cast to this common type at the cost of a small performance penalty.; 159 /// This allows, for example, storing RDataFrame nodes in a vector, or passing them; 160 /// around via (non-template, C++11) helper functions.; 161 /// Example usage:; 162 /// ~~~{.cpp}; 163 /// // a function that conditionally adds a Range to a RDataFrame node.; 164 /// RNode MaybeAddRange(RNode df, bool mustAddRange); 165 /// {; 166 /// return mustAddRange ? df.Range(1) : df;; 167 /// }; 168 /// // use as :; 169 /// ROOT::RDataFrame df(10);; 170 /// auto maybeRanged = MaybeAddRange(df, true);; 171 /// ~~~; 172 /// Note that it is not a problem to pass RNode's by value.; 173 operator RNode() const; 174 {; 175 return RNode(std::static_pointer_cast<::ROOT::Detail::RDF::RNodeBase>(fProxiedPtr), *fLoopManager, fColRegister);; 176 }; 177 ; 178 ////////////////////////////////////////////////////////////////////////////; 179 /// \brief Append a filter to the call graph.; 180 /// \param[in] f Function, lambda expression, functor clas",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Safety,safe,safe,"> = 0>; 441 RInterface<Proxied, DS_t> Define(std::string_view name, F expression, const ColumnNames_t &columns = {}); 442 {; 443 return DefineImpl<F, RDFDetail::ExtraArgsForDefine::None>(name, std::move(expression), columns, ""Define"");; 444 }; 445 // clang-format on; 446 ; 447 // clang-format off; 448 ////////////////////////////////////////////////////////////////////////////; 449 /// \brief Define a new column with a value dependent on the processing slot.; 450 /// \param[in] name The name of the defined column.; 451 /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; 452 /// \param[in] columns Names of the columns/branches in input to the producer function (excluding the slot number).; 453 /// \return the first node of the computation graph for which the new quantity is defined.; 454 ///; 455 /// This alternative implementation of `Define` is meant as a helper to evaluate new column values in a thread-safe manner.; 456 /// The expression must be a callable of signature R(unsigned int, T1, T2, ...) where `T1, T2...` are the types; 457 /// of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer; 458 /// representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; 459 /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; 460 ///; 461 /// The following two calls are equivalent, although `DefineSlot` is slightly more performant:; 462 /// ~~~{.cpp}; 463 /// int function(unsigned int, double, double);; 464 /// df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); 465 /// df.DefineSlot(""x"", function, {""column1"", ""column2""}); 466 /// ~~~; 467 ///; 468 /// See Define() for more information.; 469 template <typename F>; 470 RInterface<Proxied, DS_t> DefineSlot(std::string_view name, F expressi",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Security,access,accessible,"roxiedPtr, fColRegister, columns);; 398 return RInterface<F_t, DS_t>(std::move(filterPtr), *fLoopManager, fColRegister);; 399 }; 400 ; 401 // clang-format off; 402 ////////////////////////////////////////////////////////////////////////////; 403 /// \brief Define a new column.; 404 /// \param[in] name The name of the defined column.; 405 /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; 406 /// \param[in] columns Names of the columns/branches in input to the producer function.; 407 /// \return the first node of the computation graph for which the new quantity is defined.; 408 ///; 409 /// Define a column that will be visible from all subsequent nodes; 410 /// of the functional chain. The `expression` is only evaluated for entries that pass; 411 /// all the preceding filters.; 412 /// A new variable is created called `name`, accessible as if it was contained; 413 /// in the dataset from subsequent transformations/actions.; 414 ///; 415 /// Use cases include:; 416 /// * caching the results of complex calculations for easy and efficient multiple access; 417 /// * extraction of quantities of interest from complex objects; 418 ///; 419 /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; 420 ///; 421 /// ### Example usage:; 422 /// ~~~{.cpp}; 423 /// // assuming a function with signature:; 424 /// double myComplexCalculation(const RVec<float> &muon_pts);; 425 /// // we can pass it directly to Define; 426 /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; 427 /// // alternatively, we can pass the body of the function as a string, as in Filter:; 428 /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; 429 /// ~~~; 430 ///; 431 /// \note If the body of the string expression contains an explicit `return` statement (even if it is",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Usability,simpl,simplify,"; 697 newCols.AddDefine(std::move(newColumn));; 698 ; 699 RInterface<Proxied> newInterface(fProxiedPtr, *fLoopManager, std::move(newCols));; 700 ; 701 return newInterface;; 702 }; 703 ; 704 // clang-format off; 705 ////////////////////////////////////////////////////////////////////////////; 706 /// \brief Define a new column that is updated when the input sample changes.; 707 /// \param[in] name The name of the defined column.; 708 /// \param[in] expression A C++ callable that computes the new value of the defined column.; 709 /// \return the first node of the computation graph for which the new quantity is defined.; 710 ///; 711 /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; 712 /// where:; 713 /// - `T` is the type of the defined column; 714 /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; 715 /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; 716 /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; 717 /// being processed (see the class docs for more information).; 718 ///; 719 /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; 720 /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; 721 /// starts rather than at every entry.; 722 ///; 723 /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; 724 ///; 725 /// ### Example usage:; 726 /// ~~~{.cpp}; 727 /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; 728 /// df.DefinePerSample(""weightbysample"",; 729 /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); 730 /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; 731 /// ~~~; 732 // clang-format ",MatchSource.WIKI,doc/master/RInterface_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html
Availability,error,errors,"T  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Enumerations |; Functions ; RLogger.hxx File ReferenceCore ROOT classes » Base ROOT classes | ROOT7 classes. #include <atomic>; #include <list>; #include <memory>; #include <mutex>; #include <sstream>; #include <string>; #include <utility>. Include dependency graph for RLogger.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Experimental::Detail::RLogBuilder;  Builds a diagnostic entry, emitted by the static RLogManager upon destruction of this builder, where - by definition - the RLogEntry has been completely built. More...;  ; class  ROOT::Experimental::RLogChannel;  A log configuration for a channel, e.g. More...;  ; class  ROOT::Experimental::RLogDiagCount;  Keep track of emitted errors and warnings. More...;  ; class  ROOT::Experimental::RLogEntry;  A diagnostic that can be emitted by the RLogManager. More...;  ; class  ROOT::Experimental::RLogHandler;  Abstract RLogHandler base class. More...;  ; struct  ROOT::Experimental::RLogLocation;  A diagnostic location, part of an RLogEntry. More...;  ; class  ROOT::Experimental::RLogManager;  A RLogHandler that multiplexes diagnostics to different client RLogHandlers and keeps track of the sum of RLogDiagCounts for all channels. More...;  ; class  ROOT::Experimental::RLogScopedDiagCount;  Object to count the number of warnings and errors emitted by a section of code, after construction of this type. More...;  ; class  ROOT::Experimental::RLogScopedVerbosity;  Change the verbosity level (global or specific to the RLogChannel passed to the constructor) for the lifetime of this object. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doe",MatchSource.WIKI,doc/master/RLogger_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx.html
Deployability,configurat,configuration,". ROOT: core/foundation/inc/ROOT/RLogger.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Enumerations |; Functions ; RLogger.hxx File ReferenceCore ROOT classes » Base ROOT classes | ROOT7 classes. #include <atomic>; #include <list>; #include <memory>; #include <mutex>; #include <sstream>; #include <string>; #include <utility>. Include dependency graph for RLogger.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Experimental::Detail::RLogBuilder;  Builds a diagnostic entry, emitted by the static RLogManager upon destruction of this builder, where - by definition - the RLogEntry has been completely built. More...;  ; class  ROOT::Experimental::RLogChannel;  A log configuration for a channel, e.g. More...;  ; class  ROOT::Experimental::RLogDiagCount;  Keep track of emitted errors and warnings. More...;  ; class  ROOT::Experimental::RLogEntry;  A diagnostic that can be emitted by the RLogManager. More...;  ; class  ROOT::Experimental::RLogHandler;  Abstract RLogHandler base class. More...;  ; struct  ROOT::Experimental::RLogLocation;  A diagnostic location, part of an RLogEntry. More...;  ; class  ROOT::Experimental::RLogManager;  A RLogHandler that multiplexes diagnostics to different client RLogHandlers and keeps track of the sum of RLogDiagCounts for all channels. More...;  ; class  ROOT::Experimental::RLogScopedDiagCount;  Object to count the number of warnings and errors emitted by a section of code, after construction of this type. More...;  ; class  ROOT::Experimental::RLogScopedVerbosity;  Change the verbosity level (global or specific to the RLogChannel passed to the constructor) for the lifetime of this object. More...;  . Namespaces; namespace  ROOT;  tbb:",MatchSource.WIKI,doc/master/RLogger_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx.html
Integrability,depend,dependency,". ROOT: core/foundation/inc/ROOT/RLogger.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Enumerations |; Functions ; RLogger.hxx File ReferenceCore ROOT classes » Base ROOT classes | ROOT7 classes. #include <atomic>; #include <list>; #include <memory>; #include <mutex>; #include <sstream>; #include <string>; #include <utility>. Include dependency graph for RLogger.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Experimental::Detail::RLogBuilder;  Builds a diagnostic entry, emitted by the static RLogManager upon destruction of this builder, where - by definition - the RLogEntry has been completely built. More...;  ; class  ROOT::Experimental::RLogChannel;  A log configuration for a channel, e.g. More...;  ; class  ROOT::Experimental::RLogDiagCount;  Keep track of emitted errors and warnings. More...;  ; class  ROOT::Experimental::RLogEntry;  A diagnostic that can be emitted by the RLogManager. More...;  ; class  ROOT::Experimental::RLogHandler;  Abstract RLogHandler base class. More...;  ; struct  ROOT::Experimental::RLogLocation;  A diagnostic location, part of an RLogEntry. More...;  ; class  ROOT::Experimental::RLogManager;  A RLogHandler that multiplexes diagnostics to different client RLogHandlers and keeps track of the sum of RLogDiagCounts for all channels. More...;  ; class  ROOT::Experimental::RLogScopedDiagCount;  Object to count the number of warnings and errors emitted by a section of code, after construction of this type. More...;  ; class  ROOT::Experimental::RLogScopedVerbosity;  Change the verbosity level (global or specific to the RLogChannel passed to the constructor) for the lifetime of this object. More...;  . Namespaces; namespace  ROOT;  tbb:",MatchSource.WIKI,doc/master/RLogger_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx.html
Modifiability,config,configuration,". ROOT: core/foundation/inc/ROOT/RLogger.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Enumerations |; Functions ; RLogger.hxx File ReferenceCore ROOT classes » Base ROOT classes | ROOT7 classes. #include <atomic>; #include <list>; #include <memory>; #include <mutex>; #include <sstream>; #include <string>; #include <utility>. Include dependency graph for RLogger.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Experimental::Detail::RLogBuilder;  Builds a diagnostic entry, emitted by the static RLogManager upon destruction of this builder, where - by definition - the RLogEntry has been completely built. More...;  ; class  ROOT::Experimental::RLogChannel;  A log configuration for a channel, e.g. More...;  ; class  ROOT::Experimental::RLogDiagCount;  Keep track of emitted errors and warnings. More...;  ; class  ROOT::Experimental::RLogEntry;  A diagnostic that can be emitted by the RLogManager. More...;  ; class  ROOT::Experimental::RLogHandler;  Abstract RLogHandler base class. More...;  ; struct  ROOT::Experimental::RLogLocation;  A diagnostic location, part of an RLogEntry. More...;  ; class  ROOT::Experimental::RLogManager;  A RLogHandler that multiplexes diagnostics to different client RLogHandlers and keeps track of the sum of RLogDiagCounts for all channels. More...;  ; class  ROOT::Experimental::RLogScopedDiagCount;  Object to count the number of warnings and errors emitted by a section of code, after construction of this type. More...;  ; class  ROOT::Experimental::RLogScopedVerbosity;  Change the verbosity level (global or specific to the RLogChannel passed to the constructor) for the lifetime of this object. More...;  . Namespaces; namespace  ROOT;  tbb:",MatchSource.WIKI,doc/master/RLogger_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx.html
Testability,log,log,". ROOT: core/foundation/inc/ROOT/RLogger.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Enumerations |; Functions ; RLogger.hxx File ReferenceCore ROOT classes » Base ROOT classes | ROOT7 classes. #include <atomic>; #include <list>; #include <memory>; #include <mutex>; #include <sstream>; #include <string>; #include <utility>. Include dependency graph for RLogger.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Experimental::Detail::RLogBuilder;  Builds a diagnostic entry, emitted by the static RLogManager upon destruction of this builder, where - by definition - the RLogEntry has been completely built. More...;  ; class  ROOT::Experimental::RLogChannel;  A log configuration for a channel, e.g. More...;  ; class  ROOT::Experimental::RLogDiagCount;  Keep track of emitted errors and warnings. More...;  ; class  ROOT::Experimental::RLogEntry;  A diagnostic that can be emitted by the RLogManager. More...;  ; class  ROOT::Experimental::RLogHandler;  Abstract RLogHandler base class. More...;  ; struct  ROOT::Experimental::RLogLocation;  A diagnostic location, part of an RLogEntry. More...;  ; class  ROOT::Experimental::RLogManager;  A RLogHandler that multiplexes diagnostics to different client RLogHandlers and keeps track of the sum of RLogDiagCounts for all channels. More...;  ; class  ROOT::Experimental::RLogScopedDiagCount;  Object to count the number of warnings and errors emitted by a section of code, after construction of this type. More...;  ; class  ROOT::Experimental::RLogScopedVerbosity;  Change the verbosity level (global or specific to the RLogChannel passed to the constructor) for the lifetime of this object. More...;  . Namespaces; namespace  ROOT;  tbb:",MatchSource.WIKI,doc/master/RLogger_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx.html
Availability,error,error,"ange without notice. It might trigger earthquakes. Feedback; 6/// is welcome!; 7 ; 8/*************************************************************************; 9 * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; 10 * All rights reserved. *; 11 * *; 12 * For the licensing terms see $ROOTSYS/LICENSE. *; 13 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 14 *************************************************************************/; 15 ; 16#ifndef ROOT7_RLogger; 17#define ROOT7_RLogger; 18 ; 19#include <atomic>; 20#include <list>; 21#include <memory>; 22#include <mutex>; 23#include <sstream>; 24#include <string>; 25#include <utility>; 26 ; 27namespace ROOT {; 28namespace Experimental {; 29 ; 30class RLogEntry;; 31class RLogManager;; 32 ; 33/**; 34 Kinds of diagnostics.; 35 */; 36enum class ELogLevel : unsigned char {; 37 kUnset,; 38 kFatal, ///< An error which causes further processing to be unreliable; 39 kError, ///< An error; 40 kWarning, ///< Warnings about likely unexpected behavior; 41 kInfo, ///< Informational messages; used for instance for tracing; 42 kDebug ///< Debug information; only useful for developers; can have added verbosity up to 255-kDebug.; 43};; 44 ; 45inline ELogLevel operator+(ELogLevel severity, int offset); 46{; 47 return static_cast<ELogLevel>(static_cast<int>(severity) + offset);; 48}; 49 ; 50/**; 51 Keep track of emitted errors and warnings.; 52 */; 53class RLogDiagCount {; 54protected:; 55 std::atomic<long long> fNumWarnings{0ll}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() c",MatchSource.WIKI,doc/master/RLogger_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html
Deployability,configurat,configuration," ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anonymous channel with a default verbosity.; 113 explicit RLogChannel(ELogLevel verbosity) : fVerbosity(verbosity) {}; 114 ; 115 /// Construct a log channel given its name, which is part of the diagnostics.; 116 RLogChannel(const std::string &name) : fName(name) {}; 117 ; 118 ELogLevel SetVerbosity(ELogLevel verbosity); 119 {; 120 std::swap(fVerbosity, verbosity);; 121 return verbosity;; 122 }; 123 ELogLevel GetVerbosity() const { return fVerbosity; }; 124 ELogLevel GetEffectiveVerbosity(con",MatchSource.WIKI,doc/master/RLogger_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html
Integrability,message,messages,"ange without notice. It might trigger earthquakes. Feedback; 6/// is welcome!; 7 ; 8/*************************************************************************; 9 * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; 10 * All rights reserved. *; 11 * *; 12 * For the licensing terms see $ROOTSYS/LICENSE. *; 13 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 14 *************************************************************************/; 15 ; 16#ifndef ROOT7_RLogger; 17#define ROOT7_RLogger; 18 ; 19#include <atomic>; 20#include <list>; 21#include <memory>; 22#include <mutex>; 23#include <sstream>; 24#include <string>; 25#include <utility>; 26 ; 27namespace ROOT {; 28namespace Experimental {; 29 ; 30class RLogEntry;; 31class RLogManager;; 32 ; 33/**; 34 Kinds of diagnostics.; 35 */; 36enum class ELogLevel : unsigned char {; 37 kUnset,; 38 kFatal, ///< An error which causes further processing to be unreliable; 39 kError, ///< An error; 40 kWarning, ///< Warnings about likely unexpected behavior; 41 kInfo, ///< Informational messages; used for instance for tracing; 42 kDebug ///< Debug information; only useful for developers; can have added verbosity up to 255-kDebug.; 43};; 44 ; 45inline ELogLevel operator+(ELogLevel severity, int offset); 46{; 47 return static_cast<ELogLevel>(static_cast<int>(severity) + offset);; 48}; 49 ; 50/**; 51 Keep track of emitted errors and warnings.; 52 */; 53class RLogDiagCount {; 54protected:; 55 std::atomic<long long> fNumWarnings{0ll}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() c",MatchSource.WIKI,doc/master/RLogger_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html
Modifiability,config,configuration," ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anonymous channel with a default verbosity.; 113 explicit RLogChannel(ELogLevel verbosity) : fVerbosity(verbosity) {}; 114 ; 115 /// Construct a log channel given its name, which is part of the diagnostics.; 116 RLogChannel(const std::string &name) : fName(name) {}; 117 ; 118 ELogLevel SetVerbosity(ELogLevel verbosity); 119 {; 120 std::swap(fVerbosity, verbosity);; 121 return verbosity;; 122 }; 123 ELogLevel GetVerbosity() const { return fVerbosity; }; 124 ELogLevel GetEffectiveVerbosity(con",MatchSource.WIKI,doc/master/RLogger_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html
Performance,concurren,concurrently,"ngs.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anonymous channel with a default verbosity.; 113 explicit RLogChannel(ELogLevel verbosity) : fVerbosity(verbosity) {}; 114 ; 115 /// Construct a log channel given its name, which is part of the diagnostics.; 116 RLogChannel(const std::string &name) : fName(name) {}; 117 ; 118 ELogLevel SetVerbosity(ELogLevel verbosit",MatchSource.WIKI,doc/master/RLogger_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html
Testability,log,logs,"/; 53class RLogDiagCount {; 54protected:; 55 std::atomic<long long> fNumWarnings{0ll}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anony",MatchSource.WIKI,doc/master/RLogger_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html
Availability,avail,available,"*; 36 *""Nelder-Mead"", ""BFGS"", ""CG"", ""L-BFGS-B"", ""SANN"", ""Brent"" (Brent only for 1D minimization); 37 */; 38 RMinimizer::RMinimizer(Option_t *method){; 39 fMethod=method;; 40 if (fMethod.empty() || fMethod==""Migrad"") fMethod=""BFGS""; ; 41 }; 42 ; 43 ///returns number of function calls; 44 unsigned int RMinimizer::NCalls() const { return gNCalls; }; 45 ; 46 ///function for finding the minimum; 47 bool RMinimizer::Minimize() {; 48 ; 49 //Set the functions; 50 (gFunction)= ObjFunction();; 51 (gGradFunction) = GradObjFunction();; 52 ; 53 gNCalls = 0; ; 54 ; 55 //pass functions and variables to R; 56 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 57 ; 58 r[""minfunction""] = ROOT::R::TRFunctionExport(minfunction);; 59 r[""mingradfunction""] = ROOT::R::TRFunctionExport(mingradfunction);; 60 r[""method""] = fMethod.c_str();; 61 std::vector<double> stepSizes(StepSizes(), StepSizes()+NDim());; 62 std::vector<double> values(X(), X()+NDim());; 63 r[""ndim""] = NDim();; 64 int ndim = NDim();; 65 r[""stepsizes""] = stepSizes;; 66 r[""initialparams""] = values;; 67 ; 68 //check if optimx is available; 69 bool optimxloaded = FALSE;; 70 r[""optimxloaded""] = optimxloaded;; 71 r.Execute(""optimxloaded<-library(optimx,logical.return=TRUE)"");; 72 //int ibool = r.ParseEval(""optimxloaded"").ToScalar<Int_t>();; 73 int ibool = r.Eval(""optimxloaded"");; 74 if (ibool==1) optimxloaded=kTRUE;; 75 ; 76 //string for the command to be processed in R; 77 TString cmd;; 78 ; 79 //optimx is available and loaded; 80 if (optimxloaded==kTRUE) {; 81 if (!gGradFunction) { ; 82 // not using gradient function; 83 cmd = TString::Format(""result <- optimx( initialparams, minfunction,method='%s',control = list(ndeps=stepsizes,maxit=%d,trace=%d,abstol=%e),hessian=TRUE)"",fMethod.c_str(),MaxIterations(),PrintLevel(),Tolerance());; 84 }; 85 else { ; 86 // using user provided gradient ; 87 cmd = TString::Format(""result <- optimx( initialparams, minfunction,mingradfunction, method='%s', control = list(ndeps=stepsizes,maxit=",MatchSource.WIKI,doc/master/RMinimizer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RMinimizer_8cxx_source.html
Deployability,configurat,configuration,"n pointer to used gradient object function (NULL if gradient is not supported)Definition BasicMinimizer.cxx:325; ROOT::Math::BasicMinimizer::Xconst double * X() const overridereturn pointer to X values at the minimumDefinition BasicMinimizer.h:118; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation.Definition IFunction.h:168; ROOT::Math::IGradientFunctionMultiDimTempl::Gradientvirtual void Gradient(const T *x, T *grad) constEvaluate all the vector of function derivatives (gradient) at a point x.Definition IFunction.h:177; ROOT::Math::Minimizer::Tolerancedouble Tolerance() constabsolute toleranceDefinition Minimizer.h:300; ROOT::Math::Minimizer::MaxIterationsunsigned int MaxIterations() constmax iterationsDefinition Minimizer.h:297; ROOT::Math::Minimizer::PrintLevelint PrintLevel() constminimizer configuration parametersDefinition Minimizer.h:291; ROOT::Math::RMinimizer::HessMatrixdouble HessMatrix(unsigned int i, unsigned int j) constReturns the ith jth component of the Hessian matrix.; ROOT::Math::RMinimizer::fCovMatrixTMatrixD fCovMatrixcovariant matrixDefinition RMinimizer.h:39; ROOT::Math::RMinimizer::fErrorsstd::vector< double > fErrorsvector of parameter errorsDefinition RMinimizer.h:38; ROOT::Math::RMinimizer::Minimizebool Minimize() overrideFunction to find the minimum.Definition RMinimizer.cxx:47; ROOT::Math::RMinimizer::fMethodstd::string fMethodminimizer method to be used, must be of a type listed in R optim or optimx descriptionsDefinition RMinimizer.h:35; ROOT::Math::RMinimizer::NCallsunsigned int NCalls() const overrideReturns the number of function calls.Definition RMinimizer.cxx:44; ROOT::Math::RMinimizer::CovMatrixdouble CovMatrix(unsigned int ivar, unsigned int jvar) const overridereturn covariance matrices element for variables ivar,jvar if the ",MatchSource.WIKI,doc/master/RMinimizer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RMinimizer_8cxx_source.html
Integrability,wrap,wrapper,". ROOT: math/rtools/src/RMinimizer.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RMinimizer.cxx. Go to the documentation of this file. 1 ; 2#include ""TRInterface.h""; 3#include ""Math/RMinimizer.h""; 4#include ""Math/IFunction.h""; 5#include <TVectorD.h>; 6#include ""Math/BasicMinimizer.h""; 7 ; 8namespace ROOT {; 9 namespace Math{; 10 ; 11 /// function wrapper for the function to be minimized; 12 const ROOT::Math::IMultiGenFunction *gFunction;; 13 /// function wrapper for the gradient of the function to be minimized; 14 const ROOT::Math::IMultiGradFunction *gGradFunction;; 15 /// integer for the number of function calls; 16 int gNCalls = 0; ; 17 ; 18 ///function to return the function values at point x; 19 double minfunction(const std::vector<double> & x){; 20 gNCalls++;; 21 //return (*gFunction)(x.GetMatrixArray());; 22 return (*gFunction)(x.data());; 23 }; 24 ///function to return the gradient values at point y; 25 TVectorD mingradfunction(TVectorD y){; 26 unsigned int size = y.GetNoElements();; 27 const double * yy = y.GetMatrixArray();; 28 double z[size];; 29 gGradFunction->Gradient(yy,z);; 30 TVectorD zz(size,z);; 31 return zz;; 32 }; 33 ; 34 /*Default constructor with option for the method of minimization, can be any of the following:; 35 *; 36 *""Nelder-Mead"", ""BFGS"", ""CG"", ""L-BFGS-B"", ""SANN"", ""Brent"" (Brent only for 1D minimization); 37 */; 38 RMinimizer::RMinimizer(Option_t *method){; 39 fMethod=method;; 40 if (fMethod.empty() || fMethod==""Migrad"") fMethod=""BFGS""; ; 41 }; 42 ; 43 ///returns number of function calls; 44 unsigned int RMinimizer::NCalls() const { return gNCalls; }; 45 ; 46 ///function for finding the minimum; 47 bool RMinimizer::Minimize() {; 48 ; 49 //Set the functions; 50 (gFunction)= ObjFunction();; 51 (gGradFunction) = GradObjFunction();; 52 ; 53 gNCalls = 0; ; 54 ; 55 //pass functions and variables to R; 56 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 57 ; 58 r[""minfunction""] = ROO",MatchSource.WIKI,doc/master/RMinimizer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RMinimizer_8cxx_source.html
Modifiability,variab,variables," gNCalls++;; 21 //return (*gFunction)(x.GetMatrixArray());; 22 return (*gFunction)(x.data());; 23 }; 24 ///function to return the gradient values at point y; 25 TVectorD mingradfunction(TVectorD y){; 26 unsigned int size = y.GetNoElements();; 27 const double * yy = y.GetMatrixArray();; 28 double z[size];; 29 gGradFunction->Gradient(yy,z);; 30 TVectorD zz(size,z);; 31 return zz;; 32 }; 33 ; 34 /*Default constructor with option for the method of minimization, can be any of the following:; 35 *; 36 *""Nelder-Mead"", ""BFGS"", ""CG"", ""L-BFGS-B"", ""SANN"", ""Brent"" (Brent only for 1D minimization); 37 */; 38 RMinimizer::RMinimizer(Option_t *method){; 39 fMethod=method;; 40 if (fMethod.empty() || fMethod==""Migrad"") fMethod=""BFGS""; ; 41 }; 42 ; 43 ///returns number of function calls; 44 unsigned int RMinimizer::NCalls() const { return gNCalls; }; 45 ; 46 ///function for finding the minimum; 47 bool RMinimizer::Minimize() {; 48 ; 49 //Set the functions; 50 (gFunction)= ObjFunction();; 51 (gGradFunction) = GradObjFunction();; 52 ; 53 gNCalls = 0; ; 54 ; 55 //pass functions and variables to R; 56 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 57 ; 58 r[""minfunction""] = ROOT::R::TRFunctionExport(minfunction);; 59 r[""mingradfunction""] = ROOT::R::TRFunctionExport(mingradfunction);; 60 r[""method""] = fMethod.c_str();; 61 std::vector<double> stepSizes(StepSizes(), StepSizes()+NDim());; 62 std::vector<double> values(X(), X()+NDim());; 63 r[""ndim""] = NDim();; 64 int ndim = NDim();; 65 r[""stepsizes""] = stepSizes;; 66 r[""initialparams""] = values;; 67 ; 68 //check if optimx is available; 69 bool optimxloaded = FALSE;; 70 r[""optimxloaded""] = optimxloaded;; 71 r.Execute(""optimxloaded<-library(optimx,logical.return=TRUE)"");; 72 //int ibool = r.ParseEval(""optimxloaded"").ToScalar<Int_t>();; 73 int ibool = r.Eval(""optimxloaded"");; 74 if (ibool==1) optimxloaded=kTRUE;; 75 ; 76 //string for the command to be processed in R; 77 TString cmd;; 78 ; 79 //optimx is available and loaded; 80 if (o",MatchSource.WIKI,doc/master/RMinimizer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RMinimizer_8cxx_source.html
Performance,load,loaded,"NCalls = 0; ; 54 ; 55 //pass functions and variables to R; 56 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 57 ; 58 r[""minfunction""] = ROOT::R::TRFunctionExport(minfunction);; 59 r[""mingradfunction""] = ROOT::R::TRFunctionExport(mingradfunction);; 60 r[""method""] = fMethod.c_str();; 61 std::vector<double> stepSizes(StepSizes(), StepSizes()+NDim());; 62 std::vector<double> values(X(), X()+NDim());; 63 r[""ndim""] = NDim();; 64 int ndim = NDim();; 65 r[""stepsizes""] = stepSizes;; 66 r[""initialparams""] = values;; 67 ; 68 //check if optimx is available; 69 bool optimxloaded = FALSE;; 70 r[""optimxloaded""] = optimxloaded;; 71 r.Execute(""optimxloaded<-library(optimx,logical.return=TRUE)"");; 72 //int ibool = r.ParseEval(""optimxloaded"").ToScalar<Int_t>();; 73 int ibool = r.Eval(""optimxloaded"");; 74 if (ibool==1) optimxloaded=kTRUE;; 75 ; 76 //string for the command to be processed in R; 77 TString cmd;; 78 ; 79 //optimx is available and loaded; 80 if (optimxloaded==kTRUE) {; 81 if (!gGradFunction) { ; 82 // not using gradient function; 83 cmd = TString::Format(""result <- optimx( initialparams, minfunction,method='%s',control = list(ndeps=stepsizes,maxit=%d,trace=%d,abstol=%e),hessian=TRUE)"",fMethod.c_str(),MaxIterations(),PrintLevel(),Tolerance());; 84 }; 85 else { ; 86 // using user provided gradient ; 87 cmd = TString::Format(""result <- optimx( initialparams, minfunction,mingradfunction, method='%s', control = list(ndeps=stepsizes,maxit=%d,trace=%d,abstol=%e),hessian=TRUE)"",fMethod.c_str(),MaxIterations(),PrintLevel(),Tolerance());; 88 ; 89 }; 90 } ; 91 ; 92 //optimx is not available; 93 else { ; 94 if (!gGradFunction) { ; 95 // not using gradient function; 96 cmd = TString::Format(""result <- optim( initialparams, minfunction,method='%s',control = list(ndeps=stepsizes,maxit=%d,trace=%d,abstol=%e),hessian=TRUE)"",fMethod.c_str(),MaxIterations(),PrintLevel(),Tolerance());; 97 }; 98 else { ; 99 // using user provided gradient ; 100 cmd = TString::Format(""result <- opti",MatchSource.WIKI,doc/master/RMinimizer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RMinimizer_8cxx_source.html
Testability,log,logical,"thod==""Migrad"") fMethod=""BFGS""; ; 41 }; 42 ; 43 ///returns number of function calls; 44 unsigned int RMinimizer::NCalls() const { return gNCalls; }; 45 ; 46 ///function for finding the minimum; 47 bool RMinimizer::Minimize() {; 48 ; 49 //Set the functions; 50 (gFunction)= ObjFunction();; 51 (gGradFunction) = GradObjFunction();; 52 ; 53 gNCalls = 0; ; 54 ; 55 //pass functions and variables to R; 56 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 57 ; 58 r[""minfunction""] = ROOT::R::TRFunctionExport(minfunction);; 59 r[""mingradfunction""] = ROOT::R::TRFunctionExport(mingradfunction);; 60 r[""method""] = fMethod.c_str();; 61 std::vector<double> stepSizes(StepSizes(), StepSizes()+NDim());; 62 std::vector<double> values(X(), X()+NDim());; 63 r[""ndim""] = NDim();; 64 int ndim = NDim();; 65 r[""stepsizes""] = stepSizes;; 66 r[""initialparams""] = values;; 67 ; 68 //check if optimx is available; 69 bool optimxloaded = FALSE;; 70 r[""optimxloaded""] = optimxloaded;; 71 r.Execute(""optimxloaded<-library(optimx,logical.return=TRUE)"");; 72 //int ibool = r.ParseEval(""optimxloaded"").ToScalar<Int_t>();; 73 int ibool = r.Eval(""optimxloaded"");; 74 if (ibool==1) optimxloaded=kTRUE;; 75 ; 76 //string for the command to be processed in R; 77 TString cmd;; 78 ; 79 //optimx is available and loaded; 80 if (optimxloaded==kTRUE) {; 81 if (!gGradFunction) { ; 82 // not using gradient function; 83 cmd = TString::Format(""result <- optimx( initialparams, minfunction,method='%s',control = list(ndeps=stepsizes,maxit=%d,trace=%d,abstol=%e),hessian=TRUE)"",fMethod.c_str(),MaxIterations(),PrintLevel(),Tolerance());; 84 }; 85 else { ; 86 // using user provided gradient ; 87 cmd = TString::Format(""result <- optimx( initialparams, minfunction,mingradfunction, method='%s', control = list(ndeps=stepsizes,maxit=%d,trace=%d,abstol=%e),hessian=TRUE)"",fMethod.c_str(),MaxIterations(),PrintLevel(),Tolerance());; 88 ; 89 }; 90 } ; 91 ; 92 //optimx is not available; 93 else { ; 94 if (!gGradFunction) { ; 95 // not",MatchSource.WIKI,doc/master/RMinimizer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RMinimizer_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/dataframe/inc/ROOT/RNTupleDS.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; RNTupleDS.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <ROOT/RDataFrame.hxx>; #include <ROOT/RDataSource.hxx>; #include <ROOT/RNTupleUtil.hxx>; #include <string_view>; #include <condition_variable>; #include <cstdint>; #include <memory>; #include <mutex>; #include <string>; #include <thread>; #include <vector>; #include <unordered_map>. Include dependency graph for RNTupleDS.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Experimental::RNTupleDS::REntryRangeDS;  The PrepareNextRanges() method populates the fNextRanges list with REntryRangeDS records. More...;  ; struct  ROOT::Experimental::RNTupleDS::RFieldInfo;  Holds useful information about fields added to the RNTupleDS. More...;  ; class  ROOT::Experimental::RNTupleDS;  The RDataSource implementation for RNTuple. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  ; namespace  ROOT::Experimental::Internal;  ; namespace  ROOT::RDF;  ; namespace  ROOT::RDF::Experimental;  . Functions; RDataFrame ROOT::RDF::Experimental::FromRNTuple (ROOT::RNTuple *ntuple);  ; RDataFrame ROOT::RDF::Experimental::FromRNTuple (std::string_view ntupleName, const std::vector< std::string > &fileNames);  ; RDataFrame ROOT::RDF::Experimental::FromRNTuple (std::string_view ntupleName, std::string_view fileName);  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h . Enrico Guiraud enric.nosp@m.o.gu.nosp@m.iraud.",MatchSource.WIKI,doc/master/RNTupleDS_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleDS_8hxx.html
Availability,failure,failure,"RException(R__FAIL(""cannot open source file "" + std::string(sourceFileName)));; 88 }; 89 ; 90 importer->fSourceTree = importer->fSourceFile->Get<TTree>(std::string(treeName).c_str());; 91 if (!importer->fSourceTree) {; 92 throw RException(R__FAIL(""cannot read TTree "" + std::string(treeName) + "" from "" + std::string(sourceFileName)));; 93 }; 94 ; 95 // If we have IMT enabled, its best use is for parallel page compression; 96 importer->fSourceTree->SetImplicitMT(false);; 97 auto result = importer->InitDestination(destFileName);; 98 ; 99 if (!result); 100 throw RException(R__FORWARD_ERROR(result));; 101 ; 102 return importer;; 103}; 104 ; 105std::unique_ptr<ROOT::Experimental::RNTupleImporter>; 106ROOT::Experimental::RNTupleImporter::Create(TTree *sourceTree, std::string_view destFileName); 107{; 108 auto importer = std::unique_ptr<RNTupleImporter>(new RNTupleImporter());; 109 ; 110 if (sourceTree->IsA() == TChain::Class() && std::strcmp(sourceTree->GetName(), """") == 0) {; 111 if (sourceTree->LoadTree(0) != 0); 112 throw RException(R__FAIL(""failure retrieving first tree from provided chain""));; 113 importer->fNTupleName = sourceTree->GetTree()->GetName();; 114 } else {; 115 importer->fNTupleName = sourceTree->GetName();; 116 }; 117 ; 118 importer->fSourceTree = sourceTree;; 119 ; 120 // If we have IMT enabled, its best use is for parallel page compression; 121 importer->fSourceTree->SetImplicitMT(false);; 122 auto result = importer->InitDestination(destFileName);; 123 ; 124 if (!result); 125 throw RException(R__FORWARD_ERROR(result));; 126 ; 127 return importer;; 128}; 129 ; 130ROOT::Experimental::RResult<void> ROOT::Experimental::RNTupleImporter::InitDestination(std::string_view destFileName); 131{; 132 fDestFileName = destFileName;; 133 fDestFile = std::unique_ptr<TFile>(TFile::Open(fDestFileName.c_str(), ""UPDATE""));; 134 if (!fDestFile || fDestFile->IsZombie()) {; 135 return R__FAIL(""cannot open dest file "" + std::string(fDestFileName));; 136 }; 137 ; 138 return RRes",MatchSource.WIKI,doc/master/RNTupleImporter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html
Deployability,update,update," 17#include <ROOT/RField.hxx>; 18#include <ROOT/RNTupleImporter.hxx>; 19#include <ROOT/RNTupleUtil.hxx>; 20#include <ROOT/RNTupleWriteOptions.hxx>; 21#include <ROOT/RNTupleWriter.hxx>; 22#include <ROOT/RPageSinkBuf.hxx>; 23#include <ROOT/RPageStorage.hxx>; 24#include <ROOT/RPageStorageFile.hxx>; 25#include <string_view>; 26 ; 27#include <TBranch.h>; 28#include <TChain.h>; 29#include <TClass.h>; 30#include <TDataType.h>; 31#include <TLeaf.h>; 32#include <TLeafC.h>; 33#include <TLeafElement.h>; 34#include <TLeafObject.h>; 35 ; 36#include <cassert>; 37#include <cstdint>; 38#include <cstring>; 39#include <iostream>; 40#include <utility>; 41 ; 42namespace {; 43 ; 44class RDefaultProgressCallback : public ROOT::Experimental::RNTupleImporter::RProgressCallback {; 45private:; 46 static constexpr std::uint64_t gUpdateFrequencyBytes = 100 * 1000 * 1000; // report every 100 MB; 47 std::uint64_t fNbytesNext = gUpdateFrequencyBytes;; 48 ; 49public:; 50 ~RDefaultProgressCallback() override {}; 51 void Call(std::uint64_t nbytesWritten, std::uint64_t neventsWritten) final; 52 {; 53 // Report if more than 100 MB (compressed) where written since the last status update; 54 if (nbytesWritten < fNbytesNext); 55 return;; 56 std::cout << ""Wrote "" << nbytesWritten / 1000 / 1000 << ""MB, "" << neventsWritten << "" entries\n"";; 57 fNbytesNext += gUpdateFrequencyBytes;; 58 if (nbytesWritten > fNbytesNext) {; 59 // If we already passed the next threshold, increase by a sensible amount.; 60 fNbytesNext = nbytesWritten + gUpdateFrequencyBytes;; 61 }; 62 }; 63 ; 64 void Finish(std::uint64_t nbytesWritten, std::uint64_t neventsWritten) final; 65 {; 66 std::cout << ""Done, wrote "" << nbytesWritten / 1000 / 1000 << ""MB, "" << neventsWritten << "" entries\n"";; 67 }; 68};; 69 ; 70} // anonymous namespace; 71 ; 72ROOT::Experimental::RResult<void>; 73ROOT::Experimental::RNTupleImporter::RCStringTransformation::Transform(const RImportBranch &branch, RImportField &field); 74{; 75 *reinterpret_cast<std::string *>",MatchSource.WIKI,doc/master/RNTupleImporter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html
Integrability,wrap,wraps,"d::vector< RImportField > fImportFieldsDefinition RNTupleImporter.hxx:227; ROOT::Experimental::RNTupleImporter::fFieldModifierFieldModifier_t fFieldModifierDefinition RNTupleImporter.hxx:222; ROOT::Experimental::RNTupleImporter::ReportSchemavoid ReportSchema()Definition RNTupleImporter.cxx:141; ROOT::Experimental::RNTupleImporter::fModelstd::unique_ptr< RNTupleModel > fModelDefinition RNTupleImporter.hxx:224; ROOT::Experimental::RNTupleImporter::fImportTransformationsstd::vector< std::unique_ptr< RImportTransformation > > fImportTransformationsThe list of transformations to be performed for every entry.Definition RNTupleImporter.hxx:231; ROOT::Experimental::RNTupleModel::CreateBarestatic std::unique_ptr< RNTupleModel > CreateBare()A bare model has no default entry.Definition RNTupleModel.cxx:236; ROOT::Experimental::RNTupleWriteOptions::GetUseBufferedWritebool GetUseBufferedWrite() constDefinition RNTupleWriteOptions.hxx:127; ROOT::Experimental::RResultThe class is used as a return type for operations that can fail; wraps a value of type T or an RError...Definition RError.hxx:194; ROOT::Experimental::RVectorField::CreateUntypedstatic std::unique_ptr< RVectorField > CreateUntyped(std::string_view fieldName, std::unique_ptr< RFieldBase > itemField)Definition RField.cxx:2650; TChain::Classstatic TClass * Class(); TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TLeafC::Classstatic TClass * Class(); TLeafElement::Classstatic TClass * Class(); TLeafObject::Classstatic TClass * Class(); TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLine:",MatchSource.WIKI,doc/master/RNTupleImporter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html
Modifiability,variab,variable,");; 291 if (isClass) {; 292 auto klass = TClass::GetClass(b->GetClassName());; 293 if (!klass) {; 294 return R__FAIL(""unable to load class "" + std::string(b->GetClassName()) + "" for branch "" +; 295 std::string(b->GetName()));; 296 }; 297 auto ptrBuf = reinterpret_cast<void **>(ib.fBranchBuffer.get());; 298 fSourceTree->SetBranchAddress(b->GetName(), ptrBuf, klass, EDataType::kOther_t, true /* isptr*/);; 299 } else {; 300 fSourceTree->SetBranchAddress(b->GetName(), reinterpret_cast<void *>(ib.fBranchBuffer.get()));; 301 }; 302 ; 303 // If the TTree branch type and the RNTuple field type match, use the branch read buffer as RNTuple write buffer; 304 if (!isLeafCountArray && !fImportFields.back().fFieldBuffer) {; 305 fImportFields.back().fFieldBuffer =; 306 isClass ? *reinterpret_cast<void **>(ib.fBranchBuffer.get()) : ib.fBranchBuffer.get();; 307 }; 308 ; 309 fImportBranches.emplace_back(std::move(ib));; 310 }; 311 ; 312 int iLeafCountCollection = 0;; 313 for (auto &p : fLeafCountCollections) {; 314 // We want to capture this variable, which is not possible with a; 315 // structured binding in C++17. Explicitly defining a variable works.; 316 auto countLeafName = p.first;; 317 auto &c = p.second;; 318 ; 319 c.fFieldName = ""_collection"" + std::to_string(iLeafCountCollection);; 320 auto recordField = std::make_unique<RRecordField>(""_0"", std::move(c.fLeafFields));; 321 c.fRecordField = recordField.get();; 322 auto collectionField = RVectorField::CreateUntyped(c.fFieldName, std::move(recordField));; 323 fModel->AddField(std::move(collectionField));; 324 ; 325 // Add projected fields for all leaf count arrays; 326 for (const auto leaf : c.fRecordField->GetSubFields()) {; 327 const auto name = leaf->GetFieldName();; 328 auto projectedField = RFieldBase::Create(name, ""ROOT::VecOps::RVec<"" + leaf->GetTypeName() + "">"").Unwrap();; 329 fModel->AddProjectedField(std::move(projectedField), [&name, &c](const std::string &fieldName) {; 330 if (fieldName == name); 331 return c.fFieldN",MatchSource.WIKI,doc/master/RNTupleImporter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html
Performance,load,load,");; 269 } else if (isLeafCountArray) {; 270 const std::string countleafName = countleaf->GetName();; 271 fLeafCountCollections[countleafName].fLeafFields.emplace_back(std::move(field));; 272 fLeafCountCollections[countleafName].fLeafBranchIndexes.emplace_back(fImportBranches.size());; 273 R__ASSERT(b->GetListOfLeaves()->GetEntries() == 1);; 274 break;; 275 } else {; 276 fModel->AddField(std::move(field));; 277 fImportFields.emplace_back(std::move(f));; 278 }; 279 }; 280 if (!recordItems.empty()) {; 281 auto recordField = std::make_unique<RRecordField>(b->GetName(), std::move(recordItems));; 282 RImportField f;; 283 f.fField = recordField.get();; 284 fImportFields.emplace_back(std::move(f));; 285 fModel->AddField(std::move(recordField));; 286 }; 287 ; 288 RImportBranch ib;; 289 ib.fBranchName = b->GetName();; 290 ib.fBranchBuffer = std::make_unique<unsigned char[]>(branchBufferSize);; 291 if (isClass) {; 292 auto klass = TClass::GetClass(b->GetClassName());; 293 if (!klass) {; 294 return R__FAIL(""unable to load class "" + std::string(b->GetClassName()) + "" for branch "" +; 295 std::string(b->GetName()));; 296 }; 297 auto ptrBuf = reinterpret_cast<void **>(ib.fBranchBuffer.get());; 298 fSourceTree->SetBranchAddress(b->GetName(), ptrBuf, klass, EDataType::kOther_t, true /* isptr*/);; 299 } else {; 300 fSourceTree->SetBranchAddress(b->GetName(), reinterpret_cast<void *>(ib.fBranchBuffer.get()));; 301 }; 302 ; 303 // If the TTree branch type and the RNTuple field type match, use the branch read buffer as RNTuple write buffer; 304 if (!isLeafCountArray && !fImportFields.back().fFieldBuffer) {; 305 fImportFields.back().fFieldBuffer =; 306 isClass ? *reinterpret_cast<void **>(ib.fBranchBuffer.get()) : ib.fBranchBuffer.get();; 307 }; 308 ; 309 fImportBranches.emplace_back(std::move(ib));; 310 }; 311 ; 312 int iLeafCountCollection = 0;; 313 for (auto &p : fLeafCountCollections) {; 314 // We want to capture this variable, which is not possible with a; 315 // structured binding in",MatchSource.WIKI,doc/master/RNTupleImporter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html
Testability,assert,assert,"ons.clear();; 156 fImportTransformations.clear();; 157 fModel = RNTupleModel::CreateBare();; 158 fEntry = nullptr;; 159}; 160 ; 161ROOT::Experimental::RResult<void> ROOT::Experimental::RNTupleImporter::PrepareSchema(); 162{; 163 ResetSchema();; 164 ; 165 // Browse through all branches and their leaves, create corresponding fields and prepare the memory buffers for; 166 // reading and writing. Usually, reading and writing share the same memory buffer, i.e. the object is read from TTree; 167 // and written as-is to the RNTuple. There are exceptions, e.g. for leaf count arrays and C strings.; 168 for (auto b : TRangeDynCast<TBranch>(*fSourceTree->GetListOfBranches())) {; 169 assert(b);; 170 const auto firstLeaf = static_cast<TLeaf *>(b->GetListOfLeaves()->First());; 171 assert(firstLeaf);; 172 ; 173 const bool isLeafList = b->GetNleaves() > 1;; 174 const bool isCountLeaf = firstLeaf->IsRange(); // A leaf storing the number of elements of a leaf count array; 175 const bool isClass = (firstLeaf->IsA() == TLeafElement::Class()); // STL or user-defined class; 176 if (isLeafList && isClass); 177 return R__FAIL(""unsupported: classes in leaf list, branch "" + std::string(b->GetName()));; 178 if (isLeafList && isCountLeaf); 179 return R__FAIL(""unsupported: count leaf arrays in leaf list, branch "" + std::string(b->GetName()));; 180 ; 181 // Only plain leafs with type identifies 'C' are C strings. Otherwise, they are char arrays.; 182 // We use GetLeafCounter instead of GetLeafCount and GetLenStatic because the latter don't distinguish between; 183 // char arrays and C strings.; 184 Int_t firstLeafCountval;; 185 const bool isCString = !isLeafList && (firstLeaf->IsA() == TLeafC::Class()) &&; 186 (!firstLeaf->GetLeafCounter(firstLeafCountval)) && (firstLeafCountval == 1);; 187 ; 188 if (isCountLeaf) {; 189 // This is a count leaf. We expect that this is not part of a leaf list. We also expect that the; 190 // leaf count comes before any array leaves that use it.; 191 // Count leaf b",MatchSource.WIKI,doc/master/RNTupleImporter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html
Usability,clear,clear," 128}; 129 ; 130ROOT::Experimental::RResult<void> ROOT::Experimental::RNTupleImporter::InitDestination(std::string_view destFileName); 131{; 132 fDestFileName = destFileName;; 133 fDestFile = std::unique_ptr<TFile>(TFile::Open(fDestFileName.c_str(), ""UPDATE""));; 134 if (!fDestFile || fDestFile->IsZombie()) {; 135 return R__FAIL(""cannot open dest file "" + std::string(fDestFileName));; 136 }; 137 ; 138 return RResult<void>::Success();; 139}; 140 ; 141void ROOT::Experimental::RNTupleImporter::ReportSchema(); 142{; 143 for (const auto &f : fImportFields) {; 144 std::cout << ""Importing '"" << f.fField->GetFieldName() << ""' ["" << f.fField->GetTypeName() << ""]\n"";; 145 }; 146 for (const auto &f : Internal::GetProjectedFieldsOfModel(*fModel).GetFieldZero().GetSubFields()) {; 147 std::cout << ""Importing (projected) '"" << f->GetFieldName() << ""' ["" << f->GetTypeName() << ""]\n"";; 148 }; 149}; 150 ; 151void ROOT::Experimental::RNTupleImporter::ResetSchema(); 152{; 153 fImportBranches.clear();; 154 fImportFields.clear();; 155 fLeafCountCollections.clear();; 156 fImportTransformations.clear();; 157 fModel = RNTupleModel::CreateBare();; 158 fEntry = nullptr;; 159}; 160 ; 161ROOT::Experimental::RResult<void> ROOT::Experimental::RNTupleImporter::PrepareSchema(); 162{; 163 ResetSchema();; 164 ; 165 // Browse through all branches and their leaves, create corresponding fields and prepare the memory buffers for; 166 // reading and writing. Usually, reading and writing share the same memory buffer, i.e. the object is read from TTree; 167 // and written as-is to the RNTuple. There are exceptions, e.g. for leaf count arrays and C strings.; 168 for (auto b : TRangeDynCast<TBranch>(*fSourceTree->GetListOfBranches())) {; 169 assert(b);; 170 const auto firstLeaf = static_cast<TLeaf *>(b->GetListOfLeaves()->First());; 171 assert(firstLeaf);; 172 ; 173 const bool isLeafList = b->GetNleaves() > 1;; 174 const bool isCountLeaf = firstLeaf->IsRange(); // A leaf storing the number of elements of a lea",MatchSource.WIKI,doc/master/RNTupleImporter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces ; RNTupleImporter.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <ROOT/REntry.hxx>; #include <ROOT/RError.hxx>; #include <ROOT/RField.hxx>; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleWriteOptions.hxx>; #include <ROOT/RNTupleWriter.hxx>; #include <string_view>; #include <TFile.h>; #include <TTree.h>; #include <cstdlib>; #include <functional>; #include <map>; #include <memory>; #include <vector>. Include dependency graph for RNTupleImporter.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Experimental::RNTupleImporter::RCStringTransformation;  Transform a NULL terminated C string branch into an std::string field. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportBranch;  ; struct  ROOT::Experimental::RNTupleImporter::RImportField;  ; struct  ROOT::Experimental::RNTupleImporter::RImportGuard;  When the schema is set up and the import started, it needs to be reset before the next Import() call can start. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportLeafCountCollection;  Leaf count arrays require special treatment. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportTransformation;  Base class to perform data transformations from TTree branches to RNTuple fields if necessary. More...;  ; class  ROOT::Experimental::RNTupleImporter;  Converts a TTree into an RNTuple. More...;  ; class  ROOT::Experimental::RNTupleImporter::RProgressCallback;  Used to report every ~100 MB (compressed), and at the end about the status of the import. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::i",MatchSource.WIKI,doc/master/RNTupleImporter_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx.html
Performance,perform,perform,"<memory>; #include <vector>. Include dependency graph for RNTupleImporter.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Experimental::RNTupleImporter::RCStringTransformation;  Transform a NULL terminated C string branch into an std::string field. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportBranch;  ; struct  ROOT::Experimental::RNTupleImporter::RImportField;  ; struct  ROOT::Experimental::RNTupleImporter::RImportGuard;  When the schema is set up and the import started, it needs to be reset before the next Import() call can start. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportLeafCountCollection;  Leaf count arrays require special treatment. More...;  ; struct  ROOT::Experimental::RNTupleImporter::RImportTransformation;  Base class to perform data transformations from TTree branches to RNTuple fields if necessary. More...;  ; class  ROOT::Experimental::RNTupleImporter;  Converts a TTree into an RNTuple. More...;  ; class  ROOT::Experimental::RNTupleImporter::RProgressCallback;  Used to report every ~100 MB (compressed), and at the end about the status of the import. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h ; Date2022-11-22 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition in file RNTupleImporter.hxx. treentupleutilv7incROOTRNTupleImporter.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RNTupleImporter_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx.html
Availability,avail,available,"cords; 76 - Leaf count arrays are translated to anonymous collections with generic names (`_collection0`, `_collection1`, etc.).; 77 In order to keep field names and branch names aligned, RNTuple projects the members of these collections and; 78 its collection counter to the input branch names. For instance, the following input leafs:; 79~~~; 80Int_t njets; 81float jet_pt[njets]; 82float jet_eta[njets]; 83~~~; 84 will be converted to the following RNTuple schema:; 85~~~; 86 _collection0 (untyped collection); 87 |- float jet_pt; 88 |- float jet_eta; 89 std::size_t (RNTupleCardinality) njets (projected from _collection0 without subfields); 90 ROOT::RVec<float> jet_pt (projected from _collection0.jet_pt); 91 ROOT::RVec<float> jet_eta (projected from _collection0.jet_eta); 92~~~; 93 These projections are meta-data only operations and don't involve duplicating the data.; 94 ; 95Current limitations of the importer:; 96 - No support for trees containing TClonesArray collections; 97 - Due to RNTuple currently storing data fully split, ""don't split"" markers are ignored; 98 - Some types are not available in RNTuple. Please refer to the; 99 [RNTuple specification](https://github.com/root-project/root/blob/master/tree/ntuple/v7/doc/specifications.md) for; 100 an overview of all types currently supported.; 101*/; 102// clang-format on; 103class RNTupleImporter {; 104public:; 105 /// Used to make adjustments to the fields of the output model.; 106 using FieldModifier_t = std::function<void(RFieldBase &)>;; 107 ; 108 /// Used to report every ~100 MB (compressed), and at the end about the status of the import.; 109 class RProgressCallback {; 110 public:; 111 virtual ~RProgressCallback() = default;; 112 void operator()(std::uint64_t nbytesWritten, std::uint64_t neventsWritten); 113 {; 114 Call(nbytesWritten, neventsWritten);; 115 }; 116 virtual void Call(std::uint64_t nbytesWritten, std::uint64_t neventsWritten) = 0;; 117 virtual void Finish(std::uint64_t nbytesWritten, std::uint64_",MatchSource.WIKI,doc/master/RNTupleImporter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx_source.html
Deployability,update,update," std::unique_ptr<RNTupleModel> fModel;; 225 std::unique_ptr<REntry> fEntry;; 226 std::vector<RImportBranch> fImportBranches;; 227 std::vector<RImportField> fImportFields;; 228 /// Maps the count leaf to the information about the corresponding untyped collection; 229 std::map<std::string, RImportLeafCountCollection> fLeafCountCollections;; 230 /// The list of transformations to be performed for every entry; 231 std::vector<std::unique_ptr<RImportTransformation>> fImportTransformations;; 232 ; 233 ROOT::Experimental::RResult<void> InitDestination(std::string_view destFileName);; 234 ; 235 void ResetSchema();; 236 /// Sets up the connection from TTree branches to RNTuple fields, including initialization of the memory; 237 /// buffers used for reading and writing.; 238 RResult<void> PrepareSchema();; 239 void ReportSchema();; 240 ; 241public:; 242 RNTupleImporter(const RNTupleImporter &other) = delete;; 243 RNTupleImporter &operator=(const RNTupleImporter &other) = delete;; 244 RNTupleImporter(RNTupleImporter &&other) = delete;; 245 RNTupleImporter &operator=(RNTupleImporter &&other) = delete;; 246 ~RNTupleImporter() = default;; 247 ; 248 /// Opens the input file for reading and the output file for writing (update).; 249 static std::unique_ptr<RNTupleImporter>; 250 Create(std::string_view sourceFileName, std::string_view treeName, std::string_view destFileName);; 251 ; 252 /// Directly uses the provided tree and opens the output file for writing (update).; 253 static std::unique_ptr<RNTupleImporter> Create(TTree *sourceTree, std::string_view destFileName);; 254 ; 255 RNTupleWriteOptions GetWriteOptions() const { return fWriteOptions; }; 256 void SetWriteOptions(RNTupleWriteOptions options) { fWriteOptions = options; }; 257 void SetNTupleName(const std::string &name) { fNTupleName = name; }; 258 void SetMaxEntries(std::uint64_t maxEntries) { fMaxEntries = maxEntries; };; 259 ; 260 /// Whereas branch names may contain dots, RNTuple field names may not. By setting this opti",MatchSource.WIKI,doc/master/RNTupleImporter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx_source.html
Integrability,wrap,wraps,"ies(std::uint64_t maxEntries)Definition RNTupleImporter.hxx:258; ROOT::Experimental::RNTupleImporter::fFieldModifierFieldModifier_t fFieldModifierDefinition RNTupleImporter.hxx:222; ROOT::Experimental::RNTupleImporter::ReportSchemavoid ReportSchema()Definition RNTupleImporter.cxx:141; ROOT::Experimental::RNTupleImporter::fModelstd::unique_ptr< RNTupleModel > fModelDefinition RNTupleImporter.hxx:224; ROOT::Experimental::RNTupleImporter::~RNTupleImporter~RNTupleImporter()=default; ROOT::Experimental::RNTupleImporter::fImportTransformationsstd::vector< std::unique_ptr< RImportTransformation > > fImportTransformationsThe list of transformations to be performed for every entry.Definition RNTupleImporter.hxx:231; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RRecordFieldThe field for an untyped record.Definition RFieldRecord.hxx:41; ROOT::Experimental::RResultThe class is used as a return type for operations that can fail; wraps a value of type T or an RError...Definition RError.hxx:194; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; int; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Experimental::RNTupleImporter::RCStringTransformationTransform a NULL terminated C string branch into an std::string field.Definition RNTupleImporter.hxx:196; ROOT::Experimental::RNTupleImporter::RCStringTransformation::RCStringTransformationRCStringTransformation(std::size_t b, std::size_t f)Definition RNTupleImporter.hxx:197; ROOT::Experimental::RNTupleImporter::RCStringTransformation::~RCStringTransformation~RCStringTransformation() override=default; ROOT::Experimental::RNTupleImporter::RCStringTransformation::TransformRResult< void > Transform(const RImportBranch",MatchSource.WIKI,doc/master/RNTupleImporter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx_source.html
Performance,perform,perform," 0;; 117 virtual void Finish(std::uint64_t nbytesWritten, std::uint64_t neventsWritten) = 0;; 118 };; 119 ; 120private:; 121 struct RImportBranch {; 122 RImportBranch() = default;; 123 RImportBranch(const RImportBranch &other) = delete;; 124 RImportBranch(RImportBranch &&other) = default;; 125 RImportBranch &operator=(const RImportBranch &other) = delete;; 126 RImportBranch &operator=(RImportBranch &&other) = default;; 127 std::string fBranchName; ///< Top-level branch name from the input TTree; 128 std::unique_ptr<unsigned char[]> fBranchBuffer; ///< The destination of SetBranchAddress() for `fBranchName`; 129 };; 130 ; 131 struct RImportField {; 132 RImportField() = default;; 133 ~RImportField() = default;; 134 RImportField(const RImportField &other) = delete;; 135 RImportField(RImportField &&other) = default;; 136 RImportField &operator=(const RImportField &other) = delete;; 137 RImportField &operator=(RImportField &&other) = default;; 138 ; 139 /// The field is kept during schema preparation and transferred to the fModel before the writing starts; 140 RFieldBase *fField = nullptr;; 141 std::unique_ptr<RFieldBase::RValue> fValue; ///< Set if a value is generated, only for transformed fields; 142 void *fFieldBuffer = nullptr; ///< Usually points to the corresponding RImportBranch::fBranchBuffer but not always; 143 };; 144 ; 145 /// Base class to perform data transformations from TTree branches to RNTuple fields if necessary; 146 struct RImportTransformation {; 147 std::size_t fImportBranchIdx = 0;; 148 std::size_t fImportFieldIdx = 0;; 149 ; 150 RImportTransformation(std::size_t branchIdx, std::size_t fieldIdx); 151 : fImportBranchIdx(branchIdx), fImportFieldIdx(fieldIdx); 152 {; 153 }; 154 virtual ~RImportTransformation() = default;; 155 virtual RResult<void> Transform(const RImportBranch &branch, RImportField &field) = 0;; 156 };; 157 ; 158 /// When the schema is set up and the import started, it needs to be reset before the next Import() call; 159 /// can start.",MatchSource.WIKI,doc/master/RNTupleImporter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8hxx_source.html
Availability,error,error,") || fnHasArrayParent(*target)) {; 73 return R__FAIL(""unsupported field mapping across fixed-size arrays"");; 74 }; 75 ; 76 // We support projections only across records and collections. In the following, we check that the projected; 77 // field is on the same path of collection fields in the field tree than the source field.; 78 ; 79 // Finds the first non-record parent field of the input field; 80 auto fnBreakPoint = [](const RFieldBase *f) -> const RFieldBase * {; 81 auto parent = f->GetParent();; 82 while (parent) {; 83 if ((parent->GetStructure() != ENTupleStructure::kRecord) &&; 84 (parent->GetStructure() != ENTupleStructure::kLeaf)) {; 85 return parent;; 86 }; 87 parent = parent->GetParent();; 88 }; 89 // We reached the zero field; 90 return nullptr;; 91 };; 92 ; 93 // If source or target has a variant or reference as a parent, error out; 94 auto *sourceBreakPoint = fnBreakPoint(source);; 95 if (sourceBreakPoint && sourceBreakPoint->GetStructure() != ENTupleStructure::kCollection); 96 return R__FAIL(""unsupported field mapping (source structure)"");; 97 auto *targetBreakPoint = fnBreakPoint(target);; 98 if (targetBreakPoint && sourceBreakPoint->GetStructure() != ENTupleStructure::kCollection); 99 return R__FAIL(""unsupported field mapping (target structure)"");; 100 ; 101 if (!sourceBreakPoint && !targetBreakPoint) {; 102 // Source and target have no collections as parent; 103 return RResult<void>::Success();; 104 }; 105 if (sourceBreakPoint && targetBreakPoint) {; 106 if (sourceBreakPoint == targetBreakPoint) {; 107 // Source and target are children of the same collection; 108 return RResult<void>::Success();; 109 }; 110 if (auto it = fieldMap.find(targetBreakPoint); it != fieldMap.end() && it->second == sourceBreakPoint) {; 111 // The parent collection of parent is mapped to the parent collection of the source; 112 return RResult<void>::Success();; 113 }; 114 // Source and target are children of different collections; 115 return R__FAIL(""field mapping structure m",MatchSource.WIKI,doc/master/RNTupleModel_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8cxx_source.html
Deployability,release,release,"ROR(result);; 128 for (const auto &f : *field) {; 129 result = EnsureValidMapping(&f, fieldMap);; 130 if (!result); 131 return R__FORWARD_ERROR(result);; 132 }; 133 ; 134 fFieldMap.insert(fieldMap.begin(), fieldMap.end());; 135 fFieldZero->Attach(std::move(field));; 136 return RResult<void>::Success();; 137}; 138 ; 139const ROOT::Experimental::RFieldBase *; 140ROOT::Experimental::Internal::RProjectedFields::GetSourceField(const RFieldBase *target) const; 141{; 142 if (auto it = fFieldMap.find(target); it != fFieldMap.end()); 143 return it->second;; 144 return nullptr;; 145}; 146 ; 147std::unique_ptr<ROOT::Experimental::Internal::RProjectedFields>; 148ROOT::Experimental::Internal::RProjectedFields::Clone(const RNTupleModel &newModel) const; 149{; 150 auto cloneFieldZero = std::unique_ptr<RFieldZero>(static_cast<RFieldZero *>(fFieldZero->Clone("""").release()));; 151 auto clone = std::unique_ptr<RProjectedFields>(new RProjectedFields(std::move(cloneFieldZero)));; 152 clone->fModel = &newModel;; 153 // TODO(jblomer): improve quadratic search to re-wire the field mappings given the new model and the cloned; 154 // projected fields. Not too critical as we generally expect a limited number of projected fields; 155 for (const auto &[k, v] : fFieldMap) {; 156 for (const auto &f : clone->GetFieldZero()) {; 157 if (f.GetQualifiedFieldName() == k->GetQualifiedFieldName()) {; 158 clone->fFieldMap[&f] = &newModel.GetConstField(v->GetQualifiedFieldName());; 159 break;; 160 }; 161 }; 162 }; 163 return clone;; 164}; 165 ; 166ROOT::Experimental::RNTupleModel::RUpdater::RUpdater(RNTupleWriter &writer); 167 : fWriter(writer), fOpenChangeset(fWriter.GetUpdatableModel()); 168{; 169}; 170 ; 171void ROOT::Experimental::RNTupleModel::RUpdater::BeginUpdate(); 172{; 173 fOpenChangeset.fModel.Unfreeze();; 174 // We set the model ID to zero until CommitUpdate(). That prevents calls to RNTupleWriter::Fill() in the middle; 175 // of updates; 176 std::swap(fOpenChangeset.fModel.fModelId, fNewModelId",MatchSource.WIKI,doc/master/RNTupleModel_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8cxx_source.html
Integrability,wrap,wraps,"rSize() constDefinition RNTupleWriteOptions.hxx:112; ROOT::Experimental::RNTupleWriteOptions::GetInitialNElementsPerPagestd::size_t GetInitialNElementsPerPage() constDefinition RNTupleWriteOptions.hxx:118; ROOT::Experimental::RNTupleWriteOptions::GetUseBufferedWritebool GetUseBufferedWrite() constDefinition RNTupleWriteOptions.hxx:127; ROOT::Experimental::RNTupleWriteOptions::GetMaxUnzippedPageSizestd::size_t GetMaxUnzippedPageSize() constDefinition RNTupleWriteOptions.hxx:121; ROOT::Experimental::RNTupleWriteOptions::GetUseImplicitMTEImplicitMT GetUseImplicitMT() constDefinition RNTupleWriteOptions.hxx:136; ROOT::Experimental::RNTupleWriteOptions::EImplicitMT::kDefault@ kDefault; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RResultBase::Throwvoid Throw()Throws an RException with fError.Definition RError.cxx:67; ROOT::Experimental::RResultThe class is used as a return type for operations that can fail; wraps a value of type T or an RError...Definition RError.hxx:194; ROOT::Experimental::Internal::GetProjectedFieldsOfModelRProjectedFields & GetProjectedFieldsOfModel(RNTupleModel &model)Definition RNTupleModel.cxx:42; ROOT::Experimental::Internal::GetFieldZeroOfModelRFieldZero & GetFieldZeroOfModel(RNTupleModel &model)Definition RNTupleModel.cxx:36; ROOT::Experimental::kLeaf@ kLeafDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kRecord@ kRecordDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kCollection@ kCollectionDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kStreamer@ kStreamerDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kVariant@ kVariantDefinition RNTupleUtil.hxx:112; ROOT::Splitstd::vector< std::string > Split(std::string_view str, std::string_view delims, bool skipEmpty=false)Splits a string at each character in delims.Definition StringUtils.cxx:23; writerDefinition writer.py:1; v@ vDefinition rootcling_impl.cxx:3699; ROOT::Expe",MatchSource.WIKI,doc/master/RNTupleModel_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8cxx_source.html
Security,access,access,"ConstField(std::string_view fieldName) constDefinition RNTupleModel.cxx:417; ROOT::Experimental::RNTupleModel::fSchemaIdstd::uint64_t fSchemaIdModels have a separate schema ID to remember that the clone of a frozen model still has the same sche...Definition RNTupleModel.hxx:213; ROOT::Experimental::RNTupleModel::GetTokenREntry::RFieldToken GetToken(std::string_view fieldName) constCreates a token to be used in REntry methods to address a field present in the entry.Definition RNTupleModel.cxx:470; ROOT::Experimental::RNTupleModel::EnsureNotBarevoid EnsureNotBare() constThrows an RException if fDefaultEntry is nullptr.Definition RNTupleModel.cxx:226; ROOT::Experimental::RNTupleModel::Clonestd::unique_ptr< RNTupleModel > Clone() constDefinition RNTupleModel.cxx:262; ROOT::Experimental::RNTupleModel::EnsureNotFrozenvoid EnsureNotFrozen() constThrows an RException if fFrozen is true.Definition RNTupleModel.cxx:220; ROOT::Experimental::RNTupleModel::GetMutableFieldZeroRFieldZero & GetMutableFieldZero()Mutable access to the root field is used to make adjustments to the fields.Definition RNTupleModel.cxx:399; ROOT::Experimental::RNTupleModel::GetDefaultEntryREntry & GetDefaultEntry()Definition RNTupleModel.cxx:426; ROOT::Experimental::RNTupleModel::EstimateWriteMemoryUsagestd::size_t EstimateWriteMemoryUsage(const RNTupleWriteOptions &options=RNTupleWriteOptions()) constEstimate the memory usage for this model during writing.Definition RNTupleModel.cxx:518; ROOT::Experimental::RNTupleModel::CreateBareEntrystd::unique_ptr< REntry > CreateBareEntry() constIn a bare entry, all values point to nullptr.Definition RNTupleModel.cxx:455; ROOT::Experimental::RNTupleModel::CreateEntrystd::unique_ptr< REntry > CreateEntry() constDefinition RNTupleModel.cxx:440; ROOT::Experimental::RNTupleModel::CreateBulkRFieldBase::RBulk CreateBulk(std::string_view fieldName) constCalls the given field's CreateBulk() method. Throws an exception if no field with the given name exis...Definition RNTuple",MatchSource.WIKI,doc/master/RNTupleModel_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8cxx_source.html
Usability,simpl,simple,tMutableField(std::string_view fieldName)Definition RNTupleModel.cxx:406; ROOT::Experimental::RNTupleModel::Freezevoid Freeze()Definition RNTupleModel.cxx:507; ROOT::Experimental::RNTupleModel::CreateBarestatic std::unique_ptr< RNTupleModel > CreateBare()A bare model has no default entry.Definition RNTupleModel.cxx:236; ROOT::Experimental::RNTupleModel::IsFrozenbool IsFrozen() constDefinition RNTupleModel.hxx:363; ROOT::Experimental::RNTupleModel::AddFieldvoid AddField(std::unique_ptr< RFieldBase > field)Adds a field whose type is not known at compile time.Definition RNTupleModel.cxx:312; ROOT::Experimental::RNTupleModel::RegisterSubfieldvoid RegisterSubfield(std::string_view qualifiedFieldName)Register a subfield so it can be accessed directly from entries belonging to the model.Definition RNTupleModel.cxx:335; ROOT::Experimental::RNTupleModel::Unfreezevoid Unfreeze()Definition RNTupleModel.cxx:493; ROOT::Experimental::RNTupleModel::fFieldZerostd::unique_ptr< RFieldZero > fFieldZeroHierarchy of fields consisting of simple types and collections (sub trees)Definition RNTupleModel.hxx:198; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriteOptions::GetCompressionint GetCompression() constDefinition RNTupleWriteOptions.hxx:105; ROOT::Experimental::RNTupleWriteOptions::GetPageBufferBudgetstd::size_t GetPageBufferBudget() constDefinition RNTupleWriteOptions.cxx:77; ROOT::Experimental::RNTupleWriteOptions::GetApproxZippedClusterSizestd::size_t GetApproxZippedClusterSize() constDefinition RNTupleWriteOptions.hxx:112; ROOT::Experimental::RNTupleWriteOptions::GetInitialNElementsPerPagestd::size_t GetInitialNElementsPerPage() constDefinition RNTupleWriteOptions.hxx:118; ROOT::Experimental::RNTupleWriteOptions::GetUseBufferedWritebool GetUseBufferedWrite() constDefinition RNTupleWriteOptions.hxx:127; ROOT::Experimental::RNTupleWriteOptions::GetMaxUnzippedPageSizestd::size,MatchSource.WIKI,doc/master/RNTupleModel_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; RNTupleModel.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <ROOT/REntry.hxx>; #include <ROOT/RError.hxx>; #include <ROOT/RField.hxx>; #include <ROOT/RNTupleUtil.hxx>; #include <string_view>; #include <cstdint>; #include <functional>; #include <memory>; #include <string>; #include <unordered_map>; #include <unordered_set>; #include <utility>. Include dependency graph for RNTupleModel.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Experimental::RNTupleModel::NameWithDescription_t;  A wrapper over a field name and an optional description; used in AddField() and RUpdater::AddField() More...;  ; class  ROOT::Experimental::RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleModelChangeset;  The incremental changes to a RNTupleModel More...;  ; class  ROOT::Experimental::Internal::RProjectedFields;  The projected fields of a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleModel::RUpdater;  A model is usually immutable after passing it to an RNTupleWriter. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  ; namespace  ROOT::Experimental::Internal;  . Functions; RFieldZero & ROOT::Experimental::Internal::GetFieldZeroOfModel (RNTupleModel &model);  ; RProjectedFields & ROOT::Experimental::Internal::GetProjectedFieldsOfModel (RNTupleModel &model);  . Detailed Description; AuthorJakob Blomer jb",MatchSource.WIKI,doc/master/RNTupleModel_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx.html
Availability,error,error,ription() const { return fDescription; }; 387 void SetDescription(std::string_view description);; 388 ; 389 /// Get the (qualified) names of subfields that have been registered to be included in entries from this model.; 390 const std::unordered_set<std::string> &GetRegisteredSubfields() const { return fRegisteredSubfields; }; 391 ; 392 /// Estimate the memory usage for this model during writing; 393 ///; 394 /// This will return an estimate in bytes for the internal page and compression buffers. The value should be; 395 /// understood per sequential RNTupleWriter or per RNTupleFillContext created for a RNTupleParallelWriter; 396 /// constructed with this model.; 397 std::size_t EstimateWriteMemoryUsage(const RNTupleWriteOptions &options = RNTupleWriteOptions()) const;; 398};; 399 ; 400} // namespace Experimental; 401} // namespace ROOT; 402 ; 403#endif; REntry.hxx; RError.hxx; RField.hxx; RNTupleUtil.hxx; f#define f(i)Definition RSha256.hxx:104; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; targetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; namechar name[80]Definition TGX11.cxx:110; ROOT::Experimental::Internal::RProjectedFieldsThe projected fiel,MatchSource.WIKI,doc/master/RNTupleModel_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html
Deployability,update,updates,"RProjectedFields &&) = default;; 84 ~RProjectedFields() = default;; 85 ; 86 /// The new model needs to be a clone of fModel; 87 std::unique_ptr<RProjectedFields> Clone(const RNTupleModel &newModel) const;; 88 ; 89 RFieldZero &GetFieldZero() { return *fFieldZero; }; 90 const RFieldBase *GetSourceField(const RFieldBase *target) const;; 91 /// Adds a new projected field. The field map needs to provide valid source fields of fModel for 'field'; 92 /// and each of its sub fields.; 93 RResult<void> Add(std::unique_ptr<RFieldBase> field, const FieldMap_t &fieldMap);; 94 bool IsEmpty() const { return fFieldZero->begin() == fFieldZero->end(); }; 95};; 96 ; 97// clang-format off; 98/**; 99\class ROOT::Experimental::Internal::RNTupleModelChangeset; 100\ingroup NTuple; 101\brief The incremental changes to a `RNTupleModel`; 102 ; 103Represents a set of alterations to a `RNTupleModel` that happened after the model is used to initialize a `RPageSink`; 104instance. This object can be used to communicate metadata updates to a `RPageSink`.; 105You will not normally use this directly; see `RNTupleModel::RUpdater` instead.; 106*/; 107// clang-format on; 108struct RNTupleModelChangeset {; 109 RNTupleModel &fModel;; 110 /// Points to the fields in fModel that were added as part of an updater transaction; 111 std::vector<RFieldBase *> fAddedFields;; 112 /// Points to the projected fields in fModel that were added as part of an updater transaction; 113 std::vector<RFieldBase *> fAddedProjectedFields;; 114 ; 115 RNTupleModelChangeset(RNTupleModel &model) : fModel(model) {}; 116 bool IsEmpty() const { return fAddedFields.empty() && fAddedProjectedFields.empty(); }; 117};; 118 ; 119} // namespace Internal; 120 ; 121// clang-format off; 122/**; 123\class ROOT::Experimental::RNTupleModel; 124\ingroup NTuple; 125\brief The RNTupleModel encapulates the schema of an ntuple.; 126 ; 127The ntuple model comprises a collection of hierarchically organized fields. From a model, ""entries""; 128can be extr",MatchSource.WIKI,doc/master/RNTupleModel_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html
Integrability,wrap,wrapper,"nalized, the model gets frozen. Only frozen models can create entries.; 134*/; 135// clang-format on; 136class RNTupleModel {; 137 friend RFieldZero &Internal::GetFieldZeroOfModel(RNTupleModel &);; 138 friend Internal::RProjectedFields &Internal::GetProjectedFieldsOfModel(RNTupleModel &);; 139 ; 140public:; 141 /// User provided function that describes the mapping of existing source fields to projected fields in terms; 142 /// of fully qualified field names. The mapping function is called with the qualified field names of the provided; 143 /// field and the subfields. It should return the qualified field names used as a mapping source.; 144 using FieldMappingFunc_t = std::function<std::string(const std::string &)>;; 145 ; 146 /// A wrapper over a field name and an optional description; used in `AddField()` and `RUpdater::AddField()`; 147 struct NameWithDescription_t {; 148 NameWithDescription_t(const char *name) : fName(name) {}; 149 NameWithDescription_t(const std::string &name) : fName(name) {}; 150 NameWithDescription_t(std::string_view name) : fName(name) {}; 151 NameWithDescription_t(std::string_view name, std::string_view descr) : fName(name), fDescription(descr) {}; 152 ; 153 std::string_view fName;; 154 std::string_view fDescription = """";; 155 };; 156 ; 157 /// A model is usually immutable after passing it to an `RNTupleWriter`. However, for the rare; 158 /// cases that require changing the model after the fact, `RUpdater` provides limited support for; 159 /// incremental updates, e.g. addition of new fields.; 160 ///; 161 /// See `RNTupleWriter::CreateModelUpdater()` for an example.; 162 class RUpdater {; 163 private:; 164 RNTupleWriter &fWriter;; 165 Internal::RNTupleModelChangeset fOpenChangeset;; 166 std::uint64_t fNewModelId = 0; ///< The model ID after committing; 167 ; 168 public:; 169 explicit RUpdater(RNTupleWriter &writer);; 170 ~RUpdater() { CommitUpdate(); }; 171 /// Begin a new set of alterations to the underlying model. As a side effect, all `RE",MatchSource.WIKI,doc/master/RNTupleModel_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html
Security,access,accessed,"del::Create();; 290 /// auto hadronFlavour = model->MakeField<float>({; 291 /// ""hadronFlavour"", ""flavour from hadron ghost clustering""; 292 /// });; 293 /// ~~~; 294 template <typename T, typename... ArgsT>; 295 std::shared_ptr<T> MakeField(const NameWithDescription_t &fieldNameDesc, ArgsT &&...args); 296 {; 297 EnsureNotFrozen();; 298 EnsureValidFieldName(fieldNameDesc.fName);; 299 auto field = std::make_unique<RField<T>>(fieldNameDesc.fName);; 300 field->SetDescription(fieldNameDesc.fDescription);; 301 std::shared_ptr<T> ptr;; 302 if (fDefaultEntry); 303 ptr = fDefaultEntry->AddValue<T>(*field, std::forward<ArgsT>(args)...);; 304 fFieldNames.insert(field->GetFieldName());; 305 fFieldZero->Attach(std::move(field));; 306 return ptr;; 307 }; 308 ; 309 /// Adds a field whose type is not known at compile time. Thus there is no shared pointer returned.; 310 ///; 311 /// Throws an exception if the field is null.; 312 void AddField(std::unique_ptr<RFieldBase> field);; 313 ; 314 /// Register a subfield so it can be accessed directly from entries belonging to the model. Because registering a; 315 /// subfield does not fundamentally change the model, previously created entries will not be invalidated, nor; 316 /// modified in any way; a registered subfield is merely an accessor added to the default entry (if present) and any; 317 /// entries created afterwards.; 318 ///; 319 /// Using models with registered subfields for writing is not allowed. Attempting to do so will result in an; 320 /// exception.; 321 ///; 322 /// Throws an exception if the provided subfield could not be found in the model.; 323 void RegisterSubfield(std::string_view qualifiedFieldName);; 324 ; 325 /// Adds a top-level field based on existing fields.; 326 ///; 327 /// The mapping function takes one argument, which is a string containing the name of the projected field. The return; 328 /// value of the mapping function should be the name of the (existing) field onto which the projection is made.; 329 //",MatchSource.WIKI,doc/master/RNTupleModel_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html
Usability,simpl,simple," an `REntry` that matching the new model.; 176 /// Upon completion, `BeginUpdate()` can be called again to begin a new set of changes.; 177 void CommitUpdate();; 178 ; 179 template <typename T, typename... ArgsT>; 180 std::shared_ptr<T> MakeField(const NameWithDescription_t &fieldNameDesc, ArgsT &&...args); 181 {; 182 auto objPtr = fOpenChangeset.fModel.MakeField<T>(fieldNameDesc, std::forward<ArgsT>(args)...);; 183 auto fieldZero = fOpenChangeset.fModel.fFieldZero.get();; 184 auto it = std::find_if(fieldZero->begin(), fieldZero->end(),; 185 [&](const auto &f) { return f.GetFieldName() == fieldNameDesc.fName; });; 186 R__ASSERT(it != fieldZero->end());; 187 fOpenChangeset.fAddedFields.emplace_back(&(*it));; 188 return objPtr;; 189 }; 190 ; 191 void AddField(std::unique_ptr<RFieldBase> field);; 192 ; 193 RResult<void> AddProjectedField(std::unique_ptr<RFieldBase> field, FieldMappingFunc_t mapping);; 194 };; 195 ; 196private:; 197 /// Hierarchy of fields consisting of simple types and collections (sub trees); 198 std::unique_ptr<RFieldZero> fFieldZero;; 199 /// Contains field values corresponding to the created top-level fields, as well as registered subfields; 200 std::unique_ptr<REntry> fDefaultEntry;; 201 /// Keeps track of which field names are taken, including projected field names.; 202 std::unordered_set<std::string> fFieldNames;; 203 /// Free text set by the user; 204 std::string fDescription;; 205 /// The set of projected top-level fields; 206 std::unique_ptr<Internal::RProjectedFields> fProjectedFields;; 207 /// Keeps track of which subfields have been registered to be included in entries belonging to this model.; 208 std::unordered_set<std::string> fRegisteredSubfields;; 209 /// Every model has a unique ID to distinguish it from other models. Entries are linked to models via the ID.; 210 /// Cloned models get a new model ID.; 211 std::uint64_t fModelId = 0;; 212 /// Models have a separate schema ID to remember that the clone of a frozen model still has the ",MatchSource.WIKI,doc/master/RNTupleModel_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html
Availability,error,error,"printing.; 174 RPrintSchemaVisitor printVisitor(output);; 175 ; 176 // Note that we do not need to connect the model, we are only looking at its tree of fields; 177 fullModel->GetConstFieldZero().AcceptVisitor(prepVisitor);; 178 ; 179 printVisitor.SetFrameSymbol(frameSymbol);; 180 printVisitor.SetWidth(width);; 181 printVisitor.SetDeepestLevel(prepVisitor.GetDeepestLevel());; 182 printVisitor.SetNumFields(prepVisitor.GetNumFields());; 183 ; 184 for (int i = 0; i < width; ++i); 185 output << frameSymbol;; 186 output << ""\n"";; 187 fullModel->GetConstFieldZero().AcceptVisitor(printVisitor);; 188 for (int i = 0; i < width; ++i); 189 output << frameSymbol;; 190 output << std::endl;; 191 break;; 192 }; 193 case ENTupleInfo::kStorageDetails: fSource->GetSharedDescriptorGuard()->PrintInfo(output); break;; 194 case ENTupleInfo::kMetrics: fMetrics.Print(output); break;; 195 default:; 196 // Unhandled case, internal error; 197 R__ASSERT(false);; 198 }; 199}; 200 ; 201ROOT::Experimental::RNTupleReader *ROOT::Experimental::RNTupleReader::GetDisplayReader(); 202{; 203 if (!fDisplayReader); 204 fDisplayReader = Clone();; 205 return fDisplayReader.get();; 206}; 207 ; 208void ROOT::Experimental::RNTupleReader::Show(NTupleSize_t index, std::ostream &output); 209{; 210 auto reader = GetDisplayReader();; 211 const auto &entry = reader->GetModel().GetDefaultEntry();; 212 ; 213 reader->LoadEntry(index);; 214 output << ""{"";; 215 for (auto iValue = entry.begin(); iValue != entry.end();) {; 216 output << std::endl;; 217 RPrintValueVisitor visitor(*iValue, output, 1 /* level */);; 218 iValue->GetField().AcceptVisitor(visitor);; 219 ; 220 if (++iValue == entry.end()) {; 221 output << std::endl;; 222 break;; 223 } else {; 224 output << "","";; 225 }; 226 }; 227 output << ""}"" << std::endl;; 228}; 229 ; 230const ROOT::Experimental::RNTupleDescriptor &ROOT::Experimental::RNTupleReader::GetDescriptor(); 231{; 232 auto descriptorGuard = fSource->GetSharedDescriptorGuard();; 233 if (!fCachedDescriptor",MatchSource.WIKI,doc/master/RNTupleReader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8cxx_source.html
Modifiability,variab,variables,"l, const ROOT::RNTuple &ntuple,; 110 const RNTupleReadOptions &options); 111{; 112 return std::unique_ptr<RNTupleReader>(; 113 new RNTupleReader(std::move(model), Internal::RPageSourceFile::CreateFromAnchor(ntuple, options), options));; 114}; 115 ; 116std::unique_ptr<ROOT::Experimental::RNTupleReader>; 117ROOT::Experimental::RNTupleReader::OpenFriends(std::span<RNTupleOpenSpec> ntuples, const RNTupleReadOptions &options); 118{; 119 std::vector<std::unique_ptr<Internal::RPageSource>> sources;; 120 sources.reserve(ntuples.size());; 121 for (const auto &n : ntuples) {; 122 sources.emplace_back(Internal::RPageSource::Create(n.fNTupleName, n.fStorage, n.fOptions));; 123 }; 124 return std::unique_ptr<RNTupleReader>(; 125 new RNTupleReader(std::make_unique<Internal::RPageSourceFriends>(""_friends"", sources), options));; 126}; 127 ; 128const ROOT::Experimental::RNTupleModel &ROOT::Experimental::RNTupleReader::GetModel(); 129{; 130 if (!fModel) {; 131 fModel = fSource->GetSharedDescriptorGuard()->CreateModel();; 132 ConnectModel(*fModel);; 133 }; 134 return *fModel;; 135}; 136 ; 137void ROOT::Experimental::RNTupleReader::PrintInfo(const ENTupleInfo what, std::ostream &output) const; 138{; 139 // TODO(lesimon): In a later version, these variables may be defined by the user or the ideal width may be read out; 140 // from the terminal.; 141 char frameSymbol = '*';; 142 int width = 80;; 143 /*; 144 if (width < 30) {; 145 output << ""The width is too small! Should be at least 30."" << std::endl;; 146 return;; 147 }; 148 */; 149 switch (what) {; 150 case ENTupleInfo::kSummary: {; 151 std::string name;; 152 std::unique_ptr<RNTupleModel> fullModel;; 153 {; 154 auto descriptorGuard = fSource->GetSharedDescriptorGuard();; 155 name = descriptorGuard->GetName();; 156 fullModel = descriptorGuard->CreateModel();; 157 }; 158 ; 159 for (int i = 0; i < (width / 2 + width % 2 - 4); ++i); 160 output << frameSymbol;; 161 output << "" NTUPLE "";; 162 for (int i = 0; i < (width / 2 - 4); ++i); 163 outp",MatchSource.WIKI,doc/master/RNTupleReader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8cxx_source.html
Performance,cache,cached,"ons::HasMetricsEnabledbool HasMetricsEnabled() constDefinition RNTupleReadOptions.hxx:61; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::Experimental::RNTupleReader::GetDisplayReaderRNTupleReader * GetDisplayReader()Definition RNTupleReader.cxx:201; ROOT::Experimental::RNTupleReader::RetrieveFieldIdDescriptorId_t RetrieveFieldId(std::string_view fieldName) constDefinition RNTupleReader.cxx:238; ROOT::Experimental::RNTupleReader::Showvoid Show(NTupleSize_t index, std::ostream &output=std::cout)Shows the values of the i-th entry/row, starting with 0 for the first entry.Definition RNTupleReader.cxx:208; ROOT::Experimental::RNTupleReader::RNTupleReaderRNTupleReader(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSource > source, const RNTupleReadOptions &options)Definition RNTupleReader.cxx:61; ROOT::Experimental::RNTupleReader::~RNTupleReader~RNTupleReader(); ROOT::Experimental::RNTupleReader::GetDescriptorconst RNTupleDescriptor & GetDescriptor()Returns a cached copy of the page source descriptor.Definition RNTupleReader.cxx:230; ROOT::Experimental::RNTupleReader::OpenFriendsstatic std::unique_ptr< RNTupleReader > OpenFriends(std::span< RNTupleOpenSpec > ntuples, const RNTupleReadOptions &options=RNTupleReadOptions())Open RNTuples as one virtual, horizontally combined ntuple.Definition RNTupleReader.cxx:117; ROOT::Experimental::RNTupleReader::fSourcestd::unique_ptr< Internal::RPageSource > fSourceDefinition RNTupleReader.hxx:77; ROOT::Experimental::RNTupleReader::GetModelconst RNTupleModel & GetModel()Definition RNTupleReader.cxx:128; ROOT::Experimental::RNTupleReader::Openstatic std::unique_ptr< RNTupleReader > Open(std::string_view ntupleName, std::string_view storage, const RNTupleReadOptions &options=RNTupleReadOptions())Open an RNTuple for reading.Definition RNTupleReader.cxx:94; ROOT::Experimental::RNTupleReader::InitPageSourcevoid InitPageSource(bool enableMetrics)",MatchSource.WIKI,doc/master/RNTupleReader_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Enumerations ; RNTupleReader.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <ROOT/RConfig.hxx>; #include <ROOT/RError.hxx>; #include <ROOT/RNTupleDescriptor.hxx>; #include <ROOT/RNTupleMetrics.hxx>; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReadOptions.hxx>; #include <ROOT/RNTupleUtil.hxx>; #include <ROOT/RNTupleView.hxx>; #include <ROOT/RPageStorage.hxx>; #include <ROOT/RSpan.hxx>; #include <iostream>; #include <iterator>; #include <memory>; #include <string>; #include <string_view>. Include dependency graph for RNTupleReader.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Experimental::RNTupleReader::RIterator;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  . Enumerations; enum class  ROOT::Experimental::ENTupleInfo { ROOT::Experimental::kSummary; , ROOT::Experimental::kStorageDetails; , ROOT::Experimental::kMetrics; };  Listing of the different options that can be printed by RNTupleReader::GetInfo() More...;  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h ; Date2024-02-20 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition in file RNTupleReader.hxx. treentuplev7incROOTRNTupleReader.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2",MatchSource.WIKI,doc/master/RNTupleReader_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx.html
Availability,error,errors," data to stderr**; 198 /// ~~~ {.cpp}; 199 /// #include <ROOT/RNTupleReader.hxx>; 200 /// using ROOT::Experimental::ENTupleInfo;; 201 /// using ROOT::Experimental::RNTupleReader;; 202 ///; 203 /// #include <iostream>; 204 ///; 205 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 206 /// ntuple->PrintInfo(ENTupleInfo::kStorageDetails, std::cerr);; 207 /// ~~~; 208 ///; 209 /// For use of ENTupleInfo::kMetrics, see #EnableMetrics.; 210 void PrintInfo(const ENTupleInfo what = ENTupleInfo::kSummary, std::ostream &output = std::cout) const;; 211 ; 212 /// Shows the values of the i-th entry/row, starting with 0 for the first entry. By default,; 213 /// prints the output in JSON format.; 214 /// Uses the visitor pattern to traverse through each field of the given entry.; 215 void Show(NTupleSize_t index, std::ostream &output = std::cout);; 216 ; 217 /// Analogous to Fill(), fills the default entry of the model. Returns false at the end of the ntuple.; 218 /// On I/O errors, raises an exception.; 219 void LoadEntry(NTupleSize_t index); 220 {; 221 // TODO(jblomer): can be templated depending on the factory method / constructor; 222 if (R__unlikely(!fModel)) {; 223 fModel = fSource->GetSharedDescriptorGuard()->CreateModel();; 224 ConnectModel(*fModel);; 225 }; 226 LoadEntry(index, fModel->GetDefaultEntry());; 227 }; 228 /// Fills a user provided entry after checking that the entry has been instantiated from the ntuple model; 229 void LoadEntry(NTupleSize_t index, REntry &entry) { entry.Read(index); }; 230 ; 231 /// Returns an iterator over the entry indices of the RNTuple.; 232 ///; 233 /// **Example: iterate over all entries and print each entry in JSON format**; 234 /// ~~~ {.cpp}; 235 /// #include <ROOT/RNTupleReader.hxx>; 236 /// using ROOT::Experimental::ENTupleShowFormat;; 237 /// using ROOT::Experimental::RNTupleReader;; 238 ///; 239 /// #include <iostream>; 240 ///; 241 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 242 /// f",MatchSource.WIKI,doc/master/RNTupleReader_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html
Energy Efficiency,schedul,scheduler,"r; 52\ingroup NTuple; 53\brief An RNTuple that is used to read data from storage; 54 ; 55An input ntuple provides data from storage as C++ objects. The ntuple model can be created from the data on storage; 56or it can be imposed by the user. The latter case allows users to read into a specialized ntuple model that covers; 57only a subset of the fields in the ntuple. The ntuple model is used when reading complete entries.; 58Individual fields can be read as well by instantiating a tree view.; 59 ; 60~~~ {.cpp}; 61#include <ROOT/RNTupleReader.hxx>; 62using ROOT::Experimental::RNTupleReader;; 63 ; 64#include <iostream>; 65 ; 66auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 67std::cout << ""myNTuple has "" << ntuple->GetNEntries() << "" entries\n"";; 68~~~; 69*/; 70// clang-format on; 71class RNTupleReader {; 72private:; 73 /// Set as the page source's scheduler for parallel page decompression if IMT is on; 74 /// Needs to be destructed after the pages source is destructed (an thus be declared before); 75 std::unique_ptr<Internal::RPageStorage::RTaskScheduler> fUnzipTasks;; 76 ; 77 std::unique_ptr<Internal::RPageSource> fSource;; 78 /// Needs to be destructed before fSource; 79 std::unique_ptr<RNTupleModel> fModel;; 80 /// We use a dedicated on-demand reader for Show() and Scan(). Printing data uses all the fields; 81 /// from the full model even if the analysis code uses only a subset of fields. The display reader; 82 /// is a clone of the original reader.; 83 std::unique_ptr<RNTupleReader> fDisplayReader;; 84 /// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; 85 /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; 86 /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; 87 /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; 88 /// not on a ho",MatchSource.WIKI,doc/master/RNTupleReader_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html
Integrability,depend,depending,"NTuple"", ""some/file.root"");; 206 /// ntuple->PrintInfo(ENTupleInfo::kStorageDetails, std::cerr);; 207 /// ~~~; 208 ///; 209 /// For use of ENTupleInfo::kMetrics, see #EnableMetrics.; 210 void PrintInfo(const ENTupleInfo what = ENTupleInfo::kSummary, std::ostream &output = std::cout) const;; 211 ; 212 /// Shows the values of the i-th entry/row, starting with 0 for the first entry. By default,; 213 /// prints the output in JSON format.; 214 /// Uses the visitor pattern to traverse through each field of the given entry.; 215 void Show(NTupleSize_t index, std::ostream &output = std::cout);; 216 ; 217 /// Analogous to Fill(), fills the default entry of the model. Returns false at the end of the ntuple.; 218 /// On I/O errors, raises an exception.; 219 void LoadEntry(NTupleSize_t index); 220 {; 221 // TODO(jblomer): can be templated depending on the factory method / constructor; 222 if (R__unlikely(!fModel)) {; 223 fModel = fSource->GetSharedDescriptorGuard()->CreateModel();; 224 ConnectModel(*fModel);; 225 }; 226 LoadEntry(index, fModel->GetDefaultEntry());; 227 }; 228 /// Fills a user provided entry after checking that the entry has been instantiated from the ntuple model; 229 void LoadEntry(NTupleSize_t index, REntry &entry) { entry.Read(index); }; 230 ; 231 /// Returns an iterator over the entry indices of the RNTuple.; 232 ///; 233 /// **Example: iterate over all entries and print each entry in JSON format**; 234 /// ~~~ {.cpp}; 235 /// #include <ROOT/RNTupleReader.hxx>; 236 /// using ROOT::Experimental::ENTupleShowFormat;; 237 /// using ROOT::Experimental::RNTupleReader;; 238 ///; 239 /// #include <iostream>; 240 ///; 241 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 242 /// for (auto i : ntuple->GetEntryRange()) {; 243 /// ntuple->Show(i);; 244 /// }; 245 /// ~~~; 246 RNTupleGlobalRange GetEntryRange() { return RNTupleGlobalRange(0, GetNEntries()); }; 247 ; 248 /// Provides access to an individual field that can contain either a scalar value ",MatchSource.WIKI,doc/master/RNTupleReader_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html
Performance,perform,performance,"lude <ROOT/RConfig.hxx> // for R__unlikely; 20#include <ROOT/RError.hxx>; 21#include <ROOT/RNTupleDescriptor.hxx>; 22#include <ROOT/RNTupleMetrics.hxx>; 23#include <ROOT/RNTupleModel.hxx>; 24#include <ROOT/RNTupleReadOptions.hxx>; 25#include <ROOT/RNTupleUtil.hxx>; 26#include <ROOT/RNTupleView.hxx>; 27#include <ROOT/RPageStorage.hxx>; 28#include <ROOT/RSpan.hxx>; 29 ; 30#include <iostream>; 31#include <iterator>; 32#include <memory>; 33#include <string>; 34#include <string_view>; 35 ; 36namespace ROOT {; 37class RNTuple;; 38 ; 39namespace Experimental {; 40class REntry;; 41 ; 42/// Listing of the different options that can be printed by RNTupleReader::GetInfo(); 43enum class ENTupleInfo {; 44 kSummary, // The ntuple name, description, number of entries; 45 kStorageDetails, // size on storage, page sizes, compression factor, etc.; 46 kMetrics, // internals performance counters, requires that EnableMetrics() was called; 47};; 48 ; 49// clang-format off; 50/**; 51\class ROOT::Experimental::RNTupleReader; 52\ingroup NTuple; 53\brief An RNTuple that is used to read data from storage; 54 ; 55An input ntuple provides data from storage as C++ objects. The ntuple model can be created from the data on storage; 56or it can be imposed by the user. The latter case allows users to read into a specialized ntuple model that covers; 57only a subset of the fields in the ntuple. The ntuple model is used when reading complete entries.; 58Individual fields can be read as well by instantiating a tree view.; 59 ; 60~~~ {.cpp}; 61#include <ROOT/RNTupleReader.hxx>; 62using ROOT::Experimental::RNTupleReader;; 63 ; 64#include <iostream>; 65 ; 66auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 67std::cout << ""myNTuple has "" << ntuple->GetNEntries() << "" entries\n"";; 68~~~; 69*/; 70// clang-format on; 71class RNTupleReader {; 72private:; 73 /// Set as the page source's scheduler for parallel page decompression if IMT is on; 74 /// Needs to be destructed after the pages source is",MatchSource.WIKI,doc/master/RNTupleReader_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html
Security,expose,expose,"(""myNTuple"", ""some/file.root"");; 67std::cout << ""myNTuple has "" << ntuple->GetNEntries() << "" entries\n"";; 68~~~; 69*/; 70// clang-format on; 71class RNTupleReader {; 72private:; 73 /// Set as the page source's scheduler for parallel page decompression if IMT is on; 74 /// Needs to be destructed after the pages source is destructed (an thus be declared before); 75 std::unique_ptr<Internal::RPageStorage::RTaskScheduler> fUnzipTasks;; 76 ; 77 std::unique_ptr<Internal::RPageSource> fSource;; 78 /// Needs to be destructed before fSource; 79 std::unique_ptr<RNTupleModel> fModel;; 80 /// We use a dedicated on-demand reader for Show() and Scan(). Printing data uses all the fields; 81 /// from the full model even if the analysis code uses only a subset of fields. The display reader; 82 /// is a clone of the original reader.; 83 std::unique_ptr<RNTupleReader> fDisplayReader;; 84 /// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; 85 /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; 86 /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; 87 /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; 88 /// not on a hot code path.; 89 std::unique_ptr<RNTupleDescriptor> fCachedDescriptor;; 90 Detail::RNTupleMetrics fMetrics;; 91 ; 92 RNTupleReader(std::unique_ptr<RNTupleModel> model, std::unique_ptr<Internal::RPageSource> source,; 93 const RNTupleReadOptions &options);; 94 /// The model is generated from the ntuple metadata on storage.; 95 explicit RNTupleReader(std::unique_ptr<Internal::RPageSource> source, const RNTupleReadOptions &options);; 96 ; 97 void ConnectModel(RNTupleModel &model);; 98 RNTupleReader *GetDisplayReader();; 99 void InitPageSource(bool enableMetrics);; 100 ; 101 DescriptorId_t RetrieveFieldId(std::string_view fieldName) const;; 102 ; 103public:; 104",MatchSource.WIKI,doc/master/RNTupleReader_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html
Testability,test,testing,"eeds to be destructed after the pages source is destructed (an thus be declared before); 75 std::unique_ptr<Internal::RPageStorage::RTaskScheduler> fUnzipTasks;; 76 ; 77 std::unique_ptr<Internal::RPageSource> fSource;; 78 /// Needs to be destructed before fSource; 79 std::unique_ptr<RNTupleModel> fModel;; 80 /// We use a dedicated on-demand reader for Show() and Scan(). Printing data uses all the fields; 81 /// from the full model even if the analysis code uses only a subset of fields. The display reader; 82 /// is a clone of the original reader.; 83 std::unique_ptr<RNTupleReader> fDisplayReader;; 84 /// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; 85 /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; 86 /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; 87 /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; 88 /// not on a hot code path.; 89 std::unique_ptr<RNTupleDescriptor> fCachedDescriptor;; 90 Detail::RNTupleMetrics fMetrics;; 91 ; 92 RNTupleReader(std::unique_ptr<RNTupleModel> model, std::unique_ptr<Internal::RPageSource> source,; 93 const RNTupleReadOptions &options);; 94 /// The model is generated from the ntuple metadata on storage.; 95 explicit RNTupleReader(std::unique_ptr<Internal::RPageSource> source, const RNTupleReadOptions &options);; 96 ; 97 void ConnectModel(RNTupleModel &model);; 98 RNTupleReader *GetDisplayReader();; 99 void InitPageSource(bool enableMetrics);; 100 ; 101 DescriptorId_t RetrieveFieldId(std::string_view fieldName) const;; 102 ; 103public:; 104 // Browse through the entries; 105 class RIterator {; 106 private:; 107 NTupleSize_t fIndex = kInvalidNTupleIndex;; 108 ; 109 public:; 110 using iterator = RIterator;; 111 using iterator_category = std::forward_iterator_tag;; 112 using value_type = NTupleSize_t;; 113 using ",MatchSource.WIKI,doc/master/RNTupleReader_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html
Availability,avail,available,"{; 28 ; 29/// Helper types to present an offset column as array of collection sizes.; 30/// See RField<RNTupleCardinality<SizeT>> for details.; 31template <typename SizeT>; 32struct RNTupleCardinality {; 33 static_assert(std::is_same_v<SizeT, std::uint32_t> || std::is_same_v<SizeT, std::uint64_t>,; 34 ""RNTupleCardinality is only supported with std::uint32_t or std::uint64_t template parameters"");; 35 ; 36 using ValueType = SizeT;; 37 ; 38 RNTupleCardinality() : fValue(0) {}; 39 explicit constexpr RNTupleCardinality(ValueType value) : fValue(value) {}; 40 RNTupleCardinality &operator=(const ValueType value); 41 {; 42 fValue = value;; 43 return *this;; 44 }; 45 operator ValueType() const { return fValue; }; 46 ; 47 ValueType fValue;; 48};; 49 ; 50namespace Experimental {; 51 ; 52class RLogChannel;; 53/// Log channel for RNTuple diagnostics.; 54RLogChannel &NTupleLog();; 55 ; 56// clang-format off; 57/**; 58\class ROOT::Experimental::EColumnType; 59\ingroup NTuple; 60\brief The available trivial, native content types of a column; 61 ; 62More complex types, such as classes, get translated into columns of such simple types by the RField.; 63When changed, remember to update; 64 - RColumnElement::Generate(); 65 - RColumnElement::GetTypeName(); 66 - RColumnElement::GetValidBitRange(); 67 - RColumnElement template specializations / packing & unpacking; 68 - If necessary, endianess handling for the packing + unit test in ntuple_endian; 69 - RNTupleSerializer::[Des|S]erializeColumnType; 70*/; 71// clang-format on; 72enum class EColumnType {; 73 kUnknown = 0,; 74 // type for root columns of (nested) collections; offsets are relative to the current cluster; 75 kIndex64,; 76 kIndex32,; 77 // 96 bit column that is a pair of a kIndex64 and a 32bit dispatch tag to a column ID;; 78 // used to serialize std::variant.; 79 kSwitch,; 80 kByte,; 81 kChar,; 82 kBit,; 83 kReal64,; 84 kReal32,; 85 kReal16,; 86 kInt64,; 87 kUInt64,; 88 kInt32,; 89 kUInt32,; 90 kInt16,; 91 kUInt16,; 92 kInt8,;",MatchSource.WIKI,doc/master/RNTupleUtil_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html
Deployability,update,update,"it constexpr RNTupleCardinality(ValueType value) : fValue(value) {}; 40 RNTupleCardinality &operator=(const ValueType value); 41 {; 42 fValue = value;; 43 return *this;; 44 }; 45 operator ValueType() const { return fValue; }; 46 ; 47 ValueType fValue;; 48};; 49 ; 50namespace Experimental {; 51 ; 52class RLogChannel;; 53/// Log channel for RNTuple diagnostics.; 54RLogChannel &NTupleLog();; 55 ; 56// clang-format off; 57/**; 58\class ROOT::Experimental::EColumnType; 59\ingroup NTuple; 60\brief The available trivial, native content types of a column; 61 ; 62More complex types, such as classes, get translated into columns of such simple types by the RField.; 63When changed, remember to update; 64 - RColumnElement::Generate(); 65 - RColumnElement::GetTypeName(); 66 - RColumnElement::GetValidBitRange(); 67 - RColumnElement template specializations / packing & unpacking; 68 - If necessary, endianess handling for the packing + unit test in ntuple_endian; 69 - RNTupleSerializer::[Des|S]erializeColumnType; 70*/; 71// clang-format on; 72enum class EColumnType {; 73 kUnknown = 0,; 74 // type for root columns of (nested) collections; offsets are relative to the current cluster; 75 kIndex64,; 76 kIndex32,; 77 // 96 bit column that is a pair of a kIndex64 and a 32bit dispatch tag to a column ID;; 78 // used to serialize std::variant.; 79 kSwitch,; 80 kByte,; 81 kChar,; 82 kBit,; 83 kReal64,; 84 kReal32,; 85 kReal16,; 86 kInt64,; 87 kUInt64,; 88 kInt32,; 89 kUInt32,; 90 kInt16,; 91 kUInt16,; 92 kInt8,; 93 kUInt8,; 94 kSplitIndex64,; 95 kSplitIndex32,; 96 kSplitReal64,; 97 kSplitReal32,; 98 kSplitInt64,; 99 kSplitUInt64,; 100 kSplitInt32,; 101 kSplitUInt32,; 102 kSplitInt16,; 103 kSplitUInt16,; 104 kReal32Trunc,; 105 kReal32Quant,; 106 kMax,; 107};; 108 ; 109/// The fields in the ntuple model tree can carry different structural information about the type system.; 110/// Leaf fields contain just data, collection fields resolve to offset columns, record fields have no; 111/// materiali",MatchSource.WIKI,doc/master/RNTupleUtil_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html
Integrability,depend,depend,"; 191 }; 192 RClusterIndex &operator++() /* prefix */; 193 {; 194 ++fIndex;; 195 return *this;; 196 }; 197 bool operator==(RClusterIndex other) const { return fClusterId == other.fClusterId && fIndex == other.fIndex; }; 198 bool operator!=(RClusterIndex other) const { return !(*this == other); }; 199 ; 200 DescriptorId_t GetClusterId() const { return fClusterId; }; 201 ClusterSize_t::ValueType GetIndex() const { return fIndex; }; 202};; 203 ; 204/// RNTupleLocator payload that is common for object stores using 64bit location information.; 205/// This might not contain the full location of the content. In particular, for page locators this information may be; 206/// used in conjunction with the cluster and column ID.; 207struct RNTupleLocatorObject64 {; 208 std::uint64_t fLocation = 0;; 209 bool operator==(const RNTupleLocatorObject64 &other) const { return fLocation == other.fLocation; }; 210};; 211 ; 212/// Generic information about the physical location of data. Values depend on the concrete storage type. E.g.,; 213/// for a local file `fPosition` might be a 64bit file offset. Referenced objects on storage can be compressed; 214/// and therefore we need to store their actual size.; 215/// TODO(jblomer): consider moving this to `RNTupleDescriptor`; 216struct RNTupleLocator {; 217 /// Values for the _Type_ field in non-disk locators. Serializable types must have the MSb == 0; see; 218 /// `doc/BinaryFormatSpecification.md` for details; 219 enum ELocatorType : std::uint8_t {; 220 // The kTypeFile locator may translate to an on-disk standard locator (type 0x00) or a large locator (type 0x01),; 221 // if the size of the referenced data block is >2GB; 222 kTypeFile = 0x00,; 223 kTypeDAOS = 0x02,; 224 ; 225 kLastSerializableType = 0x7f,; 226 kTypePageZero = kLastSerializableType + 1,; 227 kTypeUnknown,; 228 };; 229 ; 230 std::uint64_t fBytesOnStorage = 0;; 231 /// Simple on-disk locators consisting of a 64-bit offset use variant type `uint64_t`; extended locators have; 2",MatchSource.WIKI,doc/master/RNTupleUtil_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html
Modifiability,extend,extended,"struct RNTupleLocatorObject64 {; 208 std::uint64_t fLocation = 0;; 209 bool operator==(const RNTupleLocatorObject64 &other) const { return fLocation == other.fLocation; }; 210};; 211 ; 212/// Generic information about the physical location of data. Values depend on the concrete storage type. E.g.,; 213/// for a local file `fPosition` might be a 64bit file offset. Referenced objects on storage can be compressed; 214/// and therefore we need to store their actual size.; 215/// TODO(jblomer): consider moving this to `RNTupleDescriptor`; 216struct RNTupleLocator {; 217 /// Values for the _Type_ field in non-disk locators. Serializable types must have the MSb == 0; see; 218 /// `doc/BinaryFormatSpecification.md` for details; 219 enum ELocatorType : std::uint8_t {; 220 // The kTypeFile locator may translate to an on-disk standard locator (type 0x00) or a large locator (type 0x01),; 221 // if the size of the referenced data block is >2GB; 222 kTypeFile = 0x00,; 223 kTypeDAOS = 0x02,; 224 ; 225 kLastSerializableType = 0x7f,; 226 kTypePageZero = kLastSerializableType + 1,; 227 kTypeUnknown,; 228 };; 229 ; 230 std::uint64_t fBytesOnStorage = 0;; 231 /// Simple on-disk locators consisting of a 64-bit offset use variant type `uint64_t`; extended locators have; 232 /// `fPosition.index()` > 0; 233 std::variant<std::uint64_t, RNTupleLocatorObject64> fPosition{};; 234 /// For non-disk locators, the value for the _Type_ field. This makes it possible to have different type values even; 235 /// if the payload structure is identical.; 236 ELocatorType fType = kTypeFile;; 237 /// Reserved for use by concrete storage backends; 238 std::uint8_t fReserved = 0;; 239 ; 240 bool operator==(const RNTupleLocator &other) const; 241 {; 242 return fPosition == other.fPosition && fBytesOnStorage == other.fBytesOnStorage && fType == other.fType;; 243 }; 244 template <typename T>; 245 const T &GetPosition() const; 246 {; 247 return std::get<T>(fPosition);; 248 }; 249};; 250 ; 251/// Used to specify t",MatchSource.WIKI,doc/master/RNTupleUtil_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html
Safety,avoid,avoid,"rd fields have no; 111/// materialization on the primitive column layer.; 112enum ENTupleStructure : std::uint16_t { kInvalid, kLeaf, kCollection, kRecord, kVariant, kStreamer, kUnknown };; 113 ; 114/// Integer type long enough to hold the maximum number of entries in a column; 115using NTupleSize_t = std::uint64_t;; 116constexpr NTupleSize_t kInvalidNTupleIndex = std::uint64_t(-1);; 117/// Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t; 118struct RClusterSize {; 119 using ValueType = std::uint64_t;; 120 ; 121 RClusterSize() : fValue(0) {}; 122 explicit constexpr RClusterSize(ValueType value) : fValue(value) {}; 123 RClusterSize &operator=(const ValueType value); 124 {; 125 fValue = value;; 126 return *this;; 127 }; 128 RClusterSize &operator+=(const ValueType value); 129 {; 130 fValue += value;; 131 return *this;; 132 }; 133 RClusterSize operator++(int); 134 {; 135 auto result = *this;; 136 fValue++;; 137 return result;; 138 }; 139 operator ValueType() const { return fValue; }; 140 ; 141 ValueType fValue;; 142};; 143using ClusterSize_t = RClusterSize;; 144constexpr ClusterSize_t kInvalidClusterIndex(std::uint64_t(-1));; 145 ; 146constexpr int kUnknownCompressionSettings = -1;; 147 ; 148/// Holds the index and the tag of a kSwitch column; 149class RColumnSwitch {; 150private:; 151 ClusterSize_t fIndex;; 152 std::uint32_t fTag = 0;; 153 ; 154public:; 155 RColumnSwitch() = default;; 156 RColumnSwitch(ClusterSize_t index, std::uint32_t tag) : fIndex(index), fTag(tag) {}; 157 ClusterSize_t GetIndex() const { return fIndex; }; 158 std::uint32_t GetTag() const { return fTag; }; 159};; 160 ; 161/// Uniquely identifies a physical column within the scope of the current process, used to tag pages; 162using ColumnId_t = std::int64_t;; 163constexpr ColumnId_t kInvalidColumnId = -1;; 164 ; 165/// Distriniguishes elements of the same type within a descriptor, e.g. different fields; 166using DescriptorId_t = std::uint64_t;; 167conste",MatchSource.WIKI,doc/master/RNTupleUtil_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html
Testability,test,test,"it constexpr RNTupleCardinality(ValueType value) : fValue(value) {}; 40 RNTupleCardinality &operator=(const ValueType value); 41 {; 42 fValue = value;; 43 return *this;; 44 }; 45 operator ValueType() const { return fValue; }; 46 ; 47 ValueType fValue;; 48};; 49 ; 50namespace Experimental {; 51 ; 52class RLogChannel;; 53/// Log channel for RNTuple diagnostics.; 54RLogChannel &NTupleLog();; 55 ; 56// clang-format off; 57/**; 58\class ROOT::Experimental::EColumnType; 59\ingroup NTuple; 60\brief The available trivial, native content types of a column; 61 ; 62More complex types, such as classes, get translated into columns of such simple types by the RField.; 63When changed, remember to update; 64 - RColumnElement::Generate(); 65 - RColumnElement::GetTypeName(); 66 - RColumnElement::GetValidBitRange(); 67 - RColumnElement template specializations / packing & unpacking; 68 - If necessary, endianess handling for the packing + unit test in ntuple_endian; 69 - RNTupleSerializer::[Des|S]erializeColumnType; 70*/; 71// clang-format on; 72enum class EColumnType {; 73 kUnknown = 0,; 74 // type for root columns of (nested) collections; offsets are relative to the current cluster; 75 kIndex64,; 76 kIndex32,; 77 // 96 bit column that is a pair of a kIndex64 and a 32bit dispatch tag to a column ID;; 78 // used to serialize std::variant.; 79 kSwitch,; 80 kByte,; 81 kChar,; 82 kBit,; 83 kReal64,; 84 kReal32,; 85 kReal16,; 86 kInt64,; 87 kUInt64,; 88 kInt32,; 89 kUInt32,; 90 kInt16,; 91 kUInt16,; 92 kInt8,; 93 kUInt8,; 94 kSplitIndex64,; 95 kSplitIndex32,; 96 kSplitReal64,; 97 kSplitReal32,; 98 kSplitInt64,; 99 kSplitUInt64,; 100 kSplitInt32,; 101 kSplitUInt32,; 102 kSplitInt16,; 103 kSplitUInt16,; 104 kReal32Trunc,; 105 kReal32Quant,; 106 kMax,; 107};; 108 ; 109/// The fields in the ntuple model tree can carry different structural information about the type system.; 110/// Leaf fields contain just data, collection fields resolve to offset columns, record fields have no; 111/// materiali",MatchSource.WIKI,doc/master/RNTupleUtil_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html
Usability,simpl,simple,"{; 28 ; 29/// Helper types to present an offset column as array of collection sizes.; 30/// See RField<RNTupleCardinality<SizeT>> for details.; 31template <typename SizeT>; 32struct RNTupleCardinality {; 33 static_assert(std::is_same_v<SizeT, std::uint32_t> || std::is_same_v<SizeT, std::uint64_t>,; 34 ""RNTupleCardinality is only supported with std::uint32_t or std::uint64_t template parameters"");; 35 ; 36 using ValueType = SizeT;; 37 ; 38 RNTupleCardinality() : fValue(0) {}; 39 explicit constexpr RNTupleCardinality(ValueType value) : fValue(value) {}; 40 RNTupleCardinality &operator=(const ValueType value); 41 {; 42 fValue = value;; 43 return *this;; 44 }; 45 operator ValueType() const { return fValue; }; 46 ; 47 ValueType fValue;; 48};; 49 ; 50namespace Experimental {; 51 ; 52class RLogChannel;; 53/// Log channel for RNTuple diagnostics.; 54RLogChannel &NTupleLog();; 55 ; 56// clang-format off; 57/**; 58\class ROOT::Experimental::EColumnType; 59\ingroup NTuple; 60\brief The available trivial, native content types of a column; 61 ; 62More complex types, such as classes, get translated into columns of such simple types by the RField.; 63When changed, remember to update; 64 - RColumnElement::Generate(); 65 - RColumnElement::GetTypeName(); 66 - RColumnElement::GetValidBitRange(); 67 - RColumnElement template specializations / packing & unpacking; 68 - If necessary, endianess handling for the packing + unit test in ntuple_endian; 69 - RNTupleSerializer::[Des|S]erializeColumnType; 70*/; 71// clang-format on; 72enum class EColumnType {; 73 kUnknown = 0,; 74 // type for root columns of (nested) collections; offsets are relative to the current cluster; 75 kIndex64,; 76 kIndex32,; 77 // 96 bit column that is a pair of a kIndex64 and a 32bit dispatch tag to a column ID;; 78 // used to serialize std::variant.; 79 kSwitch,; 80 kByte,; 81 kChar,; 82 kBit,; 83 kReal64,; 84 kReal32,; 85 kReal16,; 86 kInt64,; 87 kUInt64,; 88 kInt32,; 89 kUInt32,; 90 kInt16,; 91 kUInt16,; 92 kInt8,;",MatchSource.WIKI,doc/master/RNTupleUtil_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html
Availability,failure,failure," ; 28#include <TROOT.h>; 29 ; 30#include <utility>; 31 ; 32ROOT::Experimental::RNTupleWriter::RNTupleWriter(std::unique_ptr<ROOT::Experimental::RNTupleModel> model,; 33 std::unique_ptr<ROOT::Experimental::Internal::RPageSink> sink); 34 : fFillContext(std::move(model), std::move(sink)), fMetrics(""RNTupleWriter""); 35{; 36#ifdef R__USE_IMT; 37 if (IsImplicitMTEnabled() &&; 38 fFillContext.fSink->GetWriteOptions().GetUseImplicitMT() == RNTupleWriteOptions::EImplicitMT::kDefault) {; 39 fZipTasks = std::make_unique<Internal::RNTupleImtTaskScheduler>();; 40 fFillContext.fSink->SetTaskScheduler(fZipTasks.get());; 41 }; 42#endif; 43 // Observe directly the sink's metrics to avoid an additional prefix from the fill context.; 44 fMetrics.ObserveMetrics(fFillContext.fSink->GetMetrics());; 45}; 46 ; 47ROOT::Experimental::RNTupleWriter::~RNTupleWriter(); 48{; 49 try {; 50 CommitCluster(true /* commitClusterGroup */);; 51 fFillContext.fSink->CommitDataset();; 52 } catch (const RException &err) {; 53 R__LOG_ERROR(NTupleLog()) << ""failure committing ntuple: "" << err.GetError().GetReport();; 54 }; 55}; 56 ; 57std::unique_ptr<ROOT::Experimental::RNTupleWriter>; 58ROOT::Experimental::RNTupleWriter::Create(std::unique_ptr<RNTupleModel> model,; 59 std::unique_ptr<Internal::RPageSink> sink, const RNTupleWriteOptions &options); 60{; 61 if (model->GetRegisteredSubfields().size() > 0) {; 62 throw RException(R__FAIL(""cannot create an RNTupleWriter from a model with registered subfields""));; 63 }; 64 if (options.GetUseBufferedWrite()) {; 65 sink = std::make_unique<Internal::RPageSinkBuf>(std::move(sink));; 66 }; 67 return std::unique_ptr<RNTupleWriter>(new RNTupleWriter(std::move(model), std::move(sink)));; 68}; 69 ; 70std::unique_ptr<ROOT::Experimental::RNTupleWriter>; 71ROOT::Experimental::RNTupleWriter::Recreate(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 72 std::string_view storage, const RNTupleWriteOptions &options); 73{; 74 auto sink = Internal::RPagePersistentSin",MatchSource.WIKI,doc/master/RNTupleWriter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html
Energy Efficiency,schedul,scheduler," RField.cxx:611; ROOT::Experimental::RNTupleFillContext::fSinkstd::unique_ptr< Internal::RPageSink > fSinkDefinition RNTupleFillContext.hxx:56; ROOT::Experimental::RNTupleModel::Createstatic std::unique_ptr< RNTupleModel > Create()Definition RNTupleModel.cxx:249; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriteOptions::GetUseBufferedWritebool GetUseBufferedWrite() constDefinition RNTupleWriteOptions.hxx:127; ROOT::Experimental::RNTupleWriteOptions::EImplicitMT::kDefault@ kDefault; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RNTupleWriter::RNTupleWriterRNTupleWriter(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink)Definition RNTupleWriter.cxx:32; ROOT::Experimental::RNTupleWriter::fZipTasksstd::unique_ptr< Internal::RPageStorage::RTaskScheduler > fZipTasksThe page sink's parallel page compression scheduler if IMT is on.Definition RNTupleWriter.hxx:68; ROOT::Experimental::RNTupleWriter::Createstatic std::unique_ptr< RNTupleWriter > Create(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink, const RNTupleWriteOptions &options)Create a writer, potentially wrapping the sink in a RPageSinkBuf.Definition RNTupleWriter.cxx:58; ROOT::Experimental::RNTupleWriter::CommitClusterGroupvoid CommitClusterGroup()Definition RNTupleWriter.cxx:102; ROOT::Experimental::RNTupleWriter::fMetricsDetail::RNTupleMetrics fMetricsDefinition RNTupleWriter.hxx:70; ROOT::Experimental::RNTupleWriter::~RNTupleWriter~RNTupleWriter()Definition RNTupleWriter.cxx:47; ROOT::Experimental::RNTupleWriter::Recreatestatic std::unique_ptr< RNTupleWriter > Recreate(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an ",MatchSource.WIKI,doc/master/RNTupleWriter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html
Integrability,message,message,"));; 116}; R__FAIL#define R__FAIL(msg)Short-hand to return an RResult<T> in an error state; the RError is implicitly converted into RResult...Definition RError.hxx:290; RLogger.hxx; R__LOG_ERROR#define R__LOG_ERROR(...)Definition RLogger.hxx:362; RNTupleFillContext.hxx; RNTupleImtTaskScheduler.hxx; RNTupleMetrics.hxx; RNTupleModel.hxx; RNTupleWriteOptions.hxx; RNTupleWriter.hxx; RPageSinkBuf.hxx; RPageStorageFile.hxx; RPageStorage.hxx; TROOT.h; ROOT::Experimental::Detail::RNTupleMetrics::ObserveMetricsvoid ObserveMetrics(RNTupleMetrics &observee)Definition RNTupleMetrics.cxx:90; ROOT::Experimental::Internal::RPagePersistentSink::Createstatic std::unique_ptr< RPageSink > Create(std::string_view ntupleName, std::string_view location, const RNTupleWriteOptions &options=RNTupleWriteOptions())Guess the concrete derived page source from the location.Definition RPageStorage.cxx:694; ROOT::Experimental::RError::GetReportstd::string GetReport() constFormat a dignostics report, e.g. for an exception message.Definition RError.cxx:25; ROOT::Experimental::RExceptionBase class for all ROOT issued exceptions.Definition RError.hxx:78; ROOT::Experimental::RException::GetErrorconst RError & GetError() constDefinition RError.hxx:82; ROOT::Experimental::RFieldBase::Createstatic RResult< std::unique_ptr< RFieldBase > > Create(const std::string &fieldName, const std::string &canonicalType, const std::string &typeAlias, bool continueOnError=false)Factory method to resurrect a field from the stored on-disk type information.Definition RField.cxx:611; ROOT::Experimental::RNTupleFillContext::fSinkstd::unique_ptr< Internal::RPageSink > fSinkDefinition RNTupleFillContext.hxx:56; ROOT::Experimental::RNTupleModel::Createstatic std::unique_ptr< RNTupleModel > Create()Definition RNTupleModel.cxx:249; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriteOptions::GetUseBufferedWritebool GetUseBuf",MatchSource.WIKI,doc/master/RNTupleWriter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html
Performance,multi-thread,multi-threading,"< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink, const RNTupleWriteOptions &options)Create a writer, potentially wrapping the sink in a RPageSinkBuf.Definition RNTupleWriter.cxx:58; ROOT::Experimental::RNTupleWriter::CommitClusterGroupvoid CommitClusterGroup()Definition RNTupleWriter.cxx:102; ROOT::Experimental::RNTupleWriter::fMetricsDetail::RNTupleMetrics fMetricsDefinition RNTupleWriter.hxx:70; ROOT::Experimental::RNTupleWriter::~RNTupleWriter~RNTupleWriter()Definition RNTupleWriter.cxx:47; ROOT::Experimental::RNTupleWriter::Recreatestatic std::unique_ptr< RNTupleWriter > Recreate(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an exception if the model is null.Definition RNTupleWriter.cxx:71; ROOT::Experimental::RNTupleWriter::fFillContextRNTupleFillContext fFillContextDefinition RNTupleWriter.hxx:69; ROOT::Experimental::RNTupleWriter::Appendstatic std::unique_ptr< RNTupleWriter > Append(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, TFile &file, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an exception if the model is null.Definition RNTupleWriter.cxx:95; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; ROOT::Experimental::Internal::CreateRNTupleWriterstd::unique_ptr< RNTupleWriter > CreateRNTupleWriter(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink)Definition RNTupleWriter.cxx:111; ROOT::Experimental::NTupleLogRLogChannel & NTupleLog()Log channel for RNTuple diagnostics.Definition RNTupleUtil.cxx:24; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570. treentuplev7srcRNTupleWriter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RNTupleWriter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html
Safety,avoid,avoid,"OT/RLogger.hxx>; 19#include <ROOT/RNTupleImtTaskScheduler.hxx>; 20#include <ROOT/RNTupleFillContext.hxx>; 21#include <ROOT/RNTupleMetrics.hxx>; 22#include <ROOT/RNTupleModel.hxx>; 23#include <ROOT/RNTupleWriteOptions.hxx>; 24#include <ROOT/RPageSinkBuf.hxx>; 25#include <ROOT/RPageStorage.hxx>; 26#include <ROOT/RPageStorageFile.hxx>; 27 ; 28#include <TROOT.h>; 29 ; 30#include <utility>; 31 ; 32ROOT::Experimental::RNTupleWriter::RNTupleWriter(std::unique_ptr<ROOT::Experimental::RNTupleModel> model,; 33 std::unique_ptr<ROOT::Experimental::Internal::RPageSink> sink); 34 : fFillContext(std::move(model), std::move(sink)), fMetrics(""RNTupleWriter""); 35{; 36#ifdef R__USE_IMT; 37 if (IsImplicitMTEnabled() &&; 38 fFillContext.fSink->GetWriteOptions().GetUseImplicitMT() == RNTupleWriteOptions::EImplicitMT::kDefault) {; 39 fZipTasks = std::make_unique<Internal::RNTupleImtTaskScheduler>();; 40 fFillContext.fSink->SetTaskScheduler(fZipTasks.get());; 41 }; 42#endif; 43 // Observe directly the sink's metrics to avoid an additional prefix from the fill context.; 44 fMetrics.ObserveMetrics(fFillContext.fSink->GetMetrics());; 45}; 46 ; 47ROOT::Experimental::RNTupleWriter::~RNTupleWriter(); 48{; 49 try {; 50 CommitCluster(true /* commitClusterGroup */);; 51 fFillContext.fSink->CommitDataset();; 52 } catch (const RException &err) {; 53 R__LOG_ERROR(NTupleLog()) << ""failure committing ntuple: "" << err.GetError().GetReport();; 54 }; 55}; 56 ; 57std::unique_ptr<ROOT::Experimental::RNTupleWriter>; 58ROOT::Experimental::RNTupleWriter::Create(std::unique_ptr<RNTupleModel> model,; 59 std::unique_ptr<Internal::RPageSink> sink, const RNTupleWriteOptions &options); 60{; 61 if (model->GetRegisteredSubfields().size() > 0) {; 62 throw RException(R__FAIL(""cannot create an RNTupleWriter from a model with registered subfields""));; 63 }; 64 if (options.GetUseBufferedWrite()) {; 65 sink = std::make_unique<Internal::RPageSinkBuf>(std::move(sink));; 66 }; 67 return std::unique_ptr<RNTupleWriter>(new RNTuple",MatchSource.WIKI,doc/master/RNTupleWriter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; RNTupleWriter.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <ROOT/RConfig.hxx>; #include <ROOT/REntry.hxx>; #include <ROOT/RError.hxx>; #include <ROOT/RNTupleFillContext.hxx>; #include <ROOT/RNTupleFillStatus.hxx>; #include <ROOT/RNTupleMetrics.hxx>; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleUtil.hxx>; #include <ROOT/RPageStorage.hxx>; #include <cstddef>; #include <cstdint>; #include <memory>; #include <string_view>; #include <utility>. Include dependency graph for RNTupleWriter.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  ; namespace  ROOT::Experimental::Internal;  . Functions; std::unique_ptr< RNTupleWriter > ROOT::Experimental::Internal::CreateRNTupleWriter (std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink);  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h ; Date2024-02-20 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition in file RNTupleWriter.hxx. treentuplev7incROOTRNTupleWriter.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RNTupleWriter_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx.html
Availability,error,errors," ; 37namespace ROOT {; 38namespace Experimental {; 39 ; 40class RNTupleWriteOptions;; 41 ; 42namespace Internal {; 43// Non-public factory method for an RNTuple writer that uses an already constructed page sink; 44std::unique_ptr<RNTupleWriter>; 45CreateRNTupleWriter(std::unique_ptr<RNTupleModel> model, std::unique_ptr<Internal::RPageSink> sink);; 46} // namespace Internal; 47 ; 48// clang-format off; 49/**; 50\class ROOT::Experimental::RNTupleWriter; 51\ingroup NTuple; 52\brief An RNTuple that gets filled with entries (data) and writes them to storage; 53 ; 54An output ntuple can be filled with entries. The caller has to make sure that the data that gets filled into an ntuple; 55is not modified for the time of the Fill() call. The fill call serializes the C++ object into the column format and; 56writes data into the corresponding column page buffers. Writing of the buffers to storage is deferred and can be; 57triggered by FlushCluster() or by destructing the writer. On I/O errors, an exception is thrown.; 58*/; 59// clang-format on; 60class RNTupleWriter {; 61 friend RNTupleModel::RUpdater;; 62 friend std::unique_ptr<RNTupleWriter>; 63 Internal::CreateRNTupleWriter(std::unique_ptr<RNTupleModel>, std::unique_ptr<Internal::RPageSink>);; 64 ; 65private:; 66 /// The page sink's parallel page compression scheduler if IMT is on.; 67 /// Needs to be destructed after the page sink (in the fill context) is destructed and so declared before.; 68 std::unique_ptr<Internal::RPageStorage::RTaskScheduler> fZipTasks;; 69 RNTupleFillContext fFillContext;; 70 Detail::RNTupleMetrics fMetrics;; 71 ; 72 NTupleSize_t fLastCommittedClusterGroup = 0;; 73 ; 74 RNTupleWriter(std::unique_ptr<RNTupleModel> model, std::unique_ptr<Internal::RPageSink> sink);; 75 ; 76 RNTupleModel &GetUpdatableModel() { return *fFillContext.fModel; }; 77 Internal::RPageSink &GetSink() { return *fFillContext.fSink; }; 78 ; 79 // Helper function that is called from CommitCluster() when necessary; 80 void CommitClus",MatchSource.WIKI,doc/master/RNTupleWriter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html
Deployability,update,updates,"ClusterGroup();; 124 }; 125 ; 126 std::unique_ptr<REntry> CreateEntry() { return fFillContext.CreateEntry(); }; 127 ; 128 /// Return the entry number that was last flushed in a cluster.; 129 NTupleSize_t GetLastFlushed() const { return fFillContext.GetLastFlushed(); }; 130 /// Return the entry number that was last committed in a cluster.; 131 NTupleSize_t GetLastCommitted() const { return fFillContext.GetLastFlushed(); }; 132 /// Return the entry number that was last committed in a cluster group.; 133 NTupleSize_t GetLastCommittedClusterGroup() const { return fLastCommittedClusterGroup; }; 134 /// Return the number of entries filled so far.; 135 NTupleSize_t GetNEntries() const { return fFillContext.GetNEntries(); }; 136 ; 137 void EnableMetrics() { fMetrics.Enable(); }; 138 const Detail::RNTupleMetrics &GetMetrics() const { return fMetrics; }; 139 ; 140 const RNTupleModel &GetModel() const { return *fFillContext.fModel; }; 141 ; 142 /// Get a `RNTupleModel::RUpdater` that provides limited support for incremental updates to the underlying; 143 /// model, e.g. addition of new fields.; 144 ///; 145 /// **Example: add a new field after the model has been used to construct a `RNTupleWriter` object**; 146 /// ~~~ {.cpp}; 147 /// #include <ROOT/RNTuple.hxx>; 148 /// using ROOT::Experimental::RNTupleModel;; 149 /// using ROOT::Experimental::RNTupleWriter;; 150 ///; 151 /// auto model = RNTupleModel::Create();; 152 /// auto fldFloat = model->MakeField<float>(""fldFloat"");; 153 /// auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""some/file.root"");; 154 /// auto updater = writer->CreateModelUpdater();; 155 /// updater->BeginUpdate();; 156 /// updater->AddField(std::make_unique<RField<float>>(""pt""));; 157 /// updater->CommitUpdate();; 158 ///; 159 /// // ...; 160 /// ~~~; 161 std::unique_ptr<RNTupleModel::RUpdater> CreateModelUpdater(); 162 {; 163 return std::make_unique<RNTupleModel::RUpdater>(*this);; 164 }; 165}; // class RNTupleWriter; 166 ; 167} // name",MatchSource.WIKI,doc/master/RNTupleWriter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html
Energy Efficiency,schedul,scheduler,"lready constructed page sink; 44std::unique_ptr<RNTupleWriter>; 45CreateRNTupleWriter(std::unique_ptr<RNTupleModel> model, std::unique_ptr<Internal::RPageSink> sink);; 46} // namespace Internal; 47 ; 48// clang-format off; 49/**; 50\class ROOT::Experimental::RNTupleWriter; 51\ingroup NTuple; 52\brief An RNTuple that gets filled with entries (data) and writes them to storage; 53 ; 54An output ntuple can be filled with entries. The caller has to make sure that the data that gets filled into an ntuple; 55is not modified for the time of the Fill() call. The fill call serializes the C++ object into the column format and; 56writes data into the corresponding column page buffers. Writing of the buffers to storage is deferred and can be; 57triggered by FlushCluster() or by destructing the writer. On I/O errors, an exception is thrown.; 58*/; 59// clang-format on; 60class RNTupleWriter {; 61 friend RNTupleModel::RUpdater;; 62 friend std::unique_ptr<RNTupleWriter>; 63 Internal::CreateRNTupleWriter(std::unique_ptr<RNTupleModel>, std::unique_ptr<Internal::RPageSink>);; 64 ; 65private:; 66 /// The page sink's parallel page compression scheduler if IMT is on.; 67 /// Needs to be destructed after the page sink (in the fill context) is destructed and so declared before.; 68 std::unique_ptr<Internal::RPageStorage::RTaskScheduler> fZipTasks;; 69 RNTupleFillContext fFillContext;; 70 Detail::RNTupleMetrics fMetrics;; 71 ; 72 NTupleSize_t fLastCommittedClusterGroup = 0;; 73 ; 74 RNTupleWriter(std::unique_ptr<RNTupleModel> model, std::unique_ptr<Internal::RPageSink> sink);; 75 ; 76 RNTupleModel &GetUpdatableModel() { return *fFillContext.fModel; }; 77 Internal::RPageSink &GetSink() { return *fFillContext.fSink; }; 78 ; 79 // Helper function that is called from CommitCluster() when necessary; 80 void CommitClusterGroup();; 81 ; 82 /// Create a writer, potentially wrapping the sink in a RPageSinkBuf.; 83 static std::unique_ptr<RNTupleWriter> Create(std::unique_ptr<RNTupleModel> model,; 84 s",MatchSource.WIKI,doc/master/RNTupleWriter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html
Integrability,wrap,wrapping,"ors, an exception is thrown.; 58*/; 59// clang-format on; 60class RNTupleWriter {; 61 friend RNTupleModel::RUpdater;; 62 friend std::unique_ptr<RNTupleWriter>; 63 Internal::CreateRNTupleWriter(std::unique_ptr<RNTupleModel>, std::unique_ptr<Internal::RPageSink>);; 64 ; 65private:; 66 /// The page sink's parallel page compression scheduler if IMT is on.; 67 /// Needs to be destructed after the page sink (in the fill context) is destructed and so declared before.; 68 std::unique_ptr<Internal::RPageStorage::RTaskScheduler> fZipTasks;; 69 RNTupleFillContext fFillContext;; 70 Detail::RNTupleMetrics fMetrics;; 71 ; 72 NTupleSize_t fLastCommittedClusterGroup = 0;; 73 ; 74 RNTupleWriter(std::unique_ptr<RNTupleModel> model, std::unique_ptr<Internal::RPageSink> sink);; 75 ; 76 RNTupleModel &GetUpdatableModel() { return *fFillContext.fModel; }; 77 Internal::RPageSink &GetSink() { return *fFillContext.fSink; }; 78 ; 79 // Helper function that is called from CommitCluster() when necessary; 80 void CommitClusterGroup();; 81 ; 82 /// Create a writer, potentially wrapping the sink in a RPageSinkBuf.; 83 static std::unique_ptr<RNTupleWriter> Create(std::unique_ptr<RNTupleModel> model,; 84 std::unique_ptr<Internal::RPageSink> sink,; 85 const RNTupleWriteOptions &options);; 86 ; 87public:; 88 /// Throws an exception if the model is null.; 89 static std::unique_ptr<RNTupleWriter> Recreate(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 90 std::string_view storage,; 91 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 92 static std::unique_ptr<RNTupleWriter>; 93 Recreate(std::initializer_list<std::pair<std::string_view, std::string_view>> fields, std::string_view ntupleName,; 94 std::string_view storage, const RNTupleWriteOptions &options = RNTupleWriteOptions());; 95 /// Throws an exception if the model is null.; 96 static std::unique_ptr<RNTupleWriter> Append(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 97 TFile &file,; 98 const RNTup",MatchSource.WIKI,doc/master/RNTupleWriter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html
Performance,perform,perform,"ue_ptr<RNTupleWriter>; 93 Recreate(std::initializer_list<std::pair<std::string_view, std::string_view>> fields, std::string_view ntupleName,; 94 std::string_view storage, const RNTupleWriteOptions &options = RNTupleWriteOptions());; 95 /// Throws an exception if the model is null.; 96 static std::unique_ptr<RNTupleWriter> Append(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 97 TFile &file,; 98 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 99 RNTupleWriter(const RNTupleWriter &) = delete;; 100 RNTupleWriter &operator=(const RNTupleWriter &) = delete;; 101 ~RNTupleWriter();; 102 ; 103 /// The simplest user interface if the default entry that comes with the ntuple model is used.; 104 /// \return The number of uncompressed bytes written.; 105 std::size_t Fill() { return fFillContext.Fill(fFillContext.fModel->GetDefaultEntry()); }; 106 /// Multiple entries can have been instantiated from the ntuple model. This method will perform; 107 /// a light check whether the entry comes from the ntuple's own model.; 108 /// \return The number of uncompressed bytes written.; 109 std::size_t Fill(REntry &entry) { return fFillContext.Fill(entry); }; 110 /// Fill an entry into this ntuple, but don't commit the cluster. The calling code must pass an RNTupleFillStatus; 111 /// and check RNTupleFillStatus::ShouldFlushCluster.; 112 void FillNoFlush(REntry &entry, RNTupleFillStatus &status) { fFillContext.FillNoFlush(entry, status); }; 113 /// Flush column data, preparing for CommitCluster or to reduce memory usage. This will trigger compression of pages,; 114 /// but not actually write to storage (unless buffered writing is turned off).; 115 void FlushColumns() { fFillContext.FlushColumns(); }; 116 /// Flush so far filled entries to storage; 117 void FlushCluster() { fFillContext.FlushCluster(); }; 118 /// Ensure that the data from the so far seen Fill calls has been written to storage; 119 void CommitCluster(bool commitClusterGroup = false); 120 {; 121 ",MatchSource.WIKI,doc/master/RNTupleWriter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html
Usability,simpl,simplest,"he sink in a RPageSinkBuf.; 83 static std::unique_ptr<RNTupleWriter> Create(std::unique_ptr<RNTupleModel> model,; 84 std::unique_ptr<Internal::RPageSink> sink,; 85 const RNTupleWriteOptions &options);; 86 ; 87public:; 88 /// Throws an exception if the model is null.; 89 static std::unique_ptr<RNTupleWriter> Recreate(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 90 std::string_view storage,; 91 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 92 static std::unique_ptr<RNTupleWriter>; 93 Recreate(std::initializer_list<std::pair<std::string_view, std::string_view>> fields, std::string_view ntupleName,; 94 std::string_view storage, const RNTupleWriteOptions &options = RNTupleWriteOptions());; 95 /// Throws an exception if the model is null.; 96 static std::unique_ptr<RNTupleWriter> Append(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 97 TFile &file,; 98 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 99 RNTupleWriter(const RNTupleWriter &) = delete;; 100 RNTupleWriter &operator=(const RNTupleWriter &) = delete;; 101 ~RNTupleWriter();; 102 ; 103 /// The simplest user interface if the default entry that comes with the ntuple model is used.; 104 /// \return The number of uncompressed bytes written.; 105 std::size_t Fill() { return fFillContext.Fill(fFillContext.fModel->GetDefaultEntry()); }; 106 /// Multiple entries can have been instantiated from the ntuple model. This method will perform; 107 /// a light check whether the entry comes from the ntuple's own model.; 108 /// \return The number of uncompressed bytes written.; 109 std::size_t Fill(REntry &entry) { return fFillContext.Fill(entry); }; 110 /// Fill an entry into this ntuple, but don't commit the cluster. The calling code must pass an RNTupleFillStatus; 111 /// and check RNTupleFillStatus::ShouldFlushCluster.; 112 void FillNoFlush(REntry &entry, RNTupleFillStatus &status) { fFillContext.FillNoFlush(entry, status); }; 113 /// Flush column data, pr",MatchSource.WIKI,doc/master/RNTupleWriter_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html
Integrability,depend,dependency,". ROOT: tree/ntuple/v7/inc/ROOT/RNTuple.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; RNTuple.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <Rtypes.h>; #include <cstdint>. Include dependency graph for RNTuple.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::RNTuple;  Representation of an RNTuple data set in a ROOT file. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  ; namespace  ROOT::Experimental::Internal;  . Functions; RNTuple ROOT::Experimental::Internal::CreateAnchor (std::uint16_t versionEpoch, std::uint16_t versionMajor, std::uint16_t versionMinor, std::uint16_t versionPatch, std::uint64_t seekHeader, std::uint64_t nbytesHeader, std::uint64_t lenHeader, std::uint64_t seekFooter, std::uint64_t nbytesFooter, std::uint64_t lenFooter, std::uint64_t maxKeySize);  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h ; Date2023-09-19 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition in file RNTuple.hxx. treentuplev7incROOTRNTuple.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RNTuple_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTuple_8hxx.html
Deployability,release,release,"tic constexpr std::uint16_t kVersionMinor = 0;; 82 static constexpr std::uint16_t kVersionPatch = 0;; 83 ; 84private:; 85 /// Version of the RNTuple binary format that the writer supports (see specification).; 86 /// Changing the epoch indicates backward-incompatible changes; 87 std::uint16_t fVersionEpoch = kVersionEpoch;; 88 /// Changing the major version indicates forward incompatible changes; such changes should correspond to a new; 89 /// bit in the feature flag of the RNTuple header.; 90 /// For the pre-release epoch 0, indicates the release candidate number; 91 std::uint16_t fVersionMajor = kVersionMajor;; 92 /// Changing the minor version indicates new optional fields added to the RNTuple meta-data; 93 std::uint16_t fVersionMinor = kVersionMinor;; 94 /// Changing the patch version indicates new backported features from newer binary format versions; 95 std::uint16_t fVersionPatch = kVersionPatch;; 96 /// The file offset of the header excluding the TKey part; 97 std::uint64_t fSeekHeader = 0;; 98 /// The size of the compressed ntuple header; 99 std::uint64_t fNBytesHeader = 0;; 100 /// The size of the uncompressed ntuple header; 101 std::uint64_t fLenHeader = 0;; 102 /// The file offset of the footer excluding the TKey part; 103 std::uint64_t fSeekFooter = 0;; 104 /// The size of the compressed ntuple footer; 105 std::uint64_t fNBytesFooter = 0;; 106 /// The size of the uncompressed ntuple footer; 107 std::uint64_t fLenFooter = 0;; 108 /// The maximum size for a TKey payload. Payloads bigger than this size will be written as multiple blobs.; 109 std::uint64_t fMaxKeySize = 0;; 110 ; 111 TFile *fFile = nullptr; ///<! The file from which the ntuple was streamed, registered in the custom streamer; 112 ; 113public:; 114 RNTuple() = default;; 115 ~RNTuple() = default;; 116 ; 117 std::uint16_t GetVersionEpoch() const { return fVersionEpoch; }; 118 std::uint16_t GetVersionMajor() const { return fVersionMajor; }; 119 std::uint16_t GetVersionMinor() const { return fVer",MatchSource.WIKI,doc/master/RNTuple_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTuple_8hxx_source.html
Integrability,interface,interface,"t of the footer excluding the TKey part; 103 std::uint64_t fSeekFooter = 0;; 104 /// The size of the compressed ntuple footer; 105 std::uint64_t fNBytesFooter = 0;; 106 /// The size of the uncompressed ntuple footer; 107 std::uint64_t fLenFooter = 0;; 108 /// The maximum size for a TKey payload. Payloads bigger than this size will be written as multiple blobs.; 109 std::uint64_t fMaxKeySize = 0;; 110 ; 111 TFile *fFile = nullptr; ///<! The file from which the ntuple was streamed, registered in the custom streamer; 112 ; 113public:; 114 RNTuple() = default;; 115 ~RNTuple() = default;; 116 ; 117 std::uint16_t GetVersionEpoch() const { return fVersionEpoch; }; 118 std::uint16_t GetVersionMajor() const { return fVersionMajor; }; 119 std::uint16_t GetVersionMinor() const { return fVersionMinor; }; 120 std::uint16_t GetVersionPatch() const { return fVersionPatch; }; 121 ; 122 std::uint64_t GetSeekHeader() const { return fSeekHeader; }; 123 std::uint64_t GetNBytesHeader() const { return fNBytesHeader; }; 124 std::uint64_t GetLenHeader() const { return fLenHeader; }; 125 ; 126 std::uint64_t GetSeekFooter() const { return fSeekFooter; }; 127 std::uint64_t GetNBytesFooter() const { return fNBytesFooter; }; 128 std::uint64_t GetLenFooter() const { return fLenFooter; }; 129 std::uint64_t GetMaxKeySize() const { return fMaxKeySize; }; 130 ; 131 /// RNTuple implements the hadd MergeFile interface; 132 /// Merge this NTuple with the input list entries; 133 Long64_t Merge(TCollection *input, TFileMergeInfo *mergeInfo);; 134 ; 135 /// NOTE: if you change this version you also need to update RTFNTuple::fClassVersion in RMiniFile.cxx; 136 ClassDefNV(RNTuple, 2);; 137}; // class RNTuple; 138 ; 139} // namespace ROOT; 140 ; 141#endif; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Rtypes.h; ClassDefNV#define ClassDefNV(name, id)Definition Rtypes.h:350; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlig",MatchSource.WIKI,doc/master/RNTuple_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RNTuple_8hxx_source.html
Integrability,depend,dependency,". ROOT: roofit/roofitcore/inc/RooAbsArg.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions ; RooAbsArg.h File Reference. #include <RooAbsCache.h>; #include <RooFit/Config.h>; #include <RooFit/Detail/NormalizationHelpers.h>; #include <RooLinkedListIter.h>; #include <RooNameReg.h>; #include <RooPrintable.h>; #include <RooSTLRefCountList.h>; #include <RooStringView.h>; #include <TNamed.h>; #include <TObjArray.h>; #include <TRefArray.h>; #include <ROOT/RConfig.hxx>; #include <deque>; #include <iostream>; #include <map>; #include <memory>; #include <set>; #include <stack>; #include <string>; #include <unordered_map>. Include dependency graph for RooAbsArg.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RooAbsArg::ProxyListCache;  ; class  RooAbsArg;  Common abstract base class for objects that represent a value and a ""shape"" in RooFit. More...;  ; class  RooRefArray;  . Namespaces; namespace  RooFit;  The namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or other types of arguments). ;  ; namespace  RooFit::Detail;  . Typedefs; using RooListProxy = RooCollectionProxy< RooArgList >;  ; using RooSetProxy = RooCollectionProxy< RooArgSet >;  . Functions; std::ostream & operator<< (std::ostream &os, const RooAbsArg &arg);  Ostream operator. ;  ; std::istream & operator>> (std::istream &is, RooAbsArg &arg);  Istream operator. ;  . Typedef Documentation. ◆ RooListProxy. using RooListProxy = RooCollectionProxy<RooArgList>. Definition at line 55 of file RooAbsArg.h. ◆ RooSetProxy. using RooSetProxy = RooCollectionProxy<RooArgSet>. Definition at line 54 of file RooAbsArg.h. Function Documentation. ◆ operator<<(). std::ostream & operator<<",MatchSource.WIKI,doc/master/RooAbsArg_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsArg_8h.html
Availability,error,error,"root/roofitcore:$Id$; 5 * Authors: *; 6 * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; 7 * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; 8 * *; 9 * Copyright (c) 2000-2005, Regents of the University of California *; 10 * and Stanford University. All rights reserved. *; 11 * *; 12 * Redistribution and use in source and binary forms, *; 13 * with or without modification, are permitted according to the terms *; 14 * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; 15 *****************************************************************************/; 16 ; 17//////////////////////////////////////////////////////////////////////////////; 18/** \class RooAbsPdf; 19 \ingroup Roofitcore; 20 \brief Abstract interface for all probability density functions.; 21 ; 22## RooAbsPdf, the base class of all PDFs; 23 ; 24RooAbsPdf is the base class for all probability density; 25functions (PDFs). The class provides hybrid analytical/numerical; 26normalization for its implementations, error tracing, and a Monte Carlo; 27generator interface.; 28 ; 29### A Minimal PDF Implementation; 30 ; 31A minimal implementation of a PDF class derived from RooAbsPdf; 32should override the `evaluate()` function. This function should; 33return the PDF's value (which does not need to be normalised).; 34 ; 35 ; 36#### Normalization/Integration; 37 ; 38Although the normalization of a PDF is an integral part of a; 39probability density function, normalization is treated separately; 40in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; 41PDF: it can be a building block for a more complex composite PDF; 42if any of its variables are functions instead of variables. In; 43such cases, the normalization of the composite PDF may not simply be; 44integral over the dependents of the top-level PDF: these are; 45functions with potentially non-trivial Jacobian terms themselves.; 46\note Therefore, no explicit attempt should be made to normalize the; 47function output",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Deployability,integrat,integration,"al implementation of a PDF class derived from RooAbsPdf; 32should override the `evaluate()` function. This function should; 33return the PDF's value (which does not need to be normalised).; 34 ; 35 ; 36#### Normalization/Integration; 37 ; 38Although the normalization of a PDF is an integral part of a; 39probability density function, normalization is treated separately; 40in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; 41PDF: it can be a building block for a more complex composite PDF; 42if any of its variables are functions instead of variables. In; 43such cases, the normalization of the composite PDF may not simply be; 44integral over the dependents of the top-level PDF: these are; 45functions with potentially non-trivial Jacobian terms themselves.; 46\note Therefore, no explicit attempt should be made to normalize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs t",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Energy Efficiency,efficient,efficient,"an analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79this integration configuration. If no integration can be; 80performed, zero should be returned. Second,; 81 ; 82```; 83double analyticalIntegral(Int_t code); 84```; 85 ; 86implements the actual analytical integral(s) advertised by; 87`getAnalyticalIntegral()`. This function will only be called with; 88codes returned by `getAnalyticalIntegral()`, except code zero.; 89 ; 90The integration range for each dependent to be integrated can; 91be obtained from the dependent's proxy functions `min()` and; 92`max()`. Never call these proxy functions for any proxy not known to; 93be a dependent via the integration code. Doing so may be; 94ill-defined, e.g., in case the proxy holds a function, and will; 95trigger an assert. Integrated category dependents should always be; 96summed over all of their states.; 97 ; 98 ; 99 ; 100### Direct generation of observables; 101 ; 102Distributions for any PDF can be generated with the accept/reject method,; 103but for certain PDFs, more efficient methods may be implemented. To; 104implement direct generation of one or more observables, two; 105functions need to be implemented, similar to those for analytical; 106integrals:; 107 ; 108```; 109Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars); 110```; 111and; 112```; 113void generateEvent(Int_t code); 114```; 115 ; 116The first function advertises observables, for which distributions can be generated,; 117similar to the way analytical integrals are advertised. The second; 118function implements the actual generator for the advertised observables.; 119 ; 120The generated dependent values should be stored in the proxy; 121objects. For this, the assignment operator can be used (i.e. `xProxy; 122= 3.0` ). Never call assign to any proxy not known to be a dependent; 123via the generation code. Doing so may be ill-defined, e.g. in case; 124the proxy holds a function, and will trigger an as",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Integrability,interface,interface,". ROOT: roofit/roofitcore/src/RooAbsPdf.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RooAbsPdf.cxx. Go to the documentation of this file. 1/*****************************************************************************; 2 * Project: RooFit *; 3 * Package: RooFitCore *; 4 * @(#)root/roofitcore:$Id$; 5 * Authors: *; 6 * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; 7 * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; 8 * *; 9 * Copyright (c) 2000-2005, Regents of the University of California *; 10 * and Stanford University. All rights reserved. *; 11 * *; 12 * Redistribution and use in source and binary forms, *; 13 * with or without modification, are permitted according to the terms *; 14 * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; 15 *****************************************************************************/; 16 ; 17//////////////////////////////////////////////////////////////////////////////; 18/** \class RooAbsPdf; 19 \ingroup Roofitcore; 20 \brief Abstract interface for all probability density functions.; 21 ; 22## RooAbsPdf, the base class of all PDFs; 23 ; 24RooAbsPdf is the base class for all probability density; 25functions (PDFs). The class provides hybrid analytical/numerical; 26normalization for its implementations, error tracing, and a Monte Carlo; 27generator interface.; 28 ; 29### A Minimal PDF Implementation; 30 ; 31A minimal implementation of a PDF class derived from RooAbsPdf; 32should override the `evaluate()` function. This function should; 33return the PDF's value (which does not need to be normalised).; 34 ; 35 ; 36#### Normalization/Integration; 37 ; 38Although the normalization of a PDF is an integral part of a; 39probability density function, normalization is treated separately; 40in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; 41PDF: it can be a building block for a more complex composite PDF; 42if any of its variables are f",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Modifiability,variab,variables,"///////////////////////////////////////////////////////////////////; 18/** \class RooAbsPdf; 19 \ingroup Roofitcore; 20 \brief Abstract interface for all probability density functions.; 21 ; 22## RooAbsPdf, the base class of all PDFs; 23 ; 24RooAbsPdf is the base class for all probability density; 25functions (PDFs). The class provides hybrid analytical/numerical; 26normalization for its implementations, error tracing, and a Monte Carlo; 27generator interface.; 28 ; 29### A Minimal PDF Implementation; 30 ; 31A minimal implementation of a PDF class derived from RooAbsPdf; 32should override the `evaluate()` function. This function should; 33return the PDF's value (which does not need to be normalised).; 34 ; 35 ; 36#### Normalization/Integration; 37 ; 38Although the normalization of a PDF is an integral part of a; 39probability density function, normalization is treated separately; 40in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; 41PDF: it can be a building block for a more complex composite PDF; 42if any of its variables are functions instead of variables. In; 43such cases, the normalization of the composite PDF may not simply be; 44integral over the dependents of the top-level PDF: these are; 45functions with potentially non-trivial Jacobian terms themselves.; 46\note Therefore, no explicit attempt should be made to normalize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 5",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Performance,cache,cached,"sg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normalization set (used in numeric integration of pdfs); 323 if (!nset) {; 324 RooArgSet const* tmp = _normSet ;; 325 _normSet = nullptr ;; 326 double val = evaluate() ;; 327 _normSet = tmp ;; 328 ; 329 return TMath::IsNaN(val) ? 0. : val;; 330 }; 331 ; 332 ; 333 // Process change in last data set used; 334 bool nintChanged(false) ;; 335 if (!isActiveNormSet(nset) || _norm==nullptr) {; 336 nintChanged = syncNormalization(nset) ;; 337 }; 338 ; 339 // Return value of object. Calculated if dirty, otherwise cached value is returned.; 340 if (isValueDirty() || nintChanged || _norm->isValueDirty()) {",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Safety,safe,safe,"ize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs that have one or more dependents in; 67common, etc).; 68 ; 69#### Implementing analytical integrals; 70To implement analytical integrals, two functions must be implemented. First,; 71 ; 72```; 73Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); 74```; 75should return the analytical integrals that are supported. `integSet`; 76is the set of dependents for which integration is requested. The; 77function should copy the subset of dependents it can analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79this integration configuration. If no integration can be; 80performed, zero should be returned. Second,; 81 ; 82```; 83double analyticalIntegral(Int_t code); 84```; 85 ; 86implements the actual analytical integral(s) advertised by; 87`getAnalyticalIntegral()`. This function will o",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Testability,log,logic,"ables. In; 43such cases, the normalization of the composite PDF may not simply be; 44integral over the dependents of the top-level PDF: these are; 45functions with potentially non-trivial Jacobian terms themselves.; 46\note Therefore, no explicit attempt should be made to normalize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs that have one or more dependents in; 67common, etc).; 68 ; 69#### Implementing analytical integrals; 70To implement analytical integrals, two functions must be implemented. First,; 71 ; 72```; 73Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); 74```; 75should return the analytical integrals that are supported. `integSet`; 76is the set of dependents for which integration is requested. The; 77function should copy the subset of dependents it can analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79t",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Usability,simpl,simply,"RooAbsPdf, the base class of all PDFs; 23 ; 24RooAbsPdf is the base class for all probability density; 25functions (PDFs). The class provides hybrid analytical/numerical; 26normalization for its implementations, error tracing, and a Monte Carlo; 27generator interface.; 28 ; 29### A Minimal PDF Implementation; 30 ; 31A minimal implementation of a PDF class derived from RooAbsPdf; 32should override the `evaluate()` function. This function should; 33return the PDF's value (which does not need to be normalised).; 34 ; 35 ; 36#### Normalization/Integration; 37 ; 38Although the normalization of a PDF is an integral part of a; 39probability density function, normalization is treated separately; 40in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; 41PDF: it can be a building block for a more complex composite PDF; 42if any of its variables are functions instead of variables. In; 43such cases, the normalization of the composite PDF may not simply be; 44integral over the dependents of the top-level PDF: these are; 45functions with potentially non-trivial Jacobian terms themselves.; 46\note Therefore, no explicit attempt should be made to normalize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, Roo",MatchSource.WIKI,doc/master/RooAbsPdf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html
Availability,error,errors,"const RooCmdArg& arg4={},; 118 const RooCmdArg& arg5={},const RooCmdArg& arg6={}) const;; 119 virtual RooFit::OwningPtr<RooDataHist> generateBinned(const RooArgSet &whatVars, double nEvents, bool expectedData=false, bool extended=false) const;; 120 ; 121 virtual RooFit::OwningPtr<RooDataSet> generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents) ;; 122 ; 123 ///Helper calling plotOn(RooPlot*, RooLinkedList&) const; 124 RooPlot* plotOn(RooPlot* frame,; 125 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 126 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 127 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 128 const RooCmdArg& arg7={}, const RooCmdArg& arg8={},; 129 const RooCmdArg& arg9={}, const RooCmdArg& arg10={}; 130 ) const override {; 131 return RooAbsReal::plotOn(frame,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) ;; 132 }; 133 RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const override ;; 134 ; 135 /// Add a box with parameter values (and errors) to the specified frame; 136 virtual RooPlot* paramOn(RooPlot* frame,; 137 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 138 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 139 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 140 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) ;; 141 ; 142 // Built-in generator support; 143 virtual Int_t getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, bool staticInitOK=true) const;; 144 virtual void initGenerator(Int_t code) ;; 145 virtual void generateEvent(Int_t code);; 146 virtual bool isDirectGenSafe(const RooAbsArg& arg) const ;; 147 ; 148 // Configuration of MC generators used for this pdf; 149 const RooNumGenConfig* getGeneratorConfig() const ;; 150 static RooNumGenConfig* defaultGeneratorConfig() ;; 151 RooNumGenConfig* specialGeneratorConfig() const ;; 152 RooNumGenConfig* specialGeneratorConfig(bool createOnTheFly) ;; 153 void setGeneratorConfig() ;; 154 void setGeneratorConfig(const RooNumGenConfig& ",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Deployability,configurat,configuration,"ts How many events to generate; 56 /// \param arg1,arg2,arg3,arg4,arg5 Optional command arguments.; 57 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg& arg1,; 58 const RooCmdArg& arg2={}, const RooCmdArg& arg3={},; 59 const RooCmdArg& arg4={}, const RooCmdArg& arg5={}) {; 60 return generate(whatVars,RooFit::NumEvents(nEvents),arg1,arg2,arg3,arg4,arg5) ;; 61 }; 62 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars,; 63 const RooCmdArg& arg1={},const RooCmdArg& arg2={},; 64 const RooCmdArg& arg3={},const RooCmdArg& arg4={},; 65 const RooCmdArg& arg5={},const RooCmdArg& arg6={}) ;; 66 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, double nEvents = 0, bool verbose=false, bool autoBinned=true,; 67 const char* binnedTag="""", bool expectedData=false, bool extended = false) const;; 68 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, const RooDataSet &prototype, Int_t nEvents= 0,; 69 bool verbose=false, bool randProtoOrder=false, bool resampleProto=false) const;; 70 ; 71 ; 72 class GenSpec {; 73 public:; 74 virtual ~GenSpec() ;; 75 GenSpec() = default;; 76 ; 77 private:; 78 GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, bool extended,; 79 bool randProto, bool resampleProto, TString dsetName, bool init=false) ;; 80 GenSpec(const GenSpec& other) ;; 81 ; 82 friend class RooAbsPdf ;; 83 std::unique_ptr<RooAbsGenContext> _genContext;; 84 RooArgSet _whatVars ;; 85 RooDataSet* _protoData = nullptr;; 86 Int_t _nGen = 0;; 87 bool _extended = false;; 88 bool _randProto = false;; 89 bool _resampleProto = false;; 90 TString _dsetName ;; 91 bool _init = false;; 92 ; 93 ClassDef(GenSpec,0) // Generation specification; 94 } ;; 95 ; 96 ///Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification.; 97 GenSpec* prepareMultiGen(const RooArgSet &whatVars,; 98 const RooCmdArg& arg1={},const RooCmd",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Energy Efficiency,efficient,efficient,"ts How many events to generate; 56 /// \param arg1,arg2,arg3,arg4,arg5 Optional command arguments.; 57 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg& arg1,; 58 const RooCmdArg& arg2={}, const RooCmdArg& arg3={},; 59 const RooCmdArg& arg4={}, const RooCmdArg& arg5={}) {; 60 return generate(whatVars,RooFit::NumEvents(nEvents),arg1,arg2,arg3,arg4,arg5) ;; 61 }; 62 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars,; 63 const RooCmdArg& arg1={},const RooCmdArg& arg2={},; 64 const RooCmdArg& arg3={},const RooCmdArg& arg4={},; 65 const RooCmdArg& arg5={},const RooCmdArg& arg6={}) ;; 66 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, double nEvents = 0, bool verbose=false, bool autoBinned=true,; 67 const char* binnedTag="""", bool expectedData=false, bool extended = false) const;; 68 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, const RooDataSet &prototype, Int_t nEvents= 0,; 69 bool verbose=false, bool randProtoOrder=false, bool resampleProto=false) const;; 70 ; 71 ; 72 class GenSpec {; 73 public:; 74 virtual ~GenSpec() ;; 75 GenSpec() = default;; 76 ; 77 private:; 78 GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, bool extended,; 79 bool randProto, bool resampleProto, TString dsetName, bool init=false) ;; 80 GenSpec(const GenSpec& other) ;; 81 ; 82 friend class RooAbsPdf ;; 83 std::unique_ptr<RooAbsGenContext> _genContext;; 84 RooArgSet _whatVars ;; 85 RooDataSet* _protoData = nullptr;; 86 Int_t _nGen = 0;; 87 bool _extended = false;; 88 bool _randProto = false;; 89 bool _resampleProto = false;; 90 TString _dsetName ;; 91 bool _init = false;; 92 ; 93 ClassDef(GenSpec,0) // Generation specification; 94 } ;; 95 ; 96 ///Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification.; 97 GenSpec* prepareMultiGen(const RooArgSet &whatVars,; 98 const RooCmdArg& arg1={},const RooCmd",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Integrability,interface,interface,"218 inline bool canBeExtended() const {; 219 return (extendMode() != CanNotBeExtended) ;; 220 }; 221 /// If true PDF must provide extended likelihood term.; 222 inline bool mustBeExtended() const {; 223 return (extendMode() == MustBeExtended) ;; 224 }; 225 /// Return expected number of events to be used in calculation of extended; 226 /// likelihood.; 227 virtual double expectedEvents(const RooArgSet* nset) const ;; 228 /// Return expected number of events to be used in calculation of extended; 229 /// likelihood. This function should not be overridden, as it just redirects; 230 /// to the actual virtual function but takes a RooArgSet reference instead of; 231 /// pointer. \see expectedEvents(const RooArgSet*) const; 232 double expectedEvents(const RooArgSet& nset) const {; 233 return expectedEvents(&nset) ;; 234 }; 235 ; 236 virtual std::unique_ptr<RooAbsReal> createExpectedEventsFunc(const RooArgSet* nset) const;; 237 ; 238 // Printing interface (human readable); 239 void printValue(std::ostream& os) const override ;; 240 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 241 ; 242 static void verboseEval(Int_t stat) ;; 243 static int verboseEval() ;; 244 ; 245 double extendedTerm(double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) const;; 246 double extendedTerm(double sumEntries, RooArgSet const* nset, double sumEntriesW2=0.0, bool doOffset=false) const;; 247 double extendedTerm(RooAbsData const& data, bool weightSquared, bool doOffset=false) const;; 248 ; 249 void setNormRange(const char* rangeName) ;; 250 const char* normRange() const {; 251 return _normRange.Length()>0 ? _normRange.Data() : nullptr ;; 252 }; 253 void setNormRangeOverride(const char* rangeName) ;; 254 ; 255 const RooAbsReal* getNormIntegral(const RooArgSet& nset) const { return getNormObj(nullptr,&nset,nullptr) ; }; 256 ; 257 virtual const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset,",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Modifiability,extend,extended,"ts How many events to generate; 56 /// \param arg1,arg2,arg3,arg4,arg5 Optional command arguments.; 57 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg& arg1,; 58 const RooCmdArg& arg2={}, const RooCmdArg& arg3={},; 59 const RooCmdArg& arg4={}, const RooCmdArg& arg5={}) {; 60 return generate(whatVars,RooFit::NumEvents(nEvents),arg1,arg2,arg3,arg4,arg5) ;; 61 }; 62 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars,; 63 const RooCmdArg& arg1={},const RooCmdArg& arg2={},; 64 const RooCmdArg& arg3={},const RooCmdArg& arg4={},; 65 const RooCmdArg& arg5={},const RooCmdArg& arg6={}) ;; 66 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, double nEvents = 0, bool verbose=false, bool autoBinned=true,; 67 const char* binnedTag="""", bool expectedData=false, bool extended = false) const;; 68 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, const RooDataSet &prototype, Int_t nEvents= 0,; 69 bool verbose=false, bool randProtoOrder=false, bool resampleProto=false) const;; 70 ; 71 ; 72 class GenSpec {; 73 public:; 74 virtual ~GenSpec() ;; 75 GenSpec() = default;; 76 ; 77 private:; 78 GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, bool extended,; 79 bool randProto, bool resampleProto, TString dsetName, bool init=false) ;; 80 GenSpec(const GenSpec& other) ;; 81 ; 82 friend class RooAbsPdf ;; 83 std::unique_ptr<RooAbsGenContext> _genContext;; 84 RooArgSet _whatVars ;; 85 RooDataSet* _protoData = nullptr;; 86 Int_t _nGen = 0;; 87 bool _extended = false;; 88 bool _randProto = false;; 89 bool _resampleProto = false;; 90 TString _dsetName ;; 91 bool _init = false;; 92 ; 93 ClassDef(GenSpec,0) // Generation specification; 94 } ;; 95 ; 96 ///Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification.; 97 GenSpec* prepareMultiGen(const RooArgSet &whatVars,; 98 const RooCmdArg& arg1={},const RooCmd",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Performance,cache,cache,"PlotOpt o) const override;; 306 ; 307 friend class RooMCStudy ;; 308 ; 309 Int_t* randomizeProtoOrder(Int_t nProto,Int_t nGen,bool resample=false) const ;; 310 ; 311 // This also forces the definition of a copy ctor in derived classes; 312 RooAbsPdf(const RooAbsPdf& other, const char* name = nullptr);; 313 ; 314 static Int_t _verboseEval ;; 315 ; 316 virtual bool syncNormalization(const RooArgSet* dset, bool adjustProxies=true) const ;; 317 ; 318 mutable double _rawValue = 0;; 319 mutable RooAbsReal* _norm = nullptr; //! Normalization integral (owned by _normMgr); 320 mutable RooArgSet const* _normSet = nullptr; //! Normalization set with for above integral; 321 ; 322 class CacheElem : public RooAbsCacheElement {; 323 public:; 324 CacheElem(RooAbsReal& norm) : _norm(&norm) {} ;; 325 ~CacheElem() override ;; 326 RooArgList containedArgs(Action) override { return RooArgList(*_norm) ; }; 327 std::unique_ptr<RooAbsReal> _norm;; 328 } ;; 329 mutable RooObjCacheManager _normMgr ; //! The cache manager; 330 ; 331 bool redirectServersHook(const RooAbsCollection & newServerList, bool mustReplaceAll,; 332 bool nameChange, bool isRecursiveStep) override;; 333 ; 334 mutable Int_t _errorCount = 0; ///< Number of errors remaining to print; 335 mutable Int_t _traceCount = 0; ///< Number of traces remaining to print; 336 mutable Int_t _negCount = 0; ///< Number of negative probabilities remaining to print; 337 ; 338 bool _selectComp = false; ///< Component selection flag for RooAbsPdf::plotCompOn; 339 ; 340 std::unique_ptr<RooNumGenConfig> _specGeneratorConfig ; ///<! MC generator configuration specific for this object; 341 ; 342 TString _normRange ; ///< Normalization range; 343 static TString _normRangeOverride ;; 344 ; 345private:; 346 mutable RooFit::UniqueId<RooArgSet>::Value_t _normSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<! Unique ID of the currently-active normalization set; 347 ; 348 friend class RooAbsReal;; 349 friend class RooChi2Var;; 350 ; 351 ClassDefOverride",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Safety,detect,detect,"ooFit::Detail::CompileContext & ctx) const override;; 268 ; 269private:; 270 ; 271 std::unique_ptr<RooDataSet> generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype,; 272 double nEvents, bool verbose, bool randProtoOrder, bool resampleProto, bool skipInit=false,; 273 bool extended=false) const ;; 274 ; 275 // Implementation version; 276 virtual RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, bool showConstants=false,; 277 const char *label= """", double xmin=0.65,; 278 double xmax= 0.99,double ymax=0.95, const RooCmdArg* formatCmd=nullptr) ;; 279 ; 280 void logBatchComputationErrors(std::span<const double>& outputs, std::size_t begin) const;; 281 bool traceEvalPdf(double value) const;; 282 ; 283 /// Setter for the _normSet member, which should never be set directly.; 284 inline void setActiveNormSet(RooArgSet const* normSet) const {; 285 _normSet = normSet;; 286 // Also store the unique ID of the _normSet. This makes it possible to; 287 // detect if the pointer was invalidated.; 288 _normSetId = RooFit::getUniqueId(normSet);; 289 }; 290 ; 291protected:; 292 ; 293 virtual std::unique_ptr<RooAbsReal> createNLLImpl(RooAbsData& data, const RooLinkedList& cmdList);; 294 virtual std::unique_ptr<RooFitResult> fitToImpl(RooAbsData& data, const RooLinkedList& cmdList);; 295 ; 296 /// Checks if `normSet` is the currently active normalization set of this; 297 /// PDF, meaning is exactly the same object as the one the `_normSet` member; 298 /// points to (or both are `nullptr`).; 299 inline bool isActiveNormSet(RooArgSet const* normSet) const {; 300 return RooFit::getUniqueId(normSet).value() == _normSetId;; 301 }; 302 ; 303 double normalizeWithNaNPacking(double rawVal, double normVal) const;; 304 ; 305 RooPlot *plotOn(RooPlot *frame, PlotOpt o) const override;; 306 ; 307 friend class RooMCStudy ;; 308 ; 309 Int_t* randomizeProtoOrder(Int_t nProto,Int_t nGen,bool resample=false) const ;; 310 ; 311 // This also forces the definition of",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Testability,log,logBatchComputationErrors," ;; 263 ; 264 virtual RooAbsGenContext* autoGenContext(const RooArgSet &vars, const RooDataSet* prototype=nullptr, const RooArgSet* auxProto=nullptr,; 265 bool verbose=false, bool autoBinned=true, const char* binnedTag="""") const ;; 266 ; 267 std::unique_ptr<RooAbsArg> compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext & ctx) const override;; 268 ; 269private:; 270 ; 271 std::unique_ptr<RooDataSet> generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype,; 272 double nEvents, bool verbose, bool randProtoOrder, bool resampleProto, bool skipInit=false,; 273 bool extended=false) const ;; 274 ; 275 // Implementation version; 276 virtual RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, bool showConstants=false,; 277 const char *label= """", double xmin=0.65,; 278 double xmax= 0.99,double ymax=0.95, const RooCmdArg* formatCmd=nullptr) ;; 279 ; 280 void logBatchComputationErrors(std::span<const double>& outputs, std::size_t begin) const;; 281 bool traceEvalPdf(double value) const;; 282 ; 283 /// Setter for the _normSet member, which should never be set directly.; 284 inline void setActiveNormSet(RooArgSet const* normSet) const {; 285 _normSet = normSet;; 286 // Also store the unique ID of the _normSet. This makes it possible to; 287 // detect if the pointer was invalidated.; 288 _normSetId = RooFit::getUniqueId(normSet);; 289 }; 290 ; 291protected:; 292 ; 293 virtual std::unique_ptr<RooAbsReal> createNLLImpl(RooAbsData& data, const RooLinkedList& cmdList);; 294 virtual std::unique_ptr<RooFitResult> fitToImpl(RooAbsData& data, const RooLinkedList& cmdList);; 295 ; 296 /// Checks if `normSet` is the currently active normalization set of this; 297 /// PDF, meaning is exactly the same object as the one the `_normSet` member; 298 /// points to (or both are `nullptr`).; 299 inline bool isActiveNormSet(RooArgSet const* normSet) const {; 300 return RooFit::getUniqueId(normSet).value() == _normSetId;; 301 }; 302 ; 303 ",MatchSource.WIKI,doc/master/RooAbsPdf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html
Availability,error,errors,"nt.h""; 63#include ""RooMsgService.h""; 64#include ""RooNumIntConfig.h""; 65#include ""RooNumRunningInt.h""; 66#include ""RooParamBinning.h""; 67#include ""RooPlot.h""; 68#include ""RooProduct.h""; 69#include ""RooProfileLL.h""; 70#include ""RooRealBinding.h""; 71#include ""RooRealIntegral.h""; 72#include ""RooRealVar.h""; 73#include ""RooSecondMoment.h""; 74#include ""RooVectorDataStore.h""; 75#include ""TreeReadBuffer.h""; 76#include ""ValueChecking.h""; 77 ; 78#include ""ROOT/StringUtils.hxx""; 79#include ""Compression.h""; 80#include ""Math/IFunction.h""; 81#include ""TMath.h""; 82#include ""TObjString.h""; 83#include ""TTree.h""; 84#include ""TH1.h""; 85#include ""TH2.h""; 86#include ""TH3.h""; 87#include ""TBranch.h""; 88#include ""TLeaf.h""; 89#include ""TAttLine.h""; 90#include ""TF1.h""; 91#include ""TF2.h""; 92#include ""TF3.h""; 93#include ""TMatrixD.h""; 94#include ""TVector.h""; 95#include ""strlcpy.h""; 96#ifndef NDEBUG; 97#include <TSystem.h> // To print stack traces when caching errors are detected; 98#endif; 99 ; 100#include <iomanip>; 101#include <iostream>; 102#include <limits>; 103#include <sstream>; 104#include <sys/types.h>; 105 ; 106namespace {; 107 ; 108// Internal helper RooAbsFunc that evaluates the scaled data-weighted average of; 109// given RooAbsReal as a function of a single variable using the RooFit::Evaluator.; 110class ScaledDataWeightedAverage : public RooAbsFunc {; 111public:; 112 ScaledDataWeightedAverage(RooAbsReal const &arg, RooAbsData const &data, double scaleFactor, RooAbsRealLValue &var); 113 : RooAbsFunc{1}, _var{var}, _dataWeights{data.getWeightBatch(0, data.numEntries())}, _scaleFactor{scaleFactor}; 114 {; 115 _arg = RooFit::Detail::compileForNormSet(arg, *data.get());; 116 _arg->recursiveRedirectServers(RooArgList{var});; 117 _evaluator = std::make_unique<RooFit::Evaluator>(*_arg);; 118 std::stack<std::vector<double>>{}.swap(_vectorBuffers);; 119 auto dataSpans = RooFit::BatchModeDataHelpers::getDataSpans(data, """", nullptr, /*skipZeroWeights=*/false,; 120 /*takeGlobalObservablesFromD",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Deployability,integrat,integration,"////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Energy Efficiency,efficient,efficient,"alue = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Integrability,interface,interface,": *; 6 * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; 7 * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; 8 * *; 9 * Copyright (c) 2000-2005, Regents of the University of California *; 10 * and Stanford University. All rights reserved. *; 11 * *; 12 * Redistribution and use in source and binary forms, *; 13 * with or without modification, are permitted according to the terms *; 14 * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; 15 *****************************************************************************/; 16 ; 17//////////////////////////////////////////////////////////////////////////////; 18 ; 19/** \class RooAbsReal; 20 ; 21 Abstract base class for objects that represent a; 22 real value and implements functionality common to all real-valued objects; 23 such as the ability to plot them, to construct integrals of them, the; 24 ability to advertise (partial) analytical integrals etc.; 25 ; 26 Implementation of RooAbsReal may be derived, thus no interface; 27 is provided to modify the contents.; 28 ; 29 \ingroup Roofitcore; 30*/; 31 ; 32#include ""RooAbsReal.h""; 33 ; 34#include ""FitHelpers.h""; 35#include ""RooAbsCategoryLValue.h""; 36#include ""RooAbsData.h""; 37#include ""RooAddPdf.h""; 38#include ""RooAddition.h""; 39#include ""RooArgList.h""; 40#include ""RooArgProxy.h""; 41#include ""RooArgSet.h""; 42#include ""RooBinning.h""; 43#include ""RooBrentRootFinder.h""; 44#include ""RooCachedReal.h""; 45#include ""RooCategory.h""; 46#include ""RooCmdConfig.h""; 47#include ""RooConstVar.h""; 48#include ""RooCurve.h""; 49#include ""RooCustomizer.h""; 50#include ""RooDataHist.h""; 51#include ""RooDataSet.h""; 52#include ""RooDerivative.h""; 53#include ""RooFirstMoment.h""; 54#include ""RooFit/BatchModeDataHelpers.h""; 55#include ""RooFit/Evaluator.h""; 56#include ""RooFitResult.h""; 57#include ""RooFormulaVar.h""; 58#include ""RooFunctor.h""; 59#include ""RooGlobalFunc.h""; 60#include ""RooFitImplHelpers.h""; 61#include ""RooHist.h""; 62#include ""RooMoment.h""; 63#include ""RooMsgS",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Modifiability,variab,variable,"RooProfileLL.h""; 70#include ""RooRealBinding.h""; 71#include ""RooRealIntegral.h""; 72#include ""RooRealVar.h""; 73#include ""RooSecondMoment.h""; 74#include ""RooVectorDataStore.h""; 75#include ""TreeReadBuffer.h""; 76#include ""ValueChecking.h""; 77 ; 78#include ""ROOT/StringUtils.hxx""; 79#include ""Compression.h""; 80#include ""Math/IFunction.h""; 81#include ""TMath.h""; 82#include ""TObjString.h""; 83#include ""TTree.h""; 84#include ""TH1.h""; 85#include ""TH2.h""; 86#include ""TH3.h""; 87#include ""TBranch.h""; 88#include ""TLeaf.h""; 89#include ""TAttLine.h""; 90#include ""TF1.h""; 91#include ""TF2.h""; 92#include ""TF3.h""; 93#include ""TMatrixD.h""; 94#include ""TVector.h""; 95#include ""strlcpy.h""; 96#ifndef NDEBUG; 97#include <TSystem.h> // To print stack traces when caching errors are detected; 98#endif; 99 ; 100#include <iomanip>; 101#include <iostream>; 102#include <limits>; 103#include <sstream>; 104#include <sys/types.h>; 105 ; 106namespace {; 107 ; 108// Internal helper RooAbsFunc that evaluates the scaled data-weighted average of; 109// given RooAbsReal as a function of a single variable using the RooFit::Evaluator.; 110class ScaledDataWeightedAverage : public RooAbsFunc {; 111public:; 112 ScaledDataWeightedAverage(RooAbsReal const &arg, RooAbsData const &data, double scaleFactor, RooAbsRealLValue &var); 113 : RooAbsFunc{1}, _var{var}, _dataWeights{data.getWeightBatch(0, data.numEntries())}, _scaleFactor{scaleFactor}; 114 {; 115 _arg = RooFit::Detail::compileForNormSet(arg, *data.get());; 116 _arg->recursiveRedirectServers(RooArgList{var});; 117 _evaluator = std::make_unique<RooFit::Evaluator>(*_arg);; 118 std::stack<std::vector<double>>{}.swap(_vectorBuffers);; 119 auto dataSpans = RooFit::BatchModeDataHelpers::getDataSpans(data, """", nullptr, /*skipZeroWeights=*/false,; 120 /*takeGlobalObservablesFromData=*/true,; 121 _vectorBuffers);; 122 for (auto const& item : dataSpans) {; 123 _evaluator->setInput(item.first->GetName(), item.second, false);; 124 }; 125 }; 126 ; 127 double operator()(const dou",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Performance,cache,cache," bool assumeSameType) const; 271{; 272 if (!assumeSameType) {; 273 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 274 return otherReal ? operator==(otherReal->getVal()) : false ;; 275 } else {; 276 return getVal() == static_cast<const RooAbsReal&>(other).getVal();; 277 }; 278}; 279 ; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Return this variable's title string. If appendUnit is true and; 283/// this variable has units, also append a string "" (<unit>)"".; 284 ; 285TString RooAbsReal::getTitle(bool appendUnit) const; 286{; 287 if(appendUnit && 0 != strlen(getUnit())) {; 288 return std::string{GetTitle()} + "" ("" + getUnit() + "")"";; 289 }; 290 return GetTitle();; 291}; 292 ; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Return value of object. If the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes h",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Safety,detect,detected,"nt.h""; 63#include ""RooMsgService.h""; 64#include ""RooNumIntConfig.h""; 65#include ""RooNumRunningInt.h""; 66#include ""RooParamBinning.h""; 67#include ""RooPlot.h""; 68#include ""RooProduct.h""; 69#include ""RooProfileLL.h""; 70#include ""RooRealBinding.h""; 71#include ""RooRealIntegral.h""; 72#include ""RooRealVar.h""; 73#include ""RooSecondMoment.h""; 74#include ""RooVectorDataStore.h""; 75#include ""TreeReadBuffer.h""; 76#include ""ValueChecking.h""; 77 ; 78#include ""ROOT/StringUtils.hxx""; 79#include ""Compression.h""; 80#include ""Math/IFunction.h""; 81#include ""TMath.h""; 82#include ""TObjString.h""; 83#include ""TTree.h""; 84#include ""TH1.h""; 85#include ""TH2.h""; 86#include ""TH3.h""; 87#include ""TBranch.h""; 88#include ""TLeaf.h""; 89#include ""TAttLine.h""; 90#include ""TF1.h""; 91#include ""TF2.h""; 92#include ""TF3.h""; 93#include ""TMatrixD.h""; 94#include ""TVector.h""; 95#include ""strlcpy.h""; 96#ifndef NDEBUG; 97#include <TSystem.h> // To print stack traces when caching errors are detected; 98#endif; 99 ; 100#include <iomanip>; 101#include <iostream>; 102#include <limits>; 103#include <sstream>; 104#include <sys/types.h>; 105 ; 106namespace {; 107 ; 108// Internal helper RooAbsFunc that evaluates the scaled data-weighted average of; 109// given RooAbsReal as a function of a single variable using the RooFit::Evaluator.; 110class ScaledDataWeightedAverage : public RooAbsFunc {; 111public:; 112 ScaledDataWeightedAverage(RooAbsReal const &arg, RooAbsData const &data, double scaleFactor, RooAbsRealLValue &var); 113 : RooAbsFunc{1}, _var{var}, _dataWeights{data.getWeightBatch(0, data.numEntries())}, _scaleFactor{scaleFactor}; 114 {; 115 _arg = RooFit::Detail::compileForNormSet(arg, *data.get());; 116 _arg->recursiveRedirectServers(RooArgList{var});; 117 _evaluator = std::make_unique<RooFit::Evaluator>(*_arg);; 118 std::stack<std::vector<double>>{}.swap(_vectorBuffers);; 119 auto dataSpans = RooFit::BatchModeDataHelpers::getDataSpans(data, """", nullptr, /*skipZeroWeights=*/false,; 120 /*takeGlobalObservablesFromD",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Security,validat,validation," the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Testability,log,logEvalError," the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Usability,clear,clearValueDirty," the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
Availability,down,downstream,"ationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty) ? _value : getValV(normalisationSet) ;; 118#else; 119 return (_fast && !inhibitDirty()) ? _value : getValV(normalisationSet) ;; 120#endif; 121 ; 122#endif; 123 }; 124 ; 125 /// Like getVal(const RooArgSet*), but always requires an argument for normalisation.; 126 inline double getVal(const RooArgSet& normalisationSet) const {; 127 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 128 // without normalization set instead of following the `nullptr` convention.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Deployability,integrat,integrated,"nst char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty) ? _value : getValV(normalisationSet) ;; 118#else; 119 return (_fast && !inhibitDirty()) ? _value : getValV(normalisationSet) ;; 120#endif; 121 ; 122#endif; 123 }; 124 ; 125 /// Like getVal(const RooArgSet*), but always requires an argument ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Energy Efficiency,adapt,adaptors,"ntion.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set.; 131 return _fast ? _value : getValV(normalisationSet.empty() ? nullptr : &normalisationSet) ;; 132 }; 133 ; 134 virtual double getValV(const RooArgSet* normalisationSet = nullptr) const ;; 135 ; 136 double getPropagatedError(const RooFitResult &fr, const RooArgSet &nset = {}) const;; 137 ; 138 bool operator==(double value) const ;; 139 bool operator==(const RooAbsArg& other) const override;; 140 bool isIdentical(const RooAbsArg& other, bool assumeSameType=false) const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Integrability,interface,interfaces,"; 30class RooDataSet ;; 31class RooPlot;; 32class RooRealVar;; 33class RooAbsFunc;; 34class RooAbsCategoryLValue ;; 35class RooLinkedList ;; 36class RooNumIntConfig ;; 37class RooDataHist ;; 38class RooFunctor ;; 39class RooFitResult ;; 40class RooAbsMoment ;; 41class RooDerivative ;; 42class RooVectorDataStore ;; 43struct TreeReadBuffer; /// A space to attach TBranches; 44namespace RooBatchCompute {; 45struct RunContext;; 46}; 47 ; 48class TH1;; 49class TH1F;; 50class TH2F;; 51class TH3F;; 52 ; 53#include <iostream>; 54#include <list>; 55#include <map>; 56#include <string>; 57#include <sstream>; 58 ; 59class RooAbsReal : public RooAbsArg {; 60public:; 61 using value_type = double;; 62 ; 63 /// A RooAbsReal::Ref can be constructed from a `RooAbsReal&` or a `double`; 64 /// that will be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; 65 /// can be used as a replacement for `RooAbsReal&`. With this type; 66 /// definition, you can write RooFit interfaces that accept both RooAbsReal,; 67 /// or simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Modifiability,variab,variables,"ooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Performance,cache,cached,"ill be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; 65 /// can be used as a replacement for `RooAbsReal&`. With this type; 66 /// definition, you can write RooFit interfaces that accept both RooAbsReal,; 67 /// or simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Safety,unsafe,unsafe," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Testability,log,logging,"onst RooCmdArg& arg4={},; 270 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 271 const RooCmdArg& arg7={}, const RooCmdArg& arg8={},; 272 const RooCmdArg& arg9={}, const RooCmdArg& arg10={}; 273 ) const ;; 274 ; 275 ; 276 enum ScaleType { Raw, Relative, NumEvent, RelativeExpected } ;; 277 ; 278 // Fill an existing histogram; 279 TH1 *fillHistogram(TH1 *hist, const RooArgList &plotVars,; 280 double scaleFactor= 1, const RooArgSet *projectedVars= nullptr, bool scaling=true,; 281 const RooArgSet* condObs=nullptr, bool setError=true) const;; 282 ; 283 // Create 1,2, and 3D histograms from and fill it; 284 TH1 *createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const ;; 285 TH1* createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const ;; 286 TH1 *createHistogram(const char *name, const RooAbsRealLValue& xvar,; 287 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 288 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 289 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 290 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 291 ; 292 // Fill a RooDataHist; 293 RooDataHist* fillDataHist(RooDataHist *hist, const RooArgSet* nset, double scaleFactor,; 294 bool correctForBinVolume=false, bool showProgress=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Usability,simpl,simply,"; 30class RooDataSet ;; 31class RooPlot;; 32class RooRealVar;; 33class RooAbsFunc;; 34class RooAbsCategoryLValue ;; 35class RooLinkedList ;; 36class RooNumIntConfig ;; 37class RooDataHist ;; 38class RooFunctor ;; 39class RooFitResult ;; 40class RooAbsMoment ;; 41class RooDerivative ;; 42class RooVectorDataStore ;; 43struct TreeReadBuffer; /// A space to attach TBranches; 44namespace RooBatchCompute {; 45struct RunContext;; 46}; 47 ; 48class TH1;; 49class TH1F;; 50class TH2F;; 51class TH3F;; 52 ; 53#include <iostream>; 54#include <list>; 55#include <map>; 56#include <string>; 57#include <sstream>; 58 ; 59class RooAbsReal : public RooAbsArg {; 60public:; 61 using value_type = double;; 62 ; 63 /// A RooAbsReal::Ref can be constructed from a `RooAbsReal&` or a `double`; 64 /// that will be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; 65 /// can be used as a replacement for `RooAbsReal&`. With this type; 66 /// definition, you can write RooFit interfaces that accept both RooAbsReal,; 67 /// or simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
Availability,toler,tolerance,"ses |; Macros |; Typedefs |; Enumerations |; Functions |; Variables ; RooAdaptiveGaussKronrodIntegrator1D.cxx File Reference. #include <cassert>; #include <cstdlib>; #include ""TClass.h""; #include ""Riostream.h""; #include ""RooAdaptiveGaussKronrodIntegrator1D.h""; #include ""RooArgSet.h""; #include ""RooRealVar.h""; #include ""RooNumber.h""; #include ""RooNumIntFactory.h""; #include ""TMath.h""; #include ""RooMsgService.h"". Include dependency graph for RooAdaptiveGaussKronrodIntegrator1D.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  extrapolation_table;  ; struct  gsl_function_struct;  ; struct  gsl_integration_workspace;  ; struct  il_params;  ; struct  iu_params;  . Macros; #define GSL_COERCE_DBL(x)   (gsl_coerce_double(x));  ; #define GSL_DBL_EPSILON   2.2204460492503131e-16;  ; #define GSL_DBL_MAX   1.7976931348623157e+308;  ; #define GSL_DBL_MIN   2.2250738585072014e-308;  ; #define GSL_EBADTOL   13 /* user specified an invalid tolerance */;  ; #define GSL_EDIVERGE   6;  ; #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */;  ; #define GSL_EFAILED   5;  ; #define GSL_EINVAL   2;  ; #define GSL_EMAXITER   3;  ; #define GSL_ENOMEM   8 /* malloc failed */;  ; #define GSL_EROUND   7;  ; #define GSL_ERROR(a, b)   oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;;  ; #define GSL_ERROR_VAL(reason, gsl_errno, value)   return value ;;  ; #define GSL_ESING   4;  ; #define GSL_ETOL   14 /* failed to reach the specified tolerance */;  ; #define GSL_FN_EVAL(F, x)   (*((F)->function))(x,(F)->params);  ; #define GSL_MAX(a, b)   ((a) > (b) ? (a) : (b));  ; #define GSL_SUCCESS   0;  . Typedefs; typedef struct gsl_function_struct gsl_function;  ; typedef void gsl_integration_rule(const gsl_function *f, double a, double b, double *result, double *abserr, double *defabs, double *resabs);  . Enumerations; enum  { ;   GSL_INTEG_GAUSS15 = 1; , GSL_INTEG_GAUSS21 = 2",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
Deployability,update,update,"t gsl_function *f, const double a, const double b, const double epsabs, const double epsrel, const size_t limit, gsl_integration_workspace *workspace, double *result, double *abserr, gsl_integration_rule *q);  ; static void qelg (struct extrapolation_table *table, double *result, double *abserr);  ; static void qpsrt (gsl_integration_workspace *workspace);  ; static double rescale_error (double err, const double result_abs, const double result_asc);  ; static void reset_nrmax (gsl_integration_workspace *workspace);  ; static void retrieve (const gsl_integration_workspace *workspace, double *a, double *b, double *r, double *e);  ; double RooAdaptiveGaussKronrodIntegrator1D_GSL_GlueFunction (double x, void *data);  Glue function interacing to GSL code. ;  ; static void set_initial_result (gsl_integration_workspace *workspace, double result, double error);  ; static int subinterval_too_small (double a1, double a2, double b2);  ; static double sum_results (const gsl_integration_workspace *workspace);  ; static int test_positivity (double result, double resabs);  ; static void update (gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2);  . Variables; static Roo_reg_AGKInteg1D instance;  ; static const double wgA [4];  ; static const double wgB [5];  ; static const double wgC [8];  ; static const double wgD [11];  ; static const double wgE [13];  ; static const double wgF [15];  ; static const double wgkA [8];  ; static const double wgkB [11];  ; static const double wgkC [16];  ; static const double wgkD [21];  ; static const double wgkE [26];  ; static const double wgkF [31];  ; static const double xgkA [8];  ; static const double xgkB [11];  ; static const double xgkC [16];  ; static const double xgkD [21];  ; static const double xgkE [26];  ; static const double xgkF [31];  . Macro Definition Documentation. ◆ GSL_COERCE_DBL. #define GSL_COERCE_DBL; (;  ; x);    (gsl_coerce_double(x)",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
Integrability,depend,dependency,". ROOT: roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros |; Typedefs |; Enumerations |; Functions |; Variables ; RooAdaptiveGaussKronrodIntegrator1D.cxx File Reference. #include <cassert>; #include <cstdlib>; #include ""TClass.h""; #include ""Riostream.h""; #include ""RooAdaptiveGaussKronrodIntegrator1D.h""; #include ""RooArgSet.h""; #include ""RooRealVar.h""; #include ""RooNumber.h""; #include ""RooNumIntFactory.h""; #include ""TMath.h""; #include ""RooMsgService.h"". Include dependency graph for RooAdaptiveGaussKronrodIntegrator1D.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  extrapolation_table;  ; struct  gsl_function_struct;  ; struct  gsl_integration_workspace;  ; struct  il_params;  ; struct  iu_params;  . Macros; #define GSL_COERCE_DBL(x)   (gsl_coerce_double(x));  ; #define GSL_DBL_EPSILON   2.2204460492503131e-16;  ; #define GSL_DBL_MAX   1.7976931348623157e+308;  ; #define GSL_DBL_MIN   2.2250738585072014e-308;  ; #define GSL_EBADTOL   13 /* user specified an invalid tolerance */;  ; #define GSL_EDIVERGE   6;  ; #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */;  ; #define GSL_EFAILED   5;  ; #define GSL_EINVAL   2;  ; #define GSL_EMAXITER   3;  ; #define GSL_ENOMEM   8 /* malloc failed */;  ; #define GSL_EROUND   7;  ; #define GSL_ERROR(a, b)   oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;;  ; #define GSL_ERROR_VAL(reason, gsl_errno, value)   return value ;;  ; #define GSL_ESING   4;  ; #define GSL_ETOL   14 /* failed to reach the specified tolerance */;  ; #define GSL_FN_EVAL(F, x)   (*((F)->function))(x,(F)->params);  ; #define GSL_MAX(a, b)   ((a) > (b) ? (a) : (b));  ; #define GSL_SUCCESS   0;  . Typedefs; typedef struct gsl_function_struct gsl_function;  ; typedef void gsl_integration_rule(const gsl_fun",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
Availability,error,errors,"from one or more; 31 /// RooFit objects. The set will not own its contents.; 32 /// \tparam Ts Parameter pack of objects that derive from RooAbsArg or RooFit collections; or a name.; 33 /// \param arg A RooFit object.; 34 /// Note that you can also pass a `double` as first argument; 35 /// when constructing a RooArgSet, and another templated; 36 /// constructor will be used where a RooConstVar is implicitly; 37 /// created from the `double` value.; 38 /// \param moreArgsOrName Arbitrary number of; 39 /// - Further RooFit objects that derive from RooAbsArg; 40 /// - RooFit collections of such objects; 41 /// - `double`s from which a RooConstVar is implicitly created via `RooFit::RooConst`.; 42 /// - A name for the set. Given multiple names, the last-given name prevails.; 43 template<typename... Args_t>; 44 RooArgSet(const RooAbsArg& arg, Args_t &&... moreArgsOrName); 45 /*NB: Making this a delegating constructor led to linker errors with MSVC*/; 46 {; 47 // This constructor should cause a failed static_assert if any of the input; 48 // arguments is a temporary (r-value reference), which will be checked in; 49 // processArg. This works statically because of the universal reference; 50 // mechanism with templated functions.; 51 // Unfortunately, we can't check the first arg, because it's type can't be; 52 // a template parameter and hence a universal reference can't be used.; 53 // This problem is solved by introducing another templated constructor below,; 54 // which accepts a RooAbsArg && as the first argument which is forwarded to; 55 // be the second argument for this constructor.; 56 processArgs(arg, std::forward<Args_t>(moreArgsOrName)...);; 57 }; 58 ; 59 /// This constructor will provoke a `static_assert`, because passing a; 60 /// RooAbsArg as r-value reference is not allowed.; 61 template<typename... Args_t>; 62 RooArgSet(RooAbsArg && arg, Args_t &&... moreArgsOrName); 63 : RooArgSet{arg, std::move(arg), std::forward<Args_t>(moreArgsOrName)...} {}; 64 ; 65 temp",MatchSource.WIKI,doc/master/RooArgSet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooArgSet_8h_source.html
Integrability,interface,interface,"coll, const char* name="""") ;; 108 explicit RooArgSet(const char *name);; 109 ; 110 ~RooArgSet() override;; 111 TObject* clone(const char* newname) const override { return new RooArgSet(*this,newname); }; 112 TObject* create(const char* newname) const override { return new RooArgSet(newname); }; 113 RooArgSet& operator=(const RooArgSet& other) { RooAbsCollection::operator=(other) ; return *this ;}; 114 ; 115 using RooAbsCollection::operator[];; 116 RooAbsArg& operator[](const TString& str) const;; 117 ; 118 ; 119 /// Shortcut for readFromStream(std::istream&, bool, const char*, const char*, bool), setting; 120 /// `flagReadAtt` and `section` to 0.; 121 virtual bool readFromStream(std::istream& is, bool compact, bool verbose=false) {; 122 // I/O streaming interface (machine readable); 123 return readFromStream(is, compact, nullptr, nullptr, verbose) ;; 124 }; 125 bool readFromStream(std::istream& is, bool compact, const char* flagReadAtt, const char* section, bool verbose=false) ;; 126 virtual void writeToStream(std::ostream& os, bool compact, const char* section=nullptr) const;; 127 void writeToFile(const char* fileName) const ;; 128 bool readFromFile(const char* fileName, const char* flagReadAtt=nullptr, const char* section=nullptr, bool verbose=false) ;; 129 ; 130 ; 131 /// Check if this exact instance is in this collection.; 132 bool containsInstance(const RooAbsArg& var) const override {; 133 return find(var) == &var;; 134 }; 135 ; 136 static void cleanup() ;; 137 ; 138 bool isInRange(const char* rangeSpec) ;; 139 ; 140 using RooAbsCollection::selectCommon;; 141 using RooAbsCollection::snapshot;; 142 ; 143 /// Use RooAbsCollection::selectByName(), but return as RooArgSet.; 144 inline RooArgSet* selectByName(const char* nameList, bool verbose=false) const {; 145 return static_cast<RooArgSet*>(RooAbsCollection::selectByName(nameList, verbose));; 146 }; 147 ; 148 /// Use RooAbsCollection::selecCommon(), but return as RooArgSet.; 149 inline RooArgSet* selectCommon(con",MatchSource.WIKI,doc/master/RooArgSet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooArgSet_8h_source.html
Integrability,depend,dependency," Namespaces |; Macros |; Typedefs |; Functions |; Variables ; RooLagrangianMorphFunc.cxx File Reference. #include ""Riostream.h""; #include ""RooAbsCollection.h""; #include ""RooArgList.h""; #include ""RooArgProxy.h""; #include ""RooArgSet.h""; #include ""RooBinning.h""; #include ""RooDataHist.h""; #include ""RooFormulaVar.h""; #include ""RooHistFunc.h""; #include ""RooLagrangianMorphFunc.h""; #include ""RooLinearCombination.h""; #include ""RooParamHistFunc.h""; #include ""RooProduct.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooFactoryWSTool.h""; #include ""ROOT/StringUtils.hxx""; #include ""TFile.h""; #include ""TFolder.h""; #include ""TH1.h""; #include ""TMap.h""; #include ""TParameter.h""; #include ""TRandom3.h""; #include <algorithm>; #include <array>; #include <cmath>; #include <cstddef>; #include <iostream>; #include <limits>; #include <map>; #include <memory>; #include <sstream>; #include <stdexcept>; #include <type_traits>; #include <typeinfo>; #include ""TDecompLU.h"". Include dependency graph for RooLagrangianMorphFunc.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  RooLagrangianMorphFunc::CacheElem;  ; struct  is_specialization< Test, Ref >;  ; struct  is_specialization< Ref< Args... >, Ref >;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define NaN   std::numeric_limits<double>::quiet_NaN();  . Typedefs; typedef TMatrixD Matrix;  . Functions; Matrix diagMatrix (size_t n);  create a new diagonal matrix of size n ;  ; double invertMatrix (const Matrix &matrix, Matrix &inverse);  ; TMatrixD makeRootMatrix (const Matrix &in);  convert a matrix into a TMatrixD ;  ; Matrix makeSuperMatrix (const TMatrixD &in);  convert a TMatrixD into a Matrix ;  ; void printMatrix (const TMatrixD &mat);  write a matrix ;  ; template<class MatrixT > ; size_t size (const MatrixT &mat",MatchSource.WIKI,doc/master/RooLagrangianMorphFunc_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooLagrangianMorphFunc_8cxx.html
Deployability,install,installation,"tclingTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
Integrability,interface,interface,"e; 15# define R__DLLEXPORT __attribute__ ((visibility (""default""))); 16# endif; 17#endif; 18 ; 19#include ""rootclingTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingT",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
Security,inject,inject,"gTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
Availability,error,errors," gOptSink (llvm::cl::ZeroOrMore, llvm::cl::Sink, llvm::cl::desc(""Consumes all unrecognized options.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptSplit (""split"", llvm::cl::desc(""Split the dictionary into two parts: one containing the IO (ClassDef)\; information and another the interactivity support.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptSysIncludePaths (""isystem"", llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify a system include path.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptSystemModuleByproducts (""mSystemByproducts"", llvm::cl::Hidden, llvm::cl::desc(""Allow implicit build of system modules.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptUmbrellaInput (""umbrellaHeader"", llvm::cl::desc(""A single header including all headers instead of specifying them on the command line.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< VerboseLevel > gOptVerboseLevel (llvm::cl::desc(""Choose verbosity level:""), llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")), llvm::cl::init(v2), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptWDiags (""W"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify compiler diagnostics options.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptWriteEmptyRootPCM (""writeEmptyRootPCM"", llvm::cl::Hidden, llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""), llvm::cl::cat(gRootclingOptions));  ; const std::string gPathSeparator (ROOT::TMetaUtils::GetPathSeparator());  ; llvm::StringRef GrabIndex (const cling::Interpreter &interp, const clang::FieldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Deployability,update,updates,"es (std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes);  ; const std::string GenerateStringFromHeadersForClasses (const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false);  Generate a string for the dictionary from the headers-classes map. ;  ; int GenReflexMain (int argc, char **argv);  Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ;  ; const char * GetExePath ();  Returns the executable path name, used e.g. by SetRootSys(). ;  ; std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities (const std::string line);  Performance is not critical here. ;  ; size_t GetFullArrayLength (const clang::ConstantArrayType *arrayType);  ; std::string GetFwdDeclnArgsToKeepString (const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp);  ; static llvm::StringRef GetModuleNameFromRdictName (llvm::StringRef rdictName);  ; void GetMostExternalEnclosingClassName (const clang::DeclContext &theContext, std::string &ctxtName, const cling::Interpreter &interpreter, bool treatParent=true);  Extract the proper autoload key for nested classes The routine does not erase the name, just updates it. ;  ; void GetMostExternalEnclosingClassNameFromDecl (const clang::Decl &theDecl, std::string &ctxtName, const cling::Interpreter &interpreter);  ; string GetNonConstMemberName (const clang::FieldDecl &m, const string &prefix="""");  Return the name of the data member so that it can be used by non-const operation (so it includes a const_cast if necessary). ;  ; clang::QualType GetPointeeTypeIfPossible (const clang::QualType &qt);  Get the pointee type if possible. ;  ; const std::string gLibraryExtension ("".so"");  ; static llvm::cl::list< std::string > gOptBareClingSink (llvm::cl::OneOrMore, llvm::cl::Sink, llvm::cl::desc(""Consumes options and sends them to cling.""), llvm::cl::cat(gRootclingOptions), llvm::cl::sub(g",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Integrability,depend,dependency,"g/AST/CXXInheritance.h""; #include ""clang/Basic/Diagnostic.h""; #include ""clang/Frontend/CompilerInstance.h""; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Frontend/FrontendDiagnostic.h""; #include ""clang/Lex/HeaderSearch.h""; #include ""clang/Lex/Preprocessor.h""; #include ""clang/Lex/ModuleMap.h""; #include ""clang/Lex/Pragma.h""; #include ""clang/Sema/Sema.h""; #include ""clang/Serialization/ASTWriter.h""; #include ""cling/Utils/AST.h""; #include ""llvm/ADT/StringRef.h""; #include ""llvm/Support/CommandLine.h""; #include ""llvm/Support/Path.h""; #include ""llvm/Support/PrettyStackTrace.h""; #include ""llvm/Support/Signals.h""; #include ""RtypesCore.h""; #include ""TModuleGenerator.h""; #include ""TClassEdit.h""; #include ""TClingUtils.h""; #include ""RStl.h""; #include ""XMLReader.h""; #include ""LinkdefReader.h""; #include ""DictSelectionReader.h""; #include ""SelectionRules.h""; #include ""Scanner.h""; #include ""strlcpy.h""; #include ""OptionParser.h""; #include ""clang/Basic/LangOptions.def"". Include dependency graph for rootcling_impl.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  CheckModuleBuildClient;  Custom diag client for clang that verifies that each implicitly build module is a system module. More...;  ; class  tempFileNamesCatalog;  Little helper class to bookkeep the files names which we want to make temporary. More...;  ; class  TRootClingCallbacks;  . Namespaces; namespace  genreflex;  . Macros; #define ENUM_LANGOPT(Name, Type, Bits, Default, Description);  ; #define LANGOPT(Name, Bits, Default, Description)    ROOT::TMetaUtils::Info(nullptr, ""%s = %d // %s\n"", #Name, (int)LangOpts.Name, Description);;  ; #define rootclingStringify(s)   rootclingStringifyx(s);  ; #define rootclingStringifyx(s)   #s;  . Typedefs; using HeadersDeclsMap_t = std::map< std::string, std::list< std::string > >;  . Enumerations; enum  VerboseLevel { ;   v = ROOT::TMetaUtils::kError; , v0 = ROOT::TMetaUtils::kFatal; , v1 = v; , v2 = ROOT::TMetaUtils",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Modifiability,variab,variable,"le.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleDependencies (""m"", llvm::cl::desc(""The list of dependent modules of the dictionary.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleMapFiles (""moduleMapFile"", llvm::cl::desc(""Specify a C++ modulemap file.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptMultiDict (""multiDict"", llvm::cl::desc(""If this library has multiple separate LinkDef files.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoDictSelection (""noDictSelection"", llvm::cl::Hidden, llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoGlobalUsingStd (""noGlobalUsingStd"", llvm::cl::desc(""Do not declare {using namespace std} in dictionary global scope.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoIncludePaths (""noIncludePaths"", llvm::cl::desc(""Do not store include paths but rely on the env variable ROOT_INCLUDE_PATH.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptP (""p"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptPPDefines (""D"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify defined macros.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptPPUndefines (""U"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify undefined macros.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptReflex (""reflex"", llvm::cl::desc(""Behave internally like genreflex.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptRootBuild (""rootbuild"", llvm::cl::desc(""If we are building ROOT.""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< std::string > gOptRootMapFileName (""rm",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Performance,load,loaded,"::vector< std::string > &preprocDefines, const std::vector< std::string > &preprocUndefines, const std::vector< std::string > &warnings, const std::string &rootmapFileName, const std::string &rootmapLibName, bool interpreteronly, bool doSplit, bool isCxxmodule, bool writeEmptyRootPCM, bool selSyntaxOnly, bool noIncludePaths, bool noGlobalUsingStd, const std::vector< std::string > &headersNames, bool failOnWarnings, bool printRootclingInvocation, const std::string &ofilename);  ; bool IsCorrectClingArgument (const std::string &argument);  Check if the argument is a sane cling argument. ;  ; bool IsGoodForAutoParseMap (const clang::RecordDecl &rcd);  Check if the class good for being an autoparse key. ;  ; bool IsGoodLibraryName (const std::string &name);  ; bool IsImplementationName (const std::string &filename);  ; bool IsLinkdefFile (const clang::PresumedLoc &PLoc);  ; bool isPointerToPointer (const clang::FieldDecl &m);  ; bool IsSelectionFile (const char *filename);  ; bool IsSelectionXml (const char *filename);  ; bool IsSupportedClassName (const char *name);  ; void LoadLibraryMap (const std::string &fileListName, map< string, string > &autoloads);  Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ;  ; static void MaybeSuppressWin32CrashDialogs ();  ; static bool ModuleContainsHeaders (TModuleGenerator &modGen, clang::HeaderSearch &headerSearch, clang::Module *module, std::vector< std::array< std::string, 2 > > &missingHeaders);  Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ;  ; bool Namespace__HasMethod (const clang::NamespaceDecl *cl, const char *name, const cling::Interpreter &interp);  ; bool NeedsSelection (const char *name);  ; bool ParsePragmaLine (const std::string &line, const char *expectedTokens[], size_t *end=nullptr);  Check whether the #pragma line contains expectedTokens (0-terminated array). ;  ; void ParseRoot",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Safety,detect,detectedUmbrella," dictionary parsing is done and these headers cannot be selected anymore. ;  ; static llvm::cl::SubCommand gBareClingSubcommand (""bare-cling"", ""Call directly cling and exit."");  ; static bool GenerateAllDict (TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance, const std::string &currentDirectory);  Generates a PCH from the given ModuleGenerator and CompilerInstance. ;  ; int GenerateFullDict (std::ostream &dictStream, cling::Interpreter &interp, RScanner &scan, const ROOT::TMetaUtils::RConstructorTypes &ctorTypes, bool isSplit, bool isGenreflex, bool isSelXML, bool writeEmptyRootPCM);  ; static std::string GenerateFwdDeclString (const RScanner &scan, const cling::Interpreter &interp);  Generate the fwd declarations of the selected entities. ;  ; void GenerateLinkdef (llvm::cl::list< std::string > &InputFiles, std::string &code_for_parser);  ; void GenerateNecessaryIncludes (std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes);  ; const std::string GenerateStringFromHeadersForClasses (const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false);  Generate a string for the dictionary from the headers-classes map. ;  ; int GenReflexMain (int argc, char **argv);  Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ;  ; const char * GetExePath ();  Returns the executable path name, used e.g. by SetRootSys(). ;  ; std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities (const std::string line);  Performance is not critical here. ;  ; size_t GetFullArrayLength (const clang::ConstantArrayType *arrayType);  ; std::string GetFwdDeclnArgsToKeepString (const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp);  ; static llvm::StringRef GetModuleNameFromRdictName (llvm::StringRef rdictName);  ; void GetMostExternalEnclosingClassName (const clang::DeclContext &theContext, std::string &",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Security,inject,injected,"ldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data member. ;  ; static llvm::cl::OptionCategory gRootclingOptions (""rootcling common options"");  ; bool HasPath (const std::string &name);  Check if file has a path. ;  ; void genreflex::header2outputName (std::string &fileName);  Replace the extension with ""_rflx.cpp"". ;  ; void genreflex::headers2outputsNames (const std::vector< std::string > &headersNames, std::vector< std::string > &ofilesnames);  Get a proper name for the output file. ;  ; static bool IncludeHeaders (const std::vector< std::string > &headers, cling::Interpreter &interpreter);  Includes all given headers in the interpreter. ;  ; bool InheritsFromTObject (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; bool InheritsFromTSelector (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; static bool InjectModuleUtilHeader (const char *argv0, TModuleGenerator &modGen, cling::Interpreter &interp, bool umbrella);  Write the extra header injected into the module: umbrella header if (umbrella) else content header. ;  ; int genreflex::invokeManyRootCling (const std::string &verbosity, const std::string &selectionFileName, const std::string &targetLibName, bool multiDict, const std::vector< std::string > &pcmsNames, const std::vector< std::string > &includes, const std::vector< std::string > &preprocDefines, const std::vector< std::string > &preprocUndefines, const std::vector< std::string > &warnings, const std::string &rootmapFileName, const std::string &rootmapLibName, bool interpreteronly, bool doSplit, bool isCxxmodule, bool writeEmptyRootPCM, bool selSyntaxOnly, bool noIncludePaths, bool noGlobalUsingStd, const std::vector< std::string > &headersNames, bool failOnWarnings, bool printRootclingInvocation, const std::string &outputDirName_const="""");  Get the right ofilenames and invoke se",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Usability,feedback,feedback," ). Generate a string for the dictionary from the headers-classes map. ; Definition at line 3378 of file rootcling_impl.cxx. ◆ GenReflexMain(). int GenReflexMain ; (; int ; argc, . char ** ; argv . ). Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ; These are two typical genreflex and rootcling commandlines 1) genreflex header1.h [header2.h ...] [options] [preprocessor options] 2) rootcling [-v] [-v0-4] [-f] [out.cxx] [-s sharedlib.so] [-m pcmfilename] header1.h[{+,-}][!] ..headerN.h[{+,-}][!] [{LinkDef.h,selectionRules.xml}] The rules with which the arguments are translated are (1st column genreflex): –debug -v4 –quiet -v0 -o ofile positional arg after -f -s selection file Last argument of the call –fail_on_warning Wrap ROOT::TMetaUtils::Warning and throw if selected; New arguments: -l –library targetLib name (new) -s targetLib name -m pcmname (can be many -m) (new) -m pcmname (can be many -m) –rootmap -rmf (new) –rootmap-lib -rml (new); genreflex options which rise warnings (feedback is desirable) –no_membertypedefs (it should be irrelevant) –no_templatetypedefs (it should be irrelevant); genreflex options which are ignored (know for sure they are not needed) –pool, –dataonly –interpreteronly –gccxml{path,opt,post}; Exceptions The –deep option of genreflex is passed as function parameter to rootcling since it's not needed at the moment there. ; Definition at line 5608 of file rootcling_impl.cxx. ◆ GetExePath(). const char * GetExePath ; (; ). Returns the executable path name, used e.g. by SetRootSys(). ; Definition at line 196 of file rootcling_impl.cxx. ◆ GetExternalNamespaceAndContainedEntities(). std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities ; (; const std::string ; line). Performance is not critical here. ; Definition at line 2356 of file rootcling_impl.cxx. ◆ GetFullArrayLength(). size_t GetFullArrayLength ; (; const clang::ConstantArrayType * ; arrayType). Definition at li",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
Availability,error,error,"he licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include ""rootcling_impl.h""; 12#include ""rootclingCommandLineOptionsHelp.h""; 13 ; 14#include ""RConfigure.h""; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/FoundationUtils.hxx>; 17#include ""snprintf.h""; 18 ; 19#include <iostream>; 20#include <iomanip>; 21#include <memory>; 22#include <vector>; 23#include <algorithm>; 24#include <cstdio>; 25 ; 26#include <errno.h>; 27#include <string>; 28#include <list>; 29#include <sstream>; 30#include <map>; 31#include <fstream>; 32#include <sys/stat.h>; 33#include <unordered_map>; 34#include <unordered_set>; 35#include <numeric>; 36 ; 37 ; 38#ifdef _WIN32; 39#ifdef system; 40#undef system; 41#endif; 42#undef UNICODE; 43#include <windows.h>; 44#include <Tlhelp32.h> // for MAX_MODULE_NAME32; 45#include <process.h>; 46#define PATH_MAX _MAX_PATH; 47#ifdef interface; 48// prevent error coming from clang/AST/Attrs.inc; 49#undef interface; 50#endif; 51#endif; 52 ; 53#ifdef __APPLE__; 54#include <mach-o/dyld.h>; 55#endif; 56 ; 57#ifdef R__FBSD; 58#include <sys/param.h>; 59#include <sys/user.h>; 60#include <sys/types.h>; 61#include <libutil.h>; 62#include <libprocstat.h>; 63#endif // R__FBSD; 64 ; 65#if !defined(R__WIN32); 66#include <limits.h>; 67#include <unistd.h>; 68#endif; 69 ; 70 ; 71#include ""cling/Interpreter/Interpreter.h""; 72#include ""cling/Interpreter/InterpreterCallbacks.h""; 73#include ""cling/Interpreter/LookupHelper.h""; 74#include ""cling/Interpreter/Value.h""; 75#include ""clang/AST/CXXInheritance.h""; 76#include ""clang/Basic/Diagnostic.h""; 77#include ""clang/Frontend/CompilerInstance.h""; 78#include ""clang/Frontend/FrontendActions.h""; 79#include ""clang/Frontend/FrontendDiagnostic.h""; 80#include ""clang/Lex/HeaderSearch.h""; 81#include ""clang/Lex/Preprocessor.h""; 82#include ""clang/Lex/ModuleMap.h""; 83#include ""clang/Lex/Pragma.h""; 84#include """,MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Deployability,update,updates,"bName); 2177{; 2178 // If the rootmap file name does not exist, create one following the libname; 2179 // I.E. put into the directory of the lib the rootmap and within the rootmap the normalised path to the lib; 2180 if (rootmapFileName.empty()) {; 2181 size_t libExtensionPos = rootmapLibName.find_last_of(gLibraryExtension) - gLibraryExtension.size() + 1;; 2182 rootmapFileName = rootmapLibName.substr(0, libExtensionPos) + "".rootmap"";; 2183 size_t libCleanNamePos = rootmapLibName.find_last_of(gPathSeparator) + 1;; 2184 rootmapLibName = rootmapLibName.substr(libCleanNamePos, std::string::npos);; 2185 ROOT::TMetaUtils::Info(nullptr, ""Rootmap file name %s built from rootmap lib name %s"",; 2186 rootmapLibName.c_str(),; 2187 rootmapFileName.c_str());; 2188 }; 2189}; 2190 ; 2191////////////////////////////////////////////////////////////////////////////////; 2192/// Extract the proper autoload key for nested classes; 2193/// The routine does not erase the name, just updates it; 2194 ; 2195void GetMostExternalEnclosingClassName(const clang::DeclContext &theContext,; 2196 std::string &ctxtName,; 2197 const cling::Interpreter &interpreter,; 2198 bool treatParent = true); 2199{; 2200 const clang::DeclContext *outerCtxt = treatParent ? theContext.getParent() : &theContext;; 2201 // If the context has no outer context, we are finished; 2202 if (!outerCtxt) return;; 2203 // If the context is a class, we update the name; 2204 if (const clang::RecordDecl *thisRcdDecl = llvm::dyn_cast<clang::RecordDecl>(outerCtxt)) {; 2205 ROOT::TMetaUtils::GetNormalizedName(ctxtName, thisRcdDecl, interpreter);; 2206 }; 2207 // We recurse; 2208 GetMostExternalEnclosingClassName(*outerCtxt, ctxtName, interpreter);; 2209}; 2210 ; 2211////////////////////////////////////////////////////////////////////////////////; 2212 ; 2213void GetMostExternalEnclosingClassNameFromDecl(const clang::Decl &theDecl,; 2214 std::string &ctxtName,; 2215 const cling::Interpreter &interpreter); 2216{; 2217 const clang::Decl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Integrability,interface,interface,"he licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include ""rootcling_impl.h""; 12#include ""rootclingCommandLineOptionsHelp.h""; 13 ; 14#include ""RConfigure.h""; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/FoundationUtils.hxx>; 17#include ""snprintf.h""; 18 ; 19#include <iostream>; 20#include <iomanip>; 21#include <memory>; 22#include <vector>; 23#include <algorithm>; 24#include <cstdio>; 25 ; 26#include <errno.h>; 27#include <string>; 28#include <list>; 29#include <sstream>; 30#include <map>; 31#include <fstream>; 32#include <sys/stat.h>; 33#include <unordered_map>; 34#include <unordered_set>; 35#include <numeric>; 36 ; 37 ; 38#ifdef _WIN32; 39#ifdef system; 40#undef system; 41#endif; 42#undef UNICODE; 43#include <windows.h>; 44#include <Tlhelp32.h> // for MAX_MODULE_NAME32; 45#include <process.h>; 46#define PATH_MAX _MAX_PATH; 47#ifdef interface; 48// prevent error coming from clang/AST/Attrs.inc; 49#undef interface; 50#endif; 51#endif; 52 ; 53#ifdef __APPLE__; 54#include <mach-o/dyld.h>; 55#endif; 56 ; 57#ifdef R__FBSD; 58#include <sys/param.h>; 59#include <sys/user.h>; 60#include <sys/types.h>; 61#include <libutil.h>; 62#include <libprocstat.h>; 63#endif // R__FBSD; 64 ; 65#if !defined(R__WIN32); 66#include <limits.h>; 67#include <unistd.h>; 68#endif; 69 ; 70 ; 71#include ""cling/Interpreter/Interpreter.h""; 72#include ""cling/Interpreter/InterpreterCallbacks.h""; 73#include ""cling/Interpreter/LookupHelper.h""; 74#include ""cling/Interpreter/Value.h""; 75#include ""clang/AST/CXXInheritance.h""; 76#include ""clang/Basic/Diagnostic.h""; 77#include ""clang/Frontend/CompilerInstance.h""; 78#include ""clang/Frontend/FrontendActions.h""; 79#include ""clang/Frontend/FrontendDiagnostic.h""; 80#include ""clang/Lex/HeaderSearch.h""; 81#include ""clang/Lex/Preprocessor.h""; 82#include ""clang/Lex/ModuleMap.h""; 83#include ""clang/Lex/Pragma.h""; 84#include """,MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Modifiability,inherit,inherit," name of the attribute is not ""name"", add attr to the ast.; 356 BaseSelectionRule::AttributesMap_t::iterator iter;; 357 std::string userDefinedProperty;; 358 for (auto const & attr : thisClassBaseSelectionRule->GetAttributes()) {; 359 const std::string &name = attr.first;; 360 if (name == ROOT::TMetaUtils::propNames::name) continue;; 361 const std::string &value = attr.second;; 362 userDefinedProperty = name + ROOT::TMetaUtils::propNames::separator + value;; 363 if (genreflex::verbose) std::cout << "" * "" << userDefinedProperty << std::endl;; 364 CXXRD.addAttr(AnnotateAttr::CreateImplicit(C, userDefinedProperty, nullptr, 0));; 365 }; 366 }; 367 ; 368 // See if the rule is a class selection rule (FIX dynamic_cast); 369 const ClassSelectionRule *thisClassSelectionRule = reinterpret_cast<const ClassSelectionRule *>(thisClassBaseSelectionRule);; 370 ; 371 for (CXXRecordDecl::decl_iterator I = CXXRD.decls_begin(),; 372 E = CXXRD.decls_end(); I != E; ++I) {; 373 ; 374 // CXXMethodDecl,FieldDecl and VarDecl inherit from NamedDecl; 375 // See: http://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html; 376 if (!(*I)->isImplicit(); 377 && (isa<CXXMethodDecl>(*I) || isa<FieldDecl>(*I) || isa<VarDecl>(*I))) {; 378 ; 379 // For now we allow only a special macro (ClassDef) to have meaningful comments; 380 bool isClassDefMacro = TMetaUtils::HasClassDefMacro(*I, interpreter);; 381 if (isClassDefMacro) {; 382 while (isa<NamedDecl>(*I) && cast<NamedDecl>(*I)->getName() != ""DeclFileLine"") {; 383 ++I;; 384 }; 385 }; 386 ; 387 comment = ROOT::TMetaUtils::GetComment(**I, &commentSLoc);; 388 if (comment.size()) {; 389 // The ClassDef annotation is for the class itself; 390 if (isClassDefMacro) {; 391 CXXRD.addAttr(AnnotateAttr::CreateImplicit(C, comment.str(), nullptr, 0));; 392 } else if (!isGenreflex) {; 393 // Here we check if we are in presence of a selection file so that; 394 // the comment does not ends up as a decoration in the AST,; 395 // Nevertheless, w/o PCMS this has no ef",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Performance,perform,performs,"""; 93#include ""llvm/Support/Signals.h""; 94 ; 95#include ""RtypesCore.h""; 96#include ""TModuleGenerator.h""; 97#include ""TClassEdit.h""; 98#include ""TClingUtils.h""; 99#include ""RStl.h""; 100#include ""XMLReader.h""; 101#include ""LinkdefReader.h""; 102#include ""DictSelectionReader.h""; 103#include ""SelectionRules.h""; 104#include ""Scanner.h""; 105#include ""strlcpy.h""; 106 ; 107#include ""OptionParser.h""; 108 ; 109#ifdef WIN32; 110const std::string gLibraryExtension("".dll"");; 111#else; 112const std::string gLibraryExtension("".so""); // no dylib for the moment; 113#endif; 114const std::string gPathSeparator(ROOT::TMetaUtils::GetPathSeparator());; 115 ; 116#ifdef __APPLE__; 117#include <mach-o/dyld.h>; 118#endif; 119 ; 120#if defined(R__WIN32); 121#include ""cygpath.h""; 122#define strcasecmp _stricmp; 123#define strncasecmp _strnicmp; 124#else; 125#include <unistd.h>; 126#endif; 127 ; 128bool gBuildingROOT = false;; 129const ROOT::Internal::RootCling::DriverConfig* gDriverConfig = nullptr;; 130 ; 131#define rootclingStringify(s) rootclingStringifyx(s); 132#define rootclingStringifyx(s) #s; 133 ; 134// Maybe too ugly? let's see how it performs.; 135using HeadersDeclsMap_t = std::map<std::string, std::list<std::string>>;; 136 ; 137using namespace ROOT;; 138 ; 139using std::string, std::map, std::ifstream, std::ofstream, std::endl, std::ios, std::vector;; 140 ; 141namespace genreflex {; 142 bool verbose = false;; 143}; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146 ; 147static llvm::cl::OptionCategory gRootclingOptions(""rootcling common options"");; 148 ; 149 // FIXME: We should remove after removal of r flag.; 150static llvm::cl::opt<bool>; 151gOptIgnoreExistingDict(""r"",; 152 llvm::cl::desc(""Deprecated. Similar to -f but it ignores the dictionary generation. \; 153When -r is present rootcling becomes a tool to generate rootmaps (and capability files).""),; 154 llvm::cl::Hidden,; 155 llvm::cl::cat(gRootclingOptions));; 156 ; 157//////////////",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Safety,avoid,avoid,"Attr::CreateImplicit(C, comment.str(), nullptr, 0));; 392 } else if (!isGenreflex) {; 393 // Here we check if we are in presence of a selection file so that; 394 // the comment does not ends up as a decoration in the AST,; 395 // Nevertheless, w/o PCMS this has no effect, since the headers; 396 // are parsed at runtime and the information in the AST dumped by; 397 // rootcling is not relevant.; 398 (*I)->addAttr(AnnotateAttr::CreateImplicit(C, comment.str(), nullptr, 0));; 399 }; 400 }; 401 // Match decls with sel rules if we are in presence of a selection file; 402 // and the cast was successful; 403 if (isGenreflex && thisClassSelectionRule != nullptr) {; 404 const std::list<VariableSelectionRule> &fieldSelRules = thisClassSelectionRule->GetFieldSelectionRules();; 405 ; 406 // This check is here to avoid asserts in debug mode (LLVMDEV env variable set); 407 if (FieldDecl *fieldDecl = dyn_cast<FieldDecl>(*I)) {; 408 AnnotateFieldDecl(*fieldDecl, fieldSelRules);; 409 }; 410 } // End presence of XML selection file; 411 }; 412 }; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416 ; 417size_t GetFullArrayLength(const clang::ConstantArrayType *arrayType); 418{; 419 if (!arrayType); 420 return 0;; 421 llvm::APInt len = arrayType->getSize();; 422 while (const clang::ConstantArrayType *subArrayType = llvm::dyn_cast<clang::ConstantArrayType>(arrayType->getArrayElementTypeNoTypeQual())) {; 423 len *= subArrayType->getSize();; 424 arrayType = subArrayType;; 425 }; 426 return len.getLimitedValue();; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430 ; 431bool InheritsFromTObject(const clang::RecordDecl *cl,; 432 const cling::Interpreter &interp); 433{; 434 static const clang::CXXRecordDecl *TObject_decl; 435 = ROOT::TMetaUtils::ScopeSearch(""TObject"", interp, true /*diag*/, nullptr);; 436 ; 437 const clang::CXXRecordDecl *clxx = llvm::dyn_cast<clang::CXXRecordDecl>(cl);; 438 retu",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Security,inject,injected,"932 return true;; 1933 }; 1934 }; 1935 pname = """";; 1936 return false;; 1937}; 1938 ; 1939////////////////////////////////////////////////////////////////////////////////; 1940/// If the argument starts with MODULE/inc, strip it; 1941/// to make it the name we can use in `#includes`.; 1942 ; 1943const char *CopyArg(const char *original); 1944{; 1945 if (!gBuildingROOT); 1946 return original;; 1947 ; 1948 if (IsSelectionFile(original)); 1949 return original;; 1950 ; 1951 const char *inc = strstr(original, ""\\inc\\"");; 1952 if (!inc); 1953 inc = strstr(original, ""/inc/"");; 1954 if (inc && strlen(inc) > 5); 1955 return inc + 5;; 1956 return original;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Copy the command line argument, stripping MODULE/inc if; 1961/// necessary.; 1962 ; 1963void StrcpyArg(string &dest, const char *original); 1964{; 1965 dest = CopyArg(original);; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Write the extra header injected into the module:; 1970/// umbrella header if (umbrella) else content header.; 1971 ; 1972static bool InjectModuleUtilHeader(const char *argv0,; 1973 TModuleGenerator &modGen,; 1974 cling::Interpreter &interp,; 1975 bool umbrella); 1976{; 1977 std::ostringstream out;; 1978 if (umbrella) {; 1979 // This will duplicate the -D,-U from clingArgs - but as they are surrounded; 1980 // by #ifndef there is no problem here.; 1981 modGen.WriteUmbrellaHeader(out);; 1982 if (interp.declare(out.str()) != cling::Interpreter::kSuccess) {; 1983 const std::string &hdrName; 1984 = umbrella ? modGen.GetUmbrellaName() : modGen.GetContentName();; 1985 ROOT::TMetaUtils::Error(nullptr, ""%s: compilation failure (%s)\n"", argv0,; 1986 hdrName.c_str());; 1987 return false;; 1988 }; 1989 } else {; 1990 modGen.WriteContentHeader(out);; 1991 }; 1992 return true;; 1993}; 1994 ; 1995/////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Testability,test,test,"ules there are attributes and names with; 258 // which we can annotate.; 259 // We may look for a smarter algorithm.; 260 ; 261 // Nothing to do then ...; 262 if (fieldSelRules.empty()) return;; 263 ; 264 clang::ASTContext &C = decl.getASTContext();; 265 ; 266 const std::string declName(decl.getNameAsString());; 267 std::string varName;; 268 for (std::list<VariableSelectionRule>::const_iterator it = fieldSelRules.begin();; 269 it != fieldSelRules.end(); ++it) {; 270 if (! it->GetAttributeValue(propNames::name, varName)) continue;; 271 if (declName == varName) { // we have the rule!; 272 // Let's extract the attributes; 273 BaseSelectionRule::AttributesMap_t attrMap(it->GetAttributes());; 274 BaseSelectionRule::AttributesMap_t::iterator iter;; 275 std::string userDefinedProperty;; 276 for (iter = attrMap.begin(); iter != attrMap.end(); ++iter) {; 277 const std::string &name = iter->first;; 278 const std::string &value = iter->second;; 279 ; 280 if (name == propNames::name) continue;; 281 ; 282 /* This test is here since in ROOT5, when using genreflex,; 283 * for pods, iotype is ignored */; 284 ; 285 if (name == propNames::iotype &&; 286 (decl.getType()->isArrayType() || decl.getType()->isPointerType())) {; 287 const char *msg = ""Data member \""%s\"" is an array or a pointer. ""; 288 ""It is not possible to assign to it the iotype \""%s\"". ""; 289 ""This transformation is possible only with data members ""; 290 ""which are not pointers or arrays.\n"";; 291 ROOT::TMetaUtils::Error(""AnnotateFieldDecl"",; 292 msg, varName.c_str(), value.c_str());; 293 continue;; 294 }; 295 ; 296 ; 297 // These lines are here to use the root pcms. Indeed we need to annotate the AST; 298 // before persisting the ProtoClasses in the root pcms.; 299 // BEGIN ROOT PCMS; 300 if (name == propNames::comment) {; 301 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, value, nullptr, 0));; 302 }; 303 // END ROOT PCMS; 304 ; 305 if ((name == propNames::transient && value == ""true"") ||; 306 (name == propNames:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Usability,clear,clear,""");; 678 } else if (0 != keyLenMap.count(firstChar)) {; 679 unsigned int keyLen = keyLenMap.at(firstChar);; 680 keyname = line.substr(keyLen, line.length() - keyLen);; 681 CheckClassNameForRootMap(keyname, autoloads);; 682 autoloads[keyname] = libs;; 683 }; 684 }; 685 ; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Fill the map of libraries to be loaded in presence of a class; 690/// Transparently support the old and new rootmap file format; 691 ; 692void LoadLibraryMap(const std::string &fileListName, map<string, string> &autoloads); 693{; 694 std::ifstream filelist(fileListName.c_str());; 695 ; 696 std::string filename;; 697 std::string line;; 698 ; 699 while (filelist >> filename) {; 700 ; 701 if (llvm::sys::fs::is_directory(filename)) continue;; 702 ; 703 ifstream file(filename.c_str());; 704 ; 705 // Check which format is this; 706 file >> line;; 707 bool new_format = (line[0] == '[' || line[0] == '{') ;; 708 file.clear();; 709 file.seekg(0, std::ios::beg);; 710 ; 711 // Now act; 712 if (new_format) {; 713 ParseRootMapFileNewFormat(file, autoloads);; 714 } else {; 715 ParseRootMapFile(file, autoloads);; 716 }; 717 ; 718 file.close();; 719 ; 720 } // end loop on files; 721 filelist.close();; 722}; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Check if the specified operator (what) has been properly declared if the user has; 726/// requested a custom version.; 727 ; 728bool CheckInputOperator(const char *what,; 729 const char *proto,; 730 const string &fullname,; 731 const clang::RecordDecl *cl,; 732 cling::Interpreter &interp); 733{; 734 ; 735 const clang::FunctionDecl *method; 736 = ROOT::TMetaUtils::GetFuncWithProto(llvm::dyn_cast<clang::Decl>(cl->getDeclContext()), what, proto, interp,; 737 false /*diags*/);; 738 if (!method) {; 739 // This intended to find the global scope.; 740 clang::TranslationUnitDecl *TU =; 741 cl->getASTContext().getTranslationU",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
Availability,avail,available,". ROOT: ROOT files layout. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT files layout. Table of Contents; ROOTIO files; Data record types""core"" record types; ""streamer"" layer record types; ""pointer to persistent object"" object types; ""application"" layer record types. Data compression; StreamerInfo; Pointers to persistent objects; Some useful container classesTObjArray and TClonesArray; TTree. Related pages. ROOTIO files; A ROOTIO file consists of one ""file header"", one or more ""data; records,"" and zero or more ""free segments"". The file header is always at the beginning of the file, while the data records and free segments may in principle appear in any order.; The file header is fixed length (64 bytes in the current release.) It's detailed format is given in File header format.; A free segment is of variable length. One free segment is a set of contiguous bytes that are unused, and are available for ROOTIO to use for new or resized data records. The first four bytes of a a free segment contain the negative of the number of bytes in the segment. The contents of the remainder of the free segment are irrelevant.; A data record represents either user data or data used internally by ROOTIO. All data records have two portions, a ""key"" portion and a ""data"" portion. The key portion precedes the data portion. The format of the key portion is the same for all data. (The key portion corresponds to a class TKey object). The object name and they key cycle are together sufficient to uniquely determine the record within the file. The Format of a class object in DATA page describes the format of the data portion of a record for an object that uses the default streamer. Data record types. ""core"" record types; There are several types of data records used internally by ROOTIO to support the storage of byte sequences. These record types are TFile, TDirectory, ""KeysList"", and ""FreeSegments"". These types can be considered to be in the ""core"" layer o",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
Deployability,release,release,". ROOT: ROOT files layout. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT files layout. Table of Contents; ROOTIO files; Data record types""core"" record types; ""streamer"" layer record types; ""pointer to persistent object"" object types; ""application"" layer record types. Data compression; StreamerInfo; Pointers to persistent objects; Some useful container classesTObjArray and TClonesArray; TTree. Related pages. ROOTIO files; A ROOTIO file consists of one ""file header"", one or more ""data; records,"" and zero or more ""free segments"". The file header is always at the beginning of the file, while the data records and free segments may in principle appear in any order.; The file header is fixed length (64 bytes in the current release.) It's detailed format is given in File header format.; A free segment is of variable length. One free segment is a set of contiguous bytes that are unused, and are available for ROOTIO to use for new or resized data records. The first four bytes of a a free segment contain the negative of the number of bytes in the segment. The contents of the remainder of the free segment are irrelevant.; A data record represents either user data or data used internally by ROOTIO. All data records have two portions, a ""key"" portion and a ""data"" portion. The key portion precedes the data portion. The format of the key portion is the same for all data. (The key portion corresponds to a class TKey object). The object name and they key cycle are together sufficient to uniquely determine the record within the file. The Format of a class object in DATA page describes the format of the data portion of a record for an object that uses the default streamer. Data record types. ""core"" record types; There are several types of data records used internally by ROOTIO to support the storage of byte sequences. These record types are TFile, TDirectory, ""KeysList"", and ""FreeSegments"". These types can be considered to be in the ""core"" layer o",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
Energy Efficiency,allocate,allocated,"rray, and a separate ""fUniqueID"" value for each reference. For further information, see the above URL. Some useful container classes. TObjArray and TClonesArray; The TObjArray class can be used to support an array of objects. The objects need not be of the same type, but each object must be of a class type that inherits from TObject. We have already seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used to hold an array of TStreamerElement objects, each of which is of a class inheriting from TStreamerElement, which in turn inherits from TObject.; The TClonesArray class is a specialization of the TObjArray class for holding an array of objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
Modifiability,variab,variable,". ROOT: ROOT files layout. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT files layout. Table of Contents; ROOTIO files; Data record types""core"" record types; ""streamer"" layer record types; ""pointer to persistent object"" object types; ""application"" layer record types. Data compression; StreamerInfo; Pointers to persistent objects; Some useful container classesTObjArray and TClonesArray; TTree. Related pages. ROOTIO files; A ROOTIO file consists of one ""file header"", one or more ""data; records,"" and zero or more ""free segments"". The file header is always at the beginning of the file, while the data records and free segments may in principle appear in any order.; The file header is fixed length (64 bytes in the current release.) It's detailed format is given in File header format.; A free segment is of variable length. One free segment is a set of contiguous bytes that are unused, and are available for ROOTIO to use for new or resized data records. The first four bytes of a a free segment contain the negative of the number of bytes in the segment. The contents of the remainder of the free segment are irrelevant.; A data record represents either user data or data used internally by ROOTIO. All data records have two portions, a ""key"" portion and a ""data"" portion. The key portion precedes the data portion. The format of the key portion is the same for all data. (The key portion corresponds to a class TKey object). The object name and they key cycle are together sufficient to uniquely determine the record within the file. The Format of a class object in DATA page describes the format of the data portion of a record for an object that uses the default streamer. Data record types. ""core"" record types; There are several types of data records used internally by ROOTIO to support the storage of byte sequences. These record types are TFile, TDirectory, ""KeysList"", and ""FreeSegments"". These types can be considered to be in the ""core"" layer o",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
Performance,perform,performance,"n, objects that are referenced by such a pointer have an additional field in the base TObject. See Format of the DATA for a TObject object. A description of how these pointers work is given under the Pointers to persistent objects heading below. ""application"" layer record types; These are either user defined record types, or record types supplied by ROOT that are not needed by ROOTIO. The format of such an object that uses the default streamer is shown in Format of a class object in DATA. Data compression; The user can set the data compression level for new or modified data records when creating or opening a file. When an existing file is opened for update, the compression level selected need not match that used previously. The compression level of existing records is not modified unless the record itself is modified.; There are ten compression levels, 0-9, ranging from 0 (no compression) to 9 (maximum compression), with level 1 being the default. The level chosen is a tradeoff between disk space and compression performance. The decompression speed is independent of level. Currently, in release 3.2.6, level 2 is not used. If level 2 is selected, level 1 is used with no notification to the user.; The chosen compression level is not applied to the entire file. The following portions of the file are not compressed, regardless of the compression level selected:. the file header; the KeysList data record; the FreeSegments data record; any data record (outside of a TTree) where the uncompressed size of the data portion is 256 bytes or less.; the key portion of any data record. Furthermore, the data portion of the StreamerInfo data record is always compressed at level 1 (if over 256 bytes uncompressed), regardless of the compression level selected (even if no compression is selected).; The compression algorithm used is an in memory ZIP compression written for the DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino). The source code is internal to ROOTIO.",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
Safety,avoid,avoids,"s an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated s",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
Usability,simpl,simple," selected (even if no compression is selected).; The compression algorithm used is an in memory ZIP compression written for the DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino). The source code is internal to ROOTIO. StreamerInfo; The ""StreamerInfo"" data record is used by ROOTIO to support the storage of self-identifying objects. Its detailed format is given in Format of StreamerInfo record. A ROOTIO file contains exactly one StreamerInfo record, which is written to disk automatically when a new or modified file is closed.; The StreamerInfo record is a list (ROOTIO class TList) of ""StreamerInfo"" objects (ROOTIO class TStreamerInfo). There is one StreamerInfo object in the list for every class used in the file in a data record, other than a core layer record. There is no streamerinfo object for a class used in a core layer record unless the class is also used elsewhere in a data record. When reading a self-identifying object from a file, the system uses the StreamerInfo list to decompose the object recursively into its simple data members.; Each streamerinfo object is an array of ""streamer element"" objects, each of which describes a base class of the object or a (non-static and non-transient) data member of the object. If the base class or data member is itself a class, then there will also be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a p",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
Integrability,depend,dependency,". ROOT: bindings/r/tests/ROOTR.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; ROOTR.C File Reference. #include <TRInterface.h>. Include dependency graph for ROOTR.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Double_t myFunc (Double_t x);  ; void ROOTR ();  . Function Documentation. ◆ myFunc(). Double_t myFunc ; (; Double_t ; x). Definition at line 4 of file ROOTR.C. ◆ ROOTR(). void ROOTR ; (; ). Definition at line 9 of file ROOTR.C. bindingsrtestsROOTR.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ROOTR_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ROOTR_8C.html
