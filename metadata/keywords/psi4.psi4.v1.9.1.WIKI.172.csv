id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:20404,Energy Efficiency,energy,energy,20404," module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.ge",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:21961,Energy Efficiency,energy,energy,21961,"nagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); #",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:22731,Energy Efficiency,energy,energy,22731,"ect_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in [''",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:25012,Energy Efficiency,energy,energy,25012," selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:25791,Energy Efficiency,energy,energy,25791,"adient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:27690,Energy Efficiency,energy,energy,27690,"be', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CI",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:28686,Energy Efficiency,energy,energy,28686,"SD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Conside",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:29451,Energy Efficiency,energy,energy,29451,""" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:30455,Energy Efficiency,energy,energy,30455,"a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.addons(""adcc""):; func = run_adcc; elif module in {'BUILTIN', ''}:; func = run_adc. if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['ADCC', ''] and extras.addons(""adcc""):; func = run_adcc. # Note: ROHF is theoretically available in adcc, but are not fully tested; # ... so will be added later. if",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:36171,Energy Efficiency,charge,charges,36171," to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs: ; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external po",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:36309,Energy Efficiency,charge,charge,36309,"tionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs: ; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:36731,Energy Efficiency,charge,charge,36731,"al EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). for frag, frag_qxyz in external_potential.items():; if frag.upper() in ""ABC"":; chrgfield = QMMMbohr(); for qxyz in frag_qxyz:; chrgfield.extern.addCharge(*validate_qxyz(qxyz)). wfn.set_potential_variable(frag.upper(), chrgfield.extern); total_external_potential.appendCharges(chrgfield.extern.getCharges()). else:; core.print_out(""\n Warning! Unknown key for the external_potentials argument: %s"" % fra",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:45162,Energy Efficiency,Energy,Energy,45162,"tion('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(ref_wfn). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:49565,Energy Efficiency,Energy,Energy,49565,"asisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for ob",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:50617,Energy Efficiency,ENERGY,ENERGY,50617," 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:50660,Energy Efficiency,ENERGY,ENERGY,50660," 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:50678,Energy Efficiency,ENERGY,ENERGY,50678," 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:50706,Energy Efficiency,ENERGY,ENERGY,50706," 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60479,Energy Efficiency,ENERGY,ENERGY,60479," """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_t",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60521,Energy Efficiency,ENERGY,ENERGY,60521,"n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60568,Energy Efficiency,ENERGY,ENERGY,60568," ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60611,Energy Efficiency,ENERGY,ENERGY,60611,"Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_loc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60656,Energy Efficiency,ENERGY,ENERGY,60656,"= core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5');",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60701,Energy Efficiency,ENERGY,ENERGY,60701," ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TY",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:76121,Energy Efficiency,energy,energy,76121,"ocal_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:77996,Energy Efficiency,energy,energy,77996,"component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.s",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:78576,Energy Efficiency,ENERGY,ENERGY,78576,"t_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_ener",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:78715,Energy Efficiency,ENERGY,ENERGY,78715,"core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:78966,Energy Efficiency,ENERGY,ENERGY,78966,"**kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssupe",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79042,Energy Efficiency,ENERGY,ENERGY,79042,"nctional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().ite",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79131,Energy Efficiency,ENERGY,ENERGY,79131,"core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT '",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79248,Energy Efficiency,ENERGY,ENERGY,79248,"-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79380,Energy Efficiency,ENERGY,ENERGY,79380,"s_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_va",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79448,Energy Efficiency,ENERGY,ENERGY,79448,"ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSI",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79523,Energy Efficiency,ENERGY,ENERGY,79523,"= dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variab",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79623,Energy Efficiency,Energy,Energy,79623,"mp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variabl",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79744,Energy Efficiency,Energy,Energy,79744,"leading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); sc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79901,Energy Efficiency,energy,energy,79901,"D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80312,Energy Efficiency,ENERGY,ENERGY,80312,"f_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional""",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80336,Energy Efficiency,ENERGY,ENERGY,80336,"f_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional""",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80356,Energy Efficiency,ENERGY,ENERGY,80356,"f_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional""",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80455,Energy Efficiency,ENERGY,ENERGY,80455,"TAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80505,Energy Efficiency,ENERGY,ENERGY,80505,"fn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80548,Energy Efficiency,ENERGY,ENERGY,80548,"; scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is N",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80599,Energy Efficiency,ENERGY,ENERGY,80599,"t('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80643,Energy Efficiency,ENERGY,ENERGY,80643,"' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'C",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80687,Energy Efficiency,ENERGY,ENERGY,80687,"' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasat",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80725,Energy Efficiency,ENERGY,ENERGY,80725,"ut(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad =",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80766,Energy Efficiency,ENERGY,ENERGY,80766,"' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80804,Energy Efficiency,ENERGY,ENERGY,80804,"(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80857,Energy Efficiency,ENERGY,ENERGY,80857,"h)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad =",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80901,Energy Efficiency,ENERGY,ENERGY,80901,"tal energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(gra",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80952,Energy Efficiency,ENERGY,ENERGY,80952,"re.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", g",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80989,Energy Efficiency,ENERGY,ENERGY,80989," for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85472,Energy Efficiency,ENERGY,ENERGY,85472,"rithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfm",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85511,Energy Efficiency,ENERGY,ENERGY,85511,"not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85566,Energy Efficiency,ENERGY,ENERGY,85566,"se ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION E",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85611,Energy Efficiency,ENERGY,ENERGY,85611,"ce.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86144,Energy Efficiency,ENERGY,ENERGY,86144,"MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD');",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86189,Energy Efficiency,ENERGY,ENERGY,86189,"); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86242,Energy Efficiency,ENERGY,ENERGY,86242,". dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86288,Energy Efficiency,ENERGY,ENERGY,86288,"fn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_opti",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86334,Energy Efficiency,ENERGY,ENERGY,86334,"grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_lo",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86374,Energy Efficiency,ENERGY,ENERGY,86374,"dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86417,Energy Efficiency,ENERGY,ENERGY,86417,"NT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_op",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86457,Energy Efficiency,ENERGY,ENERGY,86457,"iable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86512,Energy Efficiency,ENERGY,ENERGY,86512," TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); co",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86558,Energy Efficiency,ENERGY,ENERGY,86558,"RENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCS",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:88643,Energy Efficiency,energy,energy,88643,", 'WFN', 'CCSD_AT'); core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_AT'); elif name == 'cc2':; core.set_local_option('TRANSQT2', 'WFN', 'CC2'); core.set_local_option('CCSORT', 'WFN', 'CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'CC2'); core.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; core.set_local_option('TRANSQT2', 'WFN', 'CC3'); core.set_local_option('CCSORT', 'WFN', 'CC3'); core.set_local_option('CCTRANSORT', 'WFN', 'CC3'); core.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option(""CC_TYPE"") == ""DF"":; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (core.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driv",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105344,Energy Efficiency,ENERGY,ENERGY,105344,"on_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105387,Energy Efficiency,ENERGY,ENERGY,105387,"tion('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calcu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105442,Energy Efficiency,ENERGY,ENERGY,105442,"/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computi",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105491,Energy Efficiency,ENERGY,ENERGY,105491,"ype (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105555,Energy Efficiency,ENERGY,ENERGY,105555,"_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = [",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105594,Energy Efficiency,ENERGY,ENERGY,105594,"or('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPO",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105649,Energy Efficiency,ENERGY,ENERGY,105649," properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties =",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105694,Energy Efficiency,ENERGY,ENERGY,105694,"util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in prope",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:111645,Energy Efficiency,energy,energy,111645," core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc_deprecated(*args, **kwargs):; warnings.warn(""The method 'adc' has been deprecated, please use 'adc2' instead.""; ""The method key 'adc' will be removed Psi4 1.6."", DeprecationWarning); return select_adc2(*args, **kwargs). def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). warnings.warn(""Using built-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117438,Energy Efficiency,energy,energy,117438,"ng interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""C",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117737,Energy Efficiency,energy,energy,117737,"(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_v",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117863,Energy Efficiency,energy,energy,117863,"reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117903,Energy Efficiency,Energy,Energy,117903,"s ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:117947,Energy Efficiency,energy,energy,117947,"""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118049,Energy Efficiency,energy,energy,118049,"t_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.ex",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118098,Energy Efficiency,energy,energy,118098,"?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118151,Energy Efficiency,ENERGY,ENERGY,118151," not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excit",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118160,Energy Efficiency,energy,energy,118160," not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excit",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118208,Energy Efficiency,ENERGY,ENERGY,118208,"oper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{met",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118220,Energy Efficiency,energy,energy,118220,"); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index}",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118254,Energy Efficiency,Energy,Energy,118254,"n.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.exci",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118284,Energy Efficiency,energy,energy,118284,"n.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.exci",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118325,Energy Efficiency,Energy,Energy,118325,"fn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROO",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118418,Energy Efficiency,ENERGY,ENERGY,118418,"(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.prin",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118478,Energy Efficiency,ENERGY,ENERGY,118478,"a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:119005,Energy Efficiency,ENERGY,ENERGY,119005," state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(toleran",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:119131,Energy Efficiency,ENERGY,ENERGY,119131,"y; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k,",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:119243,Energy Efficiency,ENERGY,ENERGY,119243,"ergy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:119355,Energy Efficiency,ENERGY,ENERGY,119355,"15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things availabl",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:125263,Energy Efficiency,ENERGY,ENERGY,125263,"able(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"")",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:125350,Energy Efficiency,ENERGY,ENERGY,125350,", data); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN)""",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:125431,Energy Efficiency,ENERGY,ENERGY,125431,"; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRE",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:125504,Energy Efficiency,ENERGY,ENERGY,125504,"oot_index} ""; ""ROTATORY STRENGTH (VEL)"", data); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ROTATORY STRENGTH (VEL) - A TRANSITION"", data). if ""DIPOLE"" in properties:; data = excitation.state_dipole_moment; props[""State dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} DIPOLE MOMENT - A TRANSITION"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (A) DIPOLE MOMENT"", data_mat); adc_wfn.set_variable(f""{method} ROOT {root_index} (IN A) DIPOLE MOMENT"", data_mat). computed.append(props). # for Psivar scraper; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - h TRANSITION"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (IN i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n (i) DIPOLE MOMENT"") # P::e ADC; # wfn.set_array_variable(""ADC ROOT n DIPOLE MOMENT - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (LEN)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (LEN)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:130525,Energy Efficiency,ENERGY,ENERGY,130525,"e == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_opti",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:130559,Energy Efficiency,ENERGY,ENERGY,130559,"'DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132261,Energy Efficiency,ENERGY,ENERGY,132261,"s):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn',",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132304,Energy Efficiency,ENERGY,ENERGY,132304,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132359,Energy Efficiency,ENERGY,ENERGY,132359,". """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.ge",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132408,Energy Efficiency,ENERGY,ENERGY,132408,"SIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132472,Energy Efficiency,ENERGY,ENERGY,132472,"obal_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_g",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132511,Energy Efficiency,ENERGY,ENERGY,132511,"t_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the w",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132566,Energy Efficiency,ENERGY,ENERGY,132566,"ut("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(re",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132611,Energy Efficiency,ENERGY,ENERGY,132611,"). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:135655,Energy Efficiency,ENERGY,ENERGY,135655,"_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Alg",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:136037,Energy Efficiency,ENERGY,ENERGY,136037,"_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=Tru",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:136215,Energy Efficiency,ENERGY,ENERGY,136215,"_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137842,Energy Efficiency,ENERGY,ENERGY,137842,"\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_opt",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137888,Energy Efficiency,ENERGY,ENERGY,137888,"""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137946,Energy Efficiency,ENERGY,ENERGY,137946,"n is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137998,Energy Efficiency,ENERGY,ENERGY,137998,"); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138071,Energy Efficiency,ENERGY,ENERGY,138071,"ified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variab",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138113,Energy Efficiency,ENERGY,ENERGY,138113,"ymbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). ret",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138171,Energy Efficiency,ENERGY,ENERGY,138171,"MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138219,Energy Efficiency,ENERGY,ENERGY,138219,"""""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:143011,Energy Efficiency,ENERGY,ENERGY,143011," in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mon",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:143653,Energy Efficiency,ENERGY,ENERGY,143653," 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:144198,Energy Efficiency,ENERGY,ENERGY,144198,"') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:144248,Energy Efficiency,ENERGY,ENERGY,144248," 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+3', 'sapt2+3",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147404,Energy Efficiency,ENERGY,ENERGY,147404,"asis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147529,Energy Efficiency,ENERGY,ENERGY,147529,"core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule());",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147591,Energy Efficiency,ENERGY,ENERGY,147591,"basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use m",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147679,Energy Efficiency,ENERGY,ENERGY,147679,"IS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147746,Energy Efficiency,ENERGY,ENERGY,147746,"global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147786,Energy Efficiency,ENERGY,ENERGY,147786,"_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_su",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147821,Energy Efficiency,ENERGY,ENERGY,147821,"sis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('mono",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:148042,Energy Efficiency,charge,charge-transfer,148042,"port sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:152210,Energy Efficiency,Charge,Charge,152210," True); elif name == 'sapt2+(3)(ccd)-ct':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name == 'sapt2+3(ccd)-ct':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', True); core.set_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ----------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:152572,Energy Efficiency,ENERGY,ENERGY,152572,"t_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:152939,Energy Efficiency,ENERGY,ENERGY,152939,"x_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_chang",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:153081,Energy Efficiency,Charge,Charge,153081,"_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is Non",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:153521,Energy Efficiency,Charge,Charge,153521,"_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of mole",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:153653,Energy Efficiency,ENERGY,ENERGY,153653,"er Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sa",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:156444,Energy Efficiency,ENERGY,ENERGY,156444,"T""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not N",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159439,Energy Efficiency,energy,energy,159439,"threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159614,Energy Efficiency,ENERGY,ENERGY,159614,"_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159665,Energy Efficiency,ENERGY,ENERGY,159665,"on('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159802,Energy Efficiency,ENERGY,ENERGY,159802,":; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_typ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159856,Energy Efficiency,ENERGY,ENERGY,159856,"fsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:160811,Energy Efficiency,energy,energy,160811,", ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_B",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:164260,Energy Efficiency,energy,energy,164260,"F_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). core.set_local_option('FNOCC', 'DFCC', False); core.set_local_option('FNOCC', 'RUN_CEPA', False); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); core.set_local_o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168467,Energy Efficiency,energy,energy,168467,"vefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168484,Energy Efficiency,energy,energy,168484,"vefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168586,Energy Efficiency,ENERGY,ENERGY,168586," C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168625,Energy Efficiency,ENERGY,ENERGY,168625,"OCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CE",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168680,Energy Efficiency,ENERGY,ENERGY,168680,"been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CE",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168725,Energy Efficiency,ENERGY,ENERGY,168725,"ion('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168812,Energy Efficiency,ENERGY,ENERGY,168812,"sis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168856,Energy Efficiency,ENERGY,ENERGY,168856," core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cep",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168911,Energy Efficiency,ENERGY,ENERGY,168911,"S_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168961,Energy Efficiency,ENERGY,ENERGY,168961,"obal_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', '",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169038,Energy Efficiency,ENERGY,ENERGY,169038," ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_op",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169077,Energy Efficiency,ENERGY,ENERGY,169077,"_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169132,Energy Efficiency,ENERGY,ENERGY,169132,"ISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169177,Energy Efficiency,ENERGY,ENERGY,169177,"sisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169447,Energy Efficiency,energy,energy,169447,"t correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:176732,Energy Efficiency,ENERGY,ENERGY,176732,"rgs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:176856,Energy Efficiency,ENERGY,ENERGY,176856,"rgs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:176915,Energy Efficiency,ENERGY,ENERGY,176915,"rgs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:176972,Energy Efficiency,ENERGY,ENERGY,176972,"rgs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:177038,Energy Efficiency,ENERGY,ENERGY,177038,"rgs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:177089,Energy Efficiency,ENERGY,ENERGY,177089,"rgs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:1873,Integrability,wrap,wrappers,1873,"se for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError(['select_scf_gradient', name, 'SCF_TYPE'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:2649,Integrability,message,message,2649,"files as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError(['select_scf_gradient', name, 'SCF_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:12357,Integrability,rout,route,12357,"al_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:30164,Integrability,rout,route,30164,"NV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.a",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:30941,Integrability,rout,routine,30941,"= run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.addons(""adcc""):; func = run_adcc; elif module in {'BUILTIN', ''}:; func = run_adc. if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['ADCC', ''] and extras.addons(""adcc""):; func = run_adcc. # Note: ROHF is theoretically available in adcc, but are not fully tested; # ... so will be added later. if func is None:; raise ManagedMethodError(['select_adc2', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_disp_functor(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; superfunc, disp_type = dft.build_superfunctional(name, r",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:46242,Integrability,rout,routine,46242,"n Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.bas",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:88750,Integrability,rout,routine,88750,"ore.set_local_option('CCSORT', 'WFN', 'CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'CC2'); core.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; core.set_local_option('TRANSQT2', 'WFN', 'CC3'); core.set_local_option('CCSORT', 'WFN', 'CC3'); core.set_local_option('CCTRANSORT', 'WFN', 'CC3'); core.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option(""CC_TYPE"") == ""DF"":; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (core.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:92113,Integrability,rout,routine,92113,"IENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_M",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:112110,Integrability,interface,interface,112110,"rad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc_deprecated(*args, **kwargs):; warnings.warn(""The method 'adc' has been deprecated, please use 'adc2' instead.""; ""The method key 'adc' will be removed Psi4 1.6."", DeprecationWarning); return select_adc2(*args, **kwargs). def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). warnings.warn(""Using built-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not a",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:112528,Integrability,interface,interface,112528,"grammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). warnings.warn(""Using built-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116436,Integrability,interface,interface,116436," ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations i",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116473,Integrability,interface,interface,116473," ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations i",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159123,Integrability,message,message,159123," for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159244,Integrability,message,message,159244,".print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return t",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:51439,Modifiability,variab,variable,51439,"f_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # reta",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:54670,Modifiability,variab,variables,54670,"ionError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.variables().items():; core.set_variable(k, v). return dct_wfn. def run_dct_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in co",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:55795,Modifiability,variab,variables,55795," of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60205,Modifiability,variab,variables,60205,"et('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need D",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60310,Modifiability,variab,variables,60310,"wargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60493,Modifiability,variab,variables,60493,"n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60582,Modifiability,variab,variables,60582,"Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_loc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:64662,Modifiability,variab,variables,64662,"se:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:64774,Modifiability,variab,variables,64774,"ot make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:66968,Modifiability,variab,variables,66968," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a referen",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:67044,Modifiability,variab,variables,67044," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a referen",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:67182,Modifiability,variab,variables,67182,"nflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wf",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:74062,Modifiability,variab,variables,74062,"_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:74228,Modifiability,variab,variables,74228,"':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.s",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:74282,Modifiability,variab,variables,74282,"re.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_loc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:76798,Modifiability,variab,variables,76798," name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:76964,Modifiability,variab,variables,76964,"r(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwarg",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:77018,Modifiability,variab,variables,77018,"('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.funct",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:78539,Modifiability,variab,variable,78539,"t_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_ener",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:78689,Modifiability,variab,variable,78689,"core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:78816,Modifiability,variab,variables,78816,"if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlatio",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:79188,Modifiability,variab,variables,79188,"IT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.d",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80010,Modifiability,variab,variables,80010," DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variable",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80125,Modifiability,variab,variables,80125," SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80400,Modifiability,variab,variable,80400,"lse:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name,",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80423,Modifiability,variab,variable,80423,"TAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80522,Modifiability,variab,variable,80522,"; scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is N",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80567,Modifiability,variab,variable,80567,"t('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80660,Modifiability,variab,variable,80660,"' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasat",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80706,Modifiability,variab,variable,80706,"ut(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad =",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80783,Modifiability,variab,variable,80783,"(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80874,Modifiability,variab,variable,80874,"tal energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(gra",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:80969,Modifiability,variab,variable,80969," for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:81008,Modifiability,variab,variables,81008,"):; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOT",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:81057,Modifiability,variab,variables,81057,"# Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten l",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:82188,Modifiability,variab,variables,82188,"""""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P:",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:82237,Modifiability,variab,variables,82237," module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().nee",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:83433,Modifiability,variab,variables,83433,"h = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:83482,Modifiability,variab,variables,83482,"al(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85346,Modifiability,variab,variables,85346,"has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variab",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85491,Modifiability,variab,variable,85491,"not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85585,Modifiability,variab,variable,85585,"ce.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:85644,Modifiability,variab,variables,85644,"ference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86163,Modifiability,variab,variable,86163,"); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86210,Modifiability,variab,variable,86210,". dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86307,Modifiability,variab,variable,86307,"grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_lo",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86355,Modifiability,variab,variable,86355,"dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86436,Modifiability,variab,variable,86436,"iable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86531,Modifiability,variab,variable,86531,"RENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCS",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86577,Modifiability,variab,variables,86577," CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN',",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:86628,Modifiability,variab,variables,86628,"dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_AT'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:89971,Modifiability,variab,variables,89971,"x_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (core.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(cc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:93011,Modifiability,variab,variable,93011,"aise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, cor",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:93054,Modifiability,variab,variable,93054,"e %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:94633,Modifiability,variab,variables,94633,"CF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in respo",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:94678,Modifiability,variab,variables,94678,"list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.a",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:96848,Modifiability,variab,variable,96848,"ties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited =",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:102714,Modifiability,variab,variables,102714," if n_one > 0:; # ==> Initialize OEProp <==; oe = core.OEProp(ccwfn); for oe_prop_name in one:; oe.add(oe_prop_name.upper()); # ==> OEProp for the ground state <==; # TODO: When Psi is Py 3.9+, transition to the removeprefix version.; title = name.upper().replace(""EOM-"", """"); #title = name.upper().removeprefix(""EOM-""); oe.set_title(title); set_of_names = {title + "" {}"", ""CC {}""}; if name.startswith(""eom""):; gs_h = 0; for h, i in enumerate(ccwfn.soccpi()):; if i % 2:; gs_h = gs_h ^ h; ct = ccwfn.molecule().point_group().char_table(); total_h_lbl = ct.gamma(0).symbol(); gs_h_lbl = ct.gamma(gs_h).symbol(); set_of_names.update({title + "" ROOT 0 {}"", ""CC ROOT 0 {}"",; f""{title} ROOT 0 {{}} - {total_h_lbl} TRANSITION"",; f""CC ROOT 0 {{}} - {total_h_lbl} TRANSITION"",; f""{title} ROOT 0 ({gs_h_lbl}) {{}}"", f""CC ROOT 0 ({gs_h_lbl}) {{}}"",; f""{title} ROOT 0 (IN {gs_h_lbl}) {{}}"", f""CC ROOT 0 (IN {gs_h_lbl}) {{}}""}); oe.set_names(set_of_names); oe.compute(); print(ccwfn.variables()); # ==> OEProp for Excited States <==; if name.startswith('eom'):; n_root_pi = core.get_global_option(""ROOTS_PER_IRREP""); for h in range(ccwfn.nirrep()):; root_h_lbl = ct.gamma(h).symbol(); trans_h_lbl = ct.gamma(h ^ gs_h).symbol(); # Don't forget to count the ground state!; for i in range(n_root_pi[h]):; if h == gs_h: i += 1; root_title = title + f"" ROOT {i} (IN {root_h_lbl})""; oe.set_title(root_title); total_idx = ccwfn.total_index(i, h); set_of_names = {f""{title} ROOT {total_idx} {{}}"", f""CC ROOT {total_idx} {{}}"",; f""{title} ROOT {total_idx} {{}} - {trans_h_lbl} TRANSITION"",; f""CC ROOT {total_idx} {{}} - {trans_h_lbl} TRANSITION"",; f""{title} ROOT {total_idx} ({root_h_lbl}) {{}}"", f""CC ROOT {total_idx} ({root_h_lbl}) {{}}"",; f""{title} ROOT {i} (IN {root_h_lbl}) {{}}"", f""CC ROOT {i} (IN {root_h_lbl}) {{}}""}; oe.set_names(set_of_names); Da = ccwfn.get_density(root_title + "" ALPHA""); oe.set_Da_so(Da); if not ccwfn.same_a_b_dens():; Db = ccwfn.get_density(root_title + "" BETA""); oe.set_Db_so(Db); oe.compu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105363,Modifiability,variab,variable,105363,"tion('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calcu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105461,Modifiability,variab,variable,105461,"ype (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105574,Modifiability,variab,variable,105574,"or('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPO",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105668,Modifiability,variab,variable,105668,"util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in prope",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105868,Modifiability,variab,variables,105868,"se, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:105919,Modifiability,variab,variables,105919,"ified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Comp",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:106355,Modifiability,config,configuration,106355," dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_pro",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:120012,Modifiability,variab,variables,120012,"tion_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_pr",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:120061,Modifiability,variab,variables,120061,"f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Star",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:127608,Modifiability,variab,variables,127608,"# wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:127657,Modifiability,variab,variables,127657,"OOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; core.set_local_option('",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:127837,Modifiability,config,configuration,127837,"ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level = 4;",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:130258,Modifiability,variab,variables,130258," 2); elif name == 'fci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function e",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:130305,Modifiability,variab,variables,130305,"_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module cal",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:130506,Modifiability,variab,variable,130506,"e == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_opti",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:130541,Modifiability,variab,variable,130541,"'DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:131104,Modifiability,variab,variable,131104,"files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_bas",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132280,Modifiability,variab,variable,132280,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132378,Modifiability,variab,variable,132378,"SIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132491,Modifiability,variab,variable,132491,"t_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the w",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132585,Modifiability,variab,variable,132585,"). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132630,Modifiability,variab,variables,132630,"tion is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:132681,Modifiability,variab,variables,132681,"'ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:134544,Modifiability,extend,extend,134544,"le(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:134745,Modifiability,extend,extend,134745,". # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sor",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:136142,Modifiability,variab,variable,136142,"rtree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPN",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137864,Modifiability,variab,variable,137864,"""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137968,Modifiability,variab,variable,137968,"); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138093,Modifiability,variab,variable,138093,"ymbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). ret",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138193,Modifiability,variab,variable,138193,"""""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138238,Modifiability,variab,variables,138238,"if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:138292,Modifiability,variab,variables,138292," != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:139015,Modifiability,variab,variables,139015," dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:139065,Modifiability,variab,variables,139065,"ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Sh",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:139718,Modifiability,variab,variables,139718,"wargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:139768,Modifiability,variab,variables,139768," written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:140075,Modifiability,variab,variables,140075,"ariable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:140128,Modifiability,variab,variables,140128,"un_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; co",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:140557,Modifiability,variab,variables,140557,"n('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); mono",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:140610,Modifiability,variab,variables,140610,"al_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(mono",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:142985,Modifiability,variab,variable,142985," in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mon",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:143627,Modifiability,variab,variable,143627," 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:144172,Modifiability,variab,variable,144172,"') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147546,Modifiability,variab,variable,147546,"ASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Wa",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147696,Modifiability,variab,variable,147696,"tion(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_uti",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:147800,Modifiability,variab,variable,147800,"sis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('mono",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:152554,Modifiability,variab,variable,152554,"t_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:152921,Modifiability,variab,variable,152921,"x_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_chang",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:156424,Modifiability,variab,variable,156424,"T""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not N",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:157117,Modifiability,variab,variables,157117,"return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy into ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:163979,Modifiability,variab,variables,163979,"onError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). core.set_local_option('FNOCC', 'DFCC', False); core.set_local_option('FNOCC', 'RUN_CEPA', False); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:164030,Modifiability,variab,variables,164030,"of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). core.set_local_option('FNOCC', 'DFCC', False); core.set_local_option('FNOCC', 'RUN_CEPA', False); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'ccsd(t)':; core.set_local_option('F",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168605,Modifiability,variab,variable,168605,"OCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CE",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168699,Modifiability,variab,variable,168699,"ion('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168831,Modifiability,variab,variable,168831," core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cep",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:168930,Modifiability,variab,variable,168930,"obal_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', '",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169057,Modifiability,variab,variable,169057,"_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169151,Modifiability,variab,variable,169151,"sisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169196,Modifiability,variab,variables,169196,"STIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif na",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:169247,Modifiability,variab,variables,169247,"S_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_le",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:172136,Modifiability,variab,variables,172136,"e.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if no",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:172187,Modifiability,variab,variables,172187,":; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SC",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:175393,Modifiability,variab,variable,175393,"_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:175438,Modifiability,variab,variables,175438,"SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efp",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:175485,Modifiability,variab,variables,175485,"n('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:1237,Performance,optimiz,optimize,1237,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwa",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:2307,Performance,perform,performance,2307,"esponse(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError(['select_scf_gradient', name, 'SCF_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:3097,Performance,perform,performance,3097,"ort response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError(['select_scf_gradient', name, 'SCF_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:5056,Performance,perform,performance,5056,"FMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n DETCI ROHF MP2 will produce non-standard results.\n""""""). if func is None:; raise ManagedMethodError(['select_mp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ/dfmp2. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:6136,Performance,perform,performance,6136,"les. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ/dfmp2. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module =",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:6943,Performance,perform,performance,6943,"rence, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:7745,Performance,perform,performance,7745,"name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Consi",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:8505,Performance,perform,performance,8505,"gedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'R",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:9191,Performance,perform,performance,9191,"is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2p5_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:9873,Performance,perform,performance,9873," 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2p5_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp3_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS',",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:10555,Performance,perform,performance,10555,"['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2p5_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp3_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_olccd_property', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:11222,Performance,perform,performance,11222,"ule in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp3_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_olccd_property', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; el",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:12691,Performance,perform,performance,12691,"; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def sele",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:13758,Performance,perform,performance,13758,"ault modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_gl",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:14558,Performance,perform,performance,14558,"YPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = co",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:15306,Performance,perform,performance,15306,"me, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:16141,Performance,perform,performance,16141,"; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_g",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:17025,Performance,perform,performance,17025,"5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Consid",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:17831,Performance,perform,performance,17831,"wargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'R",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:18579,Performance,perform,performance,18579,"agedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):;",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:19626,Performance,perform,performance,19626,"d or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:20452,Performance,perform,performance,20452," module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.ge",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:21255,Performance,perform,performance,21255,", mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:22009,Performance,perform,performance,22009,"nagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); #",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:22779,Performance,perform,performance,22779,"ect_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in [''",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:24088,Performance,perform,performance,24088," 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and dir",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:25060,Performance,perform,performance,25060," selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:25839,Performance,perform,performance,25839,"adient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:26887,Performance,perform,performance,26887,"ied or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_typ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:27738,Performance,perform,performance,27738,"be', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CI",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:28734,Performance,perform,performance,28734,"SD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Conside",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:29499,Performance,perform,performance,29499,""" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:30503,Performance,perform,performance,30503,"a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.addons(""adcc""):; func = run_adcc; elif module in {'BUILTIN', ''}:; func = run_adc. if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['ADCC', ''] and extras.addons(""adcc""):; func = run_adcc. # Note: ROHF is theoretically available in adcc, but are not fully tested; # ... so will be added later. if",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43456,Performance,perform,perform,43456,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_op",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:56020,Performance,optimiz,optimized,56020,"wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). if name in ['mp2', 'omp2']:; core.set_local",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:58515,Performance,optimiz,optimized,58515," else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'a-ccsd(t)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). set_cholesky_from(corl_type). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'a-ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:60876,Performance,optimiz,optimized,60876,"()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:64986,Performance,optimiz,optimized,64986,"s = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:67379,Performance,optimiz,optimized,67379,". core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction m",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99131,Performance,Perform,Perform,99131,"in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_globa",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116145,Performance,CACHE,CACHELEVEL,116145,"nd; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; #",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:143126,Performance,LOAD,LOAD,143126,"local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_w",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:149412,Performance,LOAD,LOAD,149412,"st; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'); core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF (Dimer Basis)'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.set_global_option('DF_INTS_IO', df_ints_io). core.IO.set_default_namespace('monomerAm'); core.print_out('\n'); p4util.banner('Monomer A HF (Monomer Basis)'); core.print_out('\n'); monomerAm_wfn = scf_helper('RHF', molecule=monomerAm, **kwargs). core.IO.set_default_namespace('monomerBm'); core.print_out('\n'); p4util.banner('Monomer B HF (Monomer Basis)'); core.print_out('\n'); monomerBm_wfn = scf_helper('RHF', molecule=monomerBm,",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:158058,Performance,Load,Load,158058,"d environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy into the outfile; core.print_out('\n===== Begin fort.56 input for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159880,Performance,Load,Load,159880," sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4uti",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43320,Safety,Detect,Detected,43320,"fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in [",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43422,Safety,Detect,Detected,43422,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_op",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:67094,Safety,risk,risks,67094,"per(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:;",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:93558,Safety,sanity check,sanity checks,93558,"lobal_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:1737,Security,Validat,ValidationError,1737,"TY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:3439,Security,validat,validation,3439,"CE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError(['select_scf_gradient', name, 'SCF_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:12345,Security,access,access,12345,"al_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:30152,Security,access,access,30152,"NV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.a",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:33736,Security,Validat,ValidationError,33736,"p_type` that quacked; # like a list rather than the more common dict handled above. if; # ever again sighted, make an issue so this code can accommodate. _disp_functor.print_out(); return superfunc, _disp_functor. else:; return superfunc, None. [docs]def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; # Figure out functional and dispersion; superfunc, _disp_functor = build_disp_functor(name, restricted=(reference in [""RKS"", ""RHF""]), **kwargs). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if _disp_functor and _disp_functor.engine != 'nl':; wfn._disp_functor = _disp_functor. # Set the DF basis sets; df_needed = core.get_global_option(""SCF_TYPE"") in [""DF"", ""MEM_DF"", ""DISK_DF"", ""COSX""]; df_needed |= (core.get_global_option(""SCF_TYPE"") == ""DIRECT"" and core.get_option(""SCF"", ""DF_SCF_GUESS"")); if df_needed:; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis); else:; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()). # Set the relativistic basis sets; if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; decon_basis = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:35816,Security,Validat,ValidationError,35816,"f SAD basis sets; if (core.get_option(""SCF"", ""GUESS"") in [""SAD"", ""SADNO"", ""HUCKEL""]):; sad_basis_list = core.BasisSet.build(wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=wfn.basisset().has_puream(),; return_atomlist=True); wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; # We need to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs: ; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_po",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:36707,Security,Validat,ValidationError,36707,"al EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). for frag, frag_qxyz in external_potential.items():; if frag.upper() in ""ABC"":; chrgfield = QMMMbohr(); for qxyz in frag_qxyz:; chrgfield.extern.addCharge(*validate_qxyz(qxyz)). wfn.set_potential_variable(frag.upper(), chrgfield.extern); total_external_potential.appendCharges(chrgfield.extern.getCharges()). else:; core.print_out(""\n Warning! Unknown key for the external_potentials argument: %s"" % fra",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:39077,Security,Validat,ValidationError,39077,"run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['INTS_TOLERANCE'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'ORBITALS_WRITE'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Make sure we grab the correctly scoped integral threshold for SCF; core.set_global_option('INTS_TOLERANCE', core.get_option('SCF', 'INTS_TOLERANCE')). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') == ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # decide if we keep the checkpoint file; _chkfile = kwargs.get('write_orbitals', True); write_checkpoint_file = False; if isinstance(_chkfile, str):; write_checkpoint_file = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # PCM needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_carte",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:40314,Security,Validat,ValidationError,40314,"ile = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # PCM needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:40911,Security,Validat,ValidationError,40911,"olecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = corresponding_basis(core.get_global_option('BASIS'), 'GUESS')[0]; if guessbasis is None:; guessbasis = '3-21G' # guess of last resort; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:42494,Security,Validat,ValidationError,42494," = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = corresponding_basis(core.get_global_option('BASIS'), 'GUESS')[0]; if guessbasis is None:; guessbasis = '3-21G' # guess of last resort; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computat",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43011,Security,Validat,ValidationError,43011,"F', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43138,Security,Validat,ValidationError,43138,"f p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43301,Security,Validat,ValidationError,43301,"fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in [",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43403,Security,Validat,ValidationError,43403,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_op",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43620,Security,Validat,ValidationError,43620,"'.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n -----------",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43817,Security,Validat,ValidationError,43817,"s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:45251,Security,Validat,ValidationError,45251,"obal_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(ref_wfn). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suf",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:46766,Security,Validat,ValidationError,46766," p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.basis_projection(Ca_occ, old_wfn.nalphapi(), old_wfn.basisset(), scf_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, old_wfn.nbetapi(), old_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = old_wfn.name().replace(""KS"", """").replace(""HF"", """"); new_ref = scf_wfn.name().replace(""KS"", """").replace(""HF"", """"); if old_ref != new_ref:; scf_wfn.reset_occ_ = True. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.pat",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:48666,Security,Validat,ValidationError,48666,"ue. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.path.isfile(read_filename):; core.print_out(f""\n !!! Unable to find file {read_filename}, defaulting to SAD guess. !!!\n\n""); core.set_local_option('SCF', 'GUESS', 'SAD'); sad_basis_list = core.BasisSet.build(scf_wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; sad_fitting_list = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_fitting_basissets(sad_fitting_list). if cast:; core.print_out(""\n Computing basis projection from %s to %s\n\n"" % (ref_wfn.basisset().name(), base_wfn.basisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:49682,Security,Validat,ValidationError,49682,"om basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:53669,Security,Validat,ValidationError,53669,"te(['PRINT']); core.set_global_option(""PRINT"", 0). # If we force c1 copy the active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:56860,Security,Validat,ValidationError,56860,"re(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFO",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:58414,Security,Validat,ValidationError,58414,"al_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'a-ccsd(t)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). set_cholesky_from(corl_type). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'a-ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:59405,Security,Validat,ValidationError,59405,"ed method %s' % (name)). set_cholesky_from(corl_type). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'a-ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name change",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:61192,Security,Validat,ValidationError,61192,"). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccd']:; core.set_local_option('DFOCC', '",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:62693,Security,Validat,ValidationError,62693,"elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd(t)']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd', 'ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); if corl_type not in [""DF"", ""CD""]:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_w",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:63011,Security,Validat,ValidationError,63011,"E'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd(t)']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd', 'ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); if corl_type not in [""DF"", ""CD""]:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",;",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:63748,Security,Validat,ValidationError,63748,"d', 'ccd', 'ccsd', 'ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); if corl_type not in [""DF"", ""CD""]:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:65490,Security,Validat,ValidationError,65490,"wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_opt",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:66220,Security,Validat,ValidationError,66220,"; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:68238,Security,Validat,ValidationError,68238,"n_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'scs-mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'SCS'); elif name == 'scs(n)-mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:73601,Security,Validat,ValidationError,73601,"OCC', 'SPIN_SCALE_TYPE', 'SOS'); elif name == 'custom-scs-omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conven",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:74883,Security,Validat,ValidationError,74883,"iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:75956,Security,Validat,ValidationError,75956,"f name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:82825,Security,Validat,ValidationError,82825,"(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:83911,Security,Validat,ValidationError,83911,"rted""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerica",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:84561,Security,Validat,ValidationError,84561,"un_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENER",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:84834,Security,Validat,ValidationError,84834,"e.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:90416,Security,Validat,ValidationError,90416,"t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:92037,Security,Validat,ValidationError,92037,"core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variabl",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:93601,Security,Validat,ValidationError,93601,"lobal_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:94901,Security,Validat,ValidationError,94901,"VERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what so",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:96245,Security,Validat,ValidationError,96245," """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:96354,Security,Validat,Validate,96354,"es'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module cal",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:98250,Security,Validat,ValidationError,98250,"turn scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:. prop = prop.upper(); if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:98876,Security,Validat,ValidationError,98876,"d = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:. prop = prop.upper(); if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everyt",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99021,Security,Validat,ValidationError,99021,"e.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99484,Security,Validat,ValidationError,99484,"' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itsel",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99788,Security,Validat,ValidationError,99788,"ported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type p",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:101173,Security,Validat,ValidationError,101173,", 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX'):; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). # => Make OEProp calls <=; if n_one > 0:; # ==> Initialize OEProp <==; oe = core.OEProp(ccwfn); for oe_prop_name in one:; oe.add(oe_prop_name.upper()); # ==> OEProp for the ground state <==; # TODO: When Psi is Py 3.9+, transition to the removeprefix version.; title = name.upper().replace(""EOM-"", """"); #title = name.upper().removeprefix(""EOM-""); oe.set_title(title); set_of_names = {title + "" {}"", ""CC {}""}; if name.startswith(""eom""):; gs_h = 0; for h, i in e",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:104581,Security,Validat,ValidationError,104581,"_density(root_title + "" ALPHA""); oe.set_Da_so(Da); if not ccwfn.same_a_b_dens():; Db = ccwfn.get_density(root_title + "" BETA""); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOT",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:109191,Security,Validat,ValidationError,109191,"r(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs); elif name == 'eom-cc2':. user_ref = core.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref). core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs); elif name == 'eom-cc3':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). core.cchbar(ref_wfn); core.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash =",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:111714,Security,Validat,ValidationError,111714,"ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc_deprecated(*args, **kwargs):; warnings.warn(""The method 'adc' has been deprecated, please use 'adc2' instead.""; ""The method key 'adc' will be removed Psi4 1.6."", DeprecationWarning); return select_adc2(*args, **kwargs). def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). warnings.warn(""Using built-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Pr",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:113074,Security,Validat,ValidationError,113074,"ilt-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") <",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:113275,Security,Validat,ValidationError,113275,"ING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:114272,Security,Validat,ValidationError,114272,"; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:114776,Security,Validat,ValidationError,114776,"n.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBIT",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:114966,Security,Validat,ValidationError,114966,"""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC var",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:115474,Security,Validat,ValidationError,115474,"ion(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(tex",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:115585,Security,Validat,ValidationError,115585,"ion(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(tex",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:115748,Security,Validat,ValidationError,115748,"ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the pass",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:115933,Security,Validat,ValidationError,115933,"glet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116228,Security,Validat,ValidationError,116228,"dcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116728,Security,Validat,ValidationError,116728," kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.gro",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116918,Security,Validat,ValidationError,116918,"e ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:120944,Security,Validat,ValidationError,120944,"s(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:122395,Security,Validat,ValidationError,122395,"eturn f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - A TRANSITION"", data_mat). if ""OSCILLATOR_STRENGTH"" in pr",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:128159,Security,Validat,ValidationError,128159," ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level = 4; else:; level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_opt",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:133398,Security,Validat,ValidationError,133398,"TION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:136771,Security,Validat,ValidationError,136771,"np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if nam",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137139,Security,Validat,ValidationError,137139,") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:137316,Security,Validat,ValidationError,137316,". def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:141827,Security,Validat,ValidationError,141827," default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(monomerB, ""BASIS"", core.get_global_option(""BASIS"")); nfc_ab = monomerA_basis.n_frozen_core() + monomerB_basis.n_frozen_core(). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False; do_empirical_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs);",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:148957,Security,Validat,ValidationError,148957,"t_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'); core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF (Dimer Basis)'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:154799,Security,Validat,ValidationError,154799,"an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('FISAPT requires requires \""reference rhf\"".'). if ref_wfn is None:; core.timer_on(""FISAPT: Dimer SCF""); ref_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""FISAPT: Dimer SCF""). core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(),; ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"",; core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). sapt_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:156663,Security,Validat,ValidationError,156663," ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159228,Security,Validat,ValidationError,159228,".print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return t",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:161299,Security,Validat,ValidationError,161299,"keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMP",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:161949,Security,Validat,ValidationError,161949,"['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenfl",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:162644,Security,Validat,ValidationError,162644,"); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_glo",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:162992,Security,Validat,ValidationError,162992,"me == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wf",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:167361,Security,Validat,ValidationError,167361,"ion('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); elif name == 'fno-mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; core.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:170394,Security,Validat,ValidationError,170394,"nocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:170784,Security,Validat,ValidationError,170784,"False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.p",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:170955,Security,Validat,ValidationError,170955,")', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:172634,Security,Validat,ValidationError,172634,"cf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:172863,Security,Validat,ValidationError,172863,"name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwargs); else:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; if (core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV'):; mints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). ref_optstash.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:174827,Security,Validat,ValidationError,174827,"1); mints.integrals(). ref_optstash.restore(). # The DF case; if core.get_option('DETCI', 'MCSCF_TYPE') == 'DF':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). core.print_out("" Constructing Basis Sets for MCSCF...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise V",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:175828,Security,Validat,ValidationError,175828,"AS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP I",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:31405,Testability,test,tested,31405,"name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.addons(""adcc""):; func = run_adcc; elif module in {'BUILTIN', ''}:; func = run_adc. if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['ADCC', ''] and extras.addons(""adcc""):; func = run_adcc. # Note: ROHF is theoretically available in adcc, but are not fully tested; # ... so will be added later. if func is None:; raise ManagedMethodError(['select_adc2', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_disp_functor(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; superfunc, disp_type = dft.build_superfunctional(name, restricted). if disp_type:; if isinstance(name, dict):; # user dft_functional={} spec - type for lookup, dict val for param defs,; # name & citation discarded so only param matches to existing defs will print labels; _disp_functor = empirical_dispersion.EmpiricalDispersion(name_hint='',; level_hint=disp_type[""type""],; param_tweaks=disp_type[""params""],; save_pairwise_disp=save_pairwise_disp,; engine=kwargs.get('e",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:121348,Testability,assert,assert,121348," # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gaug",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:51376,Usability,simpl,simplefilter,51376,"; scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:95182,Usability,simpl,simple,95182,"f_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:107939,Usability,clear,clear,107939,"f', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(); ciwfn.oeprop = oe. # If we have more than one root, compute all data; if nroots > 1:; core.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). core.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:121830,Usability,simpl,simplefilter,121830,"lternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:2188,Availability,avail,available,2188," #; from typing import Tuple. import numpy as np. from qcelemental import constants. from psi4 import core; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft import functionals, build_superfunctional_from_dictionary; from psi4.driver.procrouting.sapt import fisapt_proc. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on inpu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:2283,Availability,avail,available,2283,"i4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft import functionals, build_superfunctional_from_dictionary; from psi4.driver.procrouting.sapt import fisapt_proc. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.ba",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:11578,Deployability,update,updated,11578," '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.print_out("" %-27s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Total "" + saptd_name + ""-D"", total * units[0], total * units[1], total * units[2])); core.print_out("" "" + ""-"" * 104 + ""\n""). if saptd_name == ""FISAPT0"":; pw_disp = dimer_wfn.variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS""); pw_disp.name = 'Empirical_Disp'; filepath = core.get_option(""FISAPT"", ""FISAPT_FSAPT_FILEPATH""); fisapt_proc._drop(pw_disp, filepath). return dimer_wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc_util.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:4881,Energy Efficiency,energy,energy,4881,"ng = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). oc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:4956,Energy Efficiency,energy,energy,4956,"scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h i",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:5032,Energy Efficiency,energy,energy,5032,"pport for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:5112,Energy Efficiency,energy,energy,5112,"ame, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_la",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:5177,Energy Efficiency,energy,energy,5177,".add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for valu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:5620,Energy Efficiency,energy,energy,5620,"cally choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for value, label in occs_list:; value, label = occs_list[cnt]; core.print_out("" %4s % 8.6f"" % (label, value)); cnt += 1; if (cnt % 3) == 0:; core.print_out(""\n""). if (cnt % 3):; core.print_out(""\n""). # Print CIVector information; ciwfn.print_vector(dvec, root). # True to keep the file; dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer: core.Molecule, sapt_basis: str) -> Tuple[core.Molecule, core.Molecule, core.Molecule]:; """"""; Prepares a dime",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:5670,Energy Efficiency,ENERGY,ENERGY,5670,".""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for value, label in occs_list:; value, label = occs_list[cnt]; core.print_out("" %4s % 8.6f"" % (label, value)); cnt += 1; if (cnt % 3) == 0:; core.print_out(""\n""). if (cnt % 3):; core.print_out(""\n""). # Print CIVector information; ciwfn.print_vector(dvec, root). # True to keep the file; dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer: core.Molecule, sapt_basis: str) -> Tuple[core.Molecule, core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns t",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:5717,Energy Efficiency,energy,energy,5717,"f_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for value, label in occs_list:; value, label = occs_list[cnt]; core.print_out("" %4s % 8.6f"" % (label, value)); cnt += 1; if (cnt % 3) == 0:; core.print_out(""\n""). if (cnt % 3):; core.print_out(""\n""). # Print CIVector information; ciwfn.print_vector(dvec, root). # True to keep the file; dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer: core.Molecule, sapt_basis: str) -> Tuple[core.Molecule, core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # S",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9211,Energy Efficiency,ENERGY,ENERGY,9211,"r(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9275,Energy Efficiency,ENERGY,ENERGY,9275,"nomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9351,Energy Efficiency,ENERGY,ENERGY,9351,"args):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * uni",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9440,Energy Efficiency,ENERGY,ENERGY,9440,"pare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9680,Energy Efficiency,ENERGY,ENERGY,9680,"aptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * unit",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9767,Energy Efficiency,ENERGY,ENERGY,9767,"ctor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9826,Energy Efficiency,ENERGY,ENERGY,9826,"airwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9896,Energy Efficiency,ENERGY,ENERGY,9896,"r_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DIS",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9943,Energy Efficiency,ENERGY,ENERGY,9943,"fn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.p",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9987,Energy Efficiency,ENERGY,ENERGY,9987,"rsion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.print_out("" %-27s % 16.8f [mEh] % 16.8f [kc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:10013,Energy Efficiency,Energy,Energy,10013,"compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.print_out("" %-27s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Total ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:10139,Energy Efficiency,Energy,Energy,10139,"= dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.print_out("" %-27s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Total "" + saptd_name + ""-D"", total * units[0], total * units[1], total * units[2])); core.print_out("" "" + ""-"" * 104 ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:3727,Integrability,rout,routine,3727,"n prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"",; core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_basisset('BASIS_RELATIVISTIC', rel_bas). mints.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation."";",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:5643,Modifiability,variab,variable,5643,".""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for value, label in occs_list:; value, label = occs_list[cnt]; core.print_out("" %4s % 8.6f"" % (label, value)); cnt += 1; if (cnt % 3) == 0:; core.print_out(""\n""). if (cnt % 3):; core.print_out(""\n""). # Print CIVector information; ciwfn.print_vector(dvec, root). # True to keep the file; dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer: core.Molecule, sapt_basis: str) -> Tuple[core.Molecule, core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns t",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9491,Modifiability,variab,variables,9491,"d_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:9642,Modifiability,variab,variable,9642,":; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:11191,Modifiability,variab,variable,11191," '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.print_out("" %-27s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Total "" + saptd_name + ""-D"", total * units[0], total * units[1], total * units[2])); core.print_out("" "" + ""-"" * 104 + ""\n""). if saptd_name == ""FISAPT0"":; pw_disp = dimer_wfn.variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS""); pw_disp.name = 'Empirical_Disp'; filepath = core.get_option(""FISAPT"", ""FISAPT_FSAPT_FILEPATH""); fisapt_proc._drop(pw_disp, filepath). return dimer_wfn. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.procrouting.proc_util.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:2141,Security,Validat,ValidationError,2141," #; from typing import Tuple. import numpy as np. from qcelemental import constants. from psi4 import core; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft import functionals, build_superfunctional_from_dictionary; from psi4.driver.procrouting.sapt import fisapt_proc. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on inpu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:2236,Security,Validat,ValidationError,2236,"i4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft import functionals, build_superfunctional_from_dictionary; from psi4.driver.procrouting.sapt import fisapt_proc. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.ba",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:2412,Security,Validat,Validations,2412,"si4.driver.procrouting.sapt import fisapt_proc. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", """,MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:2555,Security,Validat,ValidationError,2555,"lly; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"",; core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_basisset('BASIS_RELATIVISTIC', rel_bas)",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:2929,Security,Validat,ValidationError,2929,"; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"",; core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_basisset('BASIS_RELATIVISTIC', rel_bas). mints.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if sc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:3989,Security,Validat,ValidationError,3989,"ves)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"",; core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_basisset('BASIS_RELATIVISTIC', rel_bas). mints.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; cor",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:4522,Security,Validat,ValidationError,4522,"nts.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d info",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:7322,Security,Validat,ValidationError,7322,"cnt % 3):; core.print_out(""\n""). # Print CIVector information; ciwfn.print_vector(dvec, root). # True to keep the file; dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer: core.Molecule, sapt_basis: str) -> Tuple[core.Molecule, core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # Shifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:7546,Security,Validat,ValidationError,7546,"core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # Shifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.s",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:7725,Security,Validat,ValidationError,7725,"hifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). fr",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html:8199,Security,Validat,ValidationError,8199,"om(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP E",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc_util.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:2445,Availability,error,error,2445,"ort Dict, List, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_string(; molstr=molinit,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); molrec = compound_molrec['qm']. elif molinit",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5099,Availability,avail,available,5099,"str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilen",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5168,Availability,avail,available,5168,"self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5850,Availability,avail,available,5850,"t_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5919,Availability,avail,available,5919," def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3}",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:37743,Availability,error,error,37743,"turn geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=e",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:40496,Availability,error,error,40496,"os; molrec['geom'][np.abs(molrec['geom']) < 5**(-(prec))] = 0. smol = qcel.molparse.to_string(; molrec,; dtype=dtype,; units=units,; atom_format=atom_format,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: str = None, dashlvl: str = None, dashparam: Dict = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43035,Availability,error,error,43035,"NT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver':",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:58325,Availability,fault,faulty,58325,"al; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.f",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:67668,Deployability,update,updated,67668,"shape[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.qcdb.molecule.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:1581,Energy Efficiency,charge,charge,1581,"eneral Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):;",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5110,Energy Efficiency,Charge,Charge,5110,"self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5213,Energy Efficiency,charge,charge,5213," += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NO",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5861,Energy Efficiency,Charge,Charge,5861," def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3}",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5964,Energy Efficiency,charge,charge,5964,"alse, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7220,Energy Efficiency,charge,charge,7220," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7248,Energy Efficiency,charge,chargem,7248," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7300,Energy Efficiency,CHARGE,CHARGE,7300," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7312,Energy Efficiency,charge,chargem,7312," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7336,Energy Efficiency,charge,chargem,7336," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7421,Energy Efficiency,charge,charge,7421," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:13750,Energy Efficiency,charge,charge,13750," be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True. return text, options. def format_molecule_for_psi4_xyz(self):; """"""not much examined. """"""; text = """"; if self.nallatom():. factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # append units and any other non-default molecule keywords; text += ""units Angstrom\n""; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += ""no_com\n""; if self.PYfix_orientation:; text += ""no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s%s%d %d\n"" % ("""" if Pfr == 0 else ""--\n"", ""#"" if self.fragment_types[fr] == 'Ghost'; or self.fragment_types[fr] == 'Absent' else """", self.fragment_charges[fr],; self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent' or self.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2a",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:15234,Energy Efficiency,CHARGE,CHARGE,15234,"f.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # TODO keep fix_or? # Jan 2015 turning off fix_or; #self.fix_orientation(True); #self.PYmove_to_com = False; self.update_geometry(). text = """"; text += 'angstrom\n'; text += 'geometry={\n'; dummy = []. for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % (self.symbol(i),; x * factor, y * factor, z * factor); if not self.Z(i):; dummy.append(str(i + 1)) # Molpro atom number is 1-indexed. text += '}\n\n'; text += 'SET,CHARGE=%d\n' % (self.molecular_charge()); text += 'SET,SPIN=%d\n' % (self.multiplicity() - 1) # Molpro wants (mult-1); if len(dummy) > 0:; text += 'dummy,' + ','.join(dummy) + '\n'; return text. def format_molecule_for_cfour(self):; """"""Function to print Molecule in a form readable by Cfour. """"""; self.update_geometry(); factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; #factor = 1.0 if self.PYunits == 'Bohr' else 1.0/psi_bohr2angstroms. text = 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # append atoms and coordentries; for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""GH""),; x * factor, y * factor, z * factor). #for fr in range(self.nfragments()):; # if self.fragment_types[fr] == 'Absent':; # pass; # else:; # for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; # [x, y, z] = self.atoms[at].compute(); # text += '%-2s %17.12f %",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:22612,Energy Efficiency,charge,charge,22612,"format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variabl",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:32321,Energy Efficiency,charge,charge,32321," 1.0e-6 else 0.0; ]. # Determine degeneracy of rotational constants.; degen = 0; for i in range(2):; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:32538,Energy Efficiency,charge,charge,32538,"rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:32704,Energy Efficiency,charge,charge,32704,"Degeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e-8):; """"""Molecule vs. laboratory frame representation (e.g., IR or IIIL). Parameters; ----------; zero : float, optional; S",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:40583,Energy Efficiency,energy,energy-only,40583,"e,; units=units,; atom_format=atom_format,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: str = None, dashlvl: str = None, dashparam: Dict = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:40635,Energy Efficiency,efficient,efficient,40635,"e,; units=units,; atom_format=atom_format,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs] def run_dftd3(self, func: str = None, dashlvl: str = None, dashparam: Dict = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:40731,Energy Efficiency,energy,energy,40731,": str = None, dashlvl: str = None, dashparam: Dict = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:40765,Energy Efficiency,energy,energy,40765,": str = None, dashlvl: str = None, dashparam: Dict = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:40846,Energy Efficiency,energy,energy,40846,"DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (f",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:40920,Energy Efficiency,energy,energy,40920,"DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (f",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:41958,Energy Efficiency,ENERGY,ENERGY,41958,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; d",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:42115,Energy Efficiency,ENERGY,ENERGY,42115,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; d",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43145,Energy Efficiency,energy,energy-only,43145,"as']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43197,Energy Efficiency,efficient,efficient,43197,"as']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_dftd4(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords'",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43309,Energy Efficiency,energy,energy,43309,"spersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43343,Energy Efficiency,energy,energy,43343,"spersion correction via Grimme's DFTD4 program. Parameters; ----------; func : str, optional; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43424,Energy Efficiency,energy,energy,43424,"hich to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43498,Energy Efficiency,energy,energy,43498,"hich to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:44806,Energy Efficiency,ENERGY,ENERGY,44806,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: str = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:44963,Energy Efficiency,ENERGY,ENERGY,44963,"ent'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: str = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) o",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:45502,Energy Efficiency,energy,energy,45502,":; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: str = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:45571,Energy Efficiency,energy,energy,45571,":; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: str = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:46235,Energy Efficiency,energy,energy-only,46235,"rogram; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; j",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:46287,Energy Efficiency,efficient,efficient,46287,"rogram; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; j",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:46418,Energy Efficiency,energy,energy,46418,"specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['ex",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:46452,Energy Efficiency,energy,energy,46452,"specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['ex",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:46533,Energy Efficiency,energy,energy,46533,"t if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:46607,Energy Efficiency,energy,energy,46607,"t if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:47625,Energy Efficiency,ENERGY,ENERGY,47625,"int, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dty",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:47768,Energy Efficiency,ENERGY,ENERGY,47768,"int, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dty",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:55181,Energy Efficiency,charge,charge,55181,"ovenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment_charges']],; molrec['fragment_multiplicities']). self.set_molecular_charge(int(molrec['molecular_charge'])); self.set_multiplicity(molrec['molecular_multiplicity']). self.fix_com(molrec['fix_com']); self.fix_orientation(molrec['fix_orientation']); if 'fix_symmetry' in molrec:; # Save the user-specified symmetry, but don't set it as the point group; # That step occurs in update_geometry, after the atoms are added; self.PYsymmetry_from_i",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:58030,Energy Efficiency,charge,charge,58030,"ays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:58571,Energy Efficiency,adapt,adapted,58571,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:62379,Energy Efficiency,charge,charge,62379," = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,; rgeom=rgeom,; cuniq=cuniq,; runiq=runiq,; do_plot=do_plot,; verbose=verbose,; atoms_map=atoms_map,; run_resorting=run_resorting,; mols_align=mols_align,; run_to_completion=run_to_completion,; run_mirror=run_mirror,; uno_cutoff=uno_cutoff). ageom, amass, aelem, aelez, auniq = solution.align_system(cgeom, cmass, celem, celez, cuniq, reverse=False); adict = qcel.molparse.from_arrays(; geom=ageom,; mass=amass,; elem=aelem,; elez=aelez,; units='Bohr',; molecular_charge=concern_mol.molecular_charge(),; molecular_multiplicity=concern_mol.multiplicity(),; fix_com=True,; fix_orientation=True); if isinstance(concern_mol, Molecule):; amol = Molecule.from_dict(adict); else:; from psi4 import core; amol = core.Molecule.fr",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:37929,Integrability,wrap,wrapper,37929,"orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43569,Integrability,wrap,wraps,43569,"writes any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43608,Integrability,wrap,wraps,43608,"writes any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:45870,Integrability,interface,interface,45870,"DIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: str = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdri",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:47984,Integrability,wrap,wrapper,47984,"resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dtype`."""""". molrec = self.to_dict(np_out=True); schmol = qcel.molparse.to_schema(molrec, dtype=dtype, units=units); return schmol. [docs] def to_dict(self, force_c1=False, force_units=False, np_out=True):; """"""Serializes instance into Molecule dictionary."""""". self.update_geometry(); molrec = {}.",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:60720,Integrability,Wrap,Wraps,60720,"r_multiplicity may not be conservable upon fragmentation; # potentially could do two passes and try to preserve it; fix_com=self.com_fixed(),; fix_orientation=self.orientation_fixed(),; fix_symmetry=(None if self.symmetry_from_input() == '' else self.symmetry_from_input()),; fragment_separators=dcontig['fragment_separators']); if isinstance(self, Molecule):; ret_mol = Molecule.from_dict(molrec); else:; from psi4 import core; ret_mol = core.Molecule.from_dict(molrec). outputs.append(ret_mol). outputs = tuple(outputs); return (frag_pattern, ) + outputs[1:]. [docs] def B787(concern_mol: Union[qcdbmol, psi4.core.Molecule],; ref_mol: Union[qcdbmol, psi4.core.Molecule],; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: bool = False,; run_to_completion: bool = False,; uno_cutoff: float = 1.e-3,; run_mirror: bool = False):; """"""Finds shift, rotation, and atom reordering of `concern_mol` that best; aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`psi4.driver.qcdb.Molecule` or; :py:class:`psi4.core.Molecule`. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters; ----------; concern_mol; Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with `ref_mol`.; ref_mol; Molecule to match.; atoms_map; Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc.; If true, specifying `True` can save much time.; mols_align; Whether `ref_mol` and `concern_mol` have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run t",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:1796,Modifiability,extend,extends,1796,"AR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:4364,Modifiability,variab,variable,4364,"me,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilena",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:4691,Modifiability,variab,variable,4691,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:21781,Modifiability,variab,variables,21781,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:21858,Modifiability,variab,variables,21858,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:23544,Modifiability,variab,variables,23544,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(),",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:37912,Modifiability,variab,variables,37912,"olstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:43779,Modifiability,extend,extending,43779," d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:45822,Modifiability,extend,extended,45822,"DIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: str = None, dertype: Union[int, str] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func : str, optional; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype : int or str, optional; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdri",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:54771,Modifiability,variab,variables,54771,"rn mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:58571,Modifiability,adapt,adapted,58571,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:50944,Performance,perform,performed,50944," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5048,Safety,detect,detected,5048," comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to tur",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:5799,Safety,detect,detected,5799,"dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.r",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:56525,Safety,Detect,Detect,56525,"s, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment_charges']],; molrec['fragment_multiplicities']). self.set_molecular_charge(int(molrec['molecular_charge'])); self.set_multiplicity(molrec['molecular_multiplicity']). self.fix_com(molrec['fix_com']); self.fix_orientation(molrec['fix_orientation']); if 'fix_symmetry' in molrec:; # Save the user-specified symmetry, but don't set it as the point group; # That step occurs in update_geometry, after the atoms are added; self.PYsymmetry_from_input = molrec['fix_symmetry'].lower(). ## hack to prevent update_geometry termination upon no atoms; #if nat == 0:; # self.set_lock_frame(True). if not unsettled:; self.update_geometry(). [docs] def BFS(self,; seed_atoms: List = None,; bond_threshold: float = 1.20,; return_arrays: bool = False,; return_molecules: bool = False,; return_molecule: bool = False):; """"""Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters; ----------; self : qcdb.Molecule or psi4.core.Molecule; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`; bond_threshold; Factor beyond average of covalent radii to determine bond cutoff.; return_arrays; If `True`, also return fragments as list of arrays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built fro",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:57259,Safety,detect,detected,57259,"etry termination upon no atoms; #if nat == 0:; # self.set_lock_frame(True). if not unsettled:; self.update_geometry(). [docs] def BFS(self,; seed_atoms: List = None,; bond_threshold: float = 1.20,; return_arrays: bool = False,; return_molecules: bool = False,; return_molecule: bool = False):; """"""Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters; ----------; self : qcdb.Molecule or psi4.core.Molecule; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`; bond_threshold; Factor beyond average of covalent radii to determine bond cutoff.; return_arrays; If `True`, also return fragments as list of arrays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:1128,Security,hash,hashlib,1128,".qcdb.molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fr",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:4631,Security,access,accessing,4631,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:6535,Security,Validat,ValidationError,6535," """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to mat",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:6684,Security,Validat,ValidationError,6684,"lse, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7466,Security,Validat,ValidationError,7466,"e, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.mat",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:7598,Security,Validat,ValidationError,7598,"name)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:8220,Security,Validat,ValidationError,8220,"GE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.frag",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:8329,Security,Validat,ValidationError,8329,"GE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.frag",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:8933,Security,Validat,ValidationError,8933,"set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / qcel.constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.0407120000",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:9051,Security,Validat,ValidationError,9051,"up(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / qcel.constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:24211,Security,Validat,ValidationError,24211,"ype(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i),; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), ma",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:33450,Security,Validat,ValidationError,33450," = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e-8):; """"""Molecule vs. laboratory frame representation (e.g., IR or IIIL). Parameters; ----------; zero : float, optional; Screen for inertial tensor elements. Returns; -------; str; Representation code IR, IIR, IIIR, IL, IIL, IIIL. When; molecule not in inertial frame, string is prefixed by ""~"". Notes; -----; Not carefully handling degenerate inertial elements. """"""; it = self.inertia_tensor(zero=zero); Iidx = np.argsort(np.diagonal(it)); if np.array_equal(Iidx, np.asarray([1, 2, 0])):; ar = 'IR'; elif np.array_equal(Iidx, np.asarray([2, 0, 1])):; ar = 'IIR'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if n",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:35108,Security,hash,hash,35108,"'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. [docs] def to_arrays(self, dummy: bool = False, ghost_as_dummy: bool = False) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:; """"""Exports coordinate info into NumPy arrays. Parameters; ----------; dummy; Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy; Whether or not to treat ghost atoms as dummies. Returns; -------; geom, mass, elem, elez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geome",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:35927,Security,hash,hashlib,35927,"ez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fi",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:36419,Security,hash,hashlib,36419,"l qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:51014,Security,expose,exposed,51014," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:52556,Security,Validat,ValidationError,52556,"_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the difference and; # (2) return the from_arrays filled-in values; # * from.arrays is expecting speclabel ""Co_userlbl"" for elbl, but we're; # sending ""_userlbl"", hence speclabel=False; # * from.arrays sets difference provenance than input mol; forgive = ['elea', 'provenance']. # * from_arrays and comparison lines below are quite unnecessary to; # to_dict, but is included as a check. in practice, only fills in mass; # numbers and heals user chgmult.; try:; validated_molrec = qcel.molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); except qcel.ValidationError as err:; # * this can legitimately happen if total chg or mult has been set; # independently b/c fragment chg/mult not reset. so try again.; print(; """"""Following warning is harmless if you've altered chgmult through `set_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, mol",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:53812,Security,validat,validated,53812,"t_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.s",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:58544,Security,Validat,ValidationError,58544,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:67138,Security,Validat,ValidationError,67138,"shape[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.qcdb.molecule.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:1335,Testability,test,testing,1335,"in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_retur",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:61688,Testability,test,test,61688,"; aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`psi4.driver.qcdb.Molecule` or; :py:class:`psi4.core.Molecule`. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters; ----------; concern_mol; Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with `ref_mol`.; ref_mol; Molecule to match.; atoms_map; Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc.; If true, specifying `True` can save much time.; mols_align; Whether `ref_mol` and `concern_mol` have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:64327,Testability,Test,Tester,64327,"e):; amol = Molecule.from_dict(adict); else:; from psi4 import core; amol = core.Molecule.from_dict(adict). compare_values(; concern_mol.nuclear_repulsion_energy(),; amol.nuclear_repulsion_energy(),; 4,; 'Q: concern_mol-->returned_mol NRE uncorrupted',; verbose=verbose - 1); if mols_align:; compare_values(; ref_mol.nuclear_repulsion_energy(),; amol.nuclear_repulsion_energy(),; 4,; 'Q: concern_mol-->returned_mol NRE matches ref_mol',; verbose=verbose - 1); compare_integers(; True,; np.allclose(ref_mol.geometry(), amol.geometry(), atol=4),; 'Q: concern_mol-->returned_mol geometry matches ref_mol',; verbose=verbose - 1). return rmsd, solution, amol. [docs] def scramble(ref_mol: ""Molecule"",; do_shift: Union[bool, np.ndarray, List] = True,; do_rotate: Union[bool, np.ndarray, List[List]] = True,; do_resort: Union[bool, List] = True,; deflection: float = 1.0,; do_mirror: bool = False,; do_plot: bool = False,; run_to_completion: bool = False,; run_resorting: bool = False,; verbose: int = 1):; """"""Tester for B787 by shifting, rotating, and atom shuffling `ref_mol` and; checking that the aligner returns the opposite transformation. Parameters; ----------; ref_mol; Molecule to perturb.; do_shift; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate; Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort; Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`).; To specify shuffle, supply a nat-element list of indices.; deflection; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror; Whether to construct the mirror image structure by inverting y-axis.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; By construction, scrambled s",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:65528,Testability,test,test,65528,"_shift; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate; Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort; Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`).; To specify shuffle, supply a nat-element list of indices.; deflection; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror; Whether to construct the mirror image structure by inverting y-axis.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, `True` turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting; Even if atoms not shuffled, test the resorting machinery.; verbose; Print level. Returns; -------; None. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); nat = rgeom.shape[0]. perturbation = qcel.molutil.compute_scramble(; rgeom.shape[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_c",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:1380,Availability,toler,tolerance,1380," file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Toleranc",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:1889,Availability,toler,tolerance,1889," FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:2096,Availability,toler,tolerance,2096,". import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:2136,Availability,error,error,2136,"ols; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:2278,Availability,failure,failure,2278,"elemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; che",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:2389,Availability,Toler,Tolerances,2389,"y max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:;",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:2513,Availability,toler,tolerance,2513,"mega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:10925,Availability,toler,tolerance,10925,"s in diff (xyz) arrangements); idx_sort_wi_degen = np.lexsort(; (idx_max_elem_each_normco[istart:istart + degree], max_elem_each_normco[istart:istart + degree])); idx_vib_reordering[istart:istart + degree] = np.arange(istart, istart + degree)[idx_sort_wi_degen]. arr2 = arr[:, idx_vib_reordering]. reorderings = ['{}-->{}'.format(i, v) for i, v in enumerate(idx_vib_reordering) if (i != v)]; if reorderings and verbose >= 2:; print('Degenerate modes reordered:', ', '.join(reorderings)). return arr2. def _phase_cols_to_max_element(arr, tol=1.e-2, verbose=1):; """"""Returns copy of 2D `arr` scaled such that, within cols, max(fabs); element is positive. If max(fabs) is pos/neg pair, scales so first; element (within `tol`) is positive. """"""; arr2 = np.copy(arr). rephasing = []; for v in range(arr.shape[1]):; vextreme = 0.0; iextreme = None. # find most extreme value; for varr in arr[:, v]:; vextreme = max(np.absolute(varr), vextreme). # find the first index whose fabs equals that value, w/i tolerance; for iarr, varr in enumerate(arr[:, v]):; if (vextreme - np.absolute(varr)) < tol:; iextreme = iarr; break. sign = np.sign(arr[iextreme, v]); if sign == -1.:; rephasing.append(str(v)); arr2[:, v] *= sign. if rephasing and verbose >= 2:; print('Negative modes rephased:', ', '.join(rephasing)). return arr2. [docs]def harmonic_analysis(hess: np.ndarray, geom: np.ndarray, mass: np.ndarray, basisset: psi4.core.BasisSet, irrep_labels: List[str], dipder: np.ndarray = None, project_trans: bool = True, project_rot: bool = True) -> Tuple[Dict[str, Datum], str]:; """"""Extract frequencies, normal modes and other properties from electronic Hessian. Like so much other Psi4 goodness, originally by @andysim. Parameters; ----------; hess; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; geom; (nat, 3) geometry [a0] at which Hessian computed.; mass; (nat,) atomic masses [u].; basisset; Basis set object (can be dummy, e.g., STO-3G) for SALCs.; irrep_labels; Irreducible representat",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:18997,Availability,down,downhill,18997,"(qcel.constants.na * qcel.constants.hartree2J * 1.0e19) /; (2 * np.pi * qcel.constants.c * qcel.constants.bohr2angstroms)); pre_frequency_cm_1 = np.lib.scimath.sqrt(pre_force_constant_au) * uconv_cm_1. pre_lowfreq = np.where(np.real(pre_frequency_cm_1) < 100.0)[0]; pre_lowfreq = np.append(pre_lowfreq, np.arange(nrt_expected)) # catch at least nrt modes; for lf in set(pre_lowfreq):; vlf = pre_frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' pre-proj low-frequency mode: {:9.4f}i [cm^-1]'.format(vlf.real, vlf.imag)); else:; text.append(' pre-proj low-frequency mode: {:9.4f} [cm^-1]'.format(vlf.real, '')); text.append(' pre-proj all modes:' + str(_format_omega(pre_frequency_cm_1, 4))). # project & solve; mwhess_proj = np.dot(P.T, mwhess).dot(P); text.append(mat_symm_info(mwhess_proj, lbl='projected mass-weighted Hessian') + f' ({nrt})'). #print('projhess = ', np.array_repr(mwhess_proj)); force_constant_au, qL = np.linalg.eigh(mwhess_proj). # expected order for vibrations is steepest downhill to steepest uphill; idx = np.argsort(force_constant_au); force_constant_au = force_constant_au[idx]; qL = qL[:, idx]; qL = _phase_cols_to_max_element(qL); vibinfo['q'] = Datum('normal mode', 'a0 u^1/2', qL, comment='normalized mass-weighted'). # frequency, LAB II.17; frequency_cm_1 = np.lib.scimath.sqrt(force_constant_au) * uconv_cm_1; vibinfo['omega'] = Datum('frequency', 'cm^-1', frequency_cm_1). # degeneracies; ufreq, uinv, ucts = np.unique(np.around(frequency_cm_1, 1), return_inverse=True, return_counts=True); vibinfo['degeneracy'] = Datum('degeneracy', '', ucts[uinv]). # look among the symmetry subspaces h for one to which the normco; # of vib does *not* add an extra dof to the vector space; active = []; irrep_classification = []; for idx, vib in enumerate(frequency_cm_1):. if vec_in_space(qL[:, idx], TRspace, 1.0e-4):; active.append('TR'); irrep_classification.append(None). else:; active.append('V'). for h in Uh.keys():; if vec_in_space(qL[:, idx], Uh[h], 1.0e-4):; ir",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:42772,Deployability,update,updated,42772,"noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.qcdb.vib.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:14211,Energy Efficiency,reduce,reduced,14211," +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | x | normal mode, normalized un-mass-weighted | a0 | ndarray(ndof, ndof) float |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | degeneracy | degree of degeneracy | | ndarray(ndof) int |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | TRV | translation/rotation/vibration | | ndarray(ndof) str 'TR' or 'V' or '-' for partial |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | gamma | irreducible representation | | ndarray(ndof) str irrep or None if unclassifiable |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | mu | reduced mass | u | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | k | force constant | mDyne/A | ndarray(ndof) float (+/-) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | DQ0 | RMS deviation v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(n",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:15637,Energy Efficiency,energy,energy,15637," | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.li",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:21431,Energy Efficiency,reduce,reduced,21431,"cted)) # catch at least nrt modes; for lf in set(lowfreq):; vlf = frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' post-proj low-frequency mode: {:9.4f}i [cm^-1] ({})'.format(vlf.imag, active[lf])); else:; text.append(' post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intens",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:21670,Energy Efficiency,reduce,reduced,21670,"post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infr",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:22206,Energy Efficiency,meter,meter,22206,"qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_intens_D2A2u); ir_intensity_kmmol = ir_intensity * uconv_kmmol; vibinfo['IR_intensity'] = Datum('infrared intensity', 'km/mol', ir_intensity_kmmol). # force constants, LAB II.16 (real compensates for earlier sqrt); uconv_mdyne_a = (0.1 * (2 * np.pi * qcel.constants.c)**2) / qcel.constants.na; force_constant_mdyne_a = reduced_mass_u * (frequency_cm_1 * frequency_cm_1).real * uconv_mdyne_a; vibinfo['k'] = Datum('force constant', 'mDyne/A', force_constant_mdyne_a). force_constant_cm_1_bb = reduced_mass_u * (f",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:25360,Energy Efficiency,reduce,reduced,25360,"ts.c / qcel.constants.kb; vib_temperature_K = frequency_cm_1.real * uconv_K; vibinfo['theta_vib'] = Datum('char temp', 'K', vib_temperature_K). return vibinfo, '\n'.join(text). def _br(string):; return '[' + string + ']'. def _format_omega(omega, decimals):; """"""Return complex frequencies in `omega` into strings showing only real or imag (""i""-labeled); to `decimals` precision. """"""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(""""""{:.{prec}f}i"""""".format(fr.imag, prec=decimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requeste",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:25840,Energy Efficiency,reduce,reduced,25840,"cimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:27806,Energy Efficiency,Reduce,Reduced,27806,"= 24; if groupby == -1:; groupby = len(active). omega_str = _format_omega(vibinfo['omega'].data, decimals=prec). text = ''; for row in grouper(active, groupby):. text += """"""\n{:{presp}}{:{prewidth}}"""""".format('', 'Vibration', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; # ran out of vibrations in this row; break; text += """"""{:^{width}d}{:{colsp}}"""""".format(vib + 1, '', width=width, colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('', 'Freq [cm^-1]', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}} """""".format(omega_str[vib], width=width); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('', 'Irrep', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; break; val = vibinfo['gamma'].data[vib]; if val is None:; val = ''; text += """"""{:^{width}}{:{colsp}}"""""".format(val, '', width=width, colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'Reduced mass ' + _br(vibinfo['mu'].units),; prewidth=prewidth,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}{:{colsp}}"""""".format(vibinfo['mu'].data[vib],; '',; width=width,; prec=prec,; colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'Force const ' + _br(vibinfo['k'].units),; prewidth=prewidth,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}{:{colsp}}"""""".format(vibinfo['k'].data[vib],; '',; width=width,; prec=prec,; colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'Turning point v=0 ' + _br(vibinfo['Xtp0'].units),; prewidth=prewidth,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}{:{colsp}}"""""".format(vibinfo['Xtp0'].data[vib],; '',; width=width,; prec=prec,; colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('',; 'RMS dev v=0 ' + _br(vibinfo['DQ0'].units),; prewidth=prewidth,; presp=presp); for vib i",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:30898,Energy Efficiency,energy,energy,30898,"[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:30952,Energy Efficiency,ENERGY,ENERGY,30952,"[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:33633,Energy Efficiency,reduce,reduced,33633,"const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['ele",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37101,Energy Efficiency,Energy,Energy,37101," [kcal/mol] {:11.3f} [kJ/mol] {:15.8f} [Eh]""""""; uconv = np.asarray([qcel.constants.hartree2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, E",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37156,Energy Efficiency,energy,energy,37156,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37206,Energy Efficiency,energy,energy,37206,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37293,Energy Efficiency,energy,energy,37293,""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); tex",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37594,Energy Efficiency,energy,energy,37594,"t = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37681,Energy Efficiency,Energy,Energy,37681,"a). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of norm",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37843,Energy Efficiency,energy,energy,37843,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:38192,Energy Efficiency,energy,energy,38192,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvibs",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:2142,Integrability,message,messages,2142,"ols; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:40125,Integrability,depend,dependencies,40125," remove=[i for i, d in enumerate(allvibs['gamma'].data) if d != 'A1']). """"""; work = {}; if remove is None:; remove = [idx for idx, dat in enumerate(vibinfo['TRV'].data) if dat != 'V']; for asp, oasp in vibinfo.items():; if asp in ['q', 'w', 'x']:; axis = 1; else:; axis = 0; work[asp] = Datum(oasp.label, oasp.units, np.delete(oasp.data, remove, axis=axis), comment=oasp.comment, numeric=False). return work. [docs]def filter_omega_to_real(omega: np.ndarray) -> np.ndarray:; """"""Returns ndarray (float) of `omega` (complex) where imaginary entries are converted to negative reals.""""""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(-1 * fr.imag); else:; freqs.append(fr.real); return np.asarray(freqs). def _get_TR_space(m: np.ndarray, geom: np.ndarray, space: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); as",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:3285,Modifiability,extend,extend,3285,"red; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and asp in toldict:; ktol = toldict[asp]; else:; ktol = tol. if asp in 'qwx':; ccnc = _phase_cols_to_max_element(computed[asp].data); eenc = _phase_cols_to_max_element(expected[asp].data); ccnc = _check_degen_modes(ccnc, computed['omega'].data); eenc = _check_degen_modes(eenc, expected['omega'].data); same = np.allclose(eenc, ccnc, atol=ktol); print_stuff(asp=asp, same=same, ref=eenc, val=ccnc, space='\n'); same = _check_rank_degen_modes(ccnc, computed[""omega""].data, eenc, difftol=ktol, svdtol=svdtol). elif asp in ['gamma', 'TRV']:; same = all([computed[asp].data[idx] == val for idx, val in enumerate(expected[asp].data)]); print_stuff(asp=asp, same=same, ref=expected[asp].data, val=computed[asp].data). elif isinstance(expected[asp].data, float):; same = abs(expected[asp].data - computed[asp].data) < ktol; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:30802,Performance,Perform,Perform,30802,"'\n'. if shortlong:; for at in range(nat):; text += """"""{:{presp}}{:5d} {:{width}}"""""".format('',; at + 1,; atom_lbl[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constan",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:15911,Security,Validat,ValidationError,15911,"--+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.linalg.matrix_rank(geom) == 1:; nrt_expected = 5; else:; nrt_expected = 6. nmwhess = hess.copy(); text.append(mat_symm_info(nmwhess, lbl='non-mass-weighted Hessian') + ' (0)'). # get SALC object, possibly w/o trans & rot; mints = psi4.core.MintsHelper(basisset); cdsalcs = mints.cdsalcs(0xFF, project_tran",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:26306,Security,Validat,ValidationError,26306,"coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if groupby == -1:; groupby = len(active). omega_str = _format_omega(vibinfo['omega'].data, decimals=prec). text = ''; for row in grouper(active, groupby):. text += """"""\n{:{presp}}{:{prewidth}}"""""".format('', 'Vibration', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; # ran out of vibrations in this row; break; text += """"""{:^{width}d}{:{colsp}}"""""".format(vib + 1, '', width=width, colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('', 'Freq [cm^-1]', prewidth=pre",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:5713,Testability,test,tested,5713,"metrize(hess: np.ndarray, mol: psi4.core.Molecule) -> np.ndarray:; """"""Apply Abelian symmetry of `mol` to Hessian `hess`. Parameters; ----------; hess; (3 * nat, 3 * nat) Hessian array perhaps with jitter unbecoming a symmetric molecule.; mol; Molecule at which Hessian computed. Returns; -------; numpy.ndarray; (3 * nat, 3 * nat) symmetrized Hessian array. """"""; ct = mol.point_group().char_table(). # Obtain atom mapping of atom * symm op to atom; atom_map = compute_atom_map(mol). syms = []; smap = []; for g in range(ct.order()):; syms.append(np.asarray(ct.symm_operation(g).d)); smap.append([atom_map[at][g] for at in range(mol.natom())]). np.set_printoptions(formatter={'float': '{: 16.12f}'.format}); b_hess = blockwise_expand(hess, (3, 3), False). bDG = []; nat = b_hess.shape[0]; for iat in range(nat):; for jat in range(nat):; for sym in range(len(syms)):; bDG.append(np.zeros_like(b_hess)); bDG[sym][iat, jat] = syms[sym].dot(b_hess[iat, jat].dot(syms[sym])); # Note that tested syms all diagonal, so above may be off by some transposes. for sym in range(len(syms)):; bDG[sym] = bDG[sym][:, smap[sym]]; bDG[sym] = bDG[sym][smap[sym], :]; tot = np.sum(bDG, axis=0); tot = np.divide(tot, len(syms)). print('symmetrization diff:', np.linalg.norm(tot - b_hess)); m_tot = blockwise_contract(tot); return m_tot. [docs]def print_molden_vibs(vibinfo: Dict[str, Datum], atom_symbol: Union[np.ndarray, List[str]], geom: Union[np.ndarray, List[List[float]]], standalone: bool = True) -> str:; """"""Format vibrational analysis for Molden. Parameters; ----------; vibinfo; Holds results of vibrational analysis.; atom_symbol; (nat,) element symbols for geometry of vibrational analysis.; geom; (nat, 3) geometry of vibrational analysis [a0].; standalone; Whether returned string prefixed ""[Molden Format]"" for standalone rather than append. Returns; -------; str; `vibinfo` formatted for Molden, including FREQ, FR-COORD, & FR-NORM-COORD fields. Notes; -----; Molden format spec from http://www.cmbi.ru.nl",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:32042,Testability,log,log,32042,"ty of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[(",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:32294,Testability,log,log,32294,"RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibon",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:32650,Testability,log,log,32650,"minfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lo",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:32948,Testability,log,log,32948,"y; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')]",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:33909,Testability,log,log,33909,"; sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uco",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:34185,Testability,assert,assert,34185,"a(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uconv_R_EhK = qcel.constants.R / qcel.constants.hartree2kJmol; for piece in ['S', 'Cv', 'Cp']:; sm[(piece, term)] *= uconv_R_EhK # [mEh/K] <-- []; for piece in ['ZPE', 'E', 'H', 'G']:; sm[(piece, term)] *= uconv_R_EhK * 0.001 # [Eh] <-- [K]. # sum corrections and totals; for piece in ['S', 'Cv', ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:40936,Testability,assert,assert,40936,"e: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in sp",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:40984,Testability,assert,assert,40984,"se: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41031,Testability,assert,assert,41031,"zed translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41078,Testability,assert,assert,41078,"geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it run",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41126,Testability,assert,assert,41126,"encies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]).",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41173,Testability,assert,assert,41173,"toms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41221,Testability,assert,assert,41221,") otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=Fals",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41353,Testability,assert,assert,41353,"ray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41596,Usability,ux,ux,41596,", 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41768,Usability,ux,ux,41768,"1 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.qcdb.vib.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41870,Usability,ux,ux,41870,"1 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.qcdb.vib.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:41919,Usability,ux,ux,41919,"1 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.qcdb.vib.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/util/filesystem.html:1603,Deployability,update,updated,1603,". psi4.driver.util.filesystem. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.util.filesystem. Source code for psi4.driver.util.filesystem; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os. [docs]def join_path(prefix, *args):; path = str(prefix); for elt in args:; path = os.path.join(path, str(elt)); return path. [docs]def ancestor(dir, n=1):; """"""Get the nth ancestor of a directory.""""""; parent = os.path.abspath(dir); for i in range(n):; parent = os.path.dirname(parent); return parent. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; psi4.driver.util.filesystem.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/psi4/driver/util/filesystem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/util/filesystem.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html:931,Deployability,update,update,931,". qcelemental.models.types. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types. Source code for qcelemental.models.types; from typing import Any, Dict. import numpy as np. class TypedArray(np.ndarray):; @classmethod; def __get_validators__(cls):; yield cls.validate. @classmethod; def validate(cls, v):; try:; v = np.asarray(v, dtype=cls._dtype); except ValueError:; raise ValueError(""Could not cast {} to NumPy Array!"".format(v)). return v. @classmethod; def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:; dt = cls._dtype; if dt is int or np.issubdtype(dt, np.integer):; items = {""type"": ""number"", ""multipleOf"": 1.0}; elif dt is float or np.issubdtype(dt, np.floating):; items = {""type"": ""number""}; elif dt is str or np.issubdtype(dt, np.string_):; items = {""type"": ""string""}; elif dt is bool or np.issubdtype(dt, np.bool_):; items = {""type"": ""boolean""}; field_schema.update(type=""array"", items=items). class ArrayMeta(type):; def __getitem__(self, dtype):; return type(""Array"", (TypedArray,), {""_dtype"": dtype}). [docs]class Array(np.ndarray, metaclass=ArrayMeta):; pass. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/models/types.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html:1309,Deployability,update,updated,1309,". qcelemental.models.types. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types. Source code for qcelemental.models.types; from typing import Any, Dict. import numpy as np. class TypedArray(np.ndarray):; @classmethod; def __get_validators__(cls):; yield cls.validate. @classmethod; def validate(cls, v):; try:; v = np.asarray(v, dtype=cls._dtype); except ValueError:; raise ValueError(""Could not cast {} to NumPy Array!"".format(v)). return v. @classmethod; def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:; dt = cls._dtype; if dt is int or np.issubdtype(dt, np.integer):; items = {""type"": ""number"", ""multipleOf"": 1.0}; elif dt is float or np.issubdtype(dt, np.floating):; items = {""type"": ""number""}; elif dt is str or np.issubdtype(dt, np.string_):; items = {""type"": ""string""}; elif dt is bool or np.issubdtype(dt, np.bool_):; items = {""type"": ""boolean""}; field_schema.update(type=""array"", items=items). class ArrayMeta(type):; def __getitem__(self, dtype):; return type(""Array"", (TypedArray,), {""_dtype"": dtype}). [docs]class Array(np.ndarray, metaclass=ArrayMeta):; pass. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/models/types.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html:303,Security,validat,validate,303,". qcelemental.models.types. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types. Source code for qcelemental.models.types; from typing import Any, Dict. import numpy as np. class TypedArray(np.ndarray):; @classmethod; def __get_validators__(cls):; yield cls.validate. @classmethod; def validate(cls, v):; try:; v = np.asarray(v, dtype=cls._dtype); except ValueError:; raise ValueError(""Could not cast {} to NumPy Array!"".format(v)). return v. @classmethod; def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:; dt = cls._dtype; if dt is int or np.issubdtype(dt, np.integer):; items = {""type"": ""number"", ""multipleOf"": 1.0}; elif dt is float or np.issubdtype(dt, np.floating):; items = {""type"": ""number""}; elif dt is str or np.issubdtype(dt, np.string_):; items = {""type"": ""string""}; elif dt is bool or np.issubdtype(dt, np.bool_):; items = {""type"": ""boolean""}; field_schema.update(type=""array"", items=items). class ArrayMeta(type):; def __getitem__(self, dtype):; return type(""Array"", (TypedArray,), {""_dtype"": dtype}). [docs]class Array(np.ndarray, metaclass=ArrayMeta):; pass. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/models/types.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html:331,Security,validat,validate,331,". qcelemental.models.types. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types. Source code for qcelemental.models.types; from typing import Any, Dict. import numpy as np. class TypedArray(np.ndarray):; @classmethod; def __get_validators__(cls):; yield cls.validate. @classmethod; def validate(cls, v):; try:; v = np.asarray(v, dtype=cls._dtype); except ValueError:; raise ValueError(""Could not cast {} to NumPy Array!"".format(v)). return v. @classmethod; def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:; dt = cls._dtype; if dt is int or np.issubdtype(dt, np.integer):; items = {""type"": ""number"", ""multipleOf"": 1.0}; elif dt is float or np.issubdtype(dt, np.floating):; items = {""type"": ""number""}; elif dt is str or np.issubdtype(dt, np.string_):; items = {""type"": ""string""}; elif dt is bool or np.issubdtype(dt, np.bool_):; items = {""type"": ""boolean""}; field_schema.update(type=""array"", items=items). class ArrayMeta(type):; def __getitem__(self, dtype):; return type(""Array"", (TypedArray,), {""_dtype"": dtype}). [docs]class Array(np.ndarray, metaclass=ArrayMeta):; pass. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.models.types.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/models/types.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/models/types.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:627,Availability,error,error,627,". qcelemental.molparse.from_arrays. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays. Source code for qcelemental.molparse.from_arrays; import pprint; import re; from copy import deepcopy. import numpy as np. from ..exceptions import ValidationError; from ..physical_constants import constants; from ..util import provenance_stamp, unnp, update_with_error; from .chgmult import validate_and_fill_chgmult; from .nucleus import reconcile_nucleus; from .regex import VERSION_PATTERN. def from_input_arrays(; *,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm=""error"",; missing_enabled_return_efp=""error"",; # qm; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; # efp; fragment_files=None,; hint_types=None,; geom_hints=None,; # qm-vz; geom_unsettled=None,; variables=None,; # processing details; speclabel=True,; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; """"""Compose a Molecule dict from unvalidated arrays and variables; in multiple domains. Drives :py:func:`qcelemental.molparse.from_arrays` for sucessive; domains and hooks them together (e.g., impose `fix_com` on ""qm""; when ""efp"" present. """"""; molinit = {}; if enable_qm:; molinit[""qm""] = {}; if enable_efp:; molinit[""efp""] = {}. if enable_efp:; processed = from_arrays(; domain=""efp"",; missing_enabled_return=missing_enabled_return_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:664,Availability,error,error,664,". qcelemental.molparse.from_arrays. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays. Source code for qcelemental.molparse.from_arrays; import pprint; import re; from copy import deepcopy. import numpy as np. from ..exceptions import ValidationError; from ..physical_constants import constants; from ..util import provenance_stamp, unnp, update_with_error; from .chgmult import validate_and_fill_chgmult; from .nucleus import reconcile_nucleus; from .regex import VERSION_PATTERN. def from_input_arrays(; *,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm=""error"",; missing_enabled_return_efp=""error"",; # qm; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; # efp; fragment_files=None,; hint_types=None,; geom_hints=None,; # qm-vz; geom_unsettled=None,; variables=None,; # processing details; speclabel=True,; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; """"""Compose a Molecule dict from unvalidated arrays and variables; in multiple domains. Drives :py:func:`qcelemental.molparse.from_arrays` for sucessive; domains and hooks them together (e.g., impose `fix_com` on ""qm""; when ""efp"" present. """"""; molinit = {}; if enable_qm:; molinit[""qm""] = {}; if enable_efp:; molinit[""efp""] = {}. if enable_efp:; processed = from_arrays(; domain=""efp"",; missing_enabled_return=missing_enabled_return_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:3723,Availability,error,error,3723,"ame,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; geom_unsettled=geom_unsettled,; variables=variables,; # processing details; speclabel=speclabel,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missing_enabled_return: str = ""error"",; np_out: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibl",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:5053,Availability,error,error,5053,"bel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:5203,Availability,error,error,5203,"bel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:5477,Availability,error,error,5477,"m` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:5532,Availability,redundant,redundant,5532,"ose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label for molecule; should be valid Python identifier.; units : {'Angstrom', 'Bohr'}; Uni",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:9028,Availability,avail,available,9028,"ds ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_sta",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:11605,Deployability,update,update,11605,"rocessed); nat = len(molinit[""geom_unsettled""]). else:; processed = validate_and_fill_geometry(geom=geom, tooclose=tooclose, copy=copy); update_with_error(molinit, processed); nat = molinit[""geom""].shape[0] // 3. processed = validate_and_fill_nuclei(; nat,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); update_with_error(molinit, processed). processed = validate_and_fill_fragments(; nat,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; ); update_with_error(molinit, processed). Z_available = molinit[""elez""] * molinit[""real""] * 1.0; processed = validate_and_fill_chgmult(; zeff=Z_available,; fragment_separators=molinit[""fragment_separators""],; molecular_charge=molecular_charge,; fragment_charges=molinit[""fragment_charges""],; molecular_multiplicity=molecular_multiplicity,; fragment_multiplicities=molinit[""fragment_multiplicities""],; zero_ghost_fragments=zero_ghost_fragments,; verbose=verbose,; ); del molinit[""fragment_charges""] # sometimes safe update is too picky about overwriting v_a_f_fragments values; del molinit[""fragment_multiplicities""]; update_with_error(molinit, processed). extern = domain == ""efp"". processed = validate_and_fill_frame(; extern=extern, fix_com=fix_com, fix_orientation=fix_orientation, fix_symmetry=fix_symmetry; ); update_with_error(molinit, processed). if verbose >= 2:; print(""RETURN FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys =",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:23569,Deployability,update,updated,23569,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:7144,Energy Efficiency,charge,charge,7144,"c. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label for molecule; should be valid Python identifier.; units : {'Angstrom', 'Bohr'}; Units for `geom`.; input_units_to_au : float, optional; If `units='Angstrom'`, overrides consumer's value for [A]-->[a0] conversion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symmetry which `geom` should be treated. Lowercase.; geom : ndarray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (nat, ) Element symbol for atoms.; mass : ndarray of float; (nat, ) Atomic mass [u] for atoms.; real : ndarray of bool; (nat, ) Real/ghostedness for atoms.; elbl : ndarray of str; (nat, ) Label with any tagging information from element spec.; fragment_separators : list of int; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; fragment_charges : list of float; (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:7589,Energy Efficiency,charge,charge,7589," : float, optional; If `units='Angstrom'`, overrides consumer's value for [A]-->[a0] conversion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symmetry which `geom` should be treated. Lowercase.; geom : ndarray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (nat, ) Element symbol for atoms.; mass : ndarray of float; (nat, ) Atomic mass [u] for atoms.; real : ndarray of bool; (nat, ) Real/ghostedness for atoms.; elbl : ndarray of str; (nat, ) Label with any tagging information from element spec.; fragment_separators : list of int; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; fragment_charges : list of float; (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of li",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:7596,Energy Efficiency,allocate,allocated,7596," : float, optional; If `units='Angstrom'`, overrides consumer's value for [A]-->[a0] conversion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symmetry which `geom` should be treated. Lowercase.; geom : ndarray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (nat, ) Element symbol for atoms.; mass : ndarray of float; (nat, ) Atomic mass [u] for atoms.; real : ndarray of bool; (nat, ) Real/ghostedness for atoms.; elbl : ndarray of str; (nat, ) Label with any tagging information from element spec.; fragment_separators : list of int; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; fragment_charges : list of float; (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of li",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:7693,Energy Efficiency,allocate,allocated,7693,"sion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symmetry which `geom` should be treated. Lowercase.; geom : ndarray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (nat, ) Element symbol for atoms.; mass : ndarray of float; (nat, ) Atomic mass [u] for atoms.; real : ndarray of bool; (nat, ) Real/ghostedness for atoms.; elbl : ndarray of str; (nat, ) Label with any tagging information from element spec.; fragment_separators : list of int; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; fragment_charges : list of float; (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing ancho",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:7754,Energy Efficiency,charge,charge,7754,"wed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symmetry which `geom` should be treated. Lowercase.; geom : ndarray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (nat, ) Element symbol for atoms.; mass : ndarray of float; (nat, ) Atomic mass [u] for atoms.; real : ndarray of bool; (nat, ) Real/ghostedness for atoms.; elbl : ndarray of str; (nat, ) Label with any tagging information from element spec.; fragment_separators : list of int; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; fragment_charges : list of float; (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:20184,Energy Efficiency,charge,charge,20184,"eal.shape == elbl.shape):; raise ValidationError(; """"""Dimension mismatch natom {} among A {}, Z {}, E {}, mass {}, real {}, and elbl {}"""""".format(; (nat,), elea.shape, elez.shape, elem.shape, mass.shape, real.shape, elbl.shape; ); ). if nat:; A, Z, E, mass, real, label = zip(; *[; reconcile_nucleus(; A=elea[at],; Z=elez[at],; E=elem[at],; mass=mass[at],; real=real[at],; label=elbl[at],; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); for at in range(nat); ]; ); else:; A = Z = E = mass = real = label = []; return {; ""elea"": np.array(A, dtype=int),; ""elez"": np.array(Z, dtype=int),; ""elem"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; rais",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:7987,Integrability,rout,routine,7987,"ray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (nat, ) Element symbol for atoms.; mass : ndarray of float; (nat, ) Atomic mass [u] for atoms.; real : ndarray of bool; (nat, ) Real/ghostedness for atoms.; elbl : ndarray of str; (nat, ) Label with any tagging information from element spec.; fragment_separators : list of int; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; fragment_charges : list of float; (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; i",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:12479,Integrability,rout,routine,12479,"_multiplicities""],; zero_ghost_fragments=zero_ghost_fragments,; verbose=verbose,; ); del molinit[""fragment_charges""] # sometimes safe update is too picky about overwriting v_a_f_fragments values; del molinit[""fragment_multiplicities""]; update_with_error(molinit, processed). extern = domain == ""efp"". processed = validate_and_fill_frame(; extern=extern, fix_com=fix_com, fix_orientation=fix_orientation, fix_symmetry=fix_symmetry; ); update_with_error(molinit, processed). if verbose >= 2:; print(""RETURN FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13082,Integrability,rout,routine,13082," molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13143,Integrability,rout,routine,13143," molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13221,Integrability,rout,routine,13221,"e,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:1109,Modifiability,variab,variables,1109,". qcelemental.molparse.from_arrays. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays. Source code for qcelemental.molparse.from_arrays; import pprint; import re; from copy import deepcopy. import numpy as np. from ..exceptions import ValidationError; from ..physical_constants import constants; from ..util import provenance_stamp, unnp, update_with_error; from .chgmult import validate_and_fill_chgmult; from .nucleus import reconcile_nucleus; from .regex import VERSION_PATTERN. def from_input_arrays(; *,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm=""error"",; missing_enabled_return_efp=""error"",; # qm; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; # efp; fragment_files=None,; hint_types=None,; geom_hints=None,; # qm-vz; geom_unsettled=None,; variables=None,; # processing details; speclabel=True,; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; """"""Compose a Molecule dict from unvalidated arrays and variables; in multiple domains. Drives :py:func:`qcelemental.molparse.from_arrays` for sucessive; domains and hooks them together (e.g., impose `fix_com` on ""qm""; when ""efp"" present. """"""; molinit = {}; if enable_qm:; molinit[""qm""] = {}; if enable_efp:; molinit[""efp""] = {}. if enable_efp:; processed = from_arrays(; domain=""efp"",; missing_enabled_return=missing_enabled_return_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:1326,Modifiability,variab,variables,1326,"tionError; from ..physical_constants import constants; from ..util import provenance_stamp, unnp, update_with_error; from .chgmult import validate_and_fill_chgmult; from .nucleus import reconcile_nucleus; from .regex import VERSION_PATTERN. def from_input_arrays(; *,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm=""error"",; missing_enabled_return_efp=""error"",; # qm; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; # efp; fragment_files=None,; hint_types=None,; geom_hints=None,; # qm-vz; geom_unsettled=None,; variables=None,; # processing details; speclabel=True,; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; """"""Compose a Molecule dict from unvalidated arrays and variables; in multiple domains. Drives :py:func:`qcelemental.molparse.from_arrays` for sucessive; domains and hooks them together (e.g., impose `fix_com` on ""qm""; when ""efp"" present. """"""; molinit = {}; if enable_qm:; molinit[""qm""] = {}; if enable_efp:; molinit[""efp""] = {}. if enable_efp:; processed = from_arrays(; domain=""efp"",; missing_enabled_return=missing_enabled_return_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error(molinit, {""efp"": processed}); if molinit[""efp""] == {}:; del molinit[""efp""]. efp_present = enable_efp and ""efp"" in molinit and bool(len(molinit[""efp""][""geom_hints""])); if efp_present:; fix_com = True; fix_orientation = True; fix_symmetry = ""c1"". if enable_qm:; dm = ""qmvz"" if geom_unsettled else ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:2864,Modifiability,variab,variables,2864,"eturn_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error(molinit, {""efp"": processed}); if molinit[""efp""] == {}:; del molinit[""efp""]. efp_present = enable_efp and ""efp"" in molinit and bool(len(molinit[""efp""][""geom_hints""])); if efp_present:; fix_com = True; fix_orientation = True; fix_symmetry = ""c1"". if enable_qm:; dm = ""qmvz"" if geom_unsettled else ""qm""; processed = from_arrays(; domain=dm,; missing_enabled_return=missing_enabled_return_qm,; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; geom_unsettled=geom_unsettled,; variables=variables,; # processing details; speclabel=speclabel,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missin",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:2874,Modifiability,variab,variables,2874,"eturn_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error(molinit, {""efp"": processed}); if molinit[""efp""] == {}:; del molinit[""efp""]. efp_present = enable_efp and ""efp"" in molinit and bool(len(molinit[""efp""][""geom_hints""])); if efp_present:; fix_com = True; fix_orientation = True; fix_symmetry = ""c1"". if enable_qm:; dm = ""qmvz"" if geom_unsettled else ""qm""; processed = from_arrays(; domain=dm,; missing_enabled_return=missing_enabled_return_qm,; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; geom_unsettled=geom_unsettled,; variables=variables,; # processing details; speclabel=speclabel,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missin",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:3661,Modifiability,variab,variables,3661,"ame,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; geom_unsettled=geom_unsettled,; variables=variables,; # processing details; speclabel=speclabel,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missing_enabled_return: str = ""error"",; np_out: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibl",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:3958,Modifiability,variab,variables,3958,"el,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; copy=copy,; verbose=1,; ); update_with_error(molinit, {""qm"": processed}); if molinit[""qm""] == {}:; del molinit[""qm""]. return molinit. [docs]def from_arrays(; *,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missing_enabled_return: str = ""error"",; np_out: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/ta",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:4450,Modifiability,extend,extending,4450,"r_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missing_enabled_return: str = ""error"",; np_out: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error;",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:8688,Modifiability,variab,variables,8688,"fragment_multiplicities : list of int; (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge : float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise Validatio",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:8700,Modifiability,variab,variables,8700,": float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:8746,Modifiability,variab,variables,8746,": float; total charge on system.; molecular_multiplicity : int; total multiplicity on system.; comment : str, optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:10414,Modifiability,variab,variables,10414,"== ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_stamp(__name__); update_with_error(molinit, processed). if domain == ""efp"":; processed = validate_and_fill_efp(fragment_files=fragment_files, hint_types=hint_types, geom_hints=geom_hints); update_with_error(molinit, processed); extern = bool(len(molinit[""geom_hints""])). if domain == ""qm"" or (domain == ""efp"" and geom is not None) or domain == ""qmvz"":; if domain == ""qmvz"":; processed = validate_and_fill_unsettled_geometry(geom_unsettled=geom_unsettled, variables=variables); update_with_error(molinit, processed); nat = len(molinit[""geom_unsettled""]). else:; processed = validate_and_fill_geometry(geom=geom, tooclose=tooclose, copy=copy); update_with_error(molinit, processed); nat = molinit[""geom""].shape[0] // 3. processed = validate_and_fill_nuclei(; nat,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); update_with_error(molinit, processed). processed = validate_and_fill_fragments(; nat,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; ); update_with_error(molinit, processed). Z_available = molinit[""elez""] * molinit[""real""] * 1.0; processed = validate_and_fill_chgmult(; zeff=Z_available,; fragment_separators=molinit[""fragment_separators""],; molecular_charge=molecular_charge,; fragment_charges=molinit[""fragment_c",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:10424,Modifiability,variab,variables,10424,"== ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_stamp(__name__); update_with_error(molinit, processed). if domain == ""efp"":; processed = validate_and_fill_efp(fragment_files=fragment_files, hint_types=hint_types, geom_hints=geom_hints); update_with_error(molinit, processed); extern = bool(len(molinit[""geom_hints""])). if domain == ""qm"" or (domain == ""efp"" and geom is not None) or domain == ""qmvz"":; if domain == ""qmvz"":; processed = validate_and_fill_unsettled_geometry(geom_unsettled=geom_unsettled, variables=variables); update_with_error(molinit, processed); nat = len(molinit[""geom_unsettled""]). else:; processed = validate_and_fill_geometry(geom=geom, tooclose=tooclose, copy=copy); update_with_error(molinit, processed); nat = molinit[""geom""].shape[0] // 3. processed = validate_and_fill_nuclei(; nat,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); update_with_error(molinit, processed). processed = validate_and_fill_fragments(; nat,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; ); update_with_error(molinit, processed). Z_available = molinit[""elez""] * molinit[""real""] * 1.0; processed = validate_and_fill_chgmult(; zeff=Z_available,; fragment_separators=molinit[""fragment_separators""],; molecular_charge=molecular_charge,; fragment_charges=molinit[""fragment_c",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:17990,Modifiability,extend,extend,17990,"6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs). # Record issues; if np.any(dists < metric):; indices = np.where(dists < metric)[0]; tooclose_inds.extend([(x, y, dist) for y, dist in zip(indices + x + 1, dists[indices] ** 0.5)]). if tooclose_inds:; raise ValidationError(; """"""Following atoms are too close: {}"""""".format([(i, j, dist) for i, j, dist in tooclose_inds]); ). return {""geom"": npgeom.reshape((-1))}. def validate_and_fill_nuclei(; nat,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; # processing details; speclabel=True,; nonphysical=False,; mtol=1.0e-3,; verbose=1,; ):; """"""Check the nuclear identity arrays for consistency and fill in knowable values."""""". if elea is None:; elea = np.asarray([None] * nat); else:; # -1 equivalent to None; elea = np.asarray(elea); if -1 in elea:; elea = np.array([(None if at == -1 else at) for at in elea]) # Rebuild to change dtype if needed. if elez is None:; elez = np.asarray([None] * nat); else:; elez = np.asarray(elez). if elem is None:; elem = np.asarray([None] * nat); else:; elem = np.asarray(elem). if mass is None:; mass = np.asarray([None] * nat); else:; mass = np.asarray(mass). if real is None:; re",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:22406,Modifiability,variab,variables,22406,"m; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. me",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:23174,Modifiability,variab,variables,23174,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:23212,Modifiability,Variab,Variables,23212,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:23257,Modifiability,variab,variables,23257,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:23313,Modifiability,variab,variables,23313,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:23368,Modifiability,variab,variables,23368,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:20929,Performance,perform,perform,20929,"em"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; f",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:5532,Safety,redund,redundant,5532,"ose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label for molecule; should be valid Python identifier.; units : {'Angstrom', 'Bohr'}; Uni",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:11600,Safety,safe,safe,11600,"rocessed); nat = len(molinit[""geom_unsettled""]). else:; processed = validate_and_fill_geometry(geom=geom, tooclose=tooclose, copy=copy); update_with_error(molinit, processed); nat = molinit[""geom""].shape[0] // 3. processed = validate_and_fill_nuclei(; nat,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); update_with_error(molinit, processed). processed = validate_and_fill_fragments(; nat,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; ); update_with_error(molinit, processed). Z_available = molinit[""elez""] * molinit[""real""] * 1.0; processed = validate_and_fill_chgmult(; zeff=Z_available,; fragment_separators=molinit[""fragment_separators""],; molecular_charge=molecular_charge,; fragment_charges=molinit[""fragment_charges""],; molecular_multiplicity=molecular_multiplicity,; fragment_multiplicities=molinit[""fragment_multiplicities""],; zero_ghost_fragments=zero_ghost_fragments,; verbose=verbose,; ); del molinit[""fragment_charges""] # sometimes safe update is too picky about overwriting v_a_f_fragments values; del molinit[""fragment_multiplicities""]; update_with_error(molinit, processed). extern = domain == ""efp"". processed = validate_and_fill_frame(; extern=extern, fix_com=fix_com, fix_orientation=fix_orientation, fix_symmetry=fix_symmetry; ); update_with_error(molinit, processed). if verbose >= 2:; print(""RETURN FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys =",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:290,Security,Validat,ValidationError,290,". qcelemental.molparse.from_arrays. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays. Source code for qcelemental.molparse.from_arrays; import pprint; import re; from copy import deepcopy. import numpy as np. from ..exceptions import ValidationError; from ..physical_constants import constants; from ..util import provenance_stamp, unnp, update_with_error; from .chgmult import validate_and_fill_chgmult; from .nucleus import reconcile_nucleus; from .regex import VERSION_PATTERN. def from_input_arrays(; *,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm=""error"",; missing_enabled_return_efp=""error"",; # qm; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units=""Angstrom"",; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; # efp; fragment_files=None,; hint_types=None,; geom_hints=None,; # qm-vz; geom_unsettled=None,; variables=None,; # processing details; speclabel=True,; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; """"""Compose a Molecule dict from unvalidated arrays and variables; in multiple domains. Drives :py:func:`qcelemental.molparse.from_arrays` for sucessive; domains and hooks them together (e.g., impose `fix_com` on ""qm""; when ""efp"" present. """"""; molinit = {}; if enable_qm:; molinit[""qm""] = {}; if enable_efp:; molinit[""efp""] = {}. if enable_efp:; processed = from_arrays(; domain=""efp"",; missing_enabled_return=missing_enabled_return_efp,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_files=fragment_files,; hint_types=hint_types,; geom_hints=geom_hints,; # which other processing details needed?; verbose=verbose,; ); update_with_error",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:4702,Security,validat,validation,4702,"t: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmet",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:5448,Security,validat,validated,5448,"m` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:5900,Security,validat,validated,5900,"alse`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label for molecule; should be valid Python identifier.; units : {'Angstrom', 'Bohr'}; Units for `geom`.; input_units_to_au : float, optional; If `units='Angstrom'`, overrides consumer's value for [A]-->[a0] conversion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symm",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:6197,Security,validat,validator,6197,"onary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label for molecule; should be valid Python identifier.; units : {'Angstrom', 'Bohr'}; Units for `geom`.; input_units_to_au : float, optional; If `units='Angstrom'`, overrides consumer's value for [A]-->[a0] conversion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symmetry which `geom` should be treated. Lowercase.; geom : ndarray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (n",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:8829,Security,Validat,ValidationError,8829,"optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:8986,Security,Validat,ValidationError,8986,"ds ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_sta",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:9294,Security,Validat,ValidationError,9294,"t_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_stamp(__name__); update_with_error(molinit, processed). if domain == ""efp"":; processed = validate_and_fill_efp(fragment_files=fragment_files, hint_types=hint_types, geom_hints=geom_hints); update_with_error(molinit, processed); extern = bool(len(molinit[""geom_hints""])). if domain == ""qm"" or (domain =",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:9616,Security,Validat,ValidationError,9616,"tled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_stamp(__name__); update_with_error(molinit, processed). if domain == ""efp"":; processed = validate_and_fill_efp(fragment_files=fragment_files, hint_types=hint_types, geom_hints=geom_hints); update_with_error(molinit, processed); extern = bool(len(molinit[""geom_hints""])). if domain == ""qm"" or (domain == ""efp"" and geom is not None) or domain == ""qmvz"":; if domain == ""qmvz"":; processed = validate_and_fill_unsettled_geometry(geom_unsettled=geom_unsettled, variables=variables); update_with_error(molinit, processed); nat = len(molinit[""geom_unsettled""]). else:; processed = validate_and_fill_geometry(geom",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:12572,Security,Validat,ValidationError,12572,"rges""] # sometimes safe update is too picky about overwriting v_a_f_fragments values; del molinit[""fragment_multiplicities""]; update_with_error(molinit, processed). extern = domain == ""efp"". processed = validate_and_fill_frame(; extern=extern, fix_com=fix_com, fix_orientation=fix_orientation, fix_symmetry=fix_symmetry; ); update_with_error(molinit, processed). if verbose >= 2:; print(""RETURN FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connec",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:12733,Security,Validat,ValidationError,12733,"cessed). extern = domain == ""efp"". processed = validate_and_fill_frame(; extern=extern, fix_com=fix_com, fix_orientation=fix_orientation, fix_symmetry=fix_symmetry; ); update_with_error(molinit, processed). if verbose >= 2:; print(""RETURN FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:12940,Security,Validat,ValidationError,12940,"N FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivit",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13106,Security,Validat,ValidationError,13106," molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13264,Security,Validat,ValidationError,13264,"e,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13659,Security,Validat,ValidationError,13659,"prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13815,Security,Validat,ValidationError,13815,""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_uni",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:13945,Security,Validat,ValidationError,13945,"or(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:14204,Security,Validat,ValidationError,14204,"}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, exter",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:14416,Security,Validat,ValidationError,14416,"rovenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise Valida",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:14727,Security,Validat,ValidationError,14727,"); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; el",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:15122,Security,Validat,ValidationError,15122,"onn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def va",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:15274,Security,Validat,ValidationError,15274,"not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:15424,Security,Validat,ValidationError,15424,"; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:15606,Security,Validat,ValidationError,15606,"utau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; frag",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:15804,Security,Validat,ValidationError,15804,", input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""x",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:16422,Security,Validat,ValidationError,16422,""".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types""",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:16724,Security,Validat,ValidationError,16724," is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:16901,Security,Validat,ValidationError,16901,"etry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:17174,Security,Validat,ValidationError,17174,"and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs). # Record issues; if np.any(dists < metric):; indices = np.where(dists < metric)[0]; tooclose_inds.extend([(x, y, dist) for y, dist in zip(indices + x + 1, dists[indices] ** 0.5)]). if tooclose_inds:; raise ValidationError(; """"""",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:17347,Security,Validat,ValidationError,17347,"t_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs). # Record issues; if np.any(dists < metric):; indices = np.where(dists < metric)[0]; tooclose_inds.extend([(x, y, dist) for y, dist in zip(indices + x + 1, dists[indices] ** 0.5)]). if tooclose_inds:; raise ValidationError(; """"""Following atoms are too close: {}"""""".format([(i, j, dist) for i, j, dist in tooclose_inds]); ). return {""geom"": npgeom.reshape((-1))}. def validate_and_fill_nuclei(; nat,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:18098,Security,Validat,ValidationError,18098,"oat(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs). # Record issues; if np.any(dists < metric):; indices = np.where(dists < metric)[0]; tooclose_inds.extend([(x, y, dist) for y, dist in zip(indices + x + 1, dists[indices] ** 0.5)]). if tooclose_inds:; raise ValidationError(; """"""Following atoms are too close: {}"""""".format([(i, j, dist) for i, j, dist in tooclose_inds]); ). return {""geom"": npgeom.reshape((-1))}. def validate_and_fill_nuclei(; nat,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; # processing details; speclabel=True,; nonphysical=False,; mtol=1.0e-3,; verbose=1,; ):; """"""Check the nuclear identity arrays for consistency and fill in knowable values."""""". if elea is None:; elea = np.asarray([None] * nat); else:; # -1 equivalent to None; elea = np.asarray(elea); if -1 in elea:; elea = np.array([(None if at == -1 else at) for at in elea]) # Rebuild to change dtype if needed. if elez is None:; elez = np.asarray([None] * nat); else:; elez = np.asarray(elez). if elem is None:; elem = np.asarray([None] * nat); else:; elem = np.asarray(elem). if mass is None:; mass = np.asarray([None] * nat); else:; mass = np.asarray(mass). if real is None:; real = np.asarray([None] * nat); else:; real = np.asarray(real). if elbl is None:; elbl",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:19283,Security,Validat,ValidationError,19283,"ass=None,; real=None,; elbl=None,; # processing details; speclabel=True,; nonphysical=False,; mtol=1.0e-3,; verbose=1,; ):; """"""Check the nuclear identity arrays for consistency and fill in knowable values."""""". if elea is None:; elea = np.asarray([None] * nat); else:; # -1 equivalent to None; elea = np.asarray(elea); if -1 in elea:; elea = np.array([(None if at == -1 else at) for at in elea]) # Rebuild to change dtype if needed. if elez is None:; elez = np.asarray([None] * nat); else:; elez = np.asarray(elez). if elem is None:; elem = np.asarray([None] * nat); else:; elem = np.asarray(elem). if mass is None:; mass = np.asarray([None] * nat); else:; mass = np.asarray(mass). if real is None:; real = np.asarray([None] * nat); else:; real = np.asarray(real). if elbl is None:; elbl = np.asarray([None] * nat); else:; elbl = np.asarray(elbl). if not ((nat,) == elea.shape == elez.shape == elem.shape == mass.shape == real.shape == elbl.shape):; raise ValidationError(; """"""Dimension mismatch natom {} among A {}, Z {}, E {}, mass {}, real {}, and elbl {}"""""".format(; (nat,), elea.shape, elez.shape, elem.shape, mass.shape, real.shape, elbl.shape; ); ). if nat:; A, Z, E, mass, real, label = zip(; *[; reconcile_nucleus(; A=elea[at],; Z=elez[at],; E=elem[at],; mass=mass[at],; real=real[at],; label=elbl[at],; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); for at in range(nat); ]; ); else:; A = Z = E = mass = real = label = []; return {; ""elea"": np.array(A, dtype=int),; ""elez"": np.array(Z, dtype=int),; ""elem"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:20550,Security,Validat,ValidationError,20550,"; A=elea[at],; Z=elez[at],; E=elem[at],; mass=mass[at],; real=real[at],; label=elbl[at],; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); for at in range(nat); ]; ); else:; A = Z = E = mass = real = label = []; return {; ""elea"": np.array(A, dtype=int),; ""elez"": np.array(Z, dtype=int),; ""elem"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None el",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:20873,Security,Validat,ValidationError,20873,"em"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; f",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:21062,Security,Validat,ValidationError,21062,"agment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == le",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:21253,Security,Validat,ValidationError,21253,"her, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fra",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:21617,Security,Validat,ValidationError,21617,"agment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:21916,Security,Validat,ValidationError,21916,"ators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_fol",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:22093,Security,Validat,ValidationError,22093,"-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]]",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:22495,Security,Validat,ValidationError,22495,"fr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molp",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:22644,Security,Validat,ValidationError,22644,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:22932,Security,Validat,ValidationError,22932,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:23193,Security,Validat,ValidationError,23193,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molparse.from_arrays.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:11506,Availability,down,down,11506,"t = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)); bnbn = [rrdistmat[first, second] for first, second in zip(rgp, rgp[1:])]; for pm in itertools.permutations(cgp):; cncn = [ccdistmat[first, second] for first, second in zip(pm, pm[1:])]; if np.allclose(bnbn, cncn, atol=1.0):; if verbose >= 1:; print(""Candidate:"", rgp, ""<--"", pm); yield pm. def filter_hungarian_uno(rgp, cgp):; """"""Hungarian algorithm on cost matrix based off headless (all Z same w/i space anyways) NRE.; Having found _a_ solution and the reduced cost matrix, this still isn't likely to produce; atom rearrangement fit for Kabsch b/c internal coordinate cost matrix doesn't nail down; distance-equivalent atoms with different Cartesian coordinates like Cartesian-distance-matrix; cost matrix does. So, form a bipartite graph from all essentially-zero connections between; ref and concern and run Uno algorithm to enumerate them. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)). # formulate cost matrix from internal (not Cartesian) layouts of R & C; npcgp = np.array(cgp); submatCC = ccnremat[np.ix_(cgp, cgp)]; submatRR = rrnremat[np.ix_(rgp, rgp)]; sumCC = 100.0 * np.sum(submatCC, axis=0) # cost mat small if not scaled, this way like Z=Neon; sumRR = 100.0 * np.sum(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorith",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:14217,Deployability,install,installing,14217," gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. if algorithm == ""hungarian_uno"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); with np.errstate(divide=""ignore""):; ccnremat = np.reciprocal(ccdistmat); rrnremat = np.reciprocal(rrdistmat); ccnremat[ccnremat == np.inf] = 0.0; rrnremat[rrnremat == np.inf] = 0.0; algofn = filter_hungarian_uno. # Ensure (optional dependency) networkx exists; if not which_import(""networkx"", return_bool=True):; raise ModuleNotFoundError(; """"""Python module networkx not found. Solve by installing it: `conda install networkx` or `pip install networkx`""""""; ) # pragma: no cover. # collect candidate atom orderings from algofn for each of the atom classes,; # recombine the classes with each other in every permutation (could maybe; # add Hungarian here, too) as generator back to permutation_kabsch; for cpmut in itertools.product(*itertools.starmap(algofn, connect.items())):; atpat = [None] * len(ref); for igp, group in enumerate(cpmut):; for iidx, idx in enumerate(list(connect.keys())[igp]):; atpat[idx] = group[iidx]; yield atpat. def kabsch_align(rgeom, cgeom, weight=None):; r""""""Finds optimal translation and rotation to align `cgeom` onto `rgeom` via; Kabsch algorithm by minimizing the norm of the residual, || R - U * C ||. Parameters; ----------; rgeom : ndarray of float; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom : ndarray of float; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same Natom, units, and 1-to-1 atom ord",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:14239,Deployability,install,install,14239," gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. if algorithm == ""hungarian_uno"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); with np.errstate(divide=""ignore""):; ccnremat = np.reciprocal(ccdistmat); rrnremat = np.reciprocal(rrdistmat); ccnremat[ccnremat == np.inf] = 0.0; rrnremat[rrnremat == np.inf] = 0.0; algofn = filter_hungarian_uno. # Ensure (optional dependency) networkx exists; if not which_import(""networkx"", return_bool=True):; raise ModuleNotFoundError(; """"""Python module networkx not found. Solve by installing it: `conda install networkx` or `pip install networkx`""""""; ) # pragma: no cover. # collect candidate atom orderings from algofn for each of the atom classes,; # recombine the classes with each other in every permutation (could maybe; # add Hungarian here, too) as generator back to permutation_kabsch; for cpmut in itertools.product(*itertools.starmap(algofn, connect.items())):; atpat = [None] * len(ref); for igp, group in enumerate(cpmut):; for iidx, idx in enumerate(list(connect.keys())[igp]):; atpat[idx] = group[iidx]; yield atpat. def kabsch_align(rgeom, cgeom, weight=None):; r""""""Finds optimal translation and rotation to align `cgeom` onto `rgeom` via; Kabsch algorithm by minimizing the norm of the residual, || R - U * C ||. Parameters; ----------; rgeom : ndarray of float; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom : ndarray of float; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same Natom, units, and 1-to-1 atom ord",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:14265,Deployability,install,install,14265," gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. if algorithm == ""hungarian_uno"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); with np.errstate(divide=""ignore""):; ccnremat = np.reciprocal(ccdistmat); rrnremat = np.reciprocal(rrdistmat); ccnremat[ccnremat == np.inf] = 0.0; rrnremat[rrnremat == np.inf] = 0.0; algofn = filter_hungarian_uno. # Ensure (optional dependency) networkx exists; if not which_import(""networkx"", return_bool=True):; raise ModuleNotFoundError(; """"""Python module networkx not found. Solve by installing it: `conda install networkx` or `pip install networkx`""""""; ) # pragma: no cover. # collect candidate atom orderings from algofn for each of the atom classes,; # recombine the classes with each other in every permutation (could maybe; # add Hungarian here, too) as generator back to permutation_kabsch; for cpmut in itertools.product(*itertools.starmap(algofn, connect.items())):; atpat = [None] * len(ref); for igp, group in enumerate(cpmut):; for iidx, idx in enumerate(list(connect.keys())[igp]):; atpat[idx] = group[iidx]; yield atpat. def kabsch_align(rgeom, cgeom, weight=None):; r""""""Finds optimal translation and rotation to align `cgeom` onto `rgeom` via; Kabsch algorithm by minimizing the norm of the residual, || R - U * C ||. Parameters; ----------; rgeom : ndarray of float; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom : ndarray of float; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same Natom, units, and 1-to-1 atom ord",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:21088,Deployability,update,updated,21088,"y-like, optional; Whether to randomly shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`); or shuffle according to specified (nat, ) indices (e.g., [2, 1, 0]); do_shift : bool or array-like, optional; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin (`False`) or shift along; specified (3, ) vector (e.g., np.array([0., 1., -1.])).; do_rotate : bool or array-like, optional; Whether to generate a random 3D rotation according to algorithm of Arvo (`True`); or leave at current orientation (`False`) or rotate with specified (3, 3) matrix.; deflection : float, optional; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror : bool, optional; Whether to set mirror reflection instruction. Changes identity of; molecule so off by default. Returns; -------; tuple; AlignmentMill with fields (shift, rotation, atommap, mirror); as requested: identity, random, or specified. """"""; rand_elord = np.arange(nat); if do_resort is True:; np.random.shuffle(rand_elord); elif do_resort is False:; pass; else:; rand_elord = np.array(do_resort); assert rand_elord.shape == (nat,). if do_shift is True:; rand_shift = 6 * np.random.random_sample((3,)) - 3; elif do_shift is False:; rand_shift = np.zeros((3,)); else:; rand_shift = np.array(do_shift); assert rand_shift.shape == (3,). if do_rotate is True:; rand_rot3d = random_rotation_matrix(deflection=deflection); elif do_rotate is False:; rand_rot3d = np.identity(3); else:; rand_rot3d = np.array(do_rotate); assert rand_rot3d.shape == (3, 3). perturbation = AlignmentMill(shift=rand_shift, rotation=rand_rot3d, atommap=rand_elord, mirror=do_mirror); return perturbation. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:571,Energy Efficiency,energy,energy,571,". qcelemental.molutil.align. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align. Source code for qcelemental.molutil.align; import collections; import itertools; import time; from typing import Union. import numpy as np. from ..exceptions import ValidationError; from ..models import AlignmentMill; from ..physical_constants import constants; from ..testing import compare_values; from ..util import distance_matrix, linear_sum_assignment, random_rotation_matrix, uno, which_import. def _nre(Z, geom):; """"""Nuclear repulsion energy"""""". nre = 0.0; for at1 in range(geom.shape[0]):; for at2 in range(at1):; dist = np.linalg.norm(geom[at1] - geom[at2]); nre += Z[at1] * Z[at2] / dist; return nre. def _pseudo_nre(Zhash, geom):; """"""Pseudo nuclear repulsion energy where non-physical Z contrived from `Zhash`."""""". Zidx = list(set(sorted(Zhash))); pZ = [Zidx.index(z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:799,Energy Efficiency,energy,energy,799,". qcelemental.molutil.align. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align. Source code for qcelemental.molutil.align; import collections; import itertools; import time; from typing import Union. import numpy as np. from ..exceptions import ValidationError; from ..models import AlignmentMill; from ..physical_constants import constants; from ..testing import compare_values; from ..util import distance_matrix, linear_sum_assignment, random_rotation_matrix, uno, which_import. def _nre(Z, geom):; """"""Nuclear repulsion energy"""""". nre = 0.0; for at1 in range(geom.shape[0]):; for at2 in range(at1):; dist = np.linalg.norm(geom[at1] - geom[at2]); nre += Z[at1] * Z[at2] / dist; return nre. def _pseudo_nre(Zhash, geom):; """"""Pseudo nuclear repulsion energy where non-physical Z contrived from `Zhash`."""""". Zidx = list(set(sorted(Zhash))); pZ = [Zidx.index(z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:11366,Energy Efficiency,reduce,reduced,11366,"t = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)); bnbn = [rrdistmat[first, second] for first, second in zip(rgp, rgp[1:])]; for pm in itertools.permutations(cgp):; cncn = [ccdistmat[first, second] for first, second in zip(pm, pm[1:])]; if np.allclose(bnbn, cncn, atol=1.0):; if verbose >= 1:; print(""Candidate:"", rgp, ""<--"", pm); yield pm. def filter_hungarian_uno(rgp, cgp):; """"""Hungarian algorithm on cost matrix based off headless (all Z same w/i space anyways) NRE.; Having found _a_ solution and the reduced cost matrix, this still isn't likely to produce; atom rearrangement fit for Kabsch b/c internal coordinate cost matrix doesn't nail down; distance-equivalent atoms with different Cartesian coordinates like Cartesian-distance-matrix; cost matrix does. So, form a bipartite graph from all essentially-zero connections between; ref and concern and run Uno algorithm to enumerate them. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)). # formulate cost matrix from internal (not Cartesian) layouts of R & C; npcgp = np.array(cgp); submatCC = ccnremat[np.ix_(cgp, cgp)]; submatRR = rrnremat[np.ix_(rgp, rgp)]; sumCC = 100.0 * np.sum(submatCC, axis=0) # cost mat small if not scaled, this way like Z=Neon; sumRR = 100.0 * np.sum(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorith",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:12634,Energy Efficiency,reduce,reducedcost,12634,"cern and run Uno algorithm to enumerate them. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)). # formulate cost matrix from internal (not Cartesian) layouts of R & C; npcgp = np.array(cgp); submatCC = ccnremat[np.ix_(cgp, cgp)]; submatRR = rrnremat[np.ix_(rgp, rgp)]; sumCC = 100.0 * np.sum(submatCC, axis=0) # cost mat small if not scaled, this way like Z=Neon; sumRR = 100.0 * np.sum(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorithm; # * linear_sum_assigment call is exactly like `scipy.optimize.linear_sum_assignment(cost)` only with extra return; t00 = time.time(); (row_ind, col_ind), reducedcost = linear_sum_assignment(cost, return_cost=True); ptsCR = list(zip(row_ind, col_ind)); ptsCR = sorted(ptsCR, key=lambda tup: tup[1]); sumCR = costcopy[row_ind, col_ind].sum(); t01 = time.time(); if verbose >= 2:; print(""Reduced cost:\n"", cost); if verbose >= 1:; print(""Hungarian time [s] for space: {:.3}"".format(t01 - t00)). # find _all_ best matches btwn R & C atoms through Uno algorithm, seeded from Hungarian sol'n; edges = np.argwhere(reducedcost < uno_cutoff); gooduns = uno(edges, ptsCR); t02 = time.time(); if verbose >= 1:; print(""Uno time [s] for space: {:.3}"".format(t02 - t01)). for gu in gooduns:; gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:12865,Energy Efficiency,Reduce,Reduced,12865,"of R & C; npcgp = np.array(cgp); submatCC = ccnremat[np.ix_(cgp, cgp)]; submatRR = rrnremat[np.ix_(rgp, rgp)]; sumCC = 100.0 * np.sum(submatCC, axis=0) # cost mat small if not scaled, this way like Z=Neon; sumRR = 100.0 * np.sum(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorithm; # * linear_sum_assigment call is exactly like `scipy.optimize.linear_sum_assignment(cost)` only with extra return; t00 = time.time(); (row_ind, col_ind), reducedcost = linear_sum_assignment(cost, return_cost=True); ptsCR = list(zip(row_ind, col_ind)); ptsCR = sorted(ptsCR, key=lambda tup: tup[1]); sumCR = costcopy[row_ind, col_ind].sum(); t01 = time.time(); if verbose >= 2:; print(""Reduced cost:\n"", cost); if verbose >= 1:; print(""Hungarian time [s] for space: {:.3}"".format(t01 - t00)). # find _all_ best matches btwn R & C atoms through Uno algorithm, seeded from Hungarian sol'n; edges = np.argwhere(reducedcost < uno_cutoff); gooduns = uno(edges, ptsCR); t02 = time.time(); if verbose >= 1:; print(""Uno time [s] for space: {:.3}"".format(t02 - t01)). for gu in gooduns:; gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. if algorithm == ""hungarian_uno"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); with np.errstate(divide=""ignore""):; ccnremat = np.reciprocal",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:13087,Energy Efficiency,reduce,reducedcost,13087,"um(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorithm; # * linear_sum_assigment call is exactly like `scipy.optimize.linear_sum_assignment(cost)` only with extra return; t00 = time.time(); (row_ind, col_ind), reducedcost = linear_sum_assignment(cost, return_cost=True); ptsCR = list(zip(row_ind, col_ind)); ptsCR = sorted(ptsCR, key=lambda tup: tup[1]); sumCR = costcopy[row_ind, col_ind].sum(); t01 = time.time(); if verbose >= 2:; print(""Reduced cost:\n"", cost); if verbose >= 1:; print(""Hungarian time [s] for space: {:.3}"".format(t01 - t00)). # find _all_ best matches btwn R & C atoms through Uno algorithm, seeded from Hungarian sol'n; edges = np.argwhere(reducedcost < uno_cutoff); gooduns = uno(edges, ptsCR); t02 = time.time(); if verbose >= 1:; print(""Uno time [s] for space: {:.3}"".format(t02 - t01)). for gu in gooduns:; gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. if algorithm == ""hungarian_uno"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); with np.errstate(divide=""ignore""):; ccnremat = np.reciprocal(ccdistmat); rrnremat = np.reciprocal(rrdistmat); ccnremat[ccnremat == np.inf] = 0.0; rrnremat[rrnremat == np.inf] = 0.0; algofn = filter_hungarian_uno. # Ensure (optional dependency) networkx exists; if not which_import(""netw",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:5647,Integrability,Wrap,Wrapper,5647,"irror are superimposable""; ). # initialization; best_rmsd = 100.0 # [A]; ocount = 0; hold_solution = None; run_resorting = run_resorting or not atoms_map; if mols_align is True:; a_convergence = 1.0e-3; elif mols_align is False:; a_convergence = 0.0; else:; a_convergence = mols_align. # initial presentation; atomfmt2 = """""" {} {:16.8f} {:16.8f} {:16.8f}"""""". if verbose >= 2:; print(""<<< Reference:""); for at, _ in enumerate(runiq):; print(atomfmt2.format(runiq[at][:6], *rgeom[at])). print(""<<< Concern:""); for at, _ in enumerate(cuniq):; print(atomfmt2.format(cuniq[at][:6], *cgeom[at])). # start_rmsd is nonsense if not atoms_map; start_rmsd = np.linalg.norm(cgeom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print(""Start RMSD = {:8.4f} [A] (naive)"".format(start_rmsd)). def _plausible_atom_orderings_wrapper(; runiq, cuniq, rgeom, cgeom, run_resorting, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3; ):; """"""Wrapper to _plausible_atom_orderings that bypasses it (`run_resorting=False`) when; atoms of R & C known to be ordered. Easier to put logic here because _plausible is generator. """"""; if run_resorting:; return _plausible_atom_orderings(; runiq, cuniq, rgeom, cgeom, algorithm=algorithm, verbose=verbose, uno_cutoff=uno_cutoff; ); else:; return [np.arange(rgeom.shape[0])]. t0 = time.time(); tc = 0.0; for ordering in _plausible_atom_orderings_wrapper(; runiq, cuniq, rgeom, cgeom, run_resorting, algorithm=algorithm, verbose=verbose, uno_cutoff=uno_cutoff; ):; t1 = time.time(); ocount += 1; npordd = np.asarray(ordering); _, RR, TT = kabsch_align(rgeom, cgeom[npordd, :], weight=None). temp_solution = AlignmentMill(shift=TT, rotation=RR, atommap=npordd, mirror=False); tgeom = temp_solution.align_coordinates(cgeom, reverse=False); if verbose >= 4:; print(""temp geom diff\n"", tgeom - rgeom); temp_rmsd = np.linalg.norm(tgeom - rgeom) * constants.bohr2angstroms / np.sqrt(rgeom.shape[0]); temp_rmsd = np.around(temp_rmsd, decimals=8); t2 = time.time(); ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:10721,Integrability,depend,depends,10721,"rbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)); bnbn = [rrdistmat[first, second] for first, second in zip(rgp, rgp[1:])]; for pm in itertools.permutations(cgp):; cncn = [ccdistmat[first, second] for first, second in zip(pm, pm[1:])]; if np.allclose(bnbn, cncn, atol=1.0):; if verbose >= 1:; print(""Candidate:"", rgp, ""<--"", pm); yield pm. def filter_hungarian_uno(rgp, cgp):; """"""Hungarian algorithm on cost matrix based off headless (all Z same w/i space anyways) NRE.; Having found _a_ solution and the reduced cost matrix, this still isn't likely to produce; atom rearrangement fit for Kabsch b/c internal coordinate cost matrix doesn't nail down; distance-equivalent atoms with different Cartesian coordinates like Cartesian-distance-matrix; cost matrix does. So, form a bipartite graph from all essentially-zero connections between; ref and concern and run Uno algorithm to enume",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:14062,Integrability,depend,dependency,14062,"uno(edges, ptsCR); t02 = time.time(); if verbose >= 1:; print(""Uno time [s] for space: {:.3}"".format(t02 - t01)). for gu in gooduns:; gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", cgp, subans); yield ans. if algorithm == ""permutative"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); algofn = filter_permutative. if algorithm == ""hungarian_uno"":; ccdistmat = distance_matrix(cgeom, cgeom); rrdistmat = distance_matrix(rgeom, rgeom); with np.errstate(divide=""ignore""):; ccnremat = np.reciprocal(ccdistmat); rrnremat = np.reciprocal(rrdistmat); ccnremat[ccnremat == np.inf] = 0.0; rrnremat[rrnremat == np.inf] = 0.0; algofn = filter_hungarian_uno. # Ensure (optional dependency) networkx exists; if not which_import(""networkx"", return_bool=True):; raise ModuleNotFoundError(; """"""Python module networkx not found. Solve by installing it: `conda install networkx` or `pip install networkx`""""""; ) # pragma: no cover. # collect candidate atom orderings from algofn for each of the atom classes,; # recombine the classes with each other in every permutation (could maybe; # add Hungarian here, too) as generator back to permutation_kabsch; for cpmut in itertools.product(*itertools.starmap(algofn, connect.items())):; atpat = [None] * len(ref); for igp, group in enumerate(cpmut):; for iidx, idx in enumerate(list(connect.keys())[igp]):; atpat[idx] = group[iidx]; yield atpat. def kabsch_align(rgeom, cgeom, weight=None):; r""""""Finds optimal translation and rotation to align `cgeom` onto `rgeom` via; Kabsch algorithm by minimizing the norm of the residual, || R - U * C ||. Parameters; ----------; rgeom : ndarray of float; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom : ndarray of fl",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:12533,Performance,optimiz,optimize,12533," with different Cartesian coordinates like Cartesian-distance-matrix; cost matrix does. So, form a bipartite graph from all essentially-zero connections between; ref and concern and run Uno algorithm to enumerate them. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)). # formulate cost matrix from internal (not Cartesian) layouts of R & C; npcgp = np.array(cgp); submatCC = ccnremat[np.ix_(cgp, cgp)]; submatRR = rrnremat[np.ix_(rgp, rgp)]; sumCC = 100.0 * np.sum(submatCC, axis=0) # cost mat small if not scaled, this way like Z=Neon; sumRR = 100.0 * np.sum(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorithm; # * linear_sum_assigment call is exactly like `scipy.optimize.linear_sum_assignment(cost)` only with extra return; t00 = time.time(); (row_ind, col_ind), reducedcost = linear_sum_assignment(cost, return_cost=True); ptsCR = list(zip(row_ind, col_ind)); ptsCR = sorted(ptsCR, key=lambda tup: tup[1]); sumCR = costcopy[row_ind, col_ind].sum(); t01 = time.time(); if verbose >= 2:; print(""Reduced cost:\n"", cost); if verbose >= 1:; print(""Hungarian time [s] for space: {:.3}"".format(t01 - t00)). # find _all_ best matches btwn R & C atoms through Uno algorithm, seeded from Hungarian sol'n; edges = np.argwhere(reducedcost < uno_cutoff); gooduns = uno(edges, ptsCR); t02 = time.time(); if verbose >= 1:; print(""Uno time [s] for space: {:.3}"".format(t02 - t01)). for gu in gooduns:; gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:9017,Safety,sanity check,sanity checks,9017,"""Hungarian time [s] for atom ordering: {:.3}"".format(t3 - t0 - tc)); print(""Kabsch time [s] for mol alignment: {:.3}"".format(tc)). ageom, auniq = hold_solution.align_mini_system(cgeom, cuniq, reverse=False); final_rmsd = np.linalg.norm(ageom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); assert abs(best_rmsd - final_rmsd) < 1.0e-3. if verbose >= 1:; print(""Final RMSD = {:8.4f} [A]"".format(final_rmsd)); print(""Mirror match:"", hold_solution.mirror); print(hold_solution). # final presentation & plotting; if verbose >= 2:; print(""<<< Aligned:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *ageom[at])); print(""<<< Aligned Diff:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *[ageom[at][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; ------",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:293,Security,Validat,ValidationError,293,". qcelemental.molutil.align. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align. Source code for qcelemental.molutil.align; import collections; import itertools; import time; from typing import Union. import numpy as np. from ..exceptions import ValidationError; from ..models import AlignmentMill; from ..physical_constants import constants; from ..testing import compare_values; from ..util import distance_matrix, linear_sum_assignment, random_rotation_matrix, uno, which_import. def _nre(Z, geom):; """"""Nuclear repulsion energy"""""". nre = 0.0; for at1 in range(geom.shape[0]):; for at2 in range(at1):; dist = np.linalg.norm(geom[at1] - geom[at2]); nre += Z[at1] * Z[at2] / dist; return nre. def _pseudo_nre(Zhash, geom):; """"""Pseudo nuclear repulsion energy where non-physical Z contrived from `Zhash`."""""". Zidx = list(set(sorted(Zhash))); pZ = [Zidx.index(z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:1848,Security,hash,hashes,1848,"z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str indicating which rows (atoms) in `cgeom` are shuffleable.; See `runiq` for more details. Strings and count in `cuniq` must match; `runiq`. That is, `sorted(cuniq) == sorted(runiq)`.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; verbose; Quantity of printing. 0 to silence.; atoms_map; Whether atom1 of rgeom already corresponds to atom1 of cgeom and so on.; If `True`, no resorting will be run, parameters `runiq` and `cuniq`; may be passed as `None`, and much time will be saved.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; mols_align; Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run re",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:3689,Security,validat,validation,3689,"tion or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; algorithm; {'hungarian_uno', 'permutative'}; When `atoms_map=False`, screening algorithm for plausible atom mappings.; `permutative` suitable only for small systems.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `rgeom`; from mirror image of `cgeom`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(cuniq):; raise ValidationError(""""""atom subclasses unequal:\n {}\n {}"""""".format(runiq, cuniq)). if run_mirror:; # use aligner to check if system and its (xz-plane) mirror image are; # superimposible and hence whether its worth doubling the number of Kabsch; # runs below to check for mirror-image matches; mcgeom = np.copy(cgeom); mcgeom[:, 1] *= -1.0; exact = 1.0e-6; mrmsd, msolution = B787(; mcgeom,; cgeom,; cuniq,; cuniq,; do_plot=False,; verbose=0,; atoms_map=False,; mols_align=exact,; run_mirror=False,; uno_cutoff=0.1,; ); superimposable = mrmsd < exact; if verbose >= 1 and superimposable:; print(; ""Not testing for mirror-image matches (despite `run_mirror`) since system and i",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:3762,Security,Validat,ValidationError,3762,"ted when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; algorithm; {'hungarian_uno', 'permutative'}; When `atoms_map=False`, screening algorithm for plausible atom mappings.; `permutative` suitable only for small systems.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `rgeom`; from mirror image of `cgeom`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(cuniq):; raise ValidationError(""""""atom subclasses unequal:\n {}\n {}"""""".format(runiq, cuniq)). if run_mirror:; # use aligner to check if system and its (xz-plane) mirror image are; # superimposible and hence whether its worth doubling the number of Kabsch; # runs below to check for mirror-image matches; mcgeom = np.copy(cgeom); mcgeom[:, 1] *= -1.0; exact = 1.0e-6; mrmsd, msolution = B787(; mcgeom,; cgeom,; cuniq,; cuniq,; do_plot=False,; verbose=0,; atoms_map=False,; mols_align=exact,; run_mirror=False,; uno_cutoff=0.1,; ); superimposable = mrmsd < exact; if verbose >= 1 and superimposable:; print(; ""Not testing for mirror-image matches (despite `run_mirror`) since system and its mirror are superimposable""; ). # initialization; best_rmsd = 100.0 # [A]; ocou",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:4024,Security,Validat,ValidationError,4024,"gs.; algorithm; {'hungarian_uno', 'permutative'}; When `atoms_map=False`, screening algorithm for plausible atom mappings.; `permutative` suitable only for small systems.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `rgeom`; from mirror image of `cgeom`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(cuniq):; raise ValidationError(""""""atom subclasses unequal:\n {}\n {}"""""".format(runiq, cuniq)). if run_mirror:; # use aligner to check if system and its (xz-plane) mirror image are; # superimposible and hence whether its worth doubling the number of Kabsch; # runs below to check for mirror-image matches; mcgeom = np.copy(cgeom); mcgeom[:, 1] *= -1.0; exact = 1.0e-6; mrmsd, msolution = B787(; mcgeom,; cgeom,; cuniq,; cuniq,; do_plot=False,; verbose=0,; atoms_map=False,; mols_align=exact,; run_mirror=False,; uno_cutoff=0.1,; ); superimposable = mrmsd < exact; if verbose >= 1 and superimposable:; print(; ""Not testing for mirror-image matches (despite `run_mirror`) since system and its mirror are superimposable""; ). # initialization; best_rmsd = 100.0 # [A]; ocount = 0; hold_solution = None; run_resorting = run_resorting or not atoms_map; if mols_align is True:; a_convergence = 1.0e-3; elif mols_align is False:; a_convergence = 0.0; else:; a_convergence = mols_align. # initial presentation; atomfmt2 = """,MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:9816,Security,Hash,Hashes,9816,"t][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms.",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:9957,Security,Hash,Hashes,9957,":8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)); bnbn = [rrdistmat[first, second] for first, second in zip(rgp, rgp[1:])]; fo",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:10162,Security,Validat,ValidationError,10162,"1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)); bnbn = [rrdistmat[first, second] for first, second in zip(rgp, rgp[1:])]; for pm in itertools.permutations(cgp):; cncn = [ccdistmat[first, second] for first, second in zip(pm, pm[1:])]; if np.allclose(bnbn, cncn, atol=1.0):; if verbose >= 1:; print(""Candidat",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:16572,Security,Validat,ValidationError,16572,"rather than split btwn R & C,; which may be invalid if not 1-to-1. Weighting is not recommended. Returns; -------; float, ndarray, ndarray; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is (3, 3) rotation matrix to optimal alignment.; Third item is (3,) translation vector [a0] to optimal alignment. Sources; -------; Kabsch: Acta Cryst. (1978). A34, 827-828 http://journals.iucr.org/a/issues/1978/05/00/a15629/a15629.pdf; C++ affine code: https://github.com/oleg-alexandrov/projects/blob/master/eigen/Kabsch.cpp; weighted RMSD: http://www.amber.utah.edu/AMBER-workshop/London-2015/tutorial1/; protein wRMSD code: https://pharmacy.umich.edu/sites/default/files/global_wrmsd_v8.3.py.txt; quaternion: https://cnx.org/contents/HV-RsdwL@23/Molecular-Distance-Measures. Author: dsirianni. """"""; if weight is None:; w = np.ones((rgeom.shape[0])); elif isinstance(weight, (list, np.ndarray)):; w = np.asarray(weight); else:; raise ValidationError(f""""""Unrecognized argument type {type(weight)} for kwarg 'weight'.""""""). R = rgeom; C = cgeom; N = rgeom.shape[0]; if np.allclose(R, C):; # can hit a mixed non-identity translation/rotation, so head off; return 0.0, np.identity(3), np.zeros(3). Rcentroid = R.sum(axis=0) / N; Ccentroid = C.sum(axis=0) / N; R = np.subtract(R, Rcentroid); C = np.subtract(C, Ccentroid). R *= np.sqrt(w[:, None]); C *= np.sqrt(w[:, None]). RR = kabsch_quaternion(C.T, R.T) # U; TT = Ccentroid - RR.dot(Rcentroid). C = C.dot(RR); rmsd = np.linalg.norm(R - C) * constants.bohr2angstroms / np.sqrt(np.sum(w)). return rmsd, RR, TT. def kabsch_quaternion(P, Q):; """"""Computes the optimal rotation matrix U which mapping a set of points P; onto the set of points Q according to the minimization of || Q - U * P ||,; using the unit quaternion formulation of the Kabsch algorithm. Arguments:; <np.ndarray> P := MxN array. M=dimension of space, N=number of points.; <np.ndarray> Q := MxN array. M=dimension of space, N=number of points. Retu",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:397,Testability,test,testing,397,". qcelemental.molutil.align. Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align. Source code for qcelemental.molutil.align; import collections; import itertools; import time; from typing import Union. import numpy as np. from ..exceptions import ValidationError; from ..models import AlignmentMill; from ..physical_constants import constants; from ..testing import compare_values; from ..util import distance_matrix, linear_sum_assignment, random_rotation_matrix, uno, which_import. def _nre(Z, geom):; """"""Nuclear repulsion energy"""""". nre = 0.0; for at1 in range(geom.shape[0]):; for at2 in range(at1):; dist = np.linalg.norm(geom[at1] - geom[at2]); nre += Z[at1] * Z[at2] / dist; return nre. def _pseudo_nre(Zhash, geom):; """"""Pseudo nuclear repulsion energy where non-physical Z contrived from `Zhash`."""""". Zidx = list(set(sorted(Zhash))); pZ = [Zidx.index(z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:3001,Testability,test,test,3001,"ting which rows (atoms) in `cgeom` are shuffleable.; See `runiq` for more details. Strings and count in `cuniq` must match; `runiq`. That is, `sorted(cuniq) == sorted(runiq)`.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; verbose; Quantity of printing. 0 to silence.; atoms_map; Whether atom1 of rgeom already corresponds to atom1 of cgeom and so on.; If `True`, no resorting will be run, parameters `runiq` and `cuniq`; may be passed as `None`, and much time will be saved.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; mols_align; Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; algorithm; {'hungarian_uno', 'permutative'}; When `atoms_map=False`, screening algorithm for plausible atom mappings.; `permutative` suitable only for small systems.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `rgeom`; from mirror image of `cgeom`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:4622,Testability,test,testing,4622,"; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(cuniq):; raise ValidationError(""""""atom subclasses unequal:\n {}\n {}"""""".format(runiq, cuniq)). if run_mirror:; # use aligner to check if system and its (xz-plane) mirror image are; # superimposible and hence whether its worth doubling the number of Kabsch; # runs below to check for mirror-image matches; mcgeom = np.copy(cgeom); mcgeom[:, 1] *= -1.0; exact = 1.0e-6; mrmsd, msolution = B787(; mcgeom,; cgeom,; cuniq,; cuniq,; do_plot=False,; verbose=0,; atoms_map=False,; mols_align=exact,; run_mirror=False,; uno_cutoff=0.1,; ); superimposable = mrmsd < exact; if verbose >= 1 and superimposable:; print(; ""Not testing for mirror-image matches (despite `run_mirror`) since system and its mirror are superimposable""; ). # initialization; best_rmsd = 100.0 # [A]; ocount = 0; hold_solution = None; run_resorting = run_resorting or not atoms_map; if mols_align is True:; a_convergence = 1.0e-3; elif mols_align is False:; a_convergence = 0.0; else:; a_convergence = mols_align. # initial presentation; atomfmt2 = """""" {} {:16.8f} {:16.8f} {:16.8f}"""""". if verbose >= 2:; print(""<<< Reference:""); for at, _ in enumerate(runiq):; print(atomfmt2.format(runiq[at][:6], *rgeom[at])). print(""<<< Concern:""); for at, _ in enumerate(cuniq):; print(atomfmt2.format(cuniq[at][:6], *cgeom[at])). # start_rmsd is nonsense if not atoms_map; start_rmsd = np.linalg.norm(cgeom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print(""Start RMSD = {:8.4f} [A] (naive)"".format(start_rmsd)). def _plausible_atom_orderings_wrapper(; runiq, cuniq, rgeom, cgeom, run_resorting, algorithm=""hungarian_uno"", verbose=1, uno_cutoff",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:5781,Testability,log,logic,5781,"ion = None; run_resorting = run_resorting or not atoms_map; if mols_align is True:; a_convergence = 1.0e-3; elif mols_align is False:; a_convergence = 0.0; else:; a_convergence = mols_align. # initial presentation; atomfmt2 = """""" {} {:16.8f} {:16.8f} {:16.8f}"""""". if verbose >= 2:; print(""<<< Reference:""); for at, _ in enumerate(runiq):; print(atomfmt2.format(runiq[at][:6], *rgeom[at])). print(""<<< Concern:""); for at, _ in enumerate(cuniq):; print(atomfmt2.format(cuniq[at][:6], *cgeom[at])). # start_rmsd is nonsense if not atoms_map; start_rmsd = np.linalg.norm(cgeom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print(""Start RMSD = {:8.4f} [A] (naive)"".format(start_rmsd)). def _plausible_atom_orderings_wrapper(; runiq, cuniq, rgeom, cgeom, run_resorting, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3; ):; """"""Wrapper to _plausible_atom_orderings that bypasses it (`run_resorting=False`) when; atoms of R & C known to be ordered. Easier to put logic here because _plausible is generator. """"""; if run_resorting:; return _plausible_atom_orderings(; runiq, cuniq, rgeom, cgeom, algorithm=algorithm, verbose=verbose, uno_cutoff=uno_cutoff; ); else:; return [np.arange(rgeom.shape[0])]. t0 = time.time(); tc = 0.0; for ordering in _plausible_atom_orderings_wrapper(; runiq, cuniq, rgeom, cgeom, run_resorting, algorithm=algorithm, verbose=verbose, uno_cutoff=uno_cutoff; ):; t1 = time.time(); ocount += 1; npordd = np.asarray(ordering); _, RR, TT = kabsch_align(rgeom, cgeom[npordd, :], weight=None). temp_solution = AlignmentMill(shift=TT, rotation=RR, atommap=npordd, mirror=False); tgeom = temp_solution.align_coordinates(cgeom, reverse=False); if verbose >= 4:; print(""temp geom diff\n"", tgeom - rgeom); temp_rmsd = np.linalg.norm(tgeom - rgeom) * constants.bohr2angstroms / np.sqrt(rgeom.shape[0]); temp_rmsd = np.around(temp_rmsd, decimals=8); t2 = time.time(); tc += t2 - t1. if temp_rmsd < best_rmsd:; best_rmsd = temp_rmsd; hold_solution = temp_solution;",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:8386,Testability,assert,assert,8386,"4:; print(""temp geom diff\n"", tgeom - rgeom); temp_rmsd = np.linalg.norm(tgeom - rgeom) * constants.bohr2angstroms / np.sqrt(rgeom.shape[0]); temp_rmsd = np.around(temp_rmsd, decimals=8); t2 = time.time(); tc += t2 - t1. if temp_rmsd < best_rmsd:; best_rmsd = temp_rmsd; hold_solution = temp_solution; if verbose >= 1:; print(""<<< trial {:8}m {} yields RMSD {} >>>"".format(ocount - 1, npordd, temp_rmsd)); if not run_to_completion and best_rmsd < a_convergence:; break; else:; if verbose >= 3:; print("" trial {:8}m {} yields RMSD {}"".format(ocount - 1, npordd, temp_rmsd)). t3 = time.time(); if verbose >= 1:; print(""Total time [s] for {:6} iterations: {:.3}"".format(ocount, t3 - t0)); print(""Hungarian time [s] for atom ordering: {:.3}"".format(t3 - t0 - tc)); print(""Kabsch time [s] for mol alignment: {:.3}"".format(tc)). ageom, auniq = hold_solution.align_mini_system(cgeom, cuniq, reverse=False); final_rmsd = np.linalg.norm(ageom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); assert abs(best_rmsd - final_rmsd) < 1.0e-3. if verbose >= 1:; print(""Final RMSD = {:8.4f} [A]"".format(final_rmsd)); print(""Mirror match:"", hold_solution.mirror); print(hold_solution). # final presentation & plotting; if verbose >= 2:; print(""<<< Aligned:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *ageom[at])); print(""<<< Aligned Diff:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *[ageom[at][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:9032,Testability,assert,assert,9032,"""Hungarian time [s] for atom ordering: {:.3}"".format(t3 - t0 - tc)); print(""Kabsch time [s] for mol alignment: {:.3}"".format(tc)). ageom, auniq = hold_solution.align_mini_system(cgeom, cuniq, reverse=False); final_rmsd = np.linalg.norm(ageom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); assert abs(best_rmsd - final_rmsd) < 1.0e-3. if verbose >= 1:; print(""Final RMSD = {:8.4f} [A]"".format(final_rmsd)); print(""Mirror match:"", hold_solution.mirror); print(hold_solution). # final presentation & plotting; if verbose >= 2:; print(""<<< Aligned:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *ageom[at])); print(""<<< Aligned Diff:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *[ageom[at][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; ------",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:9226,Testability,assert,assert,9226,"reverse=False); final_rmsd = np.linalg.norm(ageom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); assert abs(best_rmsd - final_rmsd) < 1.0e-3. if verbose >= 1:; print(""Final RMSD = {:8.4f} [A]"".format(final_rmsd)); print(""Mirror match:"", hold_solution.mirror); print(hold_solution). # final presentation & plotting; if verbose >= 2:; print(""<<< Aligned:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *ageom[at])); print(""<<< Aligned Diff:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *[ageom[at][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:9400,Testability,assert,assert,9400,"erbose >= 1:; print(""Final RMSD = {:8.4f} [A]"".format(final_rmsd)); print(""Mirror match:"", hold_solution.mirror); print(hold_solution). # final presentation & plotting; if verbose >= 2:; print(""<<< Aligned:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *ageom[at])); print(""<<< Aligned Diff:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *[ageom[at][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:9533,Testability,assert,assert,9533,"_solution.mirror); print(hold_solution). # final presentation & plotting; if verbose >= 2:; print(""<<< Aligned:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *ageom[at])); print(""<<< Aligned Diff:""); for at, hsh in enumerate(auniq):; print(atomfmt2.format(auniq[at][:6], *[ageom[at][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; conne",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:20336,Testability,assert,assert,20336,"y-like, optional; Whether to randomly shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`); or shuffle according to specified (nat, ) indices (e.g., [2, 1, 0]); do_shift : bool or array-like, optional; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin (`False`) or shift along; specified (3, ) vector (e.g., np.array([0., 1., -1.])).; do_rotate : bool or array-like, optional; Whether to generate a random 3D rotation according to algorithm of Arvo (`True`); or leave at current orientation (`False`) or rotate with specified (3, 3) matrix.; deflection : float, optional; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror : bool, optional; Whether to set mirror reflection instruction. Changes identity of; molecule so off by default. Returns; -------; tuple; AlignmentMill with fields (shift, rotation, atommap, mirror); as requested: identity, random, or specified. """"""; rand_elord = np.arange(nat); if do_resort is True:; np.random.shuffle(rand_elord); elif do_resort is False:; pass; else:; rand_elord = np.array(do_resort); assert rand_elord.shape == (nat,). if do_shift is True:; rand_shift = 6 * np.random.random_sample((3,)) - 3; elif do_shift is False:; rand_shift = np.zeros((3,)); else:; rand_shift = np.array(do_shift); assert rand_shift.shape == (3,). if do_rotate is True:; rand_rot3d = random_rotation_matrix(deflection=deflection); elif do_rotate is False:; rand_rot3d = np.identity(3); else:; rand_rot3d = np.array(do_rotate); assert rand_rot3d.shape == (3, 3). perturbation = AlignmentMill(shift=rand_shift, rotation=rand_rot3d, atommap=rand_elord, mirror=do_mirror); return perturbation. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:20539,Testability,assert,assert,20539,"y-like, optional; Whether to randomly shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`); or shuffle according to specified (nat, ) indices (e.g., [2, 1, 0]); do_shift : bool or array-like, optional; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin (`False`) or shift along; specified (3, ) vector (e.g., np.array([0., 1., -1.])).; do_rotate : bool or array-like, optional; Whether to generate a random 3D rotation according to algorithm of Arvo (`True`); or leave at current orientation (`False`) or rotate with specified (3, 3) matrix.; deflection : float, optional; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror : bool, optional; Whether to set mirror reflection instruction. Changes identity of; molecule so off by default. Returns; -------; tuple; AlignmentMill with fields (shift, rotation, atommap, mirror); as requested: identity, random, or specified. """"""; rand_elord = np.arange(nat); if do_resort is True:; np.random.shuffle(rand_elord); elif do_resort is False:; pass; else:; rand_elord = np.array(do_resort); assert rand_elord.shape == (nat,). if do_shift is True:; rand_shift = 6 * np.random.random_sample((3,)) - 3; elif do_shift is False:; rand_shift = np.zeros((3,)); else:; rand_shift = np.array(do_shift); assert rand_shift.shape == (3,). if do_rotate is True:; rand_rot3d = random_rotation_matrix(deflection=deflection); elif do_rotate is False:; rand_rot3d = np.identity(3); else:; rand_rot3d = np.array(do_rotate); assert rand_rot3d.shape == (3, 3). perturbation = AlignmentMill(shift=rand_shift, rotation=rand_rot3d, atommap=rand_elord, mirror=do_mirror); return perturbation. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:20751,Testability,assert,assert,20751,"y-like, optional; Whether to randomly shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`); or shuffle according to specified (nat, ) indices (e.g., [2, 1, 0]); do_shift : bool or array-like, optional; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin (`False`) or shift along; specified (3, ) vector (e.g., np.array([0., 1., -1.])).; do_rotate : bool or array-like, optional; Whether to generate a random 3D rotation according to algorithm of Arvo (`True`); or leave at current orientation (`False`) or rotate with specified (3, 3) matrix.; deflection : float, optional; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror : bool, optional; Whether to set mirror reflection instruction. Changes identity of; molecule so off by default. Returns; -------; tuple; AlignmentMill with fields (shift, rotation, atommap, mirror); as requested: identity, random, or specified. """"""; rand_elord = np.arange(nat); if do_resort is True:; np.random.shuffle(rand_elord); elif do_resort is False:; pass; else:; rand_elord = np.array(do_resort); assert rand_elord.shape == (nat,). if do_shift is True:; rand_shift = 6 * np.random.random_sample((3,)) - 3; elif do_shift is False:; rand_shift = np.zeros((3,)); else:; rand_shift = np.array(do_shift); assert rand_shift.shape == (3,). if do_rotate is True:; rand_rot3d = random_rotation_matrix(deflection=deflection); elif do_rotate is False:; rand_rot3d = np.identity(3); else:; rand_rot3d = np.array(do_rotate); assert rand_rot3d.shape == (3, 3). perturbation = AlignmentMill(shift=rand_shift, rotation=rand_rot3d, atommap=rand_elord, mirror=do_mirror); return perturbation. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.6; . PSI4. Module code; qcelemental.molutil.align.  Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:1909,Usability,simpl,simple,1909,"z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str indicating which rows (atoms) in `cgeom` are shuffleable.; See `runiq` for more details. Strings and count in `cuniq` must match; `runiq`. That is, `sorted(cuniq) == sorted(runiq)`.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; verbose; Quantity of printing. 0 to silence.; atoms_map; Whether atom1 of rgeom already corresponds to atom1 of cgeom and so on.; If `True`, no resorting will be run, parameters `runiq` and `cuniq`; may be passed as `None`, and much time will be saved.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; mols_align; Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run re",MatchSource.WIKI,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.AngularMomentumInt.html:464,Deployability,update,updated,464,". AngularMomentumInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt. AngularMomentumInt. class psi4.core.AngularMomentumInt; Bases: OneBodyAOInt; Computes angular momentum integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.AngularMomentumInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.AngularMomentumInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.AOShellCombinationsIterator.html:1076,Deployability,update,updated,1076,". AOShellCombinationsIterator. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator. AOShellCombinationsIterator. class psi4.core.AOShellCombinationsIterator; Bases: pybind11_object; Attributes Summary. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Summary. first(self); docstring. is_done(self); docstring. next(self); docstring. Attributes Documentation. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Documentation. first(self: psi4.core.AOShellCombinationsIterator)  None; docstring. is_done(self: psi4.core.AOShellCombinationsIterator)  bool; docstring. next(self: psi4.core.AOShellCombinationsIterator)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.AOShellCombinationsIterator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.AOShellCombinationsIterator.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variable.html:490,Deployability,update,updated,490,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variable.html:279,Modifiability,variab,variable,279,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variables.html:483,Deployability,update,updated,483,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  Dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variables.html:270,Modifiability,variab,variables,270,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  Dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisExtents.html:920,Deployability,update,updated,920,". BasisExtents. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents. BasisExtents. class psi4.core.BasisExtents; Bases: pybind11_object; docstring; Methods Summary. basis(self); docstring. delta(self); docstring. maxR(self); docstring. set_delta(self,arg0); docstring. shell_extents(self); docstring. Methods Documentation. basis(self: psi4.core.BasisExtents)  psi4.core.BasisSet; docstring. delta(self: psi4.core.BasisExtents)  float; docstring. maxR(self: psi4.core.BasisExtents)  float; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float)  None; docstring. shell_extents(self: psi4.core.BasisExtents)  psi4.core.Vector; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisExtents.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisExtents.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisFunctions.html:1098,Deployability,update,updated,1098,". BasisFunctions. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions. BasisFunctions. class psi4.core.BasisFunctions; Bases: pybind11_object; docstring; Methods Summary. basis_values(self); docstring. compute_functions(self,arg0); docstring. deriv(self); docstring. max_functions(self); docstring. max_points(self); docstring. set_deriv(self,arg0); docstring. Methods Documentation. basis_values(self: psi4.core.BasisFunctions)  Dict[str, psi4.core.Matrix]; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi4.core.BlockOPoints)  None; docstring. deriv(self: psi4.core.BasisFunctions)  int; docstring. max_functions(self: psi4.core.BasisFunctions)  int; docstring. max_points(self: psi4.core.BasisFunctions)  int; docstring. set_deriv(self: psi4.core.BasisFunctions, arg0: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisFunctions.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:3881,Availability,avail,available,3881,"oes it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; pur",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:9355,Deployability,update,updated,9355,". For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BasisSet.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:1925,Integrability,depend,depending,1925,"respond to. genbas(self); Returns basis set per atom in CFOUR format. has_ECP(self); Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it corr",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:2011,Integrability,contract,contractions,2011,"Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisna",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:2744,Integrability,contract,contraction,2744,"llback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely fr",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:7791,Integrability,depend,depending,7791,"oes not affect the underlying molecule object. n_ecp_core(*args, **kwargs); Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith she",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:7904,Integrability,contract,contractions,7904,"psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:9142,Integrability,contract,contraction,9142,". For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BasisSet.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:4100,Usability,simpl,simple,4100,"omlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; puream and this puream argument.; return_atomlist (bool)  Build one-atom basis sets (e.g., for SAD) rather than one whole-mol; basis set.; quiet (bool)  When True, do not print to the output file. Ret",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html:533,Deployability,update,updated,533,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html:260,Integrability,rout,routines,260,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html:298,Integrability,rout,routine,298,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html:223,Performance,Perform,Perform,223,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html:231,Testability,benchmark,benchmark,231,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html:533,Deployability,update,updated,533,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html:260,Integrability,rout,routines,260,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html:298,Integrability,rout,routine,298,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html:223,Performance,Perform,Perform,223,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html:231,Testability,benchmark,benchmark,231,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html:562,Deployability,update,updated,562,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html:278,Integrability,rout,routines,278,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html:316,Integrability,rout,routine,316,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html:241,Performance,Perform,Perform,241,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html:249,Testability,benchmark,benchmark,249,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html:525,Deployability,update,updated,525,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html:291,Integrability,rout,routine,291,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html:219,Performance,Perform,Perform,219,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html:250,Performance,perform,performance,250,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html:227,Testability,benchmark,benchmark,227,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html:620,Deployability,update,updated,620,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html:238,Performance,Perform,Perform,238,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html:246,Testability,benchmark,benchmark,246,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html:293,Testability,Benchmark,Benchmark,293,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html:534,Deployability,update,updated,534,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html:300,Integrability,rout,routine,300,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html:205,Performance,Perform,Perform,205,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html:213,Testability,benchmark,benchmark,213,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.be_quiet.html:478,Deployability,update,updated,478,". be_quiet. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; be_quiet. be_quiet. psi4.core.be_quiet()  None; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). Doesnt work with Windows. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; be_quiet.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.be_quiet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.be_quiet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BlockOPoints.html:1441,Deployability,update,updated,1441,". BlockOPoints. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints. BlockOPoints. class psi4.core.BlockOPoints; Bases: pybind11_object; docstring; Methods Summary. functions_local_to_global(self); docstring. npoints(self); docstring. parent_atom(self); Returns the atom number this BlockOfPoints belongs to. print_out(self[,out_fname,print]); docstring. refresh(self); docstring. shells_local_to_global(self); docstring. w(self). x(self). y(self). z(self). Methods Documentation. functions_local_to_global(self: psi4.core.BlockOPoints)  List[int]; docstring. npoints(self: psi4.core.BlockOPoints)  int; docstring. parent_atom(self: psi4.core.BlockOPoints)  int; Returns the atom number this BlockOfPoints belongs to. print_out(self: psi4.core.BlockOPoints, out_fname: str = 'outfile', print: int = 2)  None; docstring. refresh(self: psi4.core.BlockOPoints)  None; docstring. shells_local_to_global(self: psi4.core.BlockOPoints)  List[int]; docstring. w(self: psi4.core.BlockOPoints)  psi4.core.Vector. x(self: psi4.core.BlockOPoints)  psi4.core.Vector. y(self: psi4.core.BlockOPoints)  psi4.core.Vector. z(self: psi4.core.BlockOPoints)  psi4.core.Vector. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BlockOPoints.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BlockOPoints.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BoysLocalizer.html:435,Deployability,update,updated,435,". BoysLocalizer. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer. class psi4.core.BoysLocalizer; Bases: Localizer; Performs Boys orbital localization. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BoysLocalizer.html:201,Performance,Perform,Performs,201,". BoysLocalizer. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer. class psi4.core.BoysLocalizer; Bases: Localizer; Performs Boys orbital localization. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:1692,Availability,error,error,1692,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:1914,Deployability,update,updated,1914,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:344,Modifiability,extend,extend,344,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:881,Modifiability,extend,extend,881,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:928,Modifiability,extend,extend,928,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:1007,Modifiability,Extend,Extend,1007,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:1069,Modifiability,extend,extend,1069,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:1131,Modifiability,Extend,Extend,1131,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:245,Usability,clear,clear,245,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:258,Usability,Clear,Clear,258,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:692,Usability,clear,clear,692,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:740,Usability,Clear,Clear,740,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccdensity.html:457,Deployability,update,updated,457,". ccdensity. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccdensity. ccdensity. psi4.core.ccdensity(ref_wfn: psi4.core.CCWavefunction)  float; Runs the code to compute coupled cluster density matrices. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccdensity.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ccdensity.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccdensity.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccenergy.html:446,Deployability,update,updated,446,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccenergy.html:240,Energy Efficiency,energy,energy,240,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.cceom.html:447,Deployability,update,updated,447,". cceom. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cceom. cceom. psi4.core.cceom(ref_wfn: psi4.core.CCWavefunction)  float; Runs the equation of motion coupled cluster code for excited states. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cceom.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.cceom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.cceom.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.cchbar.html:446,Deployability,update,updated,446,". cchbar. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cchbar. cchbar. psi4.core.cchbar(ref_wfn: psi4.core.Wavefunction)  None; Runs the code to generate the similarity transformed Hamiltonian. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cchbar.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.cchbar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.cchbar.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.cclambda.html:456,Deployability,update,updated,456,". cclambda. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cclambda. cclambda. psi4.core.cclambda(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster lambda equations code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cclambda.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.cclambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.cclambda.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccresponse.html:448,Deployability,update,updated,448,". ccresponse. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccresponse. ccresponse. psi4.core.ccresponse(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster response theory code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ccresponse.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ccresponse.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ccresponse.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.cctransort.html:493,Deployability,update,updated,493,". cctransort. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cctransort. cctransort. psi4.core.cctransort(ref_wfn: psi4.core.Wavefunction)  None; Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cctransort.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.cctransort.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.cctransort.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.cctriples.html:438,Deployability,update,updated,438,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.cctriples.html:231,Energy Efficiency,energy,energy,231,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html:1438,Availability,error,error,1438,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html:1873,Deployability,update,updated,1873,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html:430,Energy Efficiency,energy,energy-sorted,430,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html:1142,Energy Efficiency,energy,energy,1142,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html:1637,Energy Efficiency,energy,energy-sorted,1637,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html:876,Integrability,depend,depending,876,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html:1337,Modifiability,variab,variable,1337,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalc.html:944,Deployability,update,updated,944,". CdSalc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalc. CdSalc. class psi4.core.CdSalc; Bases: pybind11_object; Cartesian displacement SALC; Methods Summary. irrep(self); Return the irrep bit representation. irrep_index(self); Return the irrep index. print_out(self); Print the irrep index and the coordinates of the SALC of Cartesian displacements. Methods Documentation. irrep(self: psi4.core.CdSalc)  str; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc)  int; Return the irrep index. print_out(self: psi4.core.CdSalc)  None; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CdSalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalcList.html:1813,Deployability,update,updated,1813,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalcList.html:225,Energy Efficiency,adapt,adapted,225,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalcList.html:225,Modifiability,adapt,adapted,225,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CharacterTable.html:1067,Deployability,update,updated,1067,". CharacterTable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable. CharacterTable. class psi4.core.CharacterTable; Bases: pybind11_object; Contains the character table of the point group; Methods Summary. gamma(self,arg0); Returns the irrep with the given index in the character table. order(self); Return the order of the point group. symm_operation(self,arg0); Return the i'th symmetry operation. Methods Documentation. gamma(self: psi4.core.CharacterTable, arg0: int)  psi4.core.IrreducibleRepresentation; Returns the irrep with the given index in the character table. order(self: psi4.core.CharacterTable)  int; Return the order of the point group. symm_operation(self: psi4.core.CharacterTable, arg0: int)  psi4.core.SymmetryOperation; Return the ith symmetry operation. 0-indexed. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CharacterTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CharacterTable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CIVector.html:2585,Deployability,update,updated,2585,"ring. shift(self,arg0,arg1); docstring. symnormalize(self,arg0,arg1); docstring. vdot(self,arg0,arg1,arg2); docstring. vector_multiply(self,arg0,arg1,arg2,...); docstring. write(self,arg0,arg1); docstring. zero(self); docstring. Attributes Documentation. np; Returns a view of the CIVectors buffer. Methods Documentation. axpy(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int, arg3: int)  None; docstring. close_io_files(self: psi4.core.CIVector, arg0: int)  None; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  None; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int)  float; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int)  None; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool)  None; docstring. norm(self: psi4.core.CIVector, arg0: int)  float; docstring. read(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. set_nvec(self: psi4.core.CIVector, arg0: int)  None; docstring. shift(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. symnormalize(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. vdot(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  float; docstring. vector_multiply(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: psi4.core.CIVector, arg3: int, arg4: int, arg5: int)  None; docstring. write(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. zero(self: psi4.core.CIVector)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CIVector.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CIVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CIVector.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CIWavefunction.html:6642,Deployability,update,updated,6642,"i4.core.CIVector; docstring. opdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector)  None; docstring. pitzer_to_ci_order_twoel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector)  None; docstring. print_vector(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int)  None; docstring. reset_ci_H0block(self: psi4.core.CIWavefunction)  None; docstring. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector)  None; docstring. semicanonical_orbs(self: psi4.core.CIWavefunction)  None; docstring. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str)  None; docstring. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix)  None; docstring. sigma(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CIWavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CIWavefunction.html:4037,Integrability,contract,contract,4037,"ulations.; Jroot (int)  The index of the root in the ket. Select -1 for the same as Iroot.; Always use -1 for single-state calculations.; spin (str)  {A, B, SUM}; Return the alpha density matrix, the beta density matrix, or their sum?; full_space (bool)  Return a density matrix in the space of all orbitals (true) or the active orbitals (false)?. Returns:; The selected one-particle density/transition matrix with Pitzer-ordered orbitals.; Irrep h of the matrix corresponds to orbitals of irrep h.; Element pq is <|a^p a_q|>. Return type:; Matrix. get_orbitals(self: psi4.core.CIWavefunction, arg0: str)  psi4.core.Matrix; docstring. get_tpdm(self: psi4.core.CIWavefunction, spin: str, symmetrize: bool)  psi4.core.Matrix; Returns the two-particle density matrix. Parameters:. spin (str)  {AA, AB, BB, SUM}; Which spin-block of the TPDM should be returned? SUM sums over all possible spin cases.; symmetrize (bool)  Return a genuine TPDM element (false) or an average of TPDM elements that contract with the same integral (true)?; Only working for SUM. Returns:; The two-particle density matrix with Pitzer-ordered orbitals, restricted to the active space.; If symmetrize is false, element pqrs is <|a^p a^r a_s a_q|>.; If symmetrize is true, element pqrs is obtained by summing over all flips of p/s, q/r, and multiplying by 0.5. Return type:; Matrix. hamiltonian(self: psi4.core.CIWavefunction, arg0: int)  psi4.core.Matrix; docstring. mcscf_object(self: psi4.core.CIWavefunction)  psi4.core.SOMCSCF; docstring. ndet(self: psi4.core.CIWavefunction)  int; docstring. new_civector(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: bool, arg3: bool)  psi4.core.CIVector; docstring. opdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector)  None; docstri",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean.html:397,Deployability,update,updated,397,". clean. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean. clean. psi4.core.clean()  None; Remove scratch files. Call between independent jobs. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean_options.html:414,Deployability,update,updated,414,". clean_options. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean_options. clean_options. psi4.core.clean_options()  None; Reset options to clean state. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean_options.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.clean_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean_options.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean_timers.html:491,Deployability,update,updated,491,". clean_timers. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean_timers. clean_timers. psi4.core.clean_timers()  None; Reinitialize timers for independent timer.dat entries. Vital when earlier independent calc finished improperly. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean_timers.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.clean_timers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean_timers.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean_variables.html:473,Deployability,update,updated,473,". clean_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean_variables. clean_variables. psi4.core.clean_variables()  None; Empties all double and Matrix QCVariables that have been set in global memory. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; clean_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.clean_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.clean_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.close_outfile.html:408,Deployability,update,updated,408,". close_outfile. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; close_outfile. close_outfile. psi4.core.close_outfile()  None; Closes the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; close_outfile.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.close_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.close_outfile.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationFactor.html:679,Deployability,update,updated,679,". CorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor. CorrelationFactor. class psi4.core.CorrelationFactor; Bases: pybind11_object; docstring; Methods Summary. set_params(self,coeff,exponent); Set coefficient and exponent. Methods Documentation. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector)  None; Set coefficient and exponent. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationFactor.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationTable.html:1877,Deployability,update,updated,1877,". CorrelationTable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. CorrelationTable. class psi4.core.CorrelationTable; Bases: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationTable.html:569,Energy Efficiency,reduce,reduced,569,". CorrelationTable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. CorrelationTable. class psi4.core.CorrelationTable; Bases: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationTable.html:1371,Energy Efficiency,reduce,reduced,1371,". CorrelationTable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. CorrelationTable. class psi4.core.CorrelationTable; Bases: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CubeProperties.html:1564,Deployability,update,updated,1564,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CubeProperties.html:531,Integrability,wrap,wrapper,531,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CubeProperties.html:1181,Integrability,wrap,wrapper,1181,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.CUHF.html:1150,Deployability,update,updated,1150,". CUHF. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CUHF. CUHF. class psi4.core.CUHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. Methods Documentation. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet)  psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring. Return type:; float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.CUHF)  psi4.core.MintsHelper; The MintsHelper object. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; CUHF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.CUHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.CUHF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DASUM.html:406,Deployability,update,updated,406,". DASUM. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DASUM. DASUM. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DASUM.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DASUM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DASUM.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DAXPY.html:448,Deployability,update,updated,448,". DAXPY. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DAXPY. DAXPY. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DAXPY.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DAXPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DAXPY.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DCOPY.html:435,Deployability,update,updated,435,". DCOPY. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DCOPY. DCOPY. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DCOPY.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DCOPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DCOPY.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dct.html:435,Deployability,update,updated,435,". dct. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dct. dct. psi4.core.dct(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density cumulant (functional) theory code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dct.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dct.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DDOT.html:431,Deployability,update,updated,431,". DDOT. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DDOT. DDOT. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  float; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DDOT.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DDOT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DDOT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.del_array_variable.html:494,Deployability,update,updated,494,". del_array_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable. del_array_variable. psi4.core.del_array_variable(key: str)  None; Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.del_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.del_array_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.del_scalar_variable.html:499,Deployability,update,updated,499,". del_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable. del_scalar_variable. psi4.core.del_scalar_variable(key: str)  None; Removes the double QCVariable key (case-insensitive); prefer del_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.del_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.del_scalar_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.del_variable.html:554,Deployability,update,updated,554,". del_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; del_variable. del_variable. psi4.core.del_variable(key); Removes scalar or array QCVariable key; from global memory if present. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; None. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; del_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.del_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.del_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Deriv.html:1523,Deployability,update,updated,1523,". Deriv. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Deriv. Deriv. class psi4.core.Deriv; Bases: pybind11_object; Computes gradients of wavefunctions; Methods Summary. compute(self,deriv_calc_type); Compute the gradient. compute_df(self,arg0,arg1); Compute the density-fitted gradient. set_deriv_density_backtransformed(self[,val]); Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self[,val]); Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self[,val]); Is the TPDM already presorted? Default is False. Methods Documentation. compute(self: psi4.core.Deriv, deriv_calc_type: psi4.core.DerivCalcType = <DerivCalcType.Default: 0>)  psi4.core.Matrix; Compute the gradient. compute_df(self: psi4.core.Deriv, arg0: str, arg1: str)  psi4.core.Matrix; Compute the density-fitted gradient. set_deriv_density_backtransformed(self: psi4.core.Deriv, val: bool = False)  None; Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self: psi4.core.Deriv, val: bool = False)  None; Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self: psi4.core.Deriv, val: bool = False)  None; Is the TPDM already presorted? Default is False. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Deriv.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Deriv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Deriv.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DerivCalcType.html:698,Deployability,update,updated,698,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DerivCalcType.html:240,Testability,log,logic,240,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.detci.html:230,Deployability,configurat,configuration,230,". detci. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.detci.html:452,Deployability,update,updated,452,". detci. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.detci.html:230,Modifiability,config,configuration,230,". detci. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html:776,Deployability,update,updated,776,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html:355,Energy Efficiency,energy,energy,355,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html:543,Energy Efficiency,energy,energy,543,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFHelper.html:2708,Deployability,update,updated,2708,"toff(self,arg0). transform(self). transpose(self,arg0,arg1). Methods Documentation. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix)  None. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str = 'Qpq')  None. clear_all(self: psi4.core.DFHelper)  None. clear_spaces(self: psi4.core.DFHelper)  None. get_AO_core(self: psi4.core.DFHelper)  bool. get_AO_size(self: psi4.core.DFHelper)  int. get_MO_core(self: psi4.core.DFHelper)  bool. get_memory(self: psi4.core.DFHelper)  int. get_method(self: psi4.core.DFHelper)  str. get_schwarz_cutoff(self: psi4.core.DFHelper)  float. get_space_size(self: psi4.core.DFHelper, arg0: str)  int. get_tensor(*args, **kwargs); Overloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], arg3: List[int]) -> psi4.core.Matrix. get_tensor_shape(self: psi4.core.DFHelper, arg0: str)  Tuple[int, int, int]. get_tensor_size(self: psi4.core.DFHelper, arg0: str)  int. hold_met(self: psi4.core.DFHelper, arg0: bool)  None. initialize(self: psi4.core.DFHelper)  None. print_header(self: psi4.core.DFHelper)  None. set_AO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_MO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_memory(self: psi4.core.DFHelper, arg0: int)  None. set_method(self: psi4.core.DFHelper, arg0: str)  None. set_nthreads(self: psi4.core.DFHelper, arg0: int)  None. set_schwarz_cutoff(self: psi4.core.DFHelper, arg0: float)  None. transform(self: psi4.core.DFHelper)  None. transpose(self: psi4.core.DFHelper, arg0: str, arg1: Tuple[int, int, int])  None. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJCOSK.html:683,Deployability,update,updated,683,". DFJCOSK. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJCOSK. DFJCOSK. class psi4.core.DFJCOSK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. clear_D_prev(self: psi4.core.DFJCOSK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.DFJCOSK)  bool; Was the last Fock build incremental?. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJCOSK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFJCOSK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJCOSK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJCOSK.html:218,Usability,Clear,Clear,218,". DFJCOSK. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJCOSK. DFJCOSK. class psi4.core.DFJCOSK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. clear_D_prev(self: psi4.core.DFJCOSK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.DFJCOSK)  bool; Was the last Fock build incremental?. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJCOSK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFJCOSK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJCOSK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJCOSK.html:376,Usability,Clear,Clear,376,". DFJCOSK. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJCOSK. DFJCOSK. class psi4.core.DFJCOSK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. clear_D_prev(self: psi4.core.DFJCOSK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.DFJCOSK)  bool; Was the last Fock build incremental?. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJCOSK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFJCOSK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJCOSK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJLinK.html:562,Deployability,update,updated,562,". DFJLinK. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJLinK. DFJLinK. class psi4.core.DFJLinK; Bases: JK; docstring; Methods Summary. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. do_incfock_iter(self: psi4.core.DFJLinK)  bool; Was the last Fock build incremental?. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFJLinK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFJLinK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFJLinK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dfmp2.html:415,Deployability,update,updated,415,". dfmp2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dfmp2. dfmp2. psi4.core.dfmp2(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DF-MP2 code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dfmp2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dfmp2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dfocc.html:445,Deployability,update,updated,445,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dfocc.html:235,Performance,optimiz,optimized,235,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFSOMCSCF.html:388,Deployability,update,updated,388,". DFSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF. DFSOMCSCF. class psi4.core.DFSOMCSCF; Bases: SOMCSCF; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFSOMCSCF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFTensor.html:1023,Deployability,update,updated,1023,". DFTensor. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFTensor. DFTensor. class psi4.core.DFTensor; Bases: pybind11_object; docstring; Methods Summary. Idfmo(self); doctsring. Imo(self); doctsring. Qmo(self); doctsring. Qoo(self); doctsring. Qov(self); doctsring. Qso(self); doctsring. Qvv(self); doctsring. Methods Documentation. Idfmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Imo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qoo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qov(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qso(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qvv(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFTensor.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFTensor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFTensor.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFTGrid.html:726,Deployability,update,updated,726,". DFTGrid. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid. DFTGrid. class psi4.core.DFTGrid; Bases: MolecularGrid; docstring; Methods Summary. build(*args,**kwargs); Overloaded function. Methods Documentation. static build(*args, **kwargs); Overloaded function. build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet) -> psi4.core.DFTGrid; build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet, arg2: Dict[str, int], arg3: Dict[str, str]) -> psi4.core.DFTGrid. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DFTGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DFTGrid.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGBMV.html:539,Deployability,update,updated,539,". DGBMV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGBMV. DGBMV. psi4.core.DGBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int, arg11: float, arg12: psi::Vector, arg13: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGBMV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGBMV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGEEV.html:558,Deployability,update,updated,558,". DGEEV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGEEV. DGEEV. psi4.core.DGEEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int, arg12: psi::Vector, arg13: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGEEV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGEEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGEEV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGEMM.html:539,Deployability,update,updated,539,". DGEMM. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGEMM. DGEMM. psi4.core.DGEMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Matrix, arg10: int, arg11: float, arg12: psi::Matrix, arg13: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGEMM.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGEMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGEMM.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGEMV.html:515,Deployability,update,updated,515,". DGEMV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGEMV. DGEMV. psi4.core.DGEMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGEMV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGEMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGEMV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGER.html:484,Deployability,update,updated,484,". DGER. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGER. DGER. psi4.core.DGER(arg0: int, arg1: int, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGER.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGER.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGER.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGETRF.html:442,Deployability,update,updated,442,". DGETRF. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGETRF. DGETRF. psi4.core.DGETRF(arg0: int, arg1: int, arg2: int, arg3: psi::Matrix, arg4: int, arg5: psi::IntVector)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGETRF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGETRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGETRF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGETRI.html:461,Deployability,update,updated,461,". DGETRI. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGETRI. DGETRI. psi4.core.DGETRI(arg0: int, arg1: int, arg2: psi::Matrix, arg3: int, arg4: psi::IntVector, arg5: psi::Vector, arg6: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGETRI.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGETRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGETRI.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGETRS.html:483,Deployability,update,updated,483,". DGETRS. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGETRS. DGETRS. psi4.core.DGETRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DGETRS.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DGETRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DGETRS.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DiagonalizeOrder.html:699,Deployability,update,updated,699,". DiagonalizeOrder. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder. DiagonalizeOrder. class psi4.core.DiagonalizeOrder; Bases: pybind11_object; Defines ordering of eigenvalues after diagonalization; Members:. Ascending; Descending. Attributes Summary. Ascending. Descending. name. value. Attributes Documentation. Ascending = <DiagonalizeOrder.Ascending: 1>. Descending = <DiagonalizeOrder.Descending: 3>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DiagonalizeOrder.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DiagonalizeOrder.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Dimension.html:2473,Deployability,update,updated,2473,"he order of the dimension. print_out(self); Print out the dimension object to the output file. sum(*args,**kwargs); Overloaded function. to_tuple(); Serializes Dimension to a tuple. zero(*args,**kwargs); Overloaded function. Attributes Documentation. name; The name of the dimension. Used in printing. Methods Documentation. fill(self: psi4.core.Dimension, val: int)  None; Fill all elements with given value. classmethod from_list(dims, name='New Dimension'); Builds a Dimension object from a Python list or tuple. If a; Dimension object is passed, a copy will be returned. Parameters:. dims (Union[Tuple[int], List[int], ndarray, Dimension])  Iterable of integers defining irrep dimensions.; name  Name for new instance. Return type:; Dimension. init(self: psi4.core.Dimension, arg0: int, arg1: str)  None; Re-initializes the dimension object. max(*args, **kwargs); Overloaded function. max(self: psi4.core.Dimension) -> int. Gets the maximum value from the dimension object. max(self: psi4.core.Dimension) -> int. Return the maximum element. n(self: psi4.core.Dimension)  int; The order of the dimension. print_out(self: psi4.core.Dimension)  None; Print out the dimension object to the output file. sum(*args, **kwargs); Overloaded function. sum(self: psi4.core.Dimension) -> int. Gets the sum of the values in the dimension object. sum(self: psi4.core.Dimension) -> int. Return the sum of constituent dimensions. to_tuple(); Serializes Dimension to a tuple. Return type:; Tuple[int]. Parameters:; self (Dimension)  . zero(*args, **kwargs); Overloaded function. zero(self: psi4.core.Dimension) -> None. Zeros all values in the dimension object. zero(self: psi4.core.Dimension) -> None. Zero all elements. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Dimension.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Dimension.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Dimension.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DipoleInt.html:409,Deployability,update,updated,409,". DipoleInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt. DipoleInt. class psi4.core.DipoleInt; Bases: OneBodyAOInt; Computes dipole integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DipoleInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DirectJK.html:568,Deployability,update,updated,568,". DirectJK. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DirectJK. DirectJK. class psi4.core.DirectJK; Bases: JK; docstring; Methods Summary. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. do_incfock_iter(self: psi4.core.DirectJK)  bool; Was the last Fock build incremental?. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DirectJK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DirectJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DirectJK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DiskSOMCSCF.html:398,Deployability,update,updated,398,". DiskSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF. DiskSOMCSCF. class psi4.core.DiskSOMCSCF; Bases: SOMCSCF; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DiskSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DiskSOMCSCF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Dispersion.html:2948,Deployability,update,updated,2948,"elf); docstring. Methods Documentation. a1(self: psi4.core.Dispersion)  float; docstring. a2(self: psi4.core.Dispersion)  float; docstring. bibtex(self: psi4.core.Dispersion)  str; Get the BibTeX key for the literature reference. static build(type: str, s6: float = 0.0, alpha6: float = 0.0, sr6: float = 0.0)  psi4.core.Dispersion; Initialize instance capable of computing a dispersion correction of type. citation(self: psi4.core.Dispersion)  str; docstring. compute_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  float; docstring. compute_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. d(self: psi4.core.Dispersion)  float; docstring. description(self: psi4.core.Dispersion)  str; docstring. name(self: psi4.core.Dispersion)  str; docstring. print_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_out(self: psi4.core.Dispersion)  None; docstring. s6(self: psi4.core.Dispersion)  float; docstring. s8(self: psi4.core.Dispersion)  float; docstring. set_bibtex(self: psi4.core.Dispersion, arg0: str)  None; Set the BibTeX key for the literature reference. set_citation(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_description(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_name(self: psi4.core.Dispersion, arg0: str)  None; docstring. sr6(self: psi4.core.Dispersion)  float; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Dispersion.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Dispersion.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dlpno.html:412,Deployability,update,updated,412,". dlpno. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dlpno. dlpno. psi4.core.dlpno(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DLPNO codes. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dlpno.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dlpno.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dlpno.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dmrg.html:409,Deployability,update,updated,409,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dmrg.html:199,Integrability,interface,interface,199,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DNRM2.html:406,Deployability,update,updated,406,". DNRM2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DNRM2. DNRM2. psi4.core.DNRM2(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DNRM2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DNRM2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DNRM2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.doublet.html:545,Deployability,update,updated,545,". doublet. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; doublet. doublet. psi4.core.doublet(A: psi4.core.Matrix, B: psi4.core.Matrix, transA: bool = False, transB: bool = False)  psi4.core.Matrix; Returns the multiplication of two matrices A and B, with options to transpose each beforehand. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; doublet.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.doublet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.doublet.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dpdbuf4.html:1005,Deployability,update,updated,1005,". dpdbuf4. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4. dpdbuf4. class psi4.core.dpdbuf4; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all with entries. Methods Documentation. axpy_matrix(self: psi4.core.dpdbuf4, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdbuf4)  int; Fill all with entries. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dpdbuf4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dpdbuf4.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.dpdfile2.html:1028,Deployability,update,updated,1028,". dpdfile2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2. dpdfile2. class psi4.core.dpdfile2; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all entries with zeroes. Methods Documentation. axpy_matrix(self: psi4.core.dpdfile2, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdfile2)  int; Fill all entries with zeroes. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.dpdfile2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.dpdfile2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DPOTRF.html:420,Deployability,update,updated,420,". DPOTRF. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF. DPOTRF. psi4.core.DPOTRF(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DPOTRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DPOTRF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DPOTRI.html:420,Deployability,update,updated,420,". DPOTRI. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI. DPOTRI. psi4.core.DPOTRI(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DPOTRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DPOTRI.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DPOTRS.html:461,Deployability,update,updated,461,". DPOTRS. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS. DPOTRS. psi4.core.DPOTRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Matrix, arg7: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DPOTRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DPOTRS.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DROT.html:456,Deployability,update,updated,456,". DROT. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DROT. DROT. psi4.core.DROT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int, arg6: float, arg7: float)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DROT.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DROT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DROT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSBMV.html:515,Deployability,update,updated,515,". DSBMV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSBMV. DSBMV. psi4.core.DSBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSBMV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSBMV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSCAL.html:418,Deployability,update,updated,418,". DSCAL. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSCAL. DSCAL. psi4.core.DSCAL(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSCAL.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSCAL.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSCAL.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSWAP.html:435,Deployability,update,updated,435,". DSWAP. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSWAP. DSWAP. psi4.core.DSWAP(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSWAP.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSWAP.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSWAP.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYEV.html:475,Deployability,update,updated,475,". DSYEV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYEV. DSYEV. psi4.core.DSYEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYEV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYEV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYMM.html:527,Deployability,update,updated,527,". DSYMM. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYMM. DSYMM. psi4.core.DSYMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYMM.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYMM.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYMV.html:503,Deployability,update,updated,503,". DSYMV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYMV. DSYMV. psi4.core.DSYMV(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: int, arg8: float, arg9: psi::Vector, arg10: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYMV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYMV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYR.html:454,Deployability,update,updated,454,". DSYR. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYR. DSYR. psi4.core.DSYR(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Matrix, arg7: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYR.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYR.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYR.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYR2.html:489,Deployability,update,updated,489,". DSYR2. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYR2. DSYR2. psi4.core.DSYR2(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYR2.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYR2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYR2.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYR2K.html:532,Deployability,update,updated,532,". DSYR2K. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K. DSYR2K. psi4.core.DSYR2K(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYR2K.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYR2K.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYRK.html:495,Deployability,update,updated,495,". DSYRK. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYRK. DSYRK. psi4.core.DSYRK(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: float, arg9: psi::Matrix, arg10: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYRK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYRK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYRK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYSV.html:509,Deployability,update,updated,509,". DSYSV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYSV. DSYSV. psi4.core.DSYSV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DSYSV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DSYSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DSYSV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTBMV.html:479,Deployability,update,updated,479,". DTBMV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTBMV. DTBMV. psi4.core.DTBMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTBMV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DTBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTBMV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTBSV.html:479,Deployability,update,updated,479,". DTBSV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTBSV. DTBSV. psi4.core.DTBSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTBSV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DTBSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTBSV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRMM.html:505,Deployability,update,updated,505,". DTRMM. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRMM. DTRMM. psi4.core.DTRMM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRMM.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DTRMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRMM.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRMV.html:468,Deployability,update,updated,468,". DTRMV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRMV. DTRMV. psi4.core.DTRMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRMV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DTRMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRMV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRSM.html:505,Deployability,update,updated,505,". DTRSM. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRSM. DTRSM. psi4.core.DTRSM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRSM.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DTRSM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRSM.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRSV.html:468,Deployability,update,updated,468,". DTRSV. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRSV. DTRSV. psi4.core.DTRSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; DTRSV.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.DTRSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.DTRSV.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ElectricFieldInt.html:452,Deployability,update,updated,452,". ElectricFieldInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt. ElectricFieldInt. class psi4.core.ElectricFieldInt; Bases: OneBodyAOInt; Computes electric field integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ElectricFieldInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ElectricFieldInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ElectrostaticInt.html:451,Deployability,update,updated,451,". ElectrostaticInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt. ElectrostaticInt. class psi4.core.ElectrostaticInt; Bases: OneBodyAOInt; Computes electrostatic integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ElectrostaticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ElectrostaticInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ERI.html:402,Deployability,update,updated,402,". ERI. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ERI. ERI. class psi4.core.ERI; Bases: TwoBodyAOInt; Computes normal two electron repulsion integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ERI.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ERI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ERI.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ERISieve.html:577,Deployability,update,updated,577,". ERISieve. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ERISieve. ERISieve. class psi4.core.ERISieve; Bases: pybind11_object; docstring; Methods Summary. shell_significant(self,arg0,arg1,arg2,arg3). Methods Documentation. shell_significant(self: psi4.core.ERISieve, arg0: int, arg1: int, arg2: int, arg3: int)  bool. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ERISieve.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ERISieve.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ERISieve.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html:1018,Deployability,update,updated,1018,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html:216,Integrability,rout,routines,216,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html:206,Security,access,access,206,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:2696,Deployability,update,updated,2696,"e contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:433,Energy Efficiency,charge,charge,433,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion ene",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:500,Energy Efficiency,charge,charge,500,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion ene",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:814,Energy Efficiency,energy,energy,814,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion ene",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:980,Energy Efficiency,charge,charge,980,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion ene",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:1377,Energy Efficiency,charge,charge,1377," of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.Exte",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:1522,Energy Efficiency,charge,charge,1522,"of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. ; h",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:1998,Energy Efficiency,energy,energy,1998,"e contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:2305,Energy Efficiency,charge,charge,2305,"e contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:546,Usability,clear,clear,546,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion ene",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:1568,Usability,clear,clear,1568,"o zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FCHKWriter.html:959,Deployability,update,updated,959,". FCHKWriter. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter. FCHKWriter. class psi4.core.FCHKWriter; Bases: pybind11_object; Extracts information from a wavefunction object, and writes it to an FCHK file; Methods Summary. SCF_Dtot(self). set_postscf_density_label(self,label); Set base label for post-SCF density, e.g. write(self,filename); Write wavefunction information to file. Methods Documentation. SCF_Dtot(self: psi4.core.FCHKWriter)  psi4.core.Matrix. set_postscf_density_label(self: psi4.core.FCHKWriter, label: str)  None; Set base label for post-SCF density, e.g.  CC Density. write(self: psi4.core.FCHKWriter, filename: str)  None; Write wavefunction information to file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FCHKWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FCHKWriter.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.fcidump_tei_helper.html:554,Deployability,update,updated,554,". fcidump_tei_helper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper. fcidump_tei_helper. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str = 'INTDUMP')  None; Write integrals to file in FCIDUMP format. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.fcidump_tei_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.fcidump_tei_helper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FDDS_Dispersion.html:2484,Deployability,update,updated,2484,"er monomer. get_tensor_pqQ(self,arg0,arg1); Debug only: fetches 3-index intermediate from disk and return as matrix. metric(self); Obtains the FDDS metric. metric_inv(self); Obtains the FDDS metric_inv. print_tensor_pqQ(self,arg0,arg1,arg2); Debug only: prints formatted 3-index intermediate to file. project_densities(self,arg0); Projects a density from the primary AO to auxiliary AO space. Methods Documentation. R_A(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer A. R_B(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer B. aux_overlap(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS aux_overlap. form_aux_matrices(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  Dict[str, psi4.core.Matrix]; Forms the uncoupled amplitudes and other matrices for either monomer. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  psi4.core.Matrix; Forms the uncoupled amplitudes for either monomer. get_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: Tuple[int, int, int])  psi4.core.Matrix; Debug only: fetches 3-index intermediate from disk and return as matrix. metric(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric_inv. print_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: str, arg2: Tuple[int, int, int])  None; Debug only: prints formatted 3-index intermediate to file. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; Projects a density from the primary AO to auxiliary AO space. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FDDS_Dispersion.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FDDS_Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FDDS_Dispersion.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.finalize.html:414,Deployability,update,updated,414,". finalize. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; finalize. finalize. psi4.core.finalize()  None; Called upon psi4 module exit to closes timers and I/O. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; finalize.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.finalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.finalize.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:4489,Deployability,update,updated,4489," F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molecule; Returns the FISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FISAPT.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:284,Energy Efficiency,energy,energy,284,". FISAPT. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT. class psi4.core.FISAPT; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. compute_energy([external_potentials]); Computes the FSAPT energy. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:454,Energy Efficiency,energy,energy,454,". FISAPT. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT. class psi4.core.FISAPT; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. compute_energy([external_potentials]); Computes the FSAPT energy. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT) ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:1628,Energy Efficiency,energy,energy,1628,"put files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. fdrop(external_potentials=None); Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self:",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:1858,Energy Efficiency,energy,energy,1858,"tion. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. fdrop(external_potentials=None); Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. k",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:2194,Energy Efficiency,energy,energy,2194," overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. fdrop(external_potentials=None); Drop output files from FSAPT calculation. FISAPT::fdrop. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molec",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:4078,Energy Efficiency,energy,energy,4078," F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molecule; Returns the FISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FISAPT.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:1252,Integrability,wrap,wrapper,1252,"entials]); Computes the FSAPT energy. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. fdrop([external_potentials]); Drop output files from FSAPT calculation. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. compute_energy(external_potentials=None); Computes the FSAPT energy. FISAPT::compute_energy. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. elst(self: psi4.core.FISAPT)  None; SAPT0 electrost",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html:3465,Integrability,wrap,wrapper,3465,"elst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molecule; Returns the FISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. plot(); Filesystem wrapper for FISAPT::plot. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FISAPT.  Copyright 2007-2022, Th",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FittedSlaterCorrelationFactor.html:620,Deployability,update,updated,620,". FittedSlaterCorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor. FittedSlaterCorrelationFactor. class psi4.core.FittedSlaterCorrelationFactor; Bases: CorrelationFactor; docstring; Methods Summary. exponent(self). Methods Documentation. exponent(self: psi4.core.FittedSlaterCorrelationFactor)  float. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FittedSlaterCorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FittedSlaterCorrelationFactor.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FittingMetric.html:1636,Deployability,update,updated,1636,". FittingMetric. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FittingMetric. FittingMetric. class psi4.core.FittingMetric; Bases: pybind11_object; docstring; Methods Summary. form_QR_inverse(self,arg0); docstring. form_cholesky_inverse(self); docstring. form_eig_inverse(self,arg0); docstring. form_fitting_metric(self); docstring. form_full_inverse(self); docstring. get_algorithm(self); docstring. get_metric(self); docstring. get_pivots(self); docstring. get_reverse_pivots(self); docstring. is_inverted(self); docstring. is_poisson(self); docstring. Methods Documentation. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric)  None; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_fitting_metric(self: psi4.core.FittingMetric)  None; docstring. form_full_inverse(self: psi4.core.FittingMetric)  None; docstring. get_algorithm(self: psi4.core.FittingMetric)  str; docstring. get_metric(self: psi4.core.FittingMetric)  psi4.core.Matrix; docstring. get_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. get_reverse_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. is_inverted(self: psi4.core.FittingMetric)  bool; docstring. is_poisson(self: psi4.core.FittingMetric)  bool; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FittingMetric.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FittingMetric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FittingMetric.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.flush_outfile.html:409,Deployability,update,updated,409,". flush_outfile. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile. flush_outfile. psi4.core.flush_outfile()  None; Flushes the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.flush_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.flush_outfile.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.fnocc.html:445,Deployability,update,updated,445,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.fnocc.html:242,Energy Efficiency,energy,energy,242,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.FragmentType.html:656,Deployability,update,updated,656,". FragmentType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FragmentType. FragmentType. class psi4.core.FragmentType; Bases: pybind11_object; Fragment activation status; Members:. Absent; Real; Ghost. Attributes Summary. Absent. Ghost. Real. name. value. Attributes Documentation. Absent = <FragmentType.Absent: 0>. Ghost = <FragmentType.Ghost: 2>. Real = <FragmentType.Real: 1>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; FragmentType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.FragmentType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.FragmentType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Functional.html:3102,Deployability,update,updated,3102,"e(alias: str)  psi4.core.Functional; docstring. citation(self: psi4.core.Functional)  str; docstring. compute_functional(self: psi4.core.Functional, arg0: Dict[str, psi4.core.Vector], arg1: Dict[str, psi4.core.Vector], arg2: int, arg3: int)  None; docstring. density_cutoff(self: psi4.core.Functional)  float; docstring. description(self: psi4.core.Functional)  str; docstring. is_gga(self: psi4.core.Functional)  bool; docstring. is_lrc(self: psi4.core.Functional)  bool; docstring. is_meta(self: psi4.core.Functional)  bool; docstring. lsda_cutoff(self: psi4.core.Functional)  float; docstring. meta_cutoff(self: psi4.core.Functional)  float; docstring. name(self: psi4.core.Functional)  str; docstring. omega(self: psi4.core.Functional)  float; docstring. print_detail(self: psi4.core.Functional, arg0: int)  None; docstring. print_out(self: psi4.core.Functional)  None; docstring. set_alpha(self: psi4.core.Functional, arg0: float)  None; docstring. set_citation(self: psi4.core.Functional, arg0: str)  None; docstring. set_density_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_description(self: psi4.core.Functional, arg0: str)  None; docstring. set_gga(self: psi4.core.Functional, arg0: bool)  None; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_meta(self: psi4.core.Functional, arg0: bool)  None; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_name(self: psi4.core.Functional, arg0: str)  None; docstring. set_omega(self: psi4.core.Functional, arg0: float)  None; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Functional.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Functional.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:2643,Deployability,update,updated,2643,"ions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:357,Integrability,contract,contraction,357,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(sel",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:408,Integrability,contract,contraction,408,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(sel",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:488,Integrability,contract,contraction,488,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(sel",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:1026,Integrability,contract,contraction,1026,"Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.Gaus",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:1087,Integrability,contract,contraction,1087,"PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the giv",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:1336,Integrability,contract,contraction,1336,"character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical ha",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:1388,Integrability,contract,contraction,1388,"The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:1469,Integrability,contract,contraction,1469,"er symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primiti",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:2168,Integrability,contract,contraction,2168,"ions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html:2262,Integrability,contract,contraction,2262,"ions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianType.html:661,Deployability,update,updated,661,". GaussianType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianType. GaussianType. class psi4.core.GaussianType; Bases: pybind11_object; 0 if Cartesian, 1 if Pure; Members:. Cartesian : (n+1)(n+2)/2 functions; Pure : 2n+1 functions. Attributes Summary. Cartesian. Pure. name. value. Attributes Documentation. Cartesian = <GaussianType.Cartesian: 0>. Pure = <GaussianType.Pure: 1>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GaussianType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GaussianType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GaussianType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.GeometryUnits.html:634,Deployability,update,updated,634,". GeometryUnits. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits. GeometryUnits. class psi4.core.GeometryUnits; Bases: pybind11_object; The units used to define the geometry; Members:. Angstrom; Bohr. Attributes Summary. Angstrom. Bohr. name. value. Attributes Documentation. Angstrom = <GeometryUnits.Angstrom: 0>. Bohr = <GeometryUnits.Bohr: 1>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.GeometryUnits.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.GeometryUnits.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_active_molecule.html:474,Deployability,update,updated,474,". get_active_molecule. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule. get_active_molecule. psi4.core.get_active_molecule()  psi4.core.Molecule; Returns the currently active molecule object. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_active_molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variable.html:469,Deployability,update,updated,469,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variable.html:246,Modifiability,variab,variable,246,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variables.html:472,Deployability,update,updated,472,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variables.html:247,Modifiability,variab,variables,247,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_datadir.html:428,Deployability,update,updated,428,". get_datadir. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_datadir. get_datadir. psi4.core.get_datadir()  str; Returns the path to shared text resources, PSIDATADIR. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_datadir.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_datadir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_datadir.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_global_option.html:392,Availability,error,error,392,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_global_option.html:626,Deployability,update,updated,626,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_global_option_list.html:472,Deployability,update,updated,472,". get_global_option_list. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list. get_global_option_list. psi4.core.get_global_option_list()  List[str]; Returns a list of all global options. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_global_option_list.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_global_option_list.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_local_option.html:388,Availability,error,error,388,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_local_option.html:636,Deployability,update,updated,636,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_memory.html:202,Availability,avail,available,202,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_memory.html:426,Deployability,update,updated,426,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_num_threads.html:460,Deployability,update,updated,460,". get_num_threads. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads. get_num_threads. psi4.core.get_num_threads()  int; Returns the number of threads to use in SMP parallel computations. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_num_threads.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_option.html:386,Availability,error,error,386,". get_option. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_option.html:665,Deployability,update,updated,665,". get_option. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_options.html:400,Deployability,update,updated,400,". get_options. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_options. get_options. psi4.core.get_options()  psi4.core.Options; Get options. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_options.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_options.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_output_file.html:459,Deployability,update,updated,459,". get_output_file. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_output_file. get_output_file. psi4.core.get_output_file()  str; Returns output file name (stem + suffix, no directory). stdout. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_output_file.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_output_file.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variable.html:439,Deployability,update,updated,439,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variable.html:222,Modifiability,variab,variable,222,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variables.html:442,Deployability,update,updated,442,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variables.html:223,Modifiability,variab,variables,223,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_writer_file_prefix.html:513,Deployability,update,updated,513,". get_writer_file_prefix. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix. get_writer_file_prefix. psi4.core.get_writer_file_prefix(molecule_name: str)  str; Returns the prefix to use for writing files for external programs. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.get_writer_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.get_writer_file_prefix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.git_version.html:404,Deployability,update,updated,404,". git_version. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; git_version. git_version. psi4.core.git_version()  None. Deprecated since version 1.4. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; git_version.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.git_version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.git_version.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_array_variable.html:493,Deployability,update,updated,493,". has_array_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable. has_array_variable. psi4.core.has_array_variable(key: str)  bool; Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.has_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_array_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_global_option_changed.html:728,Deployability,update,updated,728,". has_global_option_changed. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed. has_global_option_changed. psi4.core.has_global_option_changed(key: str)  bool; Whether keyword key value has been touched at global (all-module) scope. Has it been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.has_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_global_option_changed.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_local_option_changed.html:738,Deployability,update,updated,738,". has_local_option_changed. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed. has_local_option_changed. psi4.core.has_local_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched at module scope. Has it been touched in the scope of the specified module by either user or code.Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.has_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_local_option_changed.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_option_changed.html:702,Deployability,update,updated,702,". has_option_changed. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed. has_option_changed. psi4.core.has_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched or is default. Has it been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.has_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_option_changed.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_scalar_variable.html:498,Deployability,update,updated,498,". has_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable. has_scalar_variable. psi4.core.has_scalar_variable(key: str)  bool; Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.has_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_scalar_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_variable.html:554,Deployability,update,updated,554,". has_variable. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_variable. has_variable. psi4.core.has_variable(key); Whether scalar or array QCVariable key; has been set in global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; bool. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; has_variable.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.has_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.has_variable.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:1259,Deployability,Update,Update,1259,"ed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Ham",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:4325,Deployability,update,update,4325,"nergies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). print_stability_analysis(self,arg0); docstring. push_back_external_potential(self,V); Add an external potential to the private external_potentials list. reset_occupation(self); docstring. rotate_orbitals(self,arg0,arg1); docstring. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:6088,Deployability,Update,Update,6088," the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:10891,Deployability,update,update,10891," the private external_potentials list. reset_occupation(self: psi4.core.HF)  None; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. save_density_and_energy(self: psi4.core.HF)  None; docstring. scf_type(self: psi4.core.HF)  str; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF)  None; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float)  None; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix])  None; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK)  None; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int)  int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str)  List[psi4.core.Matrix]; Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; HF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:11567,Deployability,update,updated,11567," the private external_potentials list. reset_occupation(self: psi4.core.HF)  None; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. save_density_and_energy(self: psi4.core.HF)  None; docstring. scf_type(self: psi4.core.HF)  str; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF)  None; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float)  None; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix])  None; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK)  None; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int)  int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str)  List[psi4.core.Matrix]; Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; HF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:1898,Energy Efficiency,energy,energy,1898,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self,arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self,arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self,arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:6008,Energy Efficiency,energy,energy,6008,"he number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and call",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:7070,Energy Efficiency,energy,energy,7070,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:7138,Energy Efficiency,energy,energy,7138,"elf: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF)  None; Forms the initial F matri",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:5926,Integrability,wrap,wrapper,5926,"on_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:258,Performance,perform,performed,258,". HF. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the cu",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:468,Performance,perform,performed,468,". HF. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the cu",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:1809,Performance,Perform,Performs,1809,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self,arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self,arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self,arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:4626,Performance,perform,performed,4626,"ng. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:4841,Performance,perform,performed,4841,"); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. comput",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:6980,Performance,Perform,Performs,6980,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:11234,Security,Validat,ValidationError,11234," the private external_potentials list. reset_occupation(self: psi4.core.HF)  None; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; docstring. save_density_and_energy(self: psi4.core.HF)  None; docstring. scf_type(self: psi4.core.HF)  str; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF)  None; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float)  None; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix])  None; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK)  None; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int)  int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str)  List[psi4.core.Matrix]; Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; HF.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:1024,Usability,Clear,Clear,1024,"modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:1105,Usability,Clear,Clear,1105,"; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(se",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:5644,Usability,Clear,Clear,5644,"pt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:5747,Usability,Clear,Clear,5747,"diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_updat",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:5917,Usability,simpl,simply,5917,"on_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IDAMAX.html:409,Deployability,update,updated,409,". IDAMAX. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX. IDAMAX. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  int; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IDAMAX.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IDAMAX.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.initialize.html:455,Deployability,update,updated,455,". initialize. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; initialize. initialize. psi4.core.initialize()  bool; Called upon psi4 module import to initialize timers, singletons, and I/O. Idempotent. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; initialize.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.initialize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.initialize.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IntegralFactory.html:8171,Deployability,update,updated,8171,"OInt; Returns an F12G12 integral object. overlap_3c(self: psi4.core.IntegralFactory)  psi4.core.ThreeCenterOverlapInt; Returns a OneBodyInt that computes the 3 center overlap integral. shells_iterator(self: psi4.core.IntegralFactory)  psi4.core.AOShellCombinationsIterator; Returns an ERI iterator object, only coded for standard ERIs. so_angular_momentum(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO angular momentum integral. so_dipole(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO dipole integrals. so_kinetic(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO kinetic integrals. so_multipoles(self: psi4.core.IntegralFactory, order: int, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes arbitrary-order SO multipole integrals. so_nabla(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nabla integral. so_overlap(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO overlap integrals. so_potential(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nuclear attraction integral. so_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes SO the quadrupole integral. so_traceless_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the traceless SO quadrupole integral. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IntegralFactory.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IntegralFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IntegralFactory.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IntegralTransform.html:5544,Deployability,update,updated,5544,"lf: psi4.core.IntegralTransform, arg0: str)  None. set_dpd_id(self: psi4.core.IntegralTransform, arg0: int)  None. set_dpd_int_file(self: psi4.core.IntegralTransform, arg0: int)  None. set_keep_dpd_so_ints(self: psi4.core.IntegralTransform, arg0: bool)  None. set_keep_ht_ints(self: psi4.core.IntegralTransform, arg0: bool)  None. set_keep_iwl_so_ints(self: psi4.core.IntegralTransform, arg0: bool)  None. set_memory(self: psi4.core.IntegralTransform, arg0: int)  None. set_orbitals(self: psi4.core.IntegralTransform, arg0: psi4.core.Matrix)  None. set_print(self: psi4.core.IntegralTransform, arg0: int)  None. set_psio(self: psi4.core.IntegralTransform, arg0: psi4.core.IO)  None. set_so_tei_file(self: psi4.core.IntegralTransform, arg0: int)  None. set_tei_already_presorted(self: psi4.core.IntegralTransform, arg0: bool)  None. set_tpdm_already_presorted(self: psi4.core.IntegralTransform, arg0: bool)  None. set_write_dpd_so_tpdm(self: psi4.core.IntegralTransform, arg0: bool)  None. transform_tei(self: psi4.core.IntegralTransform, s1: psi4.core.MOSpace, s2: psi4.core.MOSpace, s3: psi4.core.MOSpace, s4: psi4.core.MOSpace, half_trans: psi4.core.IntegralTransform.HalfTrans = <HalfTrans.MakeAndNuke: 2>)  None; Transform two-electron integrals. transform_tei_first_half(self: psi4.core.IntegralTransform, s1: psi4.core.MOSpace, s2: psi4.core.MOSpace)  None; First half-transform two-electron integrals. transform_tei_second_half(self: psi4.core.IntegralTransform, s1: psi4.core.MOSpace, s2: psi4.core.MOSpace, s3: psi4.core.MOSpace, s4: psi4.core.MOSpace)  None; Second half-transform two-electron integrals. update_orbitals(self: psi4.core.IntegralTransform)  None; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IntegralTransform.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IntegralTransform.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IntegralTransform.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IntVector.html:2981,Deployability,update,updated,2981,"f: psi4.core.IntVector, m: int, val: int) -> None. Add to a single element value located at m. add(self: psi4.core.IntVector, h: int, m: int, val: int) -> None. Add to a single element value located at m in irrep h. clone(self: psi4.core.IntVector)  psi4.core.IntVector; Clone the vector. copy(self: psi4.core.IntVector, arg0: psi4.core.ProtoIntVector)  None; Copy another vector into this. dim(self: psi4.core.IntVector, h: int = 0)  int; Returns the number of dimensions per irrep h. dimpi(self: psi4.core.IntVector)  psi4.core.Dimension; Returns the Dimension object. get(*args, **kwargs); Overloaded function. get(self: psi4.core.IntVector, m: int) -> int. Returns a single element value located at m. get(self: psi4.core.IntVector, h: int, m: int) -> int. Returns a single element value located at m in irrep h. get_block(self: psi4.core.IntVector, slice: psi4.core.Slice)  psi4.core.IntVector; Get a vector block. init(self: psi4.core.IntVector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. static iota(arg0: psi4.core.Dimension)  psi4.core.IntVector. nirrep(self: psi4.core.IntVector)  int; Returns the number of irreps. print_out(self: psi4.core.IntVector)  None; Prints the vector to the output file. set(*args, **kwargs); Overloaded function. set(self: psi4.core.IntVector, m: int, val: int) -> None. Sets a single element value located at m. set(self: psi4.core.IntVector, h: int, m: int, val: int) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.IntVector, slice: psi4.core.Slice, block: psi4.core.ProtoIntVector)  None; Set a vector block. zero(self: psi4.core.IntVector)  None; Zeros the vector. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IntVector.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IntVector.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IO.html:3341,Deployability,update,updated,3341,": psi4.core.IO, unit: int, keep: int)  None; Close unit. If keep == 0, will remove the file, else keep it. exists(self: psi4.core.IO, unit: int)  bool; Check if the unit exists. static get_default_namespace()  str; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO)  str; Lookup process id. open(self: psi4.core.IO, unit: int, status: int)  None; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int)  int; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int)  None; Sync up the object to the file on disk by closing and opening the file, if necessary. static set_default_namespace(ns: str)  None; Set the current namespace (for PREFIX.NAMESPACE.UNIT file numbering). set_pid(self: psi4.core.IO, pid: str)  None; Set process id. static shared_object()  psi4.core.IO; Return the global shared object. state(self: psi4.core.IO)  int; Return 1 if PSIO library is activated. tocclean(self: psi4.core.IO, unit: int, key: str)  None; Delete all TOC entries after the given key. If a blank key is given, the entire TOC will be wiped. tocentry_exists(self: psi4.core.IO, arg0: int, arg1: str)  bool; Checks the TOC to see if a particular keyword exists there or not. tocprint(self: psi4.core.IO, arg0: int)  None; Print the table of contents for the given unit. tocscan(self: psi4.core.IO, arg0: int, arg1: str)  psi4.core.psio_entry; Seek string in binary file. This export is only good for catching None, as returned success object not exported. tocwrite(self: psi4.core.IO, arg0: int)  None; Write the table of contents for passed file number. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IO.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IO.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IO.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IOManager.html:2844,Deployability,update,updated,2844,"lf,fileno,path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IOManager.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IOManager.html:743,Integrability,protocol,protocol,743,". IOManager. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IOManager. IOManager. class psi4.core.IOManager; Bases: pybind11_object; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation; Methods Summary. crashclean(self); Clean from disk-mirrored image after crash. get_default_path(self); Return the default path. get_file_path(self,fileno); Get the path for a specific file number. mark_file_for_retention(self,full_path,retain); Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self); Print the current status of PSI4 files. psiclean(self); Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self,path); Set the default path for files to be stored. set_specific_path(self,fileno,path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IOManager.html:1913,Integrability,protocol,protocol,1913,"lf,fileno,path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IOManager.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.IrreducibleRepresentation.html:935,Deployability,update,updated,935,". IrreducibleRepresentation. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation. IrreducibleRepresentation. class psi4.core.IrreducibleRepresentation; Bases: pybind11_object; An irreducible representation of the point group; Methods Summary. character(self,arg0); Return the character of the i'th symmetry operation for the irrep. symbol(self); Return the symbol for the irrep. Methods Documentation. character(self: psi4.core.IrreducibleRepresentation, arg0: int)  float; Return the character of the ith symmetry operation for the irrep. 0-indexed. symbol(self: psi4.core.IrreducibleRepresentation)  str; Return the symbol for the irrep. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.IrreducibleRepresentation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.IrreducibleRepresentation.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.JK.html:5296,Deployability,update,updated,5296,"K)  List[int]; Array containing the number of ERI shell quartets computed (not screened out) during each compute call. finalize(self: psi4.core.JK)  None. get_early_screening(self: psi4.core.JK)  bool; Use severe screening techniques? Useful in early SCF iterations. get_omega(self: psi4.core.JK)  float; Dampening term for range separated DFT. get_omega_alpha(self: psi4.core.JK)  float; Weight for HF exchange term in range-separated DFT. get_omega_beta(self: psi4.core.JK)  float; Weight for dampened exchange term in range-separated DFT. get_wcombine(self: psi4.core.JK)  bool; wcombine. initialize(self: psi4.core.JK)  None. memory_estimate(self: psi4.core.JK)  int. name(self: psi4.core.JK)  str. print_header(self: psi4.core.JK)  None; docstring. set_cutoff(self: psi4.core.JK, arg0: float)  None. set_do_J(self: psi4.core.JK, arg0: bool)  None. set_do_K(self: psi4.core.JK, arg0: bool)  None. set_do_wK(self: psi4.core.JK, arg0: bool)  None. set_early_screening(self: psi4.core.JK, early_screening: bool)  None; Use severe screening techniques? Useful in early SCF iterations. set_memory(self: psi4.core.JK, arg0: int)  None. set_omega(self: psi4.core.JK, omega: float)  None; Dampening term for range separated DFT. set_omega_alpha(self: psi4.core.JK, alpha: float)  None; Weight for HF exchange term in range-separated DFT. set_omega_beta(self: psi4.core.JK, beta: float)  None; Weight for dampened exchange term in range-separated DFT. set_omp_nthread(self: psi4.core.JK, arg0: int)  None. set_print(self: psi4.core.JK, arg0: int)  None. set_wcombine(self: psi4.core.JK, wcombine: bool)  None; Are Exchange terms in one Matrix. wK(self: psi4.core.JK)  List[psi4.core.Matrix]. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; JK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.JK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.JK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.KineticInt.html:415,Deployability,update,updated,415,". KineticInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; KineticInt. KineticInt. class psi4.core.KineticInt; Bases: OneBodyAOInt; Computes kinetic integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; KineticInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.KineticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.KineticInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.LaplaceDenominator.html:1178,Deployability,update,updated,1178,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.LaplaceDenominator.html:288,Energy Efficiency,energy,energy,288,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.LibXCFunctional.html:1602,Deployability,update,updated,1602,". LibXCFunctional. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; LibXCFunctional. LibXCFunctional. class psi4.core.LibXCFunctional; Bases: Functional; docstring; Methods Summary. density_cutoff(self); docstring. get_mix_data(self); docstring. query_libxc(self,arg0); query libxc regarding functional parameters. set_density_cutoff(self,arg0); docstring. set_omega(self,arg0); docstring. set_tweak(*args,**kwargs); Overloaded function. Methods Documentation. density_cutoff(self: psi4.core.LibXCFunctional)  float; docstring. get_mix_data(self: psi4.core.LibXCFunctional)  List[Tuple[str, int, float]]; docstring. query_libxc(self: psi4.core.LibXCFunctional, arg0: str)  Dict[str, float]; query libxc regarding functional parameters. set_density_cutoff(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_omega(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_tweak(*args, **kwargs); Overloaded function. set_tweak(self: psi4.core.LibXCFunctional, tweaks: List[float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a list. Deprecated in v1.4. set_tweak(self: psi4.core.LibXCFunctional, tweaks: Dict[str, float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a dictionary of names (usually underscore prepended) and values. New in v1.4. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; LibXCFunctional.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.LibXCFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.LibXCFunctional.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Localizer.html:1074,Deployability,update,updated,1074,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Localizer.html:466,Performance,Perform,Perform,466,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Localizer.html:844,Performance,Perform,Perform,844,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:18292,Deployability,update,updated,18292,"rue. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix)  None; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC); Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix)  float; Returns the vector dot product of this with rhs. zero(self: psi4.core.Matrix)  None; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:3294,Energy Efficiency,power,power,3294,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:3354,Energy Efficiency,power,power,3354,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:13053,Energy Efficiency,power,power,13053,"ucted.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. row",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:13174,Energy Efficiency,power,power,13174,"turn type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0)  int; Returns the rows in irrep h. save(*args, **kwargs); Overloa",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:16462,Integrability,depend,depending,16462,"ce, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the tran",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:2737,Performance,load,load,2737,"im1,dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self,transa,transb,alpha,a,b,beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoa",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:2808,Performance,Load,Loads,2808,"into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self,transa,transb,alpha,a,b,beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_column",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:2993,Performance,load,load,2993,"); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*ar",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11129,Performance,load,load,11129,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was sav",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11174,Performance,load,load,11174,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Uni",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11227,Performance,Load,Loads,11227,"rix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped mat",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11298,Performance,load,load,11298,"nsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11394,Performance,Load,Load,11394,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11466,Performance,load,load,11466,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Opt",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11597,Performance,Load,Load,11597,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passe",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11749,Performance,Load,Loads,11749,"e(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11974,Performance,load,load,11974,"x)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:4786,Security,access,accessor,4786,"ix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,block); Set a matrix block. subtract(self,arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self,mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args,**kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A,B,C,transA,transB,transC); Multiply three matrices together. vector_dot(self,rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name; The name of the Matrix. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix)  float; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:16757,Security,access,accessor,16757,": psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix)  None; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC); Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix)  float; Returns th",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11272,Testability,test,tests,11272,"rix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector])  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped mat",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:16079,Usability,simpl,simply,16079,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*a",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MatrixFactory.html:836,Deployability,update,updated,836,". MatrixFactory. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory. MatrixFactory. class psi4.core.MatrixFactory; Bases: pybind11_object; Creates Matrix objects; Methods Summary. create_matrix(*args,**kwargs); Overloaded function. Methods Documentation. create_matrix(*args, **kwargs); Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matrix. Returns a new matrix object with default dimensions. create_matrix(self: psi4.core.MatrixFactory, arg0: str) -> psi4.core.Matrix. Returns a new Matrix object named name with default dimensions. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MatrixFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MatrixFactory.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.mcscf.html:455,Deployability,update,updated,455,". mcscf. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; mcscf. mcscf. psi4.core.mcscf(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the MCSCF code, (N.B. restricted to certain active spaces). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; mcscf.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.mcscf.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MemDFJK.html:532,Deployability,update,updated,532,". MemDFJK. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK. MemDFJK. class psi4.core.MemDFJK; Bases: JK; docstring; Methods Summary. dfh(self); Return the DFHelper object. Methods Documentation. dfh(self: psi4.core.MemDFJK)  psi4.core.DFHelper; Return the DFHelper object. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MemDFJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MemDFJK.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:19685,Deployability,update,updated,19685,"turns petite list which transforms AO basis functions to SOs, setting argument to true is for Cartesian basis, false is for Spherical Harmonic basis. play(self: psi4.core.MintsHelper)  None; play function. potential_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative potential integrals. set_basisset(self: psi4.core.MintsHelper, label: str, basis: psi4.core.BasisSet)  None; Sets a basis set. set_print(self: psi4.core.MintsHelper, arg0: int)  None; Sets the print level. so_angular_momentum(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector SO angular momentum integrals. so_dipole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector SO dipole integrals. so_dkh(self: psi4.core.MintsHelper, arg0: int)  psi4.core.Matrix; SO dkh integrals. so_ecp(self: psi4.core.MintsHelper)  psi4.core.Matrix; SO basis effective core potential integrals. so_kinetic(self: psi4.core.MintsHelper, include_perturbations: bool = True)  psi4.core.Matrix; SO basis kinetic integrals. so_nabla(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector SO nabla integrals. so_overlap(self: psi4.core.MintsHelper, include_perturbations: bool = True)  psi4.core.Matrix; SO basis overlap integrals. so_potential(self: psi4.core.MintsHelper, include_perturbations: bool = True)  psi4.core.Matrix; SO basis potential integrals. so_quadrupole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector SO quadrupole integrals. so_traceless_quadrupole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector SO traceless quadrupole integrals. sobasisset(self: psi4.core.MintsHelper)  psi4.core.SOBasisSet; Returns the SO basis set being used. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MintsHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:2782,Energy Efficiency,charge,charges,2782,"ion. ao_overlap_half_deriv1(self,side,atom); Half-derivative of AO basis overlap integrals: returns (3 * natoms) matrices. ao_potential(*args,**kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...);",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:2859,Energy Efficiency,charge,charge,2859,"ap integrals: returns (3 * natoms) matrices. ao_potential(*args,**kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4);",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:12619,Energy Efficiency,charge,charges,12619,"2 matrices. ao_traceless_quadrupole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector AO traceless quadrupole integrals. basisset(self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  Non",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:12776,Energy Efficiency,charge,charge,12776,"self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic int",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:3092,Integrability,contract,contracting,3092,"s: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4); MO F12 squared integrals. mo_f12g12(self,corr,C1,C2,C3,C4); MO F12G12 integrals. mo_oei_deriv1(self,oei_type,atom,C1,C2); Gradient of MO basis OEI integrals: returns (3 * natoms) matrices. mo_oei_deriv2(self,oei_type,atom1,atom2,...); Hessian of ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:13201,Integrability,contract,contracting,13201," dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self: psi4.core.MintsHelper, atom: int, C1: psi4.core.Matrix, C2: psi4.core.Matrix)  List[psi4.core.Matrix]; Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self: psi4.core.MintsHelper, omega: float, C1: psi4.core.Matrix, C2: psi4.core.Matrix, C3: psi4.core.Matrix, C4: psi4.core.Matrix)  psi4.core.Matrix; MO ERFC Omega Integrals. mo_eri(self: psi4.core.MintsHelper, C1: psi4.core.Matrix, C2: psi",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MoldenWriter.html:853,Deployability,update,updated,853,". MoldenWriter. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter. MoldenWriter. class psi4.core.MoldenWriter; Bases: pybind11_object; Writes wavefunction information in molden format; Methods Summary. write(self,filename,Ca,Cb,Ea,Eb,OccA,...); Writes wavefunction information in molden format. Methods Documentation. write(self: psi4.core.MoldenWriter, filename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool)  None; Writes wavefunction information in molden format. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MoldenWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MoldenWriter.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MolecularGrid.html:1706,Deployability,update,updated,1706,". MolecularGrid. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid. MolecularGrid. class psi4.core.MolecularGrid; Bases: pybind11_object; docstring; Methods Summary. atomic_blocks(self); Returns a list of blocks. blocks(self); Returns a list of blocks. collocation_size(self); Returns the total collocation size of all blocks. max_functions(self); Returns the maximum number of functions in a block. max_points(self); Returns the maximum number of points in a block. npoints(self); Returns the number of grid points. orientation(self); Returns the orientation of the grid. print(self,arg0,arg1); Prints grid information. Methods Documentation. atomic_blocks(self: psi4.core.MolecularGrid)  List[List[psi4.core.BlockOPoints]]; Returns a list of blocks. blocks(self: psi4.core.MolecularGrid)  List[psi4.core.BlockOPoints]; Returns a list of blocks. collocation_size(self: psi4.core.MolecularGrid)  int; Returns the total collocation size of all blocks. max_functions(self: psi4.core.MolecularGrid)  int; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid)  int; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid)  int; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid)  psi4.core.Matrix; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int)  None; Prints grid information. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MolecularGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MolecularGrid.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:2059,Availability,toler,tolerance,2059,"a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:2156,Availability,toler,tolerance,2156,"f,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:10010,Availability,toler,tolerance,10010,"g0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0);",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:15209,Availability,fault,faulty,15209,"ts of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol:",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:18761,Availability,toler,tolerance,18761,"ts(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Writte",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:18915,Availability,toler,tolerance,18915,"ract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='An",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:20220,Availability,error,error,20220,"ride this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Mo",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:28550,Availability,error,error,28550,"al_symmetry_number(self: psi4.core.Molecule)  int; Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:29841,Availability,error,error,29841,"ertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geom",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:37245,Availability,toler,tolerance,37245,"elf: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[so",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:39773,Deployability,update,updated,39773,"geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:264,Energy Efficiency,charge,charge,264,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:609,Energy Efficiency,charge,charge,609,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:902,Energy Efficiency,charge,charge,902,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:1186,Energy Efficiency,charge,charge,1186,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:1211,Energy Efficiency,charge,charge,1211,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:1625,Energy Efficiency,charge,charges,1625,"0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:1904,Energy Efficiency,charge,charge,1904,"ed atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:1981,Energy Efficiency,charge,charge,1981,"rloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_sc",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:3868,Energy Efficiency,charge,charge,3868,"lecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:5097,Energy Efficiency,charge,charge,5097,"gments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separato",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:5530,Energy Efficiency,energy,energy,5530,"s molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:5630,Energy Efficiency,energy,energy,5630,"nit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_r",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:5747,Energy Efficiency,energy,energy,5747,"els. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_rotational_constants(self); Print the rotational constants to output file. provenance(self); Gets molecule",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:9205,Energy Efficiency,charge,charge,9205,"arg2); Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self,arg0); Sets molecule comment. set_connectivity(self,arg0); Sets molecule connectivity. set_full_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); E",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:9384,Energy Efficiency,charge,charge,9384,"basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self,arg0); Sets molecule comment. set_connectivity(self,arg0); Sets molecule connectivity. set_full_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema d",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:13075,Energy Efficiency,charge,charge,13075,"ed final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool)  Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float)  TODO; run_mirror (bool)  Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int)  . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule)  ; seed_atoms (Optional[List])  List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float)  Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool)  If True, also return fragments as list of arrays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:14928,Energy Efficiency,charge,charge,14928,"rays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists)  Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overl",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:15407,Energy Efficiency,charge,charge,15407,"ch built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:15664,Energy Efficiency,charge,charge,15664,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:15826,Energy Efficiency,charge,charge,15826,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:16615,Energy Efficiency,charge,charge,16615,"oat, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:16674,Energy Efficiency,charge,charge,16674,", label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.M",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:17264,Energy Efficiency,charge,charges,17264," tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: p",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:18553,Energy Efficiency,charge,charge,18553,"wargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:18664,Energy Efficiency,charge,charge,18664,"si4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by cal",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:22785,Energy Efficiency,charge,charge,22785," C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule)  int; Gets n in Cnv, etc.; If there is no n (e.g. Td) its the highest-order rotation axis. fx(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg0 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg0 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:24501,Energy Efficiency,charge,charge,24501,"str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_r",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:25469,Energy Efficiency,energy,energy,25469,": psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecul",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:25650,Energy Efficiency,energy,energy,25650,"Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:25807,Energy Efficiency,energy,energy,25807,"molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule)  None; Prints the m",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:28662,Energy Efficiency,energy,energy-only,28662,"ical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:28714,Energy Efficiency,efficient,efficient,28714,"ical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:28809,Energy Efficiency,energy,energy,28809,"dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:28842,Energy Efficiency,energy,energy,28842,"dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:28929,Energy Efficiency,energy,energy,28929,":. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecule",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:29009,Energy Efficiency,energy,energy,29009,"& disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficien",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:29953,Energy Efficiency,energy,energy-only,29953,"y.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30005,Energy Efficiency,efficient,efficient,30005,"y.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30100,Energy Efficiency,energy,energy,30100,"se=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30133,Energy Efficiency,energy,energy,30133,"se=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30213,Energy Efficiency,energy,energy,30213," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30286,Energy Efficiency,energy,energy,30286," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30967,Energy Efficiency,energy,energy,30967,"nfluences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both e",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31032,Energy Efficiency,energy,energy,31032,"nfluences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both e",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31664,Energy Efficiency,energy,energy-only,31664,"rogram.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31716,Energy Efficiency,efficient,efficient,31716,"rogram.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31830,Energy Efficiency,energy,energy,31830,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31863,Energy Efficiency,energy,energy,31863,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31943,Energy Efficiency,energy,energy,31943,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:32016,Energy Efficiency,energy,energy,32016,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:35892,Energy Efficiency,charge,charge,35892,"y(self: psi4.core.Molecule, arg0: List[Tuple[int, int, float]])  None; Sets molecule connectivity. set_full_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float)  None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float)  None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: f",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:36299,Energy Efficiency,charge,charge,36299," set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float)  None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float)  None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. s",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:11411,Integrability,Wrap,Wraps,11411,"s,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self,arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule])  Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (Union[Molecule, Molecule])  Molecule to match.; atoms_map (bool)  Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool)  Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:20398,Integrability,wrap,wrapper,20398,"). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classm",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:20939,Integrability,wrap,wrapper,20939,"o_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1). fsymbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including d",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30350,Integrability,wrap,wraps,30350," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30389,Integrability,wrap,wraps,30389," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31307,Integrability,interface,interface,31307,"3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:910,Modifiability,extend,extended,910,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:2896,Modifiability,variab,variables,2896,"ion. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge o",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:4406,Modifiability,variab,variable,4406,"nates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:4438,Modifiability,variab,variables,4438,"nates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:4764,Modifiability,variab,variable,4764,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:4799,Modifiability,variab,variables,4799,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:9740,Modifiability,variab,variable,9740,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:9779,Modifiability,variab,variables,9779,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:10786,Modifiability,variab,variable,10786,"e variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self,arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule])  Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with re",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:15834,Modifiability,extend,extended,15834,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: ps",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:20380,Modifiability,variab,variables,20380,"; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molec",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:23522,Modifiability,variab,variable,23522,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:23554,Modifiability,variab,variables,23554,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:24043,Modifiability,variab,variable,24043,"ent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:24078,Modifiability,variab,variables,24078,"ent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:30545,Modifiability,extend,extending,30545,"correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31259,Modifiability,extend,extended,31259,"3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:36908,Modifiability,variab,variable,36908,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:36947,Modifiability,variab,variables,36947,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:38956,Modifiability,variab,variable,38956,"geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:504,Safety,Detect,Detect,504,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-in",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:13402,Safety,Detect,Detect,13402,"sed to test worst-case timings.; run_resorting (bool)  Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float)  TODO; run_mirror (bool)  Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int)  . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule)  ; seed_atoms (Optional[List])  List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float)  Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool)  If True, also return fragments as list of arrays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists)  Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of mole",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:14168,Safety,detect,detected,14168,"and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule)  ; seed_atoms (Optional[List])  List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float)  Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool)  If True, also return fragments as list of arrays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists)  Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped b",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:21210,Security,validat,validation,21210,"e, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1). fsymbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule)  int; Gets n in Cnv, etc.; If there is no n (e.g. ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:37939,Security,hash,hash,37939,"iables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with cur",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:7767,Testability,Test,Tester,7767,"). reset_point_group(self,arg0); Overrides symmetry from outside the molecule string. rotational_constants(self); Returns the rotational constants [cm^-1] of the molecule. rotational_symmetry_number(self); Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self); Returns rotor type, e.g. run_dftd3([func,dashlvl,dashparam,...]); Compute dispersion correction via Grimme's DFTD3 program. run_dftd4([func,dashlvl,dashparam,...]); Compute dispersion correction via Grimme's DFTD4 program. run_gcp([func,dertype,verbose]); Compute geometrical BSSE correction via Grimme's GCP program. save_string_xyz(self); Saves the string of an XYZ file to arg2. save_string_xyz_file(self); Saves an XYZ file to arg2. save_xyz_file(self,arg0,arg1); Saves an XYZ file to arg0. schoenflies_symbol(self); Returns the Schoenflies symbol. scramble([do_shift,do_rotate,do_resort,...]); Tester for B787 by shifting, rotating, and atom shuffling ref_mol and checking that the aligner returns the opposite transformation. set_active_fragment(self,arg0); Sets the specified fragment arg0 to be Real. set_active_fragments(self,arg0); Sets the specified list arg0 of fragments to be Real. set_basis_all_atoms(self,arg0,arg1); Sets basis set arg0 to all atoms. set_basis_by_label(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self,arg0); Sets molecule comment. set_connectivity(self,arg0); Sets molecule connectivity. set_full_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Se",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:12409,Testability,test,test,12409," qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule])  Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (Union[Molecule, Molecule])  Molecule to match.; atoms_map (bool)  Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool)  Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool)  Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float)  TODO; run_mirror (bool)  Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int)  . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragment",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:32587,Testability,Test,Tester,32587,"m derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate (Union[bool, ndarray, List[List]])  Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort (Union[bool, List])  Whether to shuffle atoms (True) or leave 1st atom 1st, etc. (False).; To specify shuffle, supply a nat-element list of indices.; deflection (float)  If do_rotate, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror (bool)  Whether to construct the mirror image structure by inverting y-axis.; do_plot (bool)  Pops up a mpl plot showing",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:33905,Testability,test,test,33905,"on (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate (Union[bool, ndarray, List[List]])  Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort (Union[bool, List])  Whether to shuffle atoms (True) or leave 1st atom 1st, etc. (False).; To specify shuffle, supply a nat-element list of indices.; deflection (float)  If do_rotate, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror (bool)  Whether to construct the mirror image structure by inverting y-axis.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, True turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting (bool)  Even if atoms not shuffled, test the resorting machinery.; verbose (int)  Print level. Return type:; None. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg0 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self: psi4.core.Molecule, arg0: int, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self: psi4.core.Molecule, arg0: str)  None; Sets molecule comment. set_connectivity(self: psi4.core.Molecule,",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:39005,Usability,clear,clearing,39005,"geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Molecule.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MOSpace.html:1381,Deployability,update,updated,1381,". MOSpace. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MOSpace. MOSpace. class psi4.core.MOSpace; Bases: pybind11_object; Defines orbital spaces in which to transform integrals; Methods Summary. aIndex(self); Get the alpha orbital indexing array. aOrbs(self); Get the alpha orbitals. all(). bIndex(self); Get the beta orbital indexing array. bOrbs(self); Get the beta orbitals. dum(). fzc(). fzv(). label(self); Get the unique identifier for this space. nil(). occ(). vir(). Methods Documentation. aIndex(self: psi4.core.MOSpace)  List[int]; Get the alpha orbital indexing array. aOrbs(self: psi4.core.MOSpace)  List[int]; Get the alpha orbitals. static all()  psi4.core.MOSpace. bIndex(self: psi4.core.MOSpace)  List[int]; Get the beta orbital indexing array. bOrbs(self: psi4.core.MOSpace)  List[int]; Get the beta orbitals. static dum()  psi4.core.MOSpace. static fzc()  psi4.core.MOSpace. static fzv()  psi4.core.MOSpace. label(self: psi4.core.MOSpace)  str; Get the unique identifier for this space. static nil()  psi4.core.MOSpace. static occ()  psi4.core.MOSpace. static vir()  psi4.core.MOSpace. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MOSpace.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MOSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MOSpace.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MOWriter.html:520,Deployability,update,updated,520,". MOWriter. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MOWriter. MOWriter. class psi4.core.MOWriter; Bases: pybind11_object; Writes the MOs; Methods Summary. write(self); Write the MOs. Methods Documentation. write(self: psi4.core.MOWriter)  None; Write the MOs. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MOWriter.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MOWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MOWriter.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.mrcc_generate_input.html:516,Deployability,update,updated,516,". mrcc_generate_input. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; mrcc_generate_input. mrcc_generate_input. psi4.core.mrcc_generate_input(arg0: psi4.core.Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Generates an input for Kallays MRCC code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; mrcc_generate_input.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.mrcc_generate_input.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.mrcc_generate_input.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.mrcc_load_densities.html:528,Deployability,update,updated,528,". mrcc_load_densities. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; mrcc_load_densities. mrcc_load_densities. psi4.core.mrcc_load_densities(arg0: psi4.core.Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Reads in the density matrices from Kallays MRCC code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; mrcc_load_densities.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.mrcc_load_densities.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.mrcc_load_densities.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MultipoleInt.html:443,Deployability,update,updated,443,". MultipoleInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MultipoleInt. MultipoleInt. class psi4.core.MultipoleInt; Bases: OneBodyAOInt; Computes arbitrary-order multipole integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MultipoleInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MultipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MultipoleInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.MultipoleSymmetry.html:616,Deployability,update,updated,616,". MultipoleSymmetry. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MultipoleSymmetry. MultipoleSymmetry. class psi4.core.MultipoleSymmetry; Bases: pybind11_object; docstring; Methods Summary. create_matrices(self,arg0); docstring. Methods Documentation. create_matrices(self: psi4.core.MultipoleSymmetry, arg0: str)  List[psi4.core.Matrix]; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; MultipoleSymmetry.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.MultipoleSymmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MultipoleSymmetry.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NablaInt.html:403,Deployability,update,updated,403,". NablaInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NablaInt. NablaInt. class psi4.core.NablaInt; Bases: OneBodyAOInt; Computes nabla integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NablaInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NablaInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NablaInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NBOWriter.html:624,Deployability,update,updated,624,". NBOWriter. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NBOWriter. NBOWriter. class psi4.core.NBOWriter; Bases: pybind11_object; The Natural Bond Orbital Writer; Methods Summary. write(self,filename); Write the natural bond orbitals to a file. Methods Documentation. write(self: psi4.core.NBOWriter, filename: str)  None; Write the natural bond orbitals to a file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NBOWriter.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NBOWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NBOWriter.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:666,Deployability,integrat,integration,666,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:980,Deployability,integrat,integration,980,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:1311,Deployability,integrat,integration,1311,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:1673,Deployability,integrat,integration,1673,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:1912,Deployability,update,updated,1912,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:666,Integrability,integrat,integration,666,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:980,Integrability,integrat,integration,980,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:1311,Integrability,integrat,integration,1311,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html:1673,Integrability,integrat,integration,1673,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.occ.html:420,Deployability,update,updated,420,". occ. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; occ. occ. psi4.core.occ(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the orbital optimized CC codes. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; occ.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.occ.html:212,Performance,optimiz,optimized,212,". occ. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; occ. occ. psi4.core.occ(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the orbital optimized CC codes. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; occ.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:3182,Deployability,update,updated,3182,"NTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:973,Modifiability,variab,variables,973,". OEProp. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp. class psi4.core.OEProp; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self,arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self,Da[,symmetry]); docstring. set_Da_mo(self,arg0); docstring. set_Da_so(self,arg0); docstring. set_Db_ao(self,Db[,symmetry]); docstring. set_Db_mo(self,arg0); docstring. set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:2612,Modifiability,variab,variables,2612,"NTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:2881,Modifiability,variab,variables,2881,"NTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:609,Usability,clear,clear,609,". OEProp. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp. class psi4.core.OEProp; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self,arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self,Da[,symmetry]); docstring. set_Da_mo(self,arg0); docstring. set_Da_so(self,arg0); docstring. set_Db_ao(self,Db[,symmetry]); docstring. set_Db_mo(self,arg0); docstring. set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:622,Usability,Clear,Clear,622,". OEProp. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp. class psi4.core.OEProp; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self,arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self,Da[,symmetry]); docstring. set_Da_mo(self,arg0); docstring. set_Da_so(self,arg0); docstring. set_Db_ao(self,Db[,symmetry]); docstring. set_Db_mo(self,arg0); docstring. set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:1882,Usability,clear,clear,1882,". set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:1921,Usability,Clear,Clear,1921,"mes(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Fol",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OneBodyAOInt.html:1398,Deployability,update,updated,1398,". OneBodyAOInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OneBodyAOInt. OneBodyAOInt. class psi4.core.OneBodyAOInt; Bases: pybind11_object; Basis class for all one-electron integrals; Attributes Summary. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Summary. compute(self,arg0); Compute all integrals over both basis sets, and store them in the provided matrix. compute_shell(self,arg0,arg1); Compute integrals between basis functions in the given shell pair. Attributes Documentation. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Documentation. compute(self: psi4.core.OneBodyAOInt, arg0: List[psi4.core.Matrix])  None; Compute all integrals over both basis sets, and store them in the provided matrix. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; Compute integrals between basis functions in the given shell pair. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OneBodyAOInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OneBodyAOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OneBodyAOInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OneBodySOInt.html:669,Deployability,update,updated,669,". OneBodySOInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OneBodySOInt. OneBodySOInt. class psi4.core.OneBodySOInt; Bases: pybind11_object; Attributes Summary. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. Attributes Documentation. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OneBodySOInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OneBodySOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OneBodySOInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html:3674,Deployability,update,updated,3674,"ore.Options, arg0: str, arg1: str, arg2: str)  None; add string option. get_bool(self: psi4.core.Options, arg0: str)  bool; get boolean option. get_current_module(self: psi4.core.Options)  str; gets current module. get_double(self: psi4.core.Options, arg0: str)  float; get double option. get_int(self: psi4.core.Options, arg0: str)  int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str)  List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options)  None; print the global, cross-module options. print_module_options(self: psi4.core.Options)  None; print global and local options prepared for current module. read_globals(self: psi4.core.Options)  bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str)  None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool)  None; set bool option. set_current_module(self: psi4.core.Options, arg0: str)  None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float)  None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int)  None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool)  None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. validate_options(self: psi4.core.Options)  None; validate options for arg0 module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Options.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html:1343,Security,validat,validate,1343,"(self,arg0,arg1,arg2); add string option. add_str_i(self,arg0,arg1,arg2); add string option. get_bool(self,arg0); get boolean option. get_current_module(self); gets current module. get_double(self,arg0); get double option. get_int(self,arg0); get integer option. get_int_vector(self,arg0); get int vector option. get_str(*args,**kwargs); Overloaded function. print_global_options(self); print the global, cross-module options. print_module_options(self); print global and local options prepared for current module. read_globals(self); expert. set_array(self,arg0,arg1); set array option. set_bool(self,arg0,arg1,arg2); set bool option. set_current_module(self,arg0); sets arg0 (all CAPS) as current module. set_double(self,arg0,arg1,arg2); set double option. set_int(self,arg0,arg1,arg2); set int option. set_read_globals(self,arg0); expert. set_str(self,arg0,arg1,arg2); set string option. set_str_i(self,arg0,arg1,arg2); set string option. validate_options(self); validate options for arg0 module. Methods Documentation. add_array(self: psi4.core.Options, arg0: str)  None; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool)  None; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int)  None; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; add string option. get_bool(self: psi4.core.Options, arg0: str)  bool; get boolean option. get_current_module(self: psi4.core.Options)  str; gets current module. get_double(self: psi4.core.Options, arg0: str)  float; get double option. get_int(self: psi4.core.Options, arg0: str)  int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str)  List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html:3448,Security,validat,validate,3448,"ore.Options, arg0: str, arg1: str, arg2: str)  None; add string option. get_bool(self: psi4.core.Options, arg0: str)  bool; get boolean option. get_current_module(self: psi4.core.Options)  str; gets current module. get_double(self: psi4.core.Options, arg0: str)  float; get double option. get_int(self: psi4.core.Options, arg0: str)  int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str)  List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options)  None; print the global, cross-module options. print_module_options(self: psi4.core.Options)  None; print global and local options prepared for current module. read_globals(self: psi4.core.Options)  bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str)  None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool)  None; set bool option. set_current_module(self: psi4.core.Options, arg0: str)  None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float)  None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int)  None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool)  None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. validate_options(self: psi4.core.Options)  None; validate options for arg0 module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Options.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.options_to_python.html:471,Deployability,update,updated,471,". options_to_python. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; options_to_python. options_to_python. psi4.core.options_to_python(arg0: str)  dict; Get dictionary of whether options of module have changed. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; options_to_python.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.options_to_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.options_to_python.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.option_exists_in_module.html:506,Deployability,update,updated,506,". option_exists_in_module. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; option_exists_in_module. option_exists_in_module. psi4.core.option_exists_in_module(module: str, key: str)  bool; Whether keyword key is a valid keyword for module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; option_exists_in_module.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.option_exists_in_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.option_exists_in_module.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html:1774,Availability,toler,tolerance,1774,"dimensions. evals(self); Corresponding eigenvalues of the C matrix. id(self); Unique identifier. integral(self); The integral factory used to create C. name(self); Name of the orbital space. nirrep(self); Returns number of irreps. print_out(self); Print information about the orbital space to the output file. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html:2375,Availability,toler,tolerance,2375,".core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OrbitalSpace.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Cr",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html:3200,Deployability,update,updated,3200," set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OrbitalSpace.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html:1795,Integrability,depend,dependencies,1795,"dimensions. evals(self); Corresponding eigenvalues of the C matrix. id(self); Unique identifier. integral(self); The integral factory used to create C. name(self); Name of the orbital space. nirrep(self); Returns number of irreps. print_out(self); Print information about the orbital space to the output file. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html:2055,Integrability,depend,dependent,2055,"thods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html:2396,Integrability,depend,dependencies,2396,".core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(molecule: psi4.core.Molecule, obs_key: str, aux_key: str, lindep_tol: float)  psi4.core.OrbitalSpace; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set BASIS The third argument, aux_key, is the option keyword for auxiliery basis set DF_BASIS_MP2 The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OrbitalSpace.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Cr",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.outfile_name.html:415,Deployability,update,updated,415,". outfile_name. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; outfile_name. outfile_name. psi4.core.outfile_name()  str; Returns the name of the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; outfile_name.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.outfile_name.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.outfile_name.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.OverlapInt.html:415,Deployability,update,updated,415,". OverlapInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OverlapInt. OverlapInt. class psi4.core.OverlapInt; Bases: OneBodyAOInt; Computes overlap integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; OverlapInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.OverlapInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OverlapInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PetiteList.html:865,Deployability,update,updated,865,". PetiteList. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PetiteList. PetiteList. class psi4.core.PetiteList; Bases: pybind11_object; Handles symmetry transformations; Methods Summary. aotoso(self); Return the AO->SO coefficient matrix. print(self,arg0); Print to outfile. sotoao(self); Return the SO->AO coefficient matrix. Methods Documentation. aotoso(self: psi4.core.PetiteList)  psi4.core.Matrix; Return the AO->SO coefficient matrix. print(self: psi4.core.PetiteList, arg0: str)  None; Print to outfile. sotoao(self: psi4.core.PetiteList)  psi4.core.Matrix; Return the SO->AO coefficient matrix. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PetiteList.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PetiteList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PetiteList.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:468,Deployability,update,updated,468,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:3,Modifiability,plugin,plugin,3,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:113,Modifiability,plugin,plugin,113,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:121,Modifiability,plugin,plugin,121,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:140,Modifiability,plugin,plugin,140,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:224,Modifiability,plugin,plugin,224,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:257,Modifiability,plugin,plugin,257,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html:413,Modifiability,plugin,plugin,413,". plugin. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close.html:419,Deployability,update,updated,419,". plugin_close. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close. plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close.html:201,Modifiability,plugin,plugin,201,". plugin_close. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close. plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close_all.html:423,Deployability,update,updated,423,". plugin_close_all. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all. plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close_all.html:213,Modifiability,plugin,plugins,213,". plugin_close_all. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all. plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html:471,Deployability,update,updated,471,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html:195,Modifiability,plugin,plugin,195,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html:186,Performance,Load,Load,186,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html:233,Performance,load,loaded,233,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html:246,Performance,load,loaded,246,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html:267,Performance,load,loaded,267,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PMLocalizer.html:432,Deployability,update,updated,432,". PMLocalizer. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer. PMLocalizer. class psi4.core.PMLocalizer; Bases: Localizer; Performs Pipek-Mezey orbital localization. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PMLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PMLocalizer.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PMLocalizer.html:193,Performance,Perform,Performs,193,". PMLocalizer. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer. PMLocalizer. class psi4.core.PMLocalizer; Bases: Localizer; Performs Pipek-Mezey orbital localization. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PMLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PMLocalizer.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PointFunctions.html:1538,Deployability,update,updated,1538,". PointFunctions. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PointFunctions. PointFunctions. class psi4.core.PointFunctions; Bases: BasisFunctions; docstring; Methods Summary. ansatz(self); docstring. compute_points(self,block[,force_compute]); docstring. orbital_values(self); docstring. point_values(self); docstring. print_out(self[,out_fname,print]); docstring. set_ansatz(self,arg0); docstring. set_pointers(*args,**kwargs); Overloaded function. Methods Documentation. ansatz(self: psi4.core.PointFunctions)  int; docstring. compute_points(self: psi4.core.PointFunctions, block: psi4.core.BlockOPoints, force_compute: bool = True)  None; docstring. orbital_values(self: psi4.core.PointFunctions)  Dict[str, psi4.core.Matrix]; docstring. point_values(self: psi4.core.PointFunctions)  Dict[str, psi4.core.Vector]; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str = 'outfile', print: int = 2)  None; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int)  None; docstring. set_pointers(*args, **kwargs); Overloaded function. set_pointers(self: psi4.core.PointFunctions, arg0: psi4.core.Matrix) -> None. docstring. set_pointers(self: psi4.core.PointFunctions, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PointFunctions.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PointFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PointFunctions.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PointGroup.html:1234,Deployability,update,updated,1234,". PointGroup. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PointGroup. PointGroup. class psi4.core.PointGroup; Bases: pybind11_object; Contains information about the point group; Methods Summary. bits(self); Return the bit representation of the point group. char_table(self); Return the CharacterTable of the point group. full_name(self); Return the Schoenflies symbol with direction. order(self); Return the order of the point group. symbol(self); Returns Schoenflies symbol for point group. Methods Documentation. bits(self: psi4.core.PointGroup)  int; Return the bit representation of the point group. char_table(self: psi4.core.PointGroup)  psi4.core.CharacterTable; Return the CharacterTable of the point group. full_name(self: psi4.core.PointGroup)  str; Return the Schoenflies symbol with direction. order(self: psi4.core.PointGroup)  int; Return the order of the point group. symbol(self: psi4.core.PointGroup)  str; Returns Schoenflies symbol for point group. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PointGroup.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PointGroup.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PointGroup.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PotentialInt.html:427,Deployability,update,updated,427,". PotentialInt. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PotentialInt. PotentialInt. class psi4.core.PotentialInt; Bases: OneBodyAOInt; Computes potential integrals. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PotentialInt.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PotentialInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PotentialInt.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.prepare_options_for_module.html:556,Deployability,update,updated,556,". prepare_options_for_module. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module. prepare_options_for_module. psi4.core.prepare_options_for_module(name: str)  None; Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.prepare_options_for_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.prepare_options_for_module.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.prepare_options_for_module.html:321,Modifiability,plugin,plugin,321,". prepare_options_for_module. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module. prepare_options_for_module. psi4.core.prepare_options_for_module(name: str)  None; Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.prepare_options_for_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.prepare_options_for_module.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PrimitiveType.html:670,Deployability,update,updated,670,". PrimitiveType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PrimitiveType. PrimitiveType. class psi4.core.PrimitiveType; Bases: pybind11_object; May be Normalized or Unnormalized; Members:. Normalized; Unnormalized. Attributes Summary. Normalized. Unnormalized. name. value. Attributes Documentation. Normalized = <PrimitiveType.Normalized: 0>. Unnormalized = <PrimitiveType.Unnormalized: 1>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PrimitiveType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PrimitiveType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PrimitiveType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_global_options.html:493,Deployability,update,updated,493,". print_global_options. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_global_options. print_global_options. psi4.core.print_global_options()  None; Prints the currently set global (all modules) options to the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_global_options.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.print_global_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_global_options.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_options.html:462,Deployability,update,updated,462,". print_options. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_options. print_options. psi4.core.print_options()  None; Prints the currently set options (to the output file) for the current module. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_options.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.print_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_options.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_out.html:439,Deployability,update,updated,439,". print_out. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_out. print_out. psi4.core.print_out(arg0: str)  None; Prints a string (using sprintf-like notation) to the output file. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_out.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.print_out.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_out.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_variables.html:469,Deployability,update,updated,469,". print_variables. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_variables. print_variables. psi4.core.print_variables()  None; Prints to output file all QCVariables that have been set in global memory. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; print_variables.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.print_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.print_variables.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.Prop.html:371,Deployability,update,updated,371,". Prop. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Prop. Prop. class psi4.core.Prop; Bases: pybind11_object; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; Prop.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.Prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Prop.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ProtoIntVector.html:410,Deployability,update,updated,410,". ProtoIntVector. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ProtoIntVector. ProtoIntVector. class psi4.core.ProtoIntVector; Bases: pybind11_object. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ProtoIntVector.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ProtoIntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ProtoIntVector.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.ProtoVector.html:395,Deployability,update,updated,395,". ProtoVector. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ProtoVector. ProtoVector. class psi4.core.ProtoVector; Bases: pybind11_object. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; ProtoVector.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.ProtoVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ProtoVector.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.psimrcc.html:446,Deployability,update,updated,446,". psimrcc. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; psimrcc. psimrcc. psi4.core.psimrcc(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the multireference coupled cluster code. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; psimrcc.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.psimrcc.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.psio_entry.html:401,Deployability,update,updated,401,". psio_entry. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; psio_entry. psio_entry. class psi4.core.psio_entry; Bases: pybind11_object; docstring. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; psio_entry.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.psio_entry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.psio_entry.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html:242,Availability,Failure,Failure,242,". PsiReturnType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType. PsiReturnType. class psi4.core.PsiReturnType; Bases: pybind11_object; Return status.; Members:. Success; Failure. Attributes Summary. Failure. Success. name. value. Attributes Documentation. Failure = <PsiReturnType.Failure: 1>. Success = <PsiReturnType.Success: 0>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PsiReturnType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html:271,Availability,Failure,Failure,271,". PsiReturnType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType. PsiReturnType. class psi4.core.PsiReturnType; Bases: pybind11_object; Return status.; Members:. Success; Failure. Attributes Summary. Failure. Success. name. value. Attributes Documentation. Failure = <PsiReturnType.Failure: 1>. Success = <PsiReturnType.Success: 0>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PsiReturnType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html:328,Availability,Failure,Failure,328,". PsiReturnType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType. PsiReturnType. class psi4.core.PsiReturnType; Bases: pybind11_object; Return status.; Members:. Success; Failure. Attributes Summary. Failure. Success. name. value. Attributes Documentation. Failure = <PsiReturnType.Failure: 1>. Success = <PsiReturnType.Success: 0>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PsiReturnType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html
https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html:353,Availability,Failure,Failure,353,". PsiReturnType. Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType. PsiReturnType. class psi4.core.PsiReturnType; Bases: pybind11_object; Return status.; Members:. Success; Failure. Attributes Summary. Failure. Success. name. value. Attributes Documentation. Failure = <PsiReturnType.Failure: 1>. Success = <PsiReturnType.Success: 0>. name. value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.7; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType.  Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4manual/1.7.x/api/psi4.core.PsiReturnType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.PsiReturnType.html
